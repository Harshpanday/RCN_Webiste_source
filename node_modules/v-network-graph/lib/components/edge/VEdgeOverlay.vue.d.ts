import type { EdgeConfig, StrokeStyle } from '../../common/configs';
import type { LooseRequired } from '@vue/shared';
import type { Vector2D } from '../..';
import type { Point2D } from '../../modules/vector2d/core';
import type { DefineComponent, WatchStopHandle, ExtractPropTypes, Ref, ComponentOptionsMixin, VNodeProps, AllowedComponentProps, ComponentCustomProps, PropType } from 'vue';
import { Edge, EdgePosition, Edges, LinePosition, Point } from '../../common/types';
import type { Line, EdgeState } from '../../models/edge';
declare const _sfc_main: DefineComponent<{
    edgeId: {
        type: StringConstructor;
        required: false;
        default: undefined;
    };
    edge: {
        type: PropType<Edge>;
        required: false;
        default: undefined;
    };
    edges: {
        type: PropType<Edges>;
        required: false;
        default: () => void;
    };
    state: {
        type: PropType<{
            id: string;
            line: Line;
            selectable: number | boolean;
            selected: boolean;
            hovered: boolean;
            origin: {
                p1: {
                    x: number;
                    y: number;
                };
                p2: {
                    x: number;
                    y: number;
                };
            };
            labelPosition: {
                p1: {
                    x: number;
                    y: number;
                };
                p2: {
                    x: number;
                    y: number;
                };
            };
            position: {
                p1: {
                    x: number;
                    y: number;
                };
                p2: {
                    x: number;
                    y: number;
                };
            };
            curve?: {
                center: {
                    x: number;
                    y: number;
                    add: (v: Point2D) => Vector2D;
                    subtract: (v: Point2D) => Vector2D;
                    multiply: (v: Point2D) => Vector2D;
                    multiplyScalar: (scalar: number) => Vector2D;
                    divide: (v: Point2D) => Vector2D;
                    dot: (v: Point2D) => number;
                    cross: (v: Point2D) => number;
                    lengthSquared: () => number;
                    length: () => number;
                    distanceSquared: (v: Point2D) => number;
                    distance: (v: Point2D) => number;
                    normalize: () => Vector2D;
                    angle: () => number;
                    angleDegree: () => number;
                    rotate: (angle: number) => Vector2D;
                    isEqualTo: (v: Point2D) => boolean;
                    clone: () => Vector2D;
                    toObject: () => Point2D;
                    toArray: () => [number, number];
                };
                theta: number;
                circle: {
                    center: {
                        x: number;
                        y: number;
                        add: (v: Point2D) => Vector2D;
                        subtract: (v: Point2D) => Vector2D;
                        multiply: (v: Point2D) => Vector2D;
                        multiplyScalar: (scalar: number) => Vector2D;
                        divide: (v: Point2D) => Vector2D;
                        dot: (v: Point2D) => number;
                        cross: (v: Point2D) => number;
                        lengthSquared: () => number;
                        length: () => number;
                        distanceSquared: (v: Point2D) => number;
                        distance: (v: Point2D) => number;
                        normalize: () => Vector2D;
                        angle: () => number;
                        angleDegree: () => number;
                        rotate: (angle: number) => Vector2D;
                        isEqualTo: (v: Point2D) => boolean;
                        clone: () => Vector2D;
                        toObject: () => Point2D;
                        toArray: () => [number, number];
                    };
                    radius: number;
                };
                control: {
                    x: number;
                    y: number;
                }[];
            } | undefined;
            loop?: {
                center: {
                    x: number;
                    y: number;
                    add: (v: Point2D) => Vector2D;
                    subtract: (v: Point2D) => Vector2D;
                    multiply: (v: Point2D) => Vector2D;
                    multiplyScalar: (scalar: number) => Vector2D;
                    divide: (v: Point2D) => Vector2D;
                    dot: (v: Point2D) => number;
                    cross: (v: Point2D) => number;
                    lengthSquared: () => number;
                    length: () => number;
                    distanceSquared: (v: Point2D) => number;
                    distance: (v: Point2D) => number;
                    normalize: () => Vector2D;
                    angle: () => number;
                    angleDegree: () => number;
                    rotate: (angle: number) => Vector2D;
                    isEqualTo: (v: Point2D) => boolean;
                    clone: () => Vector2D;
                    toObject: () => Point2D;
                    toArray: () => [number, number];
                };
                radius: [number, number];
                isLargeArc: boolean;
                isClockwise: boolean;
            } | undefined;
            sourceMarkerId?: string | undefined;
            targetMarkerId?: string | undefined;
            zIndex: number;
            stopWatchHandle: WatchStopHandle;
        }>;
        required: true;
    };
    isSummarized: {
        type: BooleanConstructor;
        required: true;
    };
}, {
    props: Readonly<LooseRequired<Readonly<ExtractPropTypes<{
        edgeId: {
            type: StringConstructor;
            required: false;
            default: undefined;
        };
        edge: {
            type: PropType<Edge>;
            required: false;
            default: undefined;
        };
        edges: {
            type: PropType<Edges>;
            required: false;
            default: () => void;
        };
        state: {
            type: PropType<{
                id: string;
                line: Line;
                selectable: number | boolean;
                selected: boolean;
                hovered: boolean;
                origin: {
                    p1: {
                        x: number;
                        y: number;
                    };
                    p2: {
                        x: number;
                        y: number;
                    };
                };
                labelPosition: {
                    p1: {
                        x: number;
                        y: number;
                    };
                    p2: {
                        x: number;
                        y: number;
                    };
                };
                position: {
                    p1: {
                        x: number;
                        y: number;
                    };
                    p2: {
                        x: number;
                        y: number;
                    };
                };
                curve?: {
                    center: {
                        x: number;
                        y: number;
                        add: (v: Point2D) => Vector2D;
                        subtract: (v: Point2D) => Vector2D;
                        multiply: (v: Point2D) => Vector2D;
                        multiplyScalar: (scalar: number) => Vector2D;
                        divide: (v: Point2D) => Vector2D;
                        dot: (v: Point2D) => number;
                        cross: (v: Point2D) => number;
                        lengthSquared: () => number;
                        length: () => number;
                        distanceSquared: (v: Point2D) => number;
                        distance: (v: Point2D) => number;
                        normalize: () => Vector2D;
                        angle: () => number;
                        angleDegree: () => number;
                        rotate: (angle: number) => Vector2D;
                        isEqualTo: (v: Point2D) => boolean;
                        clone: () => Vector2D;
                        toObject: () => Point2D;
                        toArray: () => [number, number];
                    };
                    theta: number;
                    circle: {
                        center: {
                            x: number;
                            y: number;
                            add: (v: Point2D) => Vector2D;
                            subtract: (v: Point2D) => Vector2D;
                            multiply: (v: Point2D) => Vector2D;
                            multiplyScalar: (scalar: number) => Vector2D;
                            divide: (v: Point2D) => Vector2D;
                            dot: (v: Point2D) => number;
                            cross: (v: Point2D) => number;
                            lengthSquared: () => number;
                            length: () => number;
                            distanceSquared: (v: Point2D) => number;
                            distance: (v: Point2D) => number;
                            normalize: () => Vector2D;
                            angle: () => number;
                            angleDegree: () => number;
                            rotate: (angle: number) => Vector2D;
                            isEqualTo: (v: Point2D) => boolean;
                            clone: () => Vector2D;
                            toObject: () => Point2D;
                            toArray: () => [number, number];
                        };
                        radius: number;
                    };
                    control: {
                        x: number;
                        y: number;
                    }[];
                } | undefined;
                loop?: {
                    center: {
                        x: number;
                        y: number;
                        add: (v: Point2D) => Vector2D;
                        subtract: (v: Point2D) => Vector2D;
                        multiply: (v: Point2D) => Vector2D;
                        multiplyScalar: (scalar: number) => Vector2D;
                        divide: (v: Point2D) => Vector2D;
                        dot: (v: Point2D) => number;
                        cross: (v: Point2D) => number;
                        lengthSquared: () => number;
                        length: () => number;
                        distanceSquared: (v: Point2D) => number;
                        distance: (v: Point2D) => number;
                        normalize: () => Vector2D;
                        angle: () => number;
                        angleDegree: () => number;
                        rotate: (angle: number) => Vector2D;
                        isEqualTo: (v: Point2D) => boolean;
                        clone: () => Vector2D;
                        toObject: () => Point2D;
                        toArray: () => [number, number];
                    };
                    radius: [number, number];
                    isLargeArc: boolean;
                    isClockwise: boolean;
                } | undefined;
                sourceMarkerId?: string | undefined;
                targetMarkerId?: string | undefined;
                zIndex: number;
                stopWatchHandle: WatchStopHandle;
            }>;
            required: true;
        };
        isSummarized: {
            type: BooleanConstructor;
            required: true;
        };
    }>> & {
        [x: string & `on${string}`]: ((...args: any[]) => any) | ((...args: unknown[]) => any) | undefined;
    }>>;
    svg: Ref<SVGElement>;
    scale: Ref<number>;
    edgeConfig: EdgeConfig<Edge>;
    getStrokeConfig: () => StrokeStyle;
    toEdgePosition: (line: LinePosition) => EdgePosition;
    calculateCenterPoint: (state: EdgeState) => Point;
    getPathTotalLength: () => number;
    calculatePointAtLength: (distance: number) => Point;
}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    edgeId: {
        type: StringConstructor;
        required: false;
        default: undefined;
    };
    edge: {
        type: PropType<Edge>;
        required: false;
        default: undefined;
    };
    edges: {
        type: PropType<Edges>;
        required: false;
        default: () => void;
    };
    state: {
        type: PropType<{
            id: string;
            line: Line;
            selectable: number | boolean;
            selected: boolean;
            hovered: boolean;
            origin: {
                p1: {
                    x: number;
                    y: number;
                };
                p2: {
                    x: number;
                    y: number;
                };
            };
            labelPosition: {
                p1: {
                    x: number;
                    y: number;
                };
                p2: {
                    x: number;
                    y: number;
                };
            };
            position: {
                p1: {
                    x: number;
                    y: number;
                };
                p2: {
                    x: number;
                    y: number;
                };
            };
            curve?: {
                center: {
                    x: number;
                    y: number;
                    add: (v: Point2D) => Vector2D;
                    subtract: (v: Point2D) => Vector2D;
                    multiply: (v: Point2D) => Vector2D;
                    multiplyScalar: (scalar: number) => Vector2D;
                    divide: (v: Point2D) => Vector2D;
                    dot: (v: Point2D) => number;
                    cross: (v: Point2D) => number;
                    lengthSquared: () => number;
                    length: () => number;
                    distanceSquared: (v: Point2D) => number;
                    distance: (v: Point2D) => number;
                    normalize: () => Vector2D;
                    angle: () => number;
                    angleDegree: () => number;
                    rotate: (angle: number) => Vector2D;
                    isEqualTo: (v: Point2D) => boolean;
                    clone: () => Vector2D;
                    toObject: () => Point2D;
                    toArray: () => [number, number];
                };
                theta: number;
                circle: {
                    center: {
                        x: number;
                        y: number;
                        add: (v: Point2D) => Vector2D;
                        subtract: (v: Point2D) => Vector2D;
                        multiply: (v: Point2D) => Vector2D;
                        multiplyScalar: (scalar: number) => Vector2D;
                        divide: (v: Point2D) => Vector2D;
                        dot: (v: Point2D) => number;
                        cross: (v: Point2D) => number;
                        lengthSquared: () => number;
                        length: () => number;
                        distanceSquared: (v: Point2D) => number;
                        distance: (v: Point2D) => number;
                        normalize: () => Vector2D;
                        angle: () => number;
                        angleDegree: () => number;
                        rotate: (angle: number) => Vector2D;
                        isEqualTo: (v: Point2D) => boolean;
                        clone: () => Vector2D;
                        toObject: () => Point2D;
                        toArray: () => [number, number];
                    };
                    radius: number;
                };
                control: {
                    x: number;
                    y: number;
                }[];
            } | undefined;
            loop?: {
                center: {
                    x: number;
                    y: number;
                    add: (v: Point2D) => Vector2D;
                    subtract: (v: Point2D) => Vector2D;
                    multiply: (v: Point2D) => Vector2D;
                    multiplyScalar: (scalar: number) => Vector2D;
                    divide: (v: Point2D) => Vector2D;
                    dot: (v: Point2D) => number;
                    cross: (v: Point2D) => number;
                    lengthSquared: () => number;
                    length: () => number;
                    distanceSquared: (v: Point2D) => number;
                    distance: (v: Point2D) => number;
                    normalize: () => Vector2D;
                    angle: () => number;
                    angleDegree: () => number;
                    rotate: (angle: number) => Vector2D;
                    isEqualTo: (v: Point2D) => boolean;
                    clone: () => Vector2D;
                    toObject: () => Point2D;
                    toArray: () => [number, number];
                };
                radius: [number, number];
                isLargeArc: boolean;
                isClockwise: boolean;
            } | undefined;
            sourceMarkerId?: string | undefined;
            targetMarkerId?: string | undefined;
            zIndex: number;
            stopWatchHandle: WatchStopHandle;
        }>;
        required: true;
    };
    isSummarized: {
        type: BooleanConstructor;
        required: true;
    };
}>>, {
    edge: Edge;
    edges: Edges;
    edgeId: string;
}>;
export default _sfc_main;

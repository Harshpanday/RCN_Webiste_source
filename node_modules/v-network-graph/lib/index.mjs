import { isReactive as ai, reactive as Se, provide as Je, inject as et, watch as q, toRef as Ce, watchEffect as ve, computed as M, unref as _, ref as A, onMounted as tt, onUnmounted as dt, nextTick as nn, defineComponent as K, openBlock as O, createElementBlock as T, useAttrs as li, Fragment as R, mergeProps as Pe, createCommentVNode as ae, createElementVNode as on, createTextVNode as ui, toDisplayString as Rn, renderList as Y, normalizeClass as de, withModifiers as ye, renderSlot as te, createVNode as Ve, createBlock as Q, normalizeStyle as ft, withCtx as me, normalizeProps as Ze, guardReactiveProps as Ne, TransitionGroup as rn, resolveDynamicComponent as ci, readonly as ot, resolveComponent as we, createSlots as Vn } from "vue";
const di = [
  "paths",
  "nodes",
  "focusring",
  "edges",
  "base",
  "grid",
  "background",
  "root"
];
function Be(e) {
  return ai(e) ? e : Se(e);
}
function F(e, t = "Parameter") {
  if (e == null)
    throw new Error(`${t} is null`);
  return e;
}
const Jo = Symbol("containers");
function fi(e) {
  Je(Jo, e);
}
function wn() {
  const e = F(et(Jo), "containers");
  return {
    container: e.container,
    svg: e.svg,
    viewport: e.viewport,
    svgPanZoom: e.svgPanZoom
  };
}
class $ {
  static value(t, n) {
    return t instanceof Function ? t(n) : t;
  }
  static values(t, n) {
    return Object.values(t).filter((o) => o instanceof Function).length === 0 ? t : Object.fromEntries(
      Object.entries(t).map(([o, r]) => [o, r instanceof Function ? r(n) : r])
    );
  }
}
var Z = /* @__PURE__ */ ((e) => (e.CENTER = "center", e.NORTH = "north", e.NORTH_EAST = "north-east", e.EAST = "east", e.SOUTH_EAST = "south-east", e.SOUTH = "south", e.SOUTH_WEST = "south-west", e.WEST = "west", e.NORTH_WEST = "north-west", e))(Z || {});
function Wt(e) {
  const t = {};
  return Object.assign(t, e(t));
}
function Ff(e) {
  return e;
}
function Uf(e) {
  return e;
}
function qn(e, t, n) {
  const o = $.values(t.normal, e);
  return o.type == "circle" ? {
    width: o.radius * 2 * n,
    height: o.radius * 2 * n
  } : {
    width: o.width * n,
    height: o.height * n
  };
}
function hi(e, t, n, o) {
  const i = Math.abs(e.x - n.x) < t.width / 2 + o.width / 2, s = Math.abs(e.y - n.y) < t.height / 2 + o.height / 2;
  return i && s;
}
function ht(e, t) {
  let n = 0;
  return t === 1 || e === void 0 || e === "none" ? n = e != null ? e : 0 : typeof e == "string" ? n = e.split(/\s+/).map((o) => parseInt(o) * t).filter((o) => !isNaN(o)).join(" ") : n = e * t, n && n !== "0" ? n : void 0;
}
function zt(e) {
  let t = 0;
  if (e === void 0 || e === "none")
    t = 0;
  else if (typeof e == "string") {
    const n = e.split(/\s+/).map((o) => parseInt(o)).filter((o) => !isNaN(o));
    n.length % 2 === 0 ? t = n.reduce((o, r) => o + r, 0) : t = n.reduce((o, r) => o + r, 0) * 2;
  } else
    t = e * 2;
  return t;
}
var vi = typeof global == "object" && global && global.Object === Object && global;
const er = vi;
var pi = typeof self == "object" && self && self.Object === Object && self, gi = er || pi || Function("return this")();
const pe = gi;
var mi = /\s/;
function yi(e) {
  for (var t = e.length; t-- && mi.test(e.charAt(t)); )
    ;
  return t;
}
var bi = /^\s+/;
function wi(e) {
  return e && e.slice(0, yi(e) + 1).replace(bi, "");
}
function Ee(e) {
  var t = typeof e;
  return e != null && (t == "object" || t == "function");
}
var Ei = pe.Symbol;
const Ie = Ei;
var tr = Object.prototype, xi = tr.hasOwnProperty, Pi = tr.toString, rt = Ie ? Ie.toStringTag : void 0;
function _i(e) {
  var t = xi.call(e, rt), n = e[rt];
  try {
    e[rt] = void 0;
    var o = !0;
  } catch (i) {
  }
  var r = Pi.call(e);
  return o && (t ? e[rt] = n : delete e[rt]), r;
}
var Si = Object.prototype, Oi = Si.toString;
function ki(e) {
  return Oi.call(e);
}
var Mi = "[object Null]", Ti = "[object Undefined]", Hn = Ie ? Ie.toStringTag : void 0;
function We(e) {
  return e == null ? e === void 0 ? Ti : Mi : Hn && Hn in Object(e) ? _i(e) : ki(e);
}
function Ae(e) {
  return e != null && typeof e == "object";
}
var Ci = "[object Symbol]";
function nr(e) {
  return typeof e == "symbol" || Ae(e) && We(e) == Ci;
}
var Wn = 0 / 0, $i = /^[-+]0x[0-9a-f]+$/i, zi = /^0b[01]+$/i, Ii = /^0o[0-7]+$/i, Ai = parseInt;
function _t(e) {
  if (typeof e == "number")
    return e;
  if (nr(e))
    return Wn;
  if (Ee(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = Ee(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = wi(e);
  var n = zi.test(e);
  return n || Ii.test(e) ? Ai(e.slice(2), n ? 2 : 8) : $i.test(e) ? Wn : +e;
}
var Fn = 1 / 0, ji = 17976931348623157e292;
function Li(e) {
  if (!e)
    return e === 0 ? e : 0;
  if (e = _t(e), e === Fn || e === -Fn) {
    var t = e < 0 ? -1 : 1;
    return t * ji;
  }
  return e === e ? e : 0;
}
function or(e) {
  var t = Li(e), n = t % 1;
  return t === t ? n ? t - n : t : 0;
}
function Di(e, t) {
  for (var n = -1, o = e == null ? 0 : e.length, r = Array(o); ++n < o; )
    r[n] = t(e[n], n, e);
  return r;
}
var Zi = Array.isArray;
const qe = Zi;
var Ni = 1 / 0, Un = Ie ? Ie.prototype : void 0, Gn = Un ? Un.toString : void 0;
function rr(e) {
  if (typeof e == "string")
    return e;
  if (qe(e))
    return Di(e, rr) + "";
  if (nr(e))
    return Gn ? Gn.call(e) : "";
  var t = e + "";
  return t == "0" && 1 / e == -Ni ? "-0" : t;
}
function Xn(e) {
  return e == null ? "" : rr(e);
}
var Bi = pe.isFinite, Ri = Math.min;
function Vi(e) {
  var t = Math[e];
  return function(n, o) {
    if (n = _t(n), o = o == null ? 0 : Ri(or(o), 292), o && Bi(n)) {
      var r = (Xn(n) + "e").split("e"), i = t(r[0] + "e" + (+r[1] + o));
      return r = (Xn(i) + "e").split("e"), +(r[0] + "e" + (+r[1] - o));
    }
    return t(n);
  };
}
var qi = Vi("round");
const Kn = qi;
var Hi = Object.defineProperty, Yn = Object.getOwnPropertySymbols, Wi = Object.prototype.hasOwnProperty, Fi = Object.prototype.propertyIsEnumerable, Qn = (e, t, n) => t in e ? Hi(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, Ui = (e, t) => {
  for (var n in t || (t = {}))
    Wi.call(t, n) && Qn(e, n, t[n]);
  if (Yn)
    for (var n of Yn(t))
      Fi.call(t, n) && Qn(e, n, t[n]);
  return e;
};
const Jn = 20;
class ir {
  activate(t) {
    const { nodePositions: n, nodes: o, configs: r, emitter: i, scale: a, svgPanZoom: s } = t, l = (g) => {
      for (const [m, d] of Object.entries(g)) {
        const E = this.getOrCreateNodePosition(n, m);
        this.setNodePosition(E, d);
      }
    }, c = (g) => {
      const m = g.filter((w) => !(w in n.value)), d = s.getViewArea(), E = a.value;
      for (const w of m) {
        const b = o.value[w], f = qn(b, r.node, E), v = Ui({}, d.center);
        for (; ; ) {
          let y = !1;
          for (const [h, p] of Object.entries(n.value)) {
            if (w === h)
              continue;
            const P = o.value[h];
            if (!P)
              continue;
            const S = qn(P, r.node, E);
            if (y = hi(v, f, p, S), y)
              break;
          }
          if (y)
            v.x += f.width + Jn * E, v.x + f.width / 2 > d.box.right && (v.x = d.center.x, v.y += f.height + Jn * E);
          else
            break;
        }
        const x = this.getOrCreateNodePosition(n, w);
        this.setNodePosition(x, v);
      }
    };
    c(Object.keys(o.value));
    const u = q(() => Object.keys(o.value), c);
    i.on("node:dragstart", l), i.on("node:pointermove", l), i.on("node:dragend", l), this.onDeactivate = () => {
      u(), i.off("node:dragstart", l), i.off("node:pointermove", l), i.off("node:dragend", l);
    };
  }
  deactivate() {
    this.onDeactivate && this.onDeactivate();
  }
  setNodePosition(t, n) {
    t.value.x = Kn(n.x, 3), t.value.y = Kn(n.y, 3);
  }
  getOrCreateNodePosition(t, n) {
    const o = Ce(t.value, n);
    return o.value || (o.value = { x: 0, y: 0 }), o;
  }
}
function Gi() {
  this.__data__ = [], this.size = 0;
}
function vt(e, t) {
  return e === t || e !== e && t !== t;
}
function It(e, t) {
  for (var n = e.length; n--; )
    if (vt(e[n][0], t))
      return n;
  return -1;
}
var Xi = Array.prototype, Ki = Xi.splice;
function Yi(e) {
  var t = this.__data__, n = It(t, e);
  if (n < 0)
    return !1;
  var o = t.length - 1;
  return n == o ? t.pop() : Ki.call(t, n, 1), --this.size, !0;
}
function Qi(e) {
  var t = this.__data__, n = It(t, e);
  return n < 0 ? void 0 : t[n][1];
}
function Ji(e) {
  return It(this.__data__, e) > -1;
}
function es(e, t) {
  var n = this.__data__, o = It(n, e);
  return o < 0 ? (++this.size, n.push([e, t])) : n[o][1] = t, this;
}
function Oe(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var o = e[t];
    this.set(o[0], o[1]);
  }
}
Oe.prototype.clear = Gi;
Oe.prototype.delete = Yi;
Oe.prototype.get = Qi;
Oe.prototype.has = Ji;
Oe.prototype.set = es;
function ts() {
  this.__data__ = new Oe(), this.size = 0;
}
function ns(e) {
  var t = this.__data__, n = t.delete(e);
  return this.size = t.size, n;
}
function os(e) {
  return this.__data__.get(e);
}
function rs(e) {
  return this.__data__.has(e);
}
var is = "[object AsyncFunction]", ss = "[object Function]", as = "[object GeneratorFunction]", ls = "[object Proxy]";
function En(e) {
  if (!Ee(e))
    return !1;
  var t = We(e);
  return t == ss || t == as || t == is || t == ls;
}
var us = pe["__core-js_shared__"];
const Ft = us;
var eo = function() {
  var e = /[^.]+$/.exec(Ft && Ft.keys && Ft.keys.IE_PROTO || "");
  return e ? "Symbol(src)_1." + e : "";
}();
function cs(e) {
  return !!eo && eo in e;
}
var ds = Function.prototype, fs = ds.toString;
function Fe(e) {
  if (e != null) {
    try {
      return fs.call(e);
    } catch (t) {
    }
    try {
      return e + "";
    } catch (t) {
    }
  }
  return "";
}
var hs = /[\\^$.*+?()[\]{}|]/g, vs = /^\[object .+?Constructor\]$/, ps = Function.prototype, gs = Object.prototype, ms = ps.toString, ys = gs.hasOwnProperty, bs = RegExp(
  "^" + ms.call(ys).replace(hs, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function ws(e) {
  if (!Ee(e) || cs(e))
    return !1;
  var t = En(e) ? bs : vs;
  return t.test(Fe(e));
}
function Es(e, t) {
  return e == null ? void 0 : e[t];
}
function Ue(e, t) {
  var n = Es(e, t);
  return ws(n) ? n : void 0;
}
var xs = Ue(pe, "Map");
const lt = xs;
var Ps = Ue(Object, "create");
const ut = Ps;
function _s() {
  this.__data__ = ut ? ut(null) : {}, this.size = 0;
}
function Ss(e) {
  var t = this.has(e) && delete this.__data__[e];
  return this.size -= t ? 1 : 0, t;
}
var Os = "__lodash_hash_undefined__", ks = Object.prototype, Ms = ks.hasOwnProperty;
function Ts(e) {
  var t = this.__data__;
  if (ut) {
    var n = t[e];
    return n === Os ? void 0 : n;
  }
  return Ms.call(t, e) ? t[e] : void 0;
}
var Cs = Object.prototype, $s = Cs.hasOwnProperty;
function zs(e) {
  var t = this.__data__;
  return ut ? t[e] !== void 0 : $s.call(t, e);
}
var Is = "__lodash_hash_undefined__";
function As(e, t) {
  var n = this.__data__;
  return this.size += this.has(e) ? 0 : 1, n[e] = ut && t === void 0 ? Is : t, this;
}
function He(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var o = e[t];
    this.set(o[0], o[1]);
  }
}
He.prototype.clear = _s;
He.prototype.delete = Ss;
He.prototype.get = Ts;
He.prototype.has = zs;
He.prototype.set = As;
function js() {
  this.size = 0, this.__data__ = {
    hash: new He(),
    map: new (lt || Oe)(),
    string: new He()
  };
}
function Ls(e) {
  var t = typeof e;
  return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? e !== "__proto__" : e === null;
}
function At(e, t) {
  var n = e.__data__;
  return Ls(t) ? n[typeof t == "string" ? "string" : "hash"] : n.map;
}
function Ds(e) {
  var t = At(this, e).delete(e);
  return this.size -= t ? 1 : 0, t;
}
function Zs(e) {
  return At(this, e).get(e);
}
function Ns(e) {
  return At(this, e).has(e);
}
function Bs(e, t) {
  var n = At(this, e), o = n.size;
  return n.set(e, t), this.size += n.size == o ? 0 : 1, this;
}
function Ge(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var o = e[t];
    this.set(o[0], o[1]);
  }
}
Ge.prototype.clear = js;
Ge.prototype.delete = Ds;
Ge.prototype.get = Zs;
Ge.prototype.has = Ns;
Ge.prototype.set = Bs;
var Rs = 200;
function Vs(e, t) {
  var n = this.__data__;
  if (n instanceof Oe) {
    var o = n.__data__;
    if (!lt || o.length < Rs - 1)
      return o.push([e, t]), this.size = ++n.size, this;
    n = this.__data__ = new Ge(o);
  }
  return n.set(e, t), this.size = n.size, this;
}
function _e(e) {
  var t = this.__data__ = new Oe(e);
  this.size = t.size;
}
_e.prototype.clear = ts;
_e.prototype.delete = ns;
_e.prototype.get = os;
_e.prototype.has = rs;
_e.prototype.set = Vs;
var qs = function() {
  try {
    var e = Ue(Object, "defineProperty");
    return e({}, "", {}), e;
  } catch (t) {
  }
}();
const St = qs;
function xn(e, t, n) {
  t == "__proto__" && St ? St(e, t, {
    configurable: !0,
    enumerable: !0,
    value: n,
    writable: !0
  }) : e[t] = n;
}
function sn(e, t, n) {
  (n !== void 0 && !vt(e[t], n) || n === void 0 && !(t in e)) && xn(e, t, n);
}
function Hs(e) {
  return function(t, n, o) {
    for (var r = -1, i = Object(t), a = o(t), s = a.length; s--; ) {
      var l = a[e ? s : ++r];
      if (n(i[l], l, i) === !1)
        break;
    }
    return t;
  };
}
var Ws = Hs();
const Fs = Ws;
var sr = typeof exports == "object" && exports && !exports.nodeType && exports, to = sr && typeof module == "object" && module && !module.nodeType && module, Us = to && to.exports === sr, no = Us ? pe.Buffer : void 0, oo = no ? no.allocUnsafe : void 0;
function Gs(e, t) {
  if (t)
    return e.slice();
  var n = e.length, o = oo ? oo(n) : new e.constructor(n);
  return e.copy(o), o;
}
var Xs = pe.Uint8Array;
const Ot = Xs;
function Ks(e) {
  var t = new e.constructor(e.byteLength);
  return new Ot(t).set(new Ot(e)), t;
}
function Ys(e, t) {
  var n = t ? Ks(e.buffer) : e.buffer;
  return new e.constructor(n, e.byteOffset, e.length);
}
function Qs(e, t) {
  var n = -1, o = e.length;
  for (t || (t = Array(o)); ++n < o; )
    t[n] = e[n];
  return t;
}
var ro = Object.create, Js = function() {
  function e() {
  }
  return function(t) {
    if (!Ee(t))
      return {};
    if (ro)
      return ro(t);
    e.prototype = t;
    var n = new e();
    return e.prototype = void 0, n;
  };
}();
const ea = Js;
function ar(e, t) {
  return function(n) {
    return e(t(n));
  };
}
var ta = ar(Object.getPrototypeOf, Object);
const lr = ta;
var na = Object.prototype;
function Pn(e) {
  var t = e && e.constructor, n = typeof t == "function" && t.prototype || na;
  return e === n;
}
function oa(e) {
  return typeof e.constructor == "function" && !Pn(e) ? ea(lr(e)) : {};
}
var ra = "[object Arguments]";
function io(e) {
  return Ae(e) && We(e) == ra;
}
var ur = Object.prototype, ia = ur.hasOwnProperty, sa = ur.propertyIsEnumerable, aa = io(function() {
  return arguments;
}()) ? io : function(e) {
  return Ae(e) && ia.call(e, "callee") && !sa.call(e, "callee");
};
const an = aa;
var la = 9007199254740991;
function cr(e) {
  return typeof e == "number" && e > -1 && e % 1 == 0 && e <= la;
}
function jt(e) {
  return e != null && cr(e.length) && !En(e);
}
function ua(e) {
  return Ae(e) && jt(e);
}
function ca() {
  return !1;
}
var dr = typeof exports == "object" && exports && !exports.nodeType && exports, so = dr && typeof module == "object" && module && !module.nodeType && module, da = so && so.exports === dr, ao = da ? pe.Buffer : void 0, fa = ao ? ao.isBuffer : void 0, ha = fa || ca;
const kt = ha;
var va = "[object Object]", pa = Function.prototype, ga = Object.prototype, fr = pa.toString, ma = ga.hasOwnProperty, ya = fr.call(Object);
function ba(e) {
  if (!Ae(e) || We(e) != va)
    return !1;
  var t = lr(e);
  if (t === null)
    return !0;
  var n = ma.call(t, "constructor") && t.constructor;
  return typeof n == "function" && n instanceof n && fr.call(n) == ya;
}
var wa = "[object Arguments]", Ea = "[object Array]", xa = "[object Boolean]", Pa = "[object Date]", _a = "[object Error]", Sa = "[object Function]", Oa = "[object Map]", ka = "[object Number]", Ma = "[object Object]", Ta = "[object RegExp]", Ca = "[object Set]", $a = "[object String]", za = "[object WeakMap]", Ia = "[object ArrayBuffer]", Aa = "[object DataView]", ja = "[object Float32Array]", La = "[object Float64Array]", Da = "[object Int8Array]", Za = "[object Int16Array]", Na = "[object Int32Array]", Ba = "[object Uint8Array]", Ra = "[object Uint8ClampedArray]", Va = "[object Uint16Array]", qa = "[object Uint32Array]", G = {};
G[ja] = G[La] = G[Da] = G[Za] = G[Na] = G[Ba] = G[Ra] = G[Va] = G[qa] = !0;
G[wa] = G[Ea] = G[Ia] = G[xa] = G[Aa] = G[Pa] = G[_a] = G[Sa] = G[Oa] = G[ka] = G[Ma] = G[Ta] = G[Ca] = G[$a] = G[za] = !1;
function Ha(e) {
  return Ae(e) && cr(e.length) && !!G[We(e)];
}
function Wa(e) {
  return function(t) {
    return e(t);
  };
}
var hr = typeof exports == "object" && exports && !exports.nodeType && exports, st = hr && typeof module == "object" && module && !module.nodeType && module, Fa = st && st.exports === hr, Ut = Fa && er.process, Ua = function() {
  try {
    var e = st && st.require && st.require("util").types;
    return e || Ut && Ut.binding && Ut.binding("util");
  } catch (t) {
  }
}();
const lo = Ua;
var uo = lo && lo.isTypedArray, Ga = uo ? Wa(uo) : Ha;
const _n = Ga;
function ln(e, t) {
  if (!(t === "constructor" && typeof e[t] == "function") && t != "__proto__")
    return e[t];
}
var Xa = Object.prototype, Ka = Xa.hasOwnProperty;
function Ya(e, t, n) {
  var o = e[t];
  (!(Ka.call(e, t) && vt(o, n)) || n === void 0 && !(t in e)) && xn(e, t, n);
}
function Qa(e, t, n, o) {
  var r = !n;
  n || (n = {});
  for (var i = -1, a = t.length; ++i < a; ) {
    var s = t[i], l = o ? o(n[s], e[s], s, n, e) : void 0;
    l === void 0 && (l = e[s]), r ? xn(n, s, l) : Ya(n, s, l);
  }
  return n;
}
function Ja(e, t) {
  for (var n = -1, o = Array(e); ++n < e; )
    o[n] = t(n);
  return o;
}
var el = 9007199254740991, tl = /^(?:0|[1-9]\d*)$/;
function vr(e, t) {
  var n = typeof e;
  return t = t == null ? el : t, !!t && (n == "number" || n != "symbol" && tl.test(e)) && e > -1 && e % 1 == 0 && e < t;
}
var nl = Object.prototype, ol = nl.hasOwnProperty;
function pr(e, t) {
  var n = qe(e), o = !n && an(e), r = !n && !o && kt(e), i = !n && !o && !r && _n(e), a = n || o || r || i, s = a ? Ja(e.length, String) : [], l = s.length;
  for (var c in e)
    (t || ol.call(e, c)) && !(a && (c == "length" || r && (c == "offset" || c == "parent") || i && (c == "buffer" || c == "byteLength" || c == "byteOffset") || vr(c, l))) && s.push(c);
  return s;
}
function rl(e) {
  var t = [];
  if (e != null)
    for (var n in Object(e))
      t.push(n);
  return t;
}
var il = Object.prototype, sl = il.hasOwnProperty;
function al(e) {
  if (!Ee(e))
    return rl(e);
  var t = Pn(e), n = [];
  for (var o in e)
    o == "constructor" && (t || !sl.call(e, o)) || n.push(o);
  return n;
}
function gr(e) {
  return jt(e) ? pr(e, !0) : al(e);
}
function ll(e) {
  return Qa(e, gr(e));
}
function ul(e, t, n, o, r, i, a) {
  var s = ln(e, n), l = ln(t, n), c = a.get(l);
  if (c) {
    sn(e, n, c);
    return;
  }
  var u = i ? i(s, l, n + "", e, t, a) : void 0, g = u === void 0;
  if (g) {
    var m = qe(l), d = !m && kt(l), E = !m && !d && _n(l);
    u = l, m || d || E ? qe(s) ? u = s : ua(s) ? u = Qs(s) : d ? (g = !1, u = Gs(l, !0)) : E ? (g = !1, u = Ys(l, !0)) : u = [] : ba(l) || an(l) ? (u = s, an(s) ? u = ll(s) : (!Ee(s) || En(s)) && (u = oa(l))) : g = !1;
  }
  g && (a.set(l, u), r(u, l, o, i, a), a.delete(l)), sn(e, n, u);
}
function mr(e, t, n, o, r) {
  e !== t && Fs(t, function(i, a) {
    if (r || (r = new _e()), Ee(i))
      ul(e, t, a, n, mr, o, r);
    else {
      var s = o ? o(ln(e, a), i, a + "", e, t, r) : void 0;
      s === void 0 && (s = i), sn(e, a, s);
    }
  }, gr);
}
function yr(e) {
  return e;
}
function cl(e, t, n) {
  switch (n.length) {
    case 0:
      return e.call(t);
    case 1:
      return e.call(t, n[0]);
    case 2:
      return e.call(t, n[0], n[1]);
    case 3:
      return e.call(t, n[0], n[1], n[2]);
  }
  return e.apply(t, n);
}
var co = Math.max;
function dl(e, t, n) {
  return t = co(t === void 0 ? e.length - 1 : t, 0), function() {
    for (var o = arguments, r = -1, i = co(o.length - t, 0), a = Array(i); ++r < i; )
      a[r] = o[t + r];
    r = -1;
    for (var s = Array(t + 1); ++r < t; )
      s[r] = o[r];
    return s[t] = n(a), cl(e, this, s);
  };
}
function fl(e) {
  return function() {
    return e;
  };
}
var hl = St ? function(e, t) {
  return St(e, "toString", {
    configurable: !0,
    enumerable: !1,
    value: fl(t),
    writable: !0
  });
} : yr;
const vl = hl;
var pl = 800, gl = 16, ml = Date.now;
function yl(e) {
  var t = 0, n = 0;
  return function() {
    var o = ml(), r = gl - (o - n);
    if (n = o, r > 0) {
      if (++t >= pl)
        return arguments[0];
    } else
      t = 0;
    return e.apply(void 0, arguments);
  };
}
var bl = yl(vl);
const wl = bl;
function El(e, t) {
  return wl(dl(e, t, yr), e + "");
}
function br(e, t, n) {
  if (!Ee(n))
    return !1;
  var o = typeof t;
  return (o == "number" ? jt(n) && vr(t, n.length) : o == "string" && t in n) ? vt(n[t], e) : !1;
}
function xl(e) {
  return El(function(t, n) {
    var o = -1, r = n.length, i = r > 1 ? n[r - 1] : void 0, a = r > 2 ? n[2] : void 0;
    for (i = e.length > 3 && typeof i == "function" ? (r--, i) : void 0, a && br(n[0], n[1], a) && (i = r < 3 ? void 0 : i, r = 1), t = Object(t); ++o < r; ) {
      var s = n[o];
      s && e(t, s, o, i);
    }
    return t;
  });
}
var Pl = xl(function(e, t, n) {
  mr(e, t, n);
});
const wr = Pl;
function Er() {
  return {
    view: {
      scalingObjects: !1,
      panEnabled: !0,
      zoomEnabled: !0,
      minZoomLevel: 0.1,
      maxZoomLevel: 64,
      doubleClickZoomEnabled: !0,
      mouseWheelZoomEnabled: !0,
      boxSelectionEnabled: !1,
      autoPanAndZoomOnLoad: "center-content",
      autoPanOnResize: !0,
      layoutHandler: new ir(),
      onSvgPanZoomInitialized: void 0,
      grid: {
        visible: !1,
        interval: 10,
        thickIncrements: 5,
        line: {
          color: "#e0e0e0",
          width: 1,
          dasharray: 1
        },
        thick: {
          color: "#cccccc",
          width: 1,
          dasharray: 0
        }
      },
      selection: {
        box: {
          color: "#0000ff20",
          strokeWidth: 1,
          strokeColor: "#aaaaff",
          strokeDasharray: 0
        },
        detector: (e) => {
          const t = /Mac OS/.test(navigator.userAgent) ? e.metaKey : e.ctrlKey;
          return e.type === "keydown" ? t : !t;
        }
      }
    },
    node: Wt((e) => ({
      normal: {
        type: "circle",
        radius: 16,
        width: 32,
        height: 32,
        borderRadius: 4,
        color: "#4466cc",
        strokeWidth: 0,
        strokeColor: "#000000",
        strokeDasharray: 0
      },
      hover: {
        type: (t) => $.value(e.normal.type, t),
        radius: (t) => {
          var n;
          return ((n = $.value(e.normal.radius, t)) != null ? n : 0) + 2;
        },
        width: (t) => {
          var n;
          return ((n = $.value(e.normal.width, t)) != null ? n : 0) + 2;
        },
        height: (t) => {
          var n;
          return ((n = $.value(e.normal.height, t)) != null ? n : 0) + 2;
        },
        borderRadius: (t) => {
          var n;
          return (n = $.value(e.normal.borderRadius, t)) != null ? n : 0;
        },
        strokeWidth: (t) => $.value(e.normal.strokeWidth, t),
        strokeColor: (t) => $.value(e.normal.strokeColor, t),
        strokeDasharray: (t) => $.value(e.normal.strokeDasharray, t),
        color: "#3355bb"
      },
      selected: void 0,
      draggable: !0,
      selectable: !1,
      label: {
        visible: !0,
        fontFamily: void 0,
        fontSize: 11,
        lineHeight: 1.1,
        color: "#000000",
        background: void 0,
        margin: 4,
        direction: Z.SOUTH,
        text: "name"
      },
      focusring: {
        visible: !0,
        width: 4,
        padding: 3,
        color: "#eebb00"
      },
      zOrder: {
        enabled: !1,
        zIndex: 0,
        bringToFrontOnHover: !0,
        bringToFrontOnSelected: !0
      },
      transition: void 0
    })),
    edge: Wt((e) => ({
      normal: {
        width: 2,
        color: "#4466cc",
        dasharray: 0,
        linecap: "butt",
        animate: !1,
        animationSpeed: 50
      },
      hover: {
        width: (t) => $.value(e.normal.width, t) + 1,
        color: "#3355bb",
        dasharray: (t) => $.value(e.normal.dasharray, t),
        linecap: (t) => $.value(e.normal.linecap, t),
        animate: (t) => $.value(e.normal.animate, t),
        animationSpeed: (t) => $.value(e.normal.animationSpeed, t)
      },
      selected: {
        width: (t) => $.value(e.normal.width, t) + 1,
        color: "#dd8800",
        dasharray: (t) => {
          const n = $.value(e.normal.width, t);
          return `${n * 1.5} ${n * 2}`;
        },
        linecap: (t) => $.value(e.normal.linecap, t),
        animate: (t) => $.value(e.normal.animate, t),
        animationSpeed: (t) => $.value(e.normal.animationSpeed, t)
      },
      selectable: !1,
      gap: 3,
      type: "straight",
      marker: {
        source: {
          type: "none",
          width: 5,
          height: 5,
          margin: -1,
          units: "strokeWidth",
          color: null
        },
        target: {
          type: "none",
          width: 5,
          height: 5,
          margin: -1,
          units: "strokeWidth",
          color: null
        }
      },
      margin: null,
      summarize: (t, n) => n.edge.type == "curve" ? !1 : null,
      summarized: {
        label: {
          fontSize: 10,
          lineHeight: 1,
          color: "#4466cc"
        },
        shape: {
          type: "rect",
          radius: 6,
          width: 12,
          height: 12,
          borderRadius: 3,
          color: "#ffffff",
          strokeWidth: 1,
          strokeColor: "#4466cc",
          strokeDasharray: void 0
        },
        stroke: {
          width: 5,
          color: "#4466cc",
          dasharray: void 0,
          linecap: void 0,
          animate: !1,
          animationSpeed: 50
        }
      },
      selfLoop: {
        radius: 12,
        isClockwise: !0,
        offset: 10,
        angle: 270
      },
      keepOrder: "clock",
      label: {
        fontFamily: void 0,
        fontSize: 11,
        lineHeight: 1.1,
        color: "#000000",
        background: void 0,
        margin: 4,
        padding: 4
      },
      zOrder: {
        enabled: !1,
        zIndex: 0,
        bringToFrontOnHover: !0,
        bringToFrontOnSelected: !0
      }
    })),
    path: Wt((e) => ({
      visible: !1,
      clickable: !1,
      hoverable: !1,
      curveInNode: !1,
      end: "centerOfNode",
      margin: 0,
      path: Se({
        width: 6,
        color: (t) => {
          const n = [
            "#d5000088",
            "#c5116288",
            "#aa00ff88",
            "#6200ea88",
            "#304ffe88",
            "#2962ff88",
            "#0091ea88",
            "#00b8d488",
            "#00bfa588",
            "#00c85388",
            "#64dd1788",
            "#aeea0088",
            "#ffd60088",
            "#ffab0088",
            "#ff6d0088",
            "#dd2c0088"
          ], o = t.edges.map(
            (r) => r.split("").reduce((i, a) => (i = (i << 5) - i + a.charCodeAt(0), i & i), 0)
          ).reduce((r, i) => r + i, 0);
          return n[Math.abs(o) % n.length];
        },
        dasharray: void 0,
        linecap: "round",
        linejoin: "round",
        animate: !1,
        animationSpeed: 50
      }),
      normal: {
        width: (t) => $.value(e.path.width, t),
        color: (t) => $.value(e.path.color, t),
        dasharray: (t) => $.value(e.path.dasharray, t),
        linecap: (t) => $.value(e.path.linecap, t),
        linejoin: (t) => $.value(e.path.linejoin, t),
        animate: (t) => $.value(e.path.animate, t),
        animationSpeed: (t) => $.value(e.path.animationSpeed, t)
      },
      hover: {
        width: (t) => $.value(e.normal.width, t) + 2,
        color: (t) => $.value(e.normal.color, t),
        dasharray: (t) => $.value(e.normal.dasharray, t),
        linecap: (t) => $.value(e.normal.linecap, t),
        linejoin: (t) => $.value(e.normal.linejoin, t),
        animate: (t) => $.value(e.normal.animate, t),
        animationSpeed: (t) => $.value(e.normal.animationSpeed, t)
      },
      selected: {
        width: (t) => $.value(e.normal.width, t) + 2,
        color: (t) => $.value(e.normal.color, t),
        dasharray: "6 12",
        linecap: (t) => $.value(e.normal.linecap, t),
        linejoin: (t) => $.value(e.normal.linejoin, t),
        animate: (t) => $.value(e.normal.animate, t),
        animationSpeed: (t) => $.value(e.normal.animationSpeed, t)
      },
      selectable: !1,
      zOrder: {
        enabled: !1,
        zIndex: 0,
        bringToFrontOnHover: !0,
        bringToFrontOnSelected: !0
      },
      transition: void 0
    }))
  };
}
function Gf(e) {
  const t = Er();
  return e && wr(t, e), t;
}
const xr = Symbol("style");
function _l(e) {
  const t = Se(Er()), n = Object.keys(t);
  for (const o of n)
    q(() => e.value[o], () => {
      wr(t[o], e.value[o] || {});
    }, { immediate: !0, deep: !0 });
  return Je(xr, t), t;
}
function Lt(e) {
  return F(et(xr), `Configs(${e})`)[e];
}
function Sl() {
  return Lt("view");
}
function Pr() {
  return Lt("node");
}
function pt() {
  return Lt("edge");
}
function _r() {
  return Lt("path");
}
let Ol = 1;
function kl() {
  return Ol++;
}
var Ml = "__lodash_hash_undefined__";
function Tl(e) {
  return this.__data__.set(e, Ml), this;
}
function Cl(e) {
  return this.__data__.has(e);
}
function Mt(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.__data__ = new Ge(); ++t < n; )
    this.add(e[t]);
}
Mt.prototype.add = Mt.prototype.push = Tl;
Mt.prototype.has = Cl;
function $l(e, t) {
  for (var n = -1, o = e == null ? 0 : e.length; ++n < o; )
    if (t(e[n], n, e))
      return !0;
  return !1;
}
function zl(e, t) {
  return e.has(t);
}
var Il = 1, Al = 2;
function Sr(e, t, n, o, r, i) {
  var a = n & Il, s = e.length, l = t.length;
  if (s != l && !(a && l > s))
    return !1;
  var c = i.get(e), u = i.get(t);
  if (c && u)
    return c == t && u == e;
  var g = -1, m = !0, d = n & Al ? new Mt() : void 0;
  for (i.set(e, t), i.set(t, e); ++g < s; ) {
    var E = e[g], w = t[g];
    if (o)
      var b = a ? o(w, E, g, t, e, i) : o(E, w, g, e, t, i);
    if (b !== void 0) {
      if (b)
        continue;
      m = !1;
      break;
    }
    if (d) {
      if (!$l(t, function(f, v) {
        if (!zl(d, v) && (E === f || r(E, f, n, o, i)))
          return d.push(v);
      })) {
        m = !1;
        break;
      }
    } else if (!(E === w || r(E, w, n, o, i))) {
      m = !1;
      break;
    }
  }
  return i.delete(e), i.delete(t), m;
}
function jl(e) {
  var t = -1, n = Array(e.size);
  return e.forEach(function(o, r) {
    n[++t] = [r, o];
  }), n;
}
function Ll(e) {
  var t = -1, n = Array(e.size);
  return e.forEach(function(o) {
    n[++t] = o;
  }), n;
}
var Dl = 1, Zl = 2, Nl = "[object Boolean]", Bl = "[object Date]", Rl = "[object Error]", Vl = "[object Map]", ql = "[object Number]", Hl = "[object RegExp]", Wl = "[object Set]", Fl = "[object String]", Ul = "[object Symbol]", Gl = "[object ArrayBuffer]", Xl = "[object DataView]", fo = Ie ? Ie.prototype : void 0, Gt = fo ? fo.valueOf : void 0;
function Kl(e, t, n, o, r, i, a) {
  switch (n) {
    case Xl:
      if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset)
        return !1;
      e = e.buffer, t = t.buffer;
    case Gl:
      return !(e.byteLength != t.byteLength || !i(new Ot(e), new Ot(t)));
    case Nl:
    case Bl:
    case ql:
      return vt(+e, +t);
    case Rl:
      return e.name == t.name && e.message == t.message;
    case Hl:
    case Fl:
      return e == t + "";
    case Vl:
      var s = jl;
    case Wl:
      var l = o & Dl;
      if (s || (s = Ll), e.size != t.size && !l)
        return !1;
      var c = a.get(e);
      if (c)
        return c == t;
      o |= Zl, a.set(e, t);
      var u = Sr(s(e), s(t), o, r, i, a);
      return a.delete(e), u;
    case Ul:
      if (Gt)
        return Gt.call(e) == Gt.call(t);
  }
  return !1;
}
function Yl(e, t) {
  for (var n = -1, o = t.length, r = e.length; ++n < o; )
    e[r + n] = t[n];
  return e;
}
function Ql(e, t, n) {
  var o = t(e);
  return qe(e) ? o : Yl(o, n(e));
}
function Jl(e, t) {
  for (var n = -1, o = e == null ? 0 : e.length, r = 0, i = []; ++n < o; ) {
    var a = e[n];
    t(a, n, e) && (i[r++] = a);
  }
  return i;
}
function eu() {
  return [];
}
var tu = Object.prototype, nu = tu.propertyIsEnumerable, ho = Object.getOwnPropertySymbols, ou = ho ? function(e) {
  return e == null ? [] : (e = Object(e), Jl(ho(e), function(t) {
    return nu.call(e, t);
  }));
} : eu;
const ru = ou;
var iu = ar(Object.keys, Object);
const su = iu;
var au = Object.prototype, lu = au.hasOwnProperty;
function uu(e) {
  if (!Pn(e))
    return su(e);
  var t = [];
  for (var n in Object(e))
    lu.call(e, n) && n != "constructor" && t.push(n);
  return t;
}
function cu(e) {
  return jt(e) ? pr(e) : uu(e);
}
function vo(e) {
  return Ql(e, cu, ru);
}
var du = 1, fu = Object.prototype, hu = fu.hasOwnProperty;
function vu(e, t, n, o, r, i) {
  var a = n & du, s = vo(e), l = s.length, c = vo(t), u = c.length;
  if (l != u && !a)
    return !1;
  for (var g = l; g--; ) {
    var m = s[g];
    if (!(a ? m in t : hu.call(t, m)))
      return !1;
  }
  var d = i.get(e), E = i.get(t);
  if (d && E)
    return d == t && E == e;
  var w = !0;
  i.set(e, t), i.set(t, e);
  for (var b = a; ++g < l; ) {
    m = s[g];
    var f = e[m], v = t[m];
    if (o)
      var x = a ? o(v, f, m, t, e, i) : o(f, v, m, e, t, i);
    if (!(x === void 0 ? f === v || r(f, v, n, o, i) : x)) {
      w = !1;
      break;
    }
    b || (b = m == "constructor");
  }
  if (w && !b) {
    var y = e.constructor, h = t.constructor;
    y != h && "constructor" in e && "constructor" in t && !(typeof y == "function" && y instanceof y && typeof h == "function" && h instanceof h) && (w = !1);
  }
  return i.delete(e), i.delete(t), w;
}
var pu = Ue(pe, "DataView");
const un = pu;
var gu = Ue(pe, "Promise");
const cn = gu;
var mu = Ue(pe, "Set");
const dn = mu;
var yu = Ue(pe, "WeakMap");
const fn = yu;
var po = "[object Map]", bu = "[object Object]", go = "[object Promise]", mo = "[object Set]", yo = "[object WeakMap]", bo = "[object DataView]", wu = Fe(un), Eu = Fe(lt), xu = Fe(cn), Pu = Fe(dn), _u = Fe(fn), Le = We;
(un && Le(new un(new ArrayBuffer(1))) != bo || lt && Le(new lt()) != po || cn && Le(cn.resolve()) != go || dn && Le(new dn()) != mo || fn && Le(new fn()) != yo) && (Le = function(e) {
  var t = We(e), n = t == bu ? e.constructor : void 0, o = n ? Fe(n) : "";
  if (o)
    switch (o) {
      case wu:
        return bo;
      case Eu:
        return po;
      case xu:
        return go;
      case Pu:
        return mo;
      case _u:
        return yo;
    }
  return t;
});
const wo = Le;
var Su = 1, Eo = "[object Arguments]", xo = "[object Array]", mt = "[object Object]", Ou = Object.prototype, Po = Ou.hasOwnProperty;
function ku(e, t, n, o, r, i) {
  var a = qe(e), s = qe(t), l = a ? xo : wo(e), c = s ? xo : wo(t);
  l = l == Eo ? mt : l, c = c == Eo ? mt : c;
  var u = l == mt, g = c == mt, m = l == c;
  if (m && kt(e)) {
    if (!kt(t))
      return !1;
    a = !0, u = !1;
  }
  if (m && !u)
    return i || (i = new _e()), a || _n(e) ? Sr(e, t, n, o, r, i) : Kl(e, t, l, n, o, r, i);
  if (!(n & Su)) {
    var d = u && Po.call(e, "__wrapped__"), E = g && Po.call(t, "__wrapped__");
    if (d || E) {
      var w = d ? e.value() : e, b = E ? t.value() : t;
      return i || (i = new _e()), r(w, b, n, o, i);
    }
  }
  return m ? (i || (i = new _e()), vu(e, t, n, o, r, i)) : !1;
}
function Or(e, t, n, o, r) {
  return e === t ? !0 : e == null || t == null || !Ae(e) && !Ae(t) ? e !== e && t !== t : ku(e, t, n, o, Or, r);
}
function Re(e, t) {
  return Or(e, t);
}
function ue(e) {
  return Object.entries(e);
}
function Xt(e, t) {
  const n = new Set(Object.keys(e));
  ue(t).forEach(([o, r]) => {
    Re(e[o], r) || (e[o] = r), n.delete(o);
  }), n.forEach((o) => delete e[o]);
}
function Mu(e, t, n) {
  const o = Be({
    edgeLayoutPoints: {},
    edgeGroups: {},
    summarizedEdges: {}
  });
  return ve(() => {
    const { edgeLayoutPoints: r, edgeGroups: i } = Cu(
      n,
      e.value,
      t.value
    );
    Xt(o.edgeLayoutPoints, r), Xt(o.edgeGroups, i);
  }), ve(() => {
    const r = {};
    for (const [i, { edges: a, groupWidth: s }] of Object.entries(o.edgeGroups)) {
      let l = !1;
      if (s == 0)
        l = !1;
      else if (n.edge.summarize instanceof Function) {
        const c = n.edge.summarize(a, n);
        c === null ? l = _o(e.value, a, n, s) : l = c;
      } else
        n.edge.summarize ? l = _o(e.value, a, n, s) : l = !1;
      o.edgeGroups[i].summarize = l, l && Object.keys(a).forEach((c) => r[c] = !0);
    }
    Xt(o.summarizedEdges, r);
  }), o;
}
function Tu(e, t, n, o, r, i) {
  return e ? t ? So(e.edge, n, o, r, 0, 0, i) : So(
    e.edge,
    n,
    o,
    r,
    e.groupWidth,
    e.pointInGroup,
    i
  ) : { p1: { x: 0, y: 0 }, p2: { x: 0, y: 0 } };
}
function Cu(e, t, n) {
  const o = {}, r = {}, i = {};
  for (const [s, l] of Object.entries(n)) {
    if (!(l.source in t && l.target in t))
      continue;
    const c = [l.source, l.target].sort().join("<=>"), u = i[c] || {};
    u[s] = l, i[c] = u;
  }
  const a = e.edge.gap instanceof Function ? e.edge.gap : (s, l) => e.edge.gap;
  for (const [s, l] of Object.entries(i)) {
    const c = Object.keys(l).length;
    if (c == 0)
      continue;
    const u = a(l, e), [g, m] = Object.entries(l)[0];
    if (c === 1)
      o[g] = { edge: m, pointInGroup: 0, groupWidth: 0 }, r[s] = { edges: l, groupWidth: 0, summarize: !1 };
    else {
      let d = 0;
      const E = Object.entries(l).map(([f, v]) => {
        let x = $.value(e.edge.normal.width, v);
        return isNaN(+x) && (console.warn(
          "[v-network-graph] Edge width is invalid value. id=[%s] value=[%s]",
          f,
          x
        ), x = 1), x / 2;
      }), w = Object.entries(l).map(([f, v], x) => (x > 0 && (d += E[x - 1] + u + E[x]), [f, v, d])), b = d;
      w.forEach(([f, v, x]) => {
        o[f] = { edge: v, pointInGroup: x, groupWidth: b };
      }), r[s] = { edges: l, groupWidth: b, summarize: !1 };
    }
  }
  return { edgeLayoutPoints: o, edgeGroups: r };
}
function _o(e, t, n, o) {
  if (Object.entries(t).length === 1)
    return !1;
  const i = Math.min(
    ...Object.values(t).flatMap((a) => [e[a.source], e[a.target]]).filter((a) => a).map((a) => {
      const s = $.values(n.node.normal, a);
      return s.type === "circle" ? s.radius * 2 : Math.min(s.width, s.height);
    })
  );
  return o > i;
}
function So(e, t, n, o, r, i, a) {
  var s, l, c, u, g, m, d, E;
  let w, b, f, v;
  return e.source < e.target ? [w, b, f, v] = Oo(
    (s = t == null ? void 0 : t.x) != null ? s : 0,
    (l = t == null ? void 0 : t.y) != null ? l : 0,
    (c = n == null ? void 0 : n.x) != null ? c : 0,
    (u = n == null ? void 0 : n.y) != null ? u : 0,
    o,
    r,
    i,
    a
  ) : [f, v, w, b] = Oo(
    (g = n == null ? void 0 : n.x) != null ? g : 0,
    (m = n == null ? void 0 : n.y) != null ? m : 0,
    (d = t == null ? void 0 : t.x) != null ? d : 0,
    (E = t == null ? void 0 : t.y) != null ? E : 0,
    o,
    r,
    i,
    a
  ), { p1: { x: w, y: b }, p2: { x: f, y: v } };
}
function Oo(e, t, n, o, r, i, a, s) {
  const l = n - e, c = o - t;
  let u = (i / 2 - a) * r;
  if (u !== 0 && s !== "clock") {
    const g = Math.atan2(o - t, n - e);
    if (s === "vertical") {
      const m = Math.PI / 2;
      (g < -m || g >= m) && (u *= -1);
    } else
      s === "horizontal" && g < 0 && (u *= -1);
  }
  if (l === 0) {
    const g = c < 0 ? -1 : 1;
    return [e + u * g, t, n + u * g, o];
  } else if (c === 0) {
    const g = l < 0 ? 1 : -1;
    return [e, t + u * g, n, o + u * g];
  } else {
    const g = c / l, m = -1 / g;
    c < 0 && (u = -u);
    const d = u / Math.sqrt(1 + Math.pow(m, 2));
    return [e + d, t + d * m, n + d, o + d * m];
  }
}
function kr(e, t, n) {
  return n || (n = { x: 0, y: 0 }), n.x = e.x + t.x, n.y = e.y + t.y, n;
}
function Mr(e, t, n) {
  return n || (n = { x: 0, y: 0 }), n.x = e.x - t.x, n.y = e.y - t.y, n;
}
function Tr(e, t, n) {
  return n || (n = { x: 0, y: 0 }), n.x = e.x * t.x, n.y = e.y * t.y, n;
}
function Cr(e, t, n) {
  return n || (n = { x: 0, y: 0 }), n.x = e.x * t, n.y = e.y * t, n;
}
function Sn(e, t, n) {
  return n || (n = { x: 0, y: 0 }), n.x = e.x / t.x, n.y = e.y / t.y, n;
}
function $r(e, t) {
  return e.x * t.x + e.y * t.y;
}
function zr(e, t) {
  return e.x * t.y - e.y * t.x;
}
function On(e) {
  return e.x * e.x + e.y * e.y;
}
function kn(e) {
  return Math.sqrt(On(e));
}
function Mn(e, t) {
  const n = e.x - t.x, o = e.y - t.y;
  return n * n + o * o;
}
function Ir(e, t) {
  return Math.sqrt(Mn(e, t));
}
function Ar(e, t) {
  t || (t = { x: 0, y: 0 });
  const n = kn(e);
  return n === 0 ? (t.x = 1, t.y = 0) : Sn(e, { x: n, y: n }, t), t;
}
function Tt(e, t, n) {
  n || (n = { x: 0, y: 0 });
  const o = e.x * Math.cos(t) - e.y * Math.sin(t), r = e.x * Math.sin(t) + e.y * Math.cos(t);
  return n.x = o, n.y = r, n;
}
const $u = 180 / Math.PI;
function zu(e) {
  return e * $u;
}
function Tn(e) {
  return Math.atan2(e.y, e.x);
}
function jr(e) {
  return zu(Tn(e));
}
const Iu = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  add: kr,
  subtract: Mr,
  multiply: Tr,
  multiplyScalar: Cr,
  divide: Sn,
  dot: $r,
  cross: zr,
  lengthSquared: On,
  length: kn,
  distanceSquared: Mn,
  distance: Ir,
  normalize: Ar,
  rotate: Tt,
  angle: Tn,
  angleDegree: jr
}, Symbol.toStringTag, { value: "Module" }));
class N {
  static fromArray(t) {
    return new N(t[0] || 0, t[1] || 0);
  }
  static fromObject(t) {
    return new N(t.x, t.y);
  }
  constructor(t, n) {
    this.x = t, this.y = n;
  }
  add(t) {
    return kr(this, t, this);
  }
  subtract(t) {
    return Mr(this, t, this);
  }
  multiply(t) {
    return Tr(this, t, this);
  }
  multiplyScalar(t) {
    return Cr(this, t, this);
  }
  divide(t) {
    return Sn(this, t, this);
  }
  dot(t) {
    return $r(this, t);
  }
  cross(t) {
    return zr(this, t);
  }
  lengthSquared() {
    return On(this);
  }
  length() {
    return kn(this);
  }
  distanceSquared(t) {
    return Mn(this, t);
  }
  distance(t) {
    return Ir(this, t);
  }
  normalize() {
    return Ar(this, this);
  }
  angle() {
    return Tn(this);
  }
  angleDegree() {
    return jr(this);
  }
  rotate(t) {
    return Tt(this, t, this);
  }
  isEqualTo(t) {
    return this.x === t.x && this.y === t.y;
  }
  clone() {
    return new N(this.x, this.y);
  }
  toObject() {
    return { x: this.x, y: this.y };
  }
  toArray() {
    return [this.x, this.y];
  }
}
var Au = Object.defineProperty, ko = Object.getOwnPropertySymbols, ju = Object.prototype.hasOwnProperty, Lu = Object.prototype.propertyIsEnumerable, Mo = (e, t, n) => t in e ? Au(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, Du = (e, t) => {
  for (var n in t || (t = {}))
    ju.call(t, n) && Mo(e, n, t[n]);
  if (ko)
    for (var n of ko(t))
      Lu.call(t, n) && Mo(e, n, t[n]);
  return e;
};
const ee = Du({
  Vector2D: N
}, Iu);
class X {
  constructor(t, n, o) {
    this.source = t, this.target = n, this.v = o;
  }
  static fromLinePosition(t) {
    const n = N.fromObject(t.p1), o = N.fromObject(t.p2);
    return new X(n, o, Ye(n, o));
  }
  static fromPositions(t, n) {
    const o = N.fromObject(t), r = N.fromObject(n);
    return new X(o, r, Ye(o, r));
  }
  static fromVectors(t, n) {
    return new X(t, n, Ye(t, n));
  }
}
function Ye(e, t) {
  return t.clone().subtract(e);
}
function Zu(e) {
  return [N.fromObject(e.p1), N.fromObject(e.p2)];
}
function Nu(e) {
  return new N((e.p1.x + e.p2.x) / 2, (e.p1.y + e.p2.y) / 2);
}
function Ct(e, t) {
  return { p1: e, p2: t };
}
function hn(e, t, n) {
  const o = X.fromLinePosition(e);
  return Bu(o, t, n);
}
function Bu(e, t, n) {
  const o = e.v.clone().normalize(), r = e.source.clone().add(o.clone().multiplyScalar(t)), i = e.target.clone().subtract(o.clone().multiplyScalar(n));
  let a = r.toObject(), s = i.toObject();
  const l = Ye(r, i);
  if (e.v.angle() * l.angle() < 0) {
    const c = new N((a.x + s.x) / 2, (a.y + s.y) / 2), u = c.clone().add(o.multiplyScalar(0.5));
    a = c.toObject(), s = u.toObject();
  }
  return { p1: a, p2: s };
}
function Ru(e) {
  return { p1: e.p2, p2: e.p1 };
}
function it(e) {
  const t = e.v.clone().normalize().rotate(Math.PI / 2);
  return X.fromVectors(e.target, e.target.clone().add(t));
}
var xe = Math.pow;
function Cn(e, t) {
  const n = t.v.clone().normalize(), o = t.source, r = ee.subtract(e, o), i = n.dot(r);
  return o.clone().add(n.multiplyScalar(i));
}
function Dt(e, t, n, o) {
  if (!(ee.lengthSquared(ee.subtract(t, n)) - o * o <= Math.pow(1, -10)))
    return null;
  const a = X.fromVectors(e, t), s = Cn(n, a), l = ee.length(ee.subtract(s, n));
  if (o < l)
    return null;
  if (o === l)
    return s;
  const c = Math.sqrt(xe(o, 2) - xe(l, 2)), u = a.v.normalize().multiplyScalar(c);
  return s.subtract(u);
}
function Vu(e, t, n, o, r) {
  if (!(ee.lengthSquared(ee.subtract(t, n)) - o * o <= Math.pow(1, -10)))
    return null;
  const s = X.fromVectors(e, t), l = Cn(n, s), c = ee.length(ee.subtract(l, n));
  if (o < c)
    return null;
  if (o === c)
    return l;
  const u = Math.sqrt(xe(o, 2) - xe(c, 2)), g = s.v.normalize().multiplyScalar(u), m = l.clone().add(g), d = l.clone().subtract(g), E = r.distance(m), w = r.distance(d);
  return Math.abs(E - w) < 2 ? d : E < w ? m : d;
}
function De(e, t) {
  const n = ee.subtract(t.source, e.source), o = e.v, r = t.v, i = ee.cross(n, o) / ee.cross(o, r);
  return t.source.clone().add(r.clone().multiplyScalar(i));
}
function ct(e, t, n, o, r) {
  const i = e, s = n.clone().subtract(i), l = s.length(), c = t + o;
  if (c < l)
    return null;
  const u = Math.abs(t - o);
  if (l < u)
    return null;
  if (l === c) {
    const p = s.clone().normalize(), P = e.clone().add(p.multiplyScalar(t));
    return r ? P : [P, P];
  }
  if (l === u) {
    const p = s.clone().normalize(), P = t > o, S = e.clone().add(p.multiplyScalar(P ? t : -t));
    return r ? S : [S, S];
  }
  const g = t, m = o, d = (xe(l, 2) + xe(g, 2) - xe(m, 2)) / (2 * l * g), E = g * d, w = Math.sqrt(xe(g, 2) - xe(E, 2)), b = s.clone().normalize(), f = new N(-b.y, b.x), v = b.clone().multiplyScalar(E), x = f.clone().multiplyScalar(w), y = e.clone().add(v).add(x), h = e.clone().add(v).subtract(x);
  if (r) {
    const p = y.distance(r), P = h.distance(r);
    return p < P ? y : h;
  } else
    return [y, h];
}
var yt = Math.pow;
function To(e, t, n, o) {
  const r = X.fromPositions(e, t), i = (n.width + n.strokeWidth) / 2 * o, a = (n.height + n.strokeWidth) / 2 * o, s = n.borderRadius > 0 ? (n.borderRadius + n.strokeWidth / 2) * o : 0, l = (r.v.angle() - Math.PI / 2) % Math.PI, c = Math.PI / 2 - l % Math.PI, u = a * Math.abs(Math.tan(l)), g = i * Math.abs(Math.tan(c)), m = u <= i - s, d = g <= a - s;
  if (m || d || s === 0)
    return Math.sqrt(m ? yt(a, 2) + yt(u, 2) : yt(i, 2) + yt(g, 2));
  {
    const E = t.x - i + s, w = t.y - a + s, b = t.x + i - s, f = t.y + a - s, v = [
      new N(E, w),
      new N(b, w),
      new N(b, f),
      new N(E, f)
    ], x = Math.floor((r.v.angleDegree() + 360) % 360 / 90), y = v[x], h = Dt(
      r.source,
      Cn(y, r),
      y,
      s
    );
    return h ? Ye(h, r.target).length() : Ye(y, r.target).length() + s;
  }
}
function Co(e, t, n, o, r) {
  const i = X.fromLinePosition(e), a = i.v.clone().normalize(), s = o === 0 ? i.source : i.source.clone().add(a.clone().multiplyScalar(o * r)), l = o === 0 ? i.target : i.target.clone().subtract(a.clone().multiplyScalar(o * r)), c = (t.width / 2 + n) * r, u = new N(-a.y, a.x).multiplyScalar(c);
  let g = ee.subtract(s, u), m = ee.add(s, u), d = ee.subtract(l, u), E = ee.add(l, u);
  const w = i.v.angleDegree();
  return (w < -90 || w >= 90) && ([g, m] = [m, g], [d, E] = [E, d]), {
    source: { above: g, below: m },
    target: { above: d, below: E }
  };
}
function qu(e, t, n, o) {
  let r;
  n.type === "circle" ? r = n.radius + n.strokeWidth / 2 : r = To(
    t,
    e,
    n,
    1
  );
  let i;
  return o.type === "circle" ? i = o.radius + o.strokeWidth / 2 : i = To(
    e,
    t,
    o,
    1
  ), [r, i];
}
function $e(e, t, n) {
  const { x: o, y: r } = e, i = o - t.x, a = r - t.y;
  return {
    x: i * Math.cos(n) - a * Math.sin(n) + t.x,
    y: i * Math.sin(n) + a * Math.cos(n) + t.y
  };
}
function vn(e) {
  return e > 0 ? -(Math.PI * 2 - e) : Math.PI * 2 + e;
}
function pn(e, t, n, o) {
  const r = [], i = X.fromVectors(t, e), a = X.fromVectors(t, n);
  let s = Qe(i, a);
  o * s < 0 && (s = vn(s));
  const l = N.fromObject($e(e, t, -s / 2)), c = X.fromVectors(t, l), u = it(c), g = Qe(i, c);
  let m = it(i);
  if (Math.abs(g) < Math.PI / 2) {
    const E = De(m, u);
    r.push(E);
  } else {
    const E = N.fromObject($e(l, t, g / 2)), w = it(
      X.fromVectors(t, N.fromObject(E))
    ), b = De(m, w), f = De(w, u);
    r.push(b, E, f);
  }
  r.push(l);
  const d = Qe(a, c);
  if (m = it(a), Math.abs(d) < Math.PI / 2) {
    const E = De(m, u);
    r.push(E);
  } else {
    const E = N.fromObject($e(l, t, d / 2)), w = it(
      X.fromVectors(t, N.fromObject(E))
    ), b = De(u, w), f = De(w, m);
    r.push(b, E, f);
  }
  return r;
}
function Qe(e, t) {
  return Math.atan2(
    e.v.y * t.v.x - e.v.x * t.v.y,
    e.v.x * t.v.x + e.v.y * t.v.y
  );
}
function Hu(e, t, n) {
  const o = e.x, r = e.y, i = t.x, a = t.y, s = n.x, l = n.y, c = o - i, u = r - a, g = s - i, m = l - a, d = (m * (c * (o + i) + u * (r + a)) - u * (g * (s + i) + m * (l + a))) / (2 * c * m - 2 * u * g), E = (-g * (c * (o + i) + u * (r + a)) + c * (g * (s + i) + m * (l + a))) / (2 * c * m - 2 * u * g), w = Math.sqrt(Math.pow(o - d, 2) + Math.pow(r - E, 2));
  return [new N(d, E), w];
}
function Ke(e) {
  return e.type == "circle" ? e.radius : Math.min(e.width, e.height) / 2;
}
function Wu(e) {
  return typeof btoa === void 0 ? Buffer.from(e).toString("base64").replaceAll("=", "") : btoa(e).replaceAll("=", "");
}
var Fu = Object.defineProperty, Uu = Object.defineProperties, Gu = Object.getOwnPropertyDescriptors, $o = Object.getOwnPropertySymbols, Xu = Object.prototype.hasOwnProperty, Ku = Object.prototype.propertyIsEnumerable, zo = (e, t, n) => t in e ? Fu(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, Yu = (e, t) => {
  for (var n in t || (t = {}))
    Xu.call(t, n) && zo(e, n, t[n]);
  if ($o)
    for (var n of $o(t))
      Ku.call(t, n) && zo(e, n, t[n]);
  return e;
}, Qu = (e, t) => Uu(e, Gu(t));
function Ju() {
  return { markers: Se({}), referenceCount: {} };
}
function ec(e) {
  const { markers: t, referenceCount: n } = e;
  function o(s, l) {
    var c;
    const u = (c = n[s]) != null ? c : 0;
    n[s] = u + 1, u || (t[s] = l);
  }
  function r(s) {
    var l;
    const c = (l = n[s]) != null ? l : 0;
    c && (c - 1 === 0 ? (delete t[s], delete n[s]) : n[s] = c - 1);
  }
  function i(s) {
    s && r(s);
  }
  function a(s, l, c, u, g) {
    if (s.type === "none") {
      i(c);
      return;
    }
    if (s.type === "custom")
      return i(c), s.customId;
    const m = tc(s, l, u), d = nc(m, g);
    return d === c || (i(c), o(d, m)), d;
  }
  return {
    makeMarker: a,
    clearMarker: i
  };
}
function tc(e, t, n) {
  var o;
  return Qu(Yu({}, e), {
    color: (o = e.color) != null ? o : n,
    isSource: t
  });
}
function nc(e, t) {
  const n = Wu(e.color), o = e.isSource ? "L" : "R", r = e.units === "strokeWidth" ? "rel" : "abs";
  return `marker_${t}_${e.type}_${e.width}_${e.height}_${e.margin}_${n}_${o}_${r}`;
}
function Kt(e, t, n, o, r, i, a) {
  const s = Se({});
  q(
    () => new Set(Object.keys(e.value)),
    (c, u) => {
      u || (u = /* @__PURE__ */ new Set([]));
      for (const g of c)
        u.has(g) || oc(e, s, g, !1, t, r);
      for (const g of u)
        c.has(g) || (n.delete(g), o.delete(g), i == null || i(g, s[g]), delete s[g]);
    },
    { immediate: !0 }
  ), q(
    () => [...n],
    (c, u) => {
      const g = u ? c.filter((d) => !u.includes(d)) : c, m = u ? u.filter((d) => !c.includes(d)) : [];
      g.forEach((d) => {
        const E = s[d];
        E && !E.selected && (E.selected = !0);
      }), m.forEach((d) => {
        const E = s[d];
        E && E.selected && (E.selected = !1);
      });
    },
    { immediate: !0 }
  ), q(
    () => [...o],
    (c, u) => {
      const g = c.filter((d) => !u.includes(d)), m = u.filter((d) => !c.includes(d));
      g.forEach((d) => {
        const E = s[d];
        E && !E.hovered && (E.hovered = !0);
      }), m.forEach((d) => {
        const E = s[d];
        E && E.hovered && (E.hovered = !1);
      });
    }
  );
  const l = M(() => {
    const c = a ? a() : Object.values(s);
    return t.zOrder.enabled ? rc(c, t.zOrder, o, n) : c;
  });
  return { states: s, zOrderedList: l };
}
function oc(e, t, n, o, r, i) {
  const a = {
    id: n,
    selected: o,
    hovered: !1,
    selectable: M(() => e.value[n] ? $.value(r.selectable, e.value[n]) : _(a.selectable)),
    zIndex: M(() => e.value[n] ? $.value(r.zOrder.zIndex, e.value[n]) : _(a.zIndex))
  };
  t[n] = a, i(e, n, t[n]);
}
function rc(e, t, n, o) {
  return t.bringToFrontOnHover && t.bringToFrontOnSelected ? e.sort((r, i) => {
    const a = n.has(r.id), s = n.has(i.id);
    if (a != s)
      return a ? 1 : -1;
    const l = o.has(r.id), c = o.has(i.id);
    return l != c ? l ? 1 : -1 : r.zIndex - i.zIndex;
  }) : t.bringToFrontOnHover ? e.sort((r, i) => {
    const a = n.has(r.id), s = n.has(i.id);
    return a != s ? a ? 1 : -1 : r.zIndex - i.zIndex;
  }) : t.bringToFrontOnSelected ? e.sort((r, i) => {
    const a = o.has(r.id), s = o.has(i.id);
    return a != s ? a ? 1 : -1 : r.zIndex - i.zIndex;
  }) : e.sort((r, i) => r.zIndex - i.zIndex);
}
function Yt(e, t, n) {
  return {
    objects: e,
    selected: t,
    hovered: n
  };
}
const Lr = Symbol("states"), ic = {
  type: "none",
  width: 0,
  height: 0,
  margin: 0,
  units: "strokeWidth",
  color: null
};
function sc(e, t, n, o, r, i, a) {
  const s = Se({}), {
    states: l,
    zOrderedList: c
  } = Kt(
    e.objects,
    o.node,
    e.selected,
    e.hovered,
    (v, x, y) => {
      uc(v, x, y, o.node);
    },
    (v, x) => {
      const y = r.nodes;
      delete y[v];
    }
  ), u = kl(), g = Mu(e.objects, t.objects, o), m = A([]), {
    states: d,
    zOrderedList: E
  } = Kt(
    t.objects,
    o.edge,
    t.selected,
    t.hovered,
    (v, x, y) => {
      dc(
        v,
        x,
        y,
        o.edge,
        i,
        l,
        g,
        r,
        a,
        u
      );
    },
    (v, x) => {
      var y;
      (y = x.stopWatchHandle) == null || y.call(x);
    },
    () => m.value
  );
  ve(() => {
    m.value = fc(g.edgeGroups, d);
  }), q(
    g.edgeGroups,
    (v) => pc(s, g, o),
    { immediate: !0 }
  );
  const {
    states: w,
    zOrderedList: b
  } = Kt(
    n.objects,
    o.path,
    n.selected,
    n.hovered,
    (v, x, y) => {
      const h = y;
      h.clickable = M(() => v.value[x] ? $.value(o.path.clickable, v.value[x]) : !1), h.hoverable = M(() => v.value[x] ? $.value(o.path.hoverable, v.value[x]) : !1), h.path = v.value[x], h.edges = M(() => v.value[x].edges.map((P) => ({ edgeId: P, edge: t.objects.value[P] })).filter((P) => P.edge));
    }
  ), f = {
    nodeStates: l,
    edgeStates: d,
    edgeGroupStates: g,
    summarizedEdgeStates: s,
    pathStates: w,
    layouts: r,
    nodeZOrderedList: c,
    edgeZOrderedList: E,
    pathZOrderedList: b
  };
  return Je(Lr, f), f;
}
function ac(e) {
  return e.summarized;
}
function gt() {
  return F(et(Lr), "states");
}
function lc(e, t, n, o) {
  return n && o.hover ? $.values(o.hover, e) : Dr(e, t, o);
}
function Dr(e, t, n) {
  return t && n.selected ? $.values(n.selected, e) : $.values(n.normal, e);
}
function uc(e, t, n, o) {
  n.shape = M(() => e.value[t] ? lc(e.value[t], n.selected, n.hovered, o) : _(n.shape)), n.staticShape = M(() => e.value[t] ? Dr(e.value[t], n.selected, o) : _(n.staticShape)), n.label = M(() => e.value[t] ? $.values(o.label, e.value[t]) : _(n.label)), n.labelText = M(() => {
    var r, i;
    return o.label.text instanceof Function ? _(n.label).text : e.value[t] ? (i = (r = e.value[t]) == null ? void 0 : r[_(n.label).text]) != null ? i : "" : _(n.labelText);
  }), n.draggable = M(() => e.value[t] ? $.value(o.draggable, e.value[t]) : _(n.draggable));
}
function cc(e, t, n, o) {
  return t ? $.values(o.selected, e) : n && o.hover ? $.values(o.hover, e) : $.values(o.normal, e);
}
function Io(e) {
  return e.type === "none" ? ic : e;
}
function dc(e, t, n, o, r, i, a, s, l, c) {
  const { makeMarker: u, clearMarker: g } = ec(r);
  Object.assign(n, {
    origin: { p1: { x: 0, y: 0 }, p2: { x: 0, y: 0 } },
    labelPosition: { p1: { x: 0, y: 0 }, p2: { x: 0, y: 0 } },
    position: { p1: { x: 0, y: 0 }, p2: { x: 0, y: 0 } }
  });
  const m = M(() => {
    const f = e.value[t], v = cc(f, n.selected, n.hovered, o);
    isNaN(+v.width) && (console.warn(
      "[v-network-graph] Edge width is invalid value. id=[%s] value=[%s]",
      t,
      v.width
    ), v.width = 1), (v.color === void 0 || v.color === null) && (console.warn(
      "[v-network-graph] Edge color is invalid value. id=[%s] value=[%s]",
      t,
      v.color
    ), v.color = "#000000");
    let x = $.value(o.normal.width, f);
    isNaN(+x) && (x = 1);
    const y = Io($.values(o.marker.source, [f, v])), h = Io($.values(o.marker.target, [f, v]));
    return { stroke: v, normalWidth: x, source: y, target: h };
  });
  n.line = m;
  const d = Ce(
    a.edgeLayoutPoints,
    t
  ), E = Ce(a.summarizedEdges, t), w = ve(() => {
    var f, v, x, y, h;
    const p = e.value[t];
    if (!p)
      return;
    const P = s.nodes[p == null ? void 0 : p.source], S = s.nodes[p == null ? void 0 : p.target], k = (f = i[p.source]) == null ? void 0 : f.staticShape, I = (v = i[p.target]) == null ? void 0 : v.staticShape;
    if (!P || !S || !k || !I)
      return;
    const z = Tu(
      d.value,
      (x = E.value) != null ? x : !1,
      P,
      S,
      l.value,
      o.keepOrder
    ), [j, B] = qu(P, S, k, I), U = l.value;
    n.labelPosition = hn(
      z,
      j * U,
      B * U
    );
    let L = 0, H = 0;
    const W = m.value;
    if (W.source.type !== "none") {
      const se = W.source;
      L = se.margin + se.width, se.units === "strokeWidth" && (L *= W.normalWidth);
    }
    if (W.target.type !== "none") {
      const se = W.target;
      H = se.margin + se.width, se.units === "strokeWidth" && (H *= W.normalWidth);
    }
    o.margin && (L += o.margin, H += o.margin);
    const ie = !!o.margin || W.source.type !== "none" || W.target.type !== "none";
    if (p.source === p.target) {
      n.origin = Ct(P, S);
      const se = $.values(o.selfLoop, p), [je, Xe] = vc(
        P,
        k,
        se,
        ie,
        L,
        H,
        (h = (y = d.value) == null ? void 0 : y.pointInGroup) != null ? h : 0,
        U
      );
      n.position = je, n.loop = Xe, n.curve = void 0;
      return;
    } else
      n.loop = void 0;
    if (ie && (L += j, H += B), o.type === "straight")
      n.origin = z, n.curve = void 0, L === 0 && H === 0 ? n.position = n.origin : n.position = hn(n.origin, L * U, H * U);
    else {
      n.origin = Ct(P, S);
      const se = d.value ? d.value.groupWidth / 2 - d.value.pointInGroup : 0, [je, Xe] = hc(
        n.origin,
        z,
        se,
        L * U,
        H * U
      );
      n.position = je, n.curve = Xe;
    }
  }), b = ve(() => {
    !e.value[t] || (n.sourceMarkerId = u(
      m.value.source,
      !0,
      n.sourceMarkerId,
      m.value.stroke.color,
      c
    ), n.targetMarkerId = u(
      m.value.target,
      !1,
      n.targetMarkerId,
      m.value.stroke.color,
      c
    ));
  });
  n.stopWatchHandle = () => {
    w(), b(), g(n.sourceMarkerId), g(n.targetMarkerId);
  };
}
function fc(e, t) {
  return Object.entries(e).map(([n, o]) => {
    var r;
    return o.summarize ? {
      id: (r = Object.keys(o.edges)[0]) != null ? r : n,
      summarized: !0,
      key: n,
      group: o,
      zIndex: Object.keys(o.edges).map((i) => {
        var a, s;
        return (s = (a = t[i]) == null ? void 0 : a.zIndex) != null ? s : 0;
      }).reduce((i, a) => Math.max(i, a))
    } : Object.entries(o.edges).map(
      ([i, a]) => {
        var s, l;
        return {
          id: i,
          summarized: !1,
          key: i,
          edge: a,
          zIndex: (l = (s = t[i]) == null ? void 0 : s.zIndex) != null ? l : 0
        };
      }
    );
  }).flat();
}
function hc(e, t, n, o, r) {
  const i = X.fromLinePosition(e), a = X.fromLinePosition(t), s = Nu(t), [l, c] = Hu(
    i.source,
    i.target,
    s
  );
  let u, g;
  if (n === 0)
    return o === 0 && r === 0 ? u = e : u = hn(e, o, r), [u, g];
  const m = X.fromVectors(l, s), d = Qe(
    X.fromVectors(l, i.source),
    m
  );
  if (o === 0 && r === 0)
    u = e;
  else {
    let f = o / c, v = r / c;
    d > 0 && (f *= -1, v *= -1), u = Ct(
      $e(i.source, l, f),
      $e(i.target, l, -v)
    );
    let x = Qe(
      X.fromVectors(l, i.source),
      X.fromVectors(l, i.target)
    ), y = Qe(
      X.fromPositions(l, u.p1),
      X.fromPositions(l, u.p2)
    );
    if (d * x < 0 && (x = vn(x), d * y < 0 && (y = vn(y))), x * y < 0) {
      const h = s.clone().add(a.v.normalize().multiplyScalar(0.5));
      return u = Ct(s, h), [u, g];
    }
  }
  const [E, w] = Zu(u), b = pn(E, l, w, d).map((f) => f.toObject());
  return g = {
    center: s,
    theta: d,
    circle: { center: l, radius: c },
    control: b
  }, [u, g];
}
function vc(e, t, n, o, r, i, a, s) {
  const l = s, c = (n.radius + a / 2) * l, u = n.offset * l + c, g = (n.angle - 90) * (Math.PI / 180), m = N.fromObject({
    x: e.x + u * Math.cos(g),
    y: e.y + u * Math.sin(g)
  }), d = n.isClockwise;
  let E, w;
  if (o) {
    const y = ct(
      m,
      c,
      N.fromObject(e),
      Ke(t) * l
    );
    if (y) {
      [E, w] = y;
      let h = 1;
      if (d || ([E, w] = [w, E], h = -1), r !== 0 || i !== 0) {
        const p = r * l / c * h, P = i * l / c * h;
        E = $e(E, m, p), w = $e(w, m, -P);
      }
    }
  }
  if (E === void 0 || w === void 0) {
    const y = N.fromObject(e).subtract(m).normalize().multiplyScalar(c);
    let h = 1 * (Math.PI / 180);
    d || (h *= -1), E = m.clone().add(Tt(y, h)), w = m.clone().add(Tt(y, -h));
  }
  const b = N.fromObject(E).subtract(m).angleDegree(), x = (N.fromObject(w).subtract(m).angleDegree() + 360 - b) % 360 >= 180;
  return [
    { p1: E, p2: w },
    {
      center: m,
      radius: [c, c],
      isLargeArc: d ? x : !x,
      isClockwise: d
    }
  ];
}
function pc(e, t, n) {
  const o = t.edgeGroups;
  Object.entries(o).filter(([r, i]) => i.summarize && !(r in e)).forEach(([r, i]) => {
    const a = { stroke: void 0 };
    a.stroke = M(
      () => $.values(n.edge.summarized.stroke, i.edges)
    ), e[r] = a;
  }), Object.keys(e).forEach((r) => {
    var i;
    (i = t.edgeGroups[r]) != null && i.summarize || delete e[r];
  });
}
class at {
  static valueOf(t) {
    return Array.from(t.values());
  }
}
const gc = 3, mc = 6, Zr = 500;
function Pt(e) {
  return e === "touch" ? mc : gc;
}
function $n(e, t, n, o) {
  let r = e.get(t);
  if (r)
    r.id !== n && (r = void 0);
  else {
    const s = Array.from(e.entries()).find(([l, c]) => c.id === n);
    if (s) {
      const [l, c] = s;
      e.delete(l), r = c;
    }
  }
  let i, a;
  return [r, i, a] = Nr(r, o, n), e.set(t, r), [i, a];
}
function Nr(e, t, n) {
  const o = Date.now();
  e && o - e.lastTime <= Zr ? (e.count++, e.lastTime = o) : e = { count: 1, lastTime: o, id: n };
  const r = {
    view: window,
    screenX: t.screenX,
    screenY: t.screenY,
    clientX: t.clientX,
    clientY: t.clientY,
    ctrlKey: t.ctrlKey,
    shiftKey: t.shiftKey,
    altKey: t.altKey,
    metaKey: t.metaKey,
    button: t.button,
    buttons: t.buttons,
    detail: e.count
  };
  let i, a;
  return t instanceof PointerEvent ? (Object.assign(r, {
    pointerId: t.pointerId,
    width: t.width,
    height: t.height,
    pressure: t.pressure,
    tangentialPressure: t.tangentialPressure,
    tiltX: t.tiltX,
    tiltY: t.tiltY,
    twist: t.twist,
    pointerType: t.pointerType,
    isPrimary: t.isPrimary
  }), i = new PointerEvent("click", r), e.count === 2 && (a = new PointerEvent("dblclick", r))) : (i = new MouseEvent("click", r), e.count === 2 && (a = new MouseEvent("dblclick", r))), [e, i, a];
}
function zn(e) {
  const t = Date.now();
  Array.from(e.entries()).filter(([n, o]) => t - o.lastTime > Zr).map(([n, o]) => e.delete(n));
}
var yc = Object.defineProperty, Ao = Object.getOwnPropertySymbols, bc = Object.prototype.hasOwnProperty, wc = Object.prototype.propertyIsEnumerable, jo = (e, t, n) => t in e ? yc(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, gn = (e, t) => {
  for (var n in t || (t = {}))
    bc.call(t, n) && jo(e, n, t[n]);
  if (Ao)
    for (var n of Ao(t))
      wc.call(t, n) && jo(e, n, t[n]);
  return e;
};
function Ec(e, t, n, o, r, i, a) {
  const s = {
    pointers: /* @__PURE__ */ new Map(),
    follow: {
      followedPointerId: -1,
      nodeBasePositions: {}
    },
    hoveredNodesPre: /* @__PURE__ */ new Set(),
    clicks: /* @__PURE__ */ new Map()
  }, l = {
    pointermove: d,
    pointerup: w,
    pointercancel: E
  };
  function c(y) {
    const h = s.follow.followedPointerId === y.pointerId, p = r.has(y.nodeId), P = !(y.pointerId in s.pointers);
    if (h && P || h && !p) {
      const S = at.valueOf(s.pointers).find((k) => r.has(k.nodeId));
      if (!S) {
        s.follow = { followedPointerId: -1, nodeBasePositions: {} };
        return;
      }
      y = S, s.follow.followedPointerId = y.pointerId;
    } else {
      const S = s.pointers.get(s.follow.followedPointerId);
      if (!S) {
        s.follow = { followedPointerId: -1, nodeBasePositions: {} };
        return;
      }
      y = S;
    }
    if (h || p) {
      const S = at.valueOf(s.pointers).map((k) => k.nodeId);
      s.follow.nodeBasePositions = Object.fromEntries(
        Array.from(r).filter((k) => !S.includes(k)).filter((k) => {
          var I;
          return (I = e[k]) == null ? void 0 : I.draggable;
        }).map((k) => [k, Qt(t.nodes, k)])
      ), y.dragBasePosition = gn({}, y.latestPosition), y.nodeBasePosition = Qt(t.nodes, y.nodeId);
    }
  }
  q(r, (y) => {
    const h = s.pointers.get(s.follow.followedPointerId);
    h && c(h), y.size > 0 && n.selectionMode.value !== "node" ? n.selectionMode.value = "node" : y.size === 0 && n.selectionMode.value === "node" && (n.selectionMode.value = "container");
  }), q(n.selectionMode, (y) => {
    y !== "node" && r.clear();
  });
  function u(y, h) {
    const p = y.dragBasePosition.x - h.pageX, P = y.dragBasePosition.y - h.pageY, S = s.follow.followedPointerId == y.pointerId ? gn({
      [y.nodeId]: y.nodeBasePosition
    }, s.follow.nodeBasePositions) : { [y.nodeId]: y.nodeBasePosition }, k = i.value;
    return Object.fromEntries(
      Object.entries(S).map(([I, z]) => [
        I,
        {
          x: z.x - p / k,
          y: z.y - P / k
        }
      ])
    );
  }
  function g(y, h) {
    var p, P;
    if (h.isTrusted || h.shiftKey && !["container", "node"].includes(n.selectionMode.value))
      return;
    n.selectionMode.value = "node";
    const S = (P = (p = e[y]) == null ? void 0 : p.selectable) != null ? P : !1;
    if (S) {
      const k = at.valueOf(s.pointers).filter((I) => r.has(I.nodeId)).length > 0;
      h.shiftKey || k ? r.has(y) ? r.delete(y) : typeof S == "number" && r.size >= S || r.add(y) : r.has(y) || (r.clear(), r.add(y));
    }
    a.emit("node:click", { node: y, event: h });
  }
  function m(y, h) {
    h.isTrusted || a.emit("node:dblclick", { node: y, event: h });
  }
  function d(y) {
    var h;
    y.stopPropagation();
    const p = s.pointers.get(y.pointerId);
    if (!p)
      return;
    p.latestPosition = { x: y.pageX, y: y.pageY }, p.moveCounter++;
    const P = Pt(y.pointerType);
    if (p.moveCounter <= P || !((h = e[p.nodeId]) != null && h.draggable))
      return;
    if (p.moveCounter === P + 1) {
      const k = u(p, {
        pointerId: p.pointerId,
        pageX: p.dragBasePosition.x,
        pageY: p.dragBasePosition.y
      });
      a.emit("node:dragstart", k);
    }
    const S = u(p, y);
    a.emit("node:pointermove", S);
  }
  function E(y) {
    y.stopPropagation();
    let h = s.pointers.get(y.pointerId);
    if (!!h) {
      for (h of s.pointers.values()) {
        const p = h.nodeId, P = Pt(y.pointerType);
        if (h.moveCounter > P) {
          const k = u(h, {
            pointerId: h.pointerId,
            pageX: h.latestPosition.x,
            pageY: h.latestPosition.y
          });
          a.emit("node:dragend", k);
        }
        a.emit("node:pointerup", { node: p, event: y });
      }
      s.pointers.clear(), s.follow = { followedPointerId: -1, nodeBasePositions: {} }, ue(l).forEach(([p, P]) => {
        document.removeEventListener(p, P);
      }), n.viewMode.value = "default";
    }
  }
  function w(y) {
    var h, p, P;
    y.stopPropagation();
    const S = s.pointers.get(y.pointerId);
    if (!S)
      return;
    s.pointers.delete(y.pointerId);
    const k = S.nodeId, I = Pt(y.pointerType), z = S.moveCounter > I;
    if (z) {
      if ((h = e[S.nodeId]) != null && h.draggable) {
        const j = u(S, y);
        a.emit("node:dragend", j), a.emit("node:pointerup", { node: k, event: y });
      }
    } else
      a.emit("node:pointerup", { node: k, event: y });
    if (!z) {
      const [j, B] = $n(
        s.clicks,
        S.pointerId,
        k,
        y
      );
      (p = S.eventTarget) == null || p.dispatchEvent(j), B && ((P = S.eventTarget) == null || P.dispatchEvent(B));
    }
    s.pointers.size === 0 ? (s.follow = { followedPointerId: -1, nodeBasePositions: {} }, ue(l).forEach(([j, B]) => {
      document.removeEventListener(j, B);
    }), zn(s.clicks), n.viewMode.value = "default") : c(S), o.clear(), s.hoveredNodesPre.forEach(o.add, o);
  }
  function b(y, h) {
    if (h.button == 2 || (h.stopPropagation(), !["default", "node"].includes(n.viewMode.value)))
      return;
    s.pointers.size == 0 && (n.viewMode.value = "node", ue(l).forEach(([P, S]) => {
      document.addEventListener(P, S);
    }));
    const p = {
      pointerId: h.pointerId,
      nodeId: y,
      moveCounter: 0,
      nodeBasePosition: Qt(t.nodes, y),
      dragBasePosition: { x: h.pageX, y: h.pageY },
      latestPosition: { x: h.pageX, y: h.pageY },
      eventTarget: h.currentTarget
    };
    s.pointers.set(h.pointerId, p), r.has(y) && (s.follow.followedPointerId < 0 ? (s.follow.followedPointerId = h.pointerId, c(p)) : delete s.follow.nodeBasePositions[p.nodeId]), a.emit("node:pointerdown", { node: y, event: h });
  }
  function f(y, h) {
    s.hoveredNodesPre.add(y), !(s.pointers.size > 0) && (o.add(y), a.emit("node:pointerover", { node: y, event: h }));
  }
  function v(y, h) {
    s.hoveredNodesPre.delete(y), !(s.pointers.size > 0) && (o.delete(y), a.emit("node:pointerout", { node: y, event: h }));
  }
  function x(y, h) {
    h.stopPropagation(), a.emit("node:contextmenu", { node: y, event: h });
  }
  return {
    handleNodePointerDownEvent: b,
    handleNodePointerOverEvent: f,
    handleNodePointerOutEvent: v,
    handleNodeClickEvent: g,
    handleNodeDoubleClickEvent: m,
    handleNodeContextMenu: x
  };
}
function Qt(e, t) {
  var n;
  const o = (n = e[t]) != null ? n : { x: 0, y: 0 };
  return gn({}, o);
}
function xc(e, t, n, o, r) {
  const i = {
    pointers: /* @__PURE__ */ new Map(),
    pointerPeekCount: 0,
    clicks: /* @__PURE__ */ new Map()
  }, a = {
    pointerup: l,
    pointercancel: c
  };
  q(o, (h) => {
    h.size > 0 && t.selectionMode.value !== "edge" ? t.selectionMode.value = "edge" : h.size === 0 && t.selectionMode.value === "edge" && (t.selectionMode.value = "container");
  }), q(t.selectionMode, (h) => {
    h !== "edge" && o.clear();
  });
  function s(h, p) {
    if (p.button == 2 || (p.stopPropagation(), !["default", "edge"].includes(t.viewMode.value)))
      return;
    i.pointers.size == 0 && (t.viewMode.value = "edge", ue(a).forEach(([S, k]) => {
      document.addEventListener(S, k);
    }), i.pointerPeekCount = 0), i.pointerPeekCount++;
    const P = {
      pointerId: p.pointerId,
      id: h,
      eventTarget: p.currentTarget
    };
    i.pointers.set(p.pointerId, P), r.emit("edge:pointerdown", he(h, p));
  }
  function l(h) {
    var p, P;
    h.stopPropagation();
    const S = i.pointers.get(h.pointerId);
    if (!S)
      return;
    i.pointers.delete(h.pointerId);
    const k = S.id;
    r.emit("edge:pointerup", he(k, h));
    const [I, z] = $n(
      i.clicks,
      S.pointerId,
      k instanceof Array ? k.join(",") : k,
      h
    );
    (p = S.eventTarget) == null || p.dispatchEvent(I), z && ((P = S.eventTarget) == null || P.dispatchEvent(z)), i.pointers.size === 0 && (i.pointerPeekCount = 0, ue(a).forEach(([j, B]) => {
      document.removeEventListener(j, B);
    }), zn(i.clicks), t.viewMode.value = "default");
  }
  function c(h) {
    if (h.stopPropagation(), !!i.pointers.get(h.pointerId)) {
      for (const P of i.pointers.values()) {
        const S = P.id;
        r.emit("edge:pointerup", he(S, h));
      }
      i.pointers.clear(), i.pointerPeekCount = 0, ue(a).forEach(([P, S]) => {
        document.removeEventListener(P, S);
      }), r.emit("view:mode", "default");
    }
  }
  function u(h, p) {
    var P;
    if (p.isTrusted || p.shiftKey && !["container", "edge"].includes(t.selectionMode.value))
      return;
    t.selectionMode.value = "edge";
    const S = h instanceof Array ? h : [h], k = at.valueOf(i.pointers).filter((I) => (I.id instanceof Array ? I.id : [I.id]).every((j) => o.has(j))).length > 0;
    if (h instanceof Array)
      S.find((z) => {
        var j;
        return (j = e[z]) == null ? void 0 : j.selectable;
      }) && (p.shiftKey || k ? S.some((z) => o.has(z)) ? S.forEach((z) => o.delete(z)) : S.forEach((z) => {
        var j;
        const B = (j = e[z]) == null ? void 0 : j.selectable;
        typeof B == "number" && o.size >= B || o.add(z);
      }) : (o.clear(), S.forEach((z) => o.add(z))));
    else {
      const I = (P = e[h]) == null ? void 0 : P.selectable;
      I && (p.shiftKey || k ? o.has(h) ? o.delete(h) : typeof I == "number" && o.size >= I || o.add(h) : o.has(h) || (o.clear(), o.add(h)));
    }
    r.emit("edge:click", he(h, p));
  }
  function g(h, p) {
    p.isTrusted || r.emit("edge:dblclick", he(h, p));
  }
  function m(h, p) {
    n.add(h), r.emit("edge:pointerover", he(h, p));
  }
  function d(h, p) {
    n.delete(h), r.emit("edge:pointerout", he(h, p));
  }
  function E(h, p) {
    p.stopPropagation(), r.emit("edge:contextmenu", he(h, p));
  }
  function w(h, p) {
    if (p.button == 2 || (p.stopPropagation(), !["default", "edge"].includes(t.viewMode.value)))
      return;
    i.pointers.size == 0 && (t.viewMode.value = "edge", ue(a).forEach(([S, k]) => {
      document.addEventListener(S, k);
    }), i.pointerPeekCount = 0), i.pointerPeekCount++;
    const P = {
      pointerId: p.pointerId,
      id: h,
      eventTarget: p.currentTarget
    };
    i.pointers.set(p.pointerId, P), r.emit("edge:pointerdown", he(h, p));
  }
  function b(h, p) {
    h.forEach((P) => n.add(P)), r.emit("edge:pointerover", he(h, p));
  }
  function f(h, p) {
    h.forEach((P) => n.delete(P)), r.emit("edge:pointerout", he(h, p));
  }
  function v(h, p) {
    u(h, p);
  }
  function x(h, p) {
    g(h, p);
  }
  function y(h, p) {
    p.stopPropagation(), r.emit("edge:contextmenu", he(h, p));
  }
  return {
    handleEdgePointerDownEvent: s,
    handleEdgePointerOverEvent: m,
    handleEdgePointerOutEvent: d,
    handleEdgeClickEvent: u,
    handleEdgeDoubleClickEvent: g,
    handleEdgeContextMenu: E,
    handleEdgesPointerDownEvent: w,
    handleEdgesPointerOverEvent: b,
    handleEdgesPointerOutEvent: f,
    handleEdgesClickEvent: v,
    handleEdgesDoubleClickEvent: x,
    handleEdgesContextMenu: y
  };
}
function he(e, t) {
  return e instanceof Array ? {
    edges: e,
    event: t,
    summarized: !0
  } : {
    edge: e,
    edges: [e],
    event: t,
    summarized: !1
  };
}
function Pc(e, t, n, o) {
  const r = {
    moveCounter: 0,
    pointerCounter: 0,
    clickState: void 0
  }, i = {
    pointermove: s,
    pointerup: l,
    pointercancel: l
  };
  function a(d) {
    r.moveCounter = 0, r.pointerCounter === 0 && ue(i).forEach(([E, w]) => {
      document.addEventListener(E, w, { passive: !0 });
    }), r.pointerCounter++;
  }
  function s(d) {
    r.moveCounter++;
  }
  function l(d) {
    if (r.pointerCounter--, r.pointerCounter <= 0) {
      r.pointerCounter = 0, ue(i).forEach(([w, b]) => {
        document.removeEventListener(w, b);
      });
      const E = Pt(d.pointerType);
      if (r.moveCounter <= E) {
        if (d.shiftKey && t.selectionMode.value !== "container")
          return;
        t.selectionMode.value = "container";
        const [w, b, f] = Nr(
          r.clickState,
          d,
          "view"
        );
        r.clickState = w, e.value.dispatchEvent(b), f && e.value.dispatchEvent(f);
      }
    }
  }
  function c(d) {
    d.isTrusted || (d.stopPropagation(), o.emit("view:click", { event: d }));
  }
  function u(d) {
    d.isTrusted || (d.stopPropagation(), o.emit("view:dblclick", { event: d }));
  }
  function g(d) {
    o.emit("view:contextmenu", { event: d }), r.pointerCounter > 0 && (r.pointerCounter = 0, ue(i).forEach(([E, w]) => {
      var b;
      (b = e.value) == null || b.removeEventListener(E, w);
    }));
  }
  const m = (d) => {
    d.preventDefault();
  };
  tt(() => {
    const d = e.value;
    !d || (d.addEventListener("pointerdown", a, { passive: !0 }), d.addEventListener("click", c, { passive: !1 }), d.addEventListener("dblclick", u, { passive: !1 }), d.addEventListener("contextmenu", g, { passive: !1 }), n.value && d.addEventListener("wheel", m, { passive: !1 }));
  }), dt(() => {
    const d = e.value;
    !d || (d.removeEventListener("pointerdown", a), d.removeEventListener("click", c), d.removeEventListener("dblclick", u), d.removeEventListener("contextmenu", g), n.value && d.removeEventListener("wheel", m));
  }), q(n, (d, E) => {
    const w = e.value;
    !w || d === E || (d ? w.addEventListener("wheel", m, { passive: !1 }) : w.removeEventListener("wheel", m));
  });
}
function _c(e, t, n, o, r, i) {
  const a = {
    pointers: /* @__PURE__ */ new Map(),
    pointerPeekCount: 0,
    clicks: /* @__PURE__ */ new Map()
  };
  function s(f, v) {
    var x, y;
    return r.value ? { path: (y = (x = e[f]) == null ? void 0 : x.path) != null ? y : f, event: v } : { path: f, event: v };
  }
  const l = {
    pointerup: u,
    pointercancel: g
  };
  q(o, (f) => {
    f.size > 0 && t.selectionMode.value !== "path" ? t.selectionMode.value = "path" : f.size === 0 && t.selectionMode.value === "path" && (t.selectionMode.value = "container");
  }), q(t.selectionMode, (f) => {
    f !== "path" && o.clear();
  });
  function c(f, v) {
    var x;
    if (!((x = e[f]) != null && x.clickable) || v.button == 2 || (v.stopPropagation(), !["default", "path"].includes(t.viewMode.value)))
      return;
    a.pointers.size == 0 && (t.viewMode.value = "path", ue(l).forEach(([h, p]) => {
      document.addEventListener(h, p);
    }), a.pointerPeekCount = 0), a.pointerPeekCount++;
    const y = {
      pointerId: v.pointerId,
      id: f,
      eventTarget: v.currentTarget
    };
    a.pointers.set(v.pointerId, y), i.emit("path:pointerdown", s(f, v));
  }
  function u(f) {
    var v, x;
    const y = a.pointers.get(f.pointerId);
    if (!y)
      return;
    f.stopPropagation(), a.pointers.delete(f.pointerId);
    const h = y.id;
    i.emit("path:pointerup", s(h, f));
    const [p, P] = $n(
      a.clicks,
      y.pointerId,
      h,
      f
    );
    (v = y.eventTarget) == null || v.dispatchEvent(p), P && ((x = y.eventTarget) == null || x.dispatchEvent(P)), a.pointers.size === 0 && (a.pointerPeekCount = 0, ue(l).forEach(([S, k]) => {
      document.removeEventListener(S, k);
    }), zn(a.clicks), t.viewMode.value = "default");
  }
  function g(f) {
    if (!!a.pointers.get(f.pointerId)) {
      f.stopPropagation();
      for (const x of a.pointers.values()) {
        const y = x.id;
        i.emit("path:pointerup", s(y, f));
      }
      a.pointers.clear(), a.pointerPeekCount = 0, ue(l).forEach(([x, y]) => {
        document.removeEventListener(x, y);
      }), i.emit("view:mode", "default");
    }
  }
  function m(f, v) {
    var x;
    !((x = e[f]) != null && x.hoverable) || (n.add(f), i.emit("path:pointerover", s(f, v)));
  }
  function d(f, v) {
    var x;
    !((x = e[f]) != null && x.hoverable) || (n.delete(f), i.emit("path:pointerout", s(f, v)));
  }
  function E(f, v) {
    var x, y, h;
    if (v.isTrusted || !((x = e[f]) != null && x.clickable) || v.shiftKey && !["container", "path"].includes(t.selectionMode.value))
      return;
    t.selectionMode.value = "path";
    const p = (h = (y = e[f]) == null ? void 0 : y.selectable) != null ? h : !1;
    if (p) {
      const P = at.valueOf(a.pointers).filter((S) => o.has(S.id)).length > 0;
      v.shiftKey || P ? o.has(f) ? o.delete(f) : typeof p == "number" && o.size >= p || o.add(f) : o.has(f) || (o.clear(), o.add(f));
    }
    i.emit("path:click", s(f, v));
  }
  function w(f, v) {
    var x;
    v.isTrusted || !((x = e[f]) != null && x.clickable) || i.emit("path:dblclick", s(f, v));
  }
  function b(f, v) {
    var x;
    !((x = e[f]) != null && x.clickable) || (v.stopPropagation(), i.emit("path:contextmenu", s(f, v)));
  }
  return {
    handlePathPointerDownEvent: c,
    handlePathPointerOverEvent: m,
    handlePathPointerOutEvent: d,
    handlePathClickEvent: E,
    handlePathDoubleClickEvent: w,
    handlePathContextMenu: b
  };
}
function Sc(e, t, n) {
  var o = -1, r = e.length;
  t < 0 && (t = -t > r ? 0 : r + t), n = n > r ? r : n, n < 0 && (n += r), r = t > n ? 0 : n - t >>> 0, t >>>= 0;
  for (var i = Array(r); ++o < r; )
    i[o] = e[o + t];
  return i;
}
var Oc = Math.ceil, kc = Math.max;
function In(e, t, n) {
  (n ? br(e, t, n) : t === void 0) ? t = 1 : t = kc(or(t), 0);
  var o = e == null ? 0 : e.length;
  if (!o || t < 1)
    return [];
  for (var r = 0, i = 0, a = Array(Oc(o / t)); r < o; )
    a[i++] = Sc(e, r, r += t);
  return a;
}
var Mc = function() {
  return pe.Date.now();
};
const Jt = Mc;
var Tc = "Expected a function", Cc = Math.max, $c = Math.min;
function zc(e, t, n) {
  var o, r, i, a, s, l, c = 0, u = !1, g = !1, m = !0;
  if (typeof e != "function")
    throw new TypeError(Tc);
  t = _t(t) || 0, Ee(n) && (u = !!n.leading, g = "maxWait" in n, i = g ? Cc(_t(n.maxWait) || 0, t) : i, m = "trailing" in n ? !!n.trailing : m);
  function d(p) {
    var P = o, S = r;
    return o = r = void 0, c = p, a = e.apply(S, P), a;
  }
  function E(p) {
    return c = p, s = setTimeout(f, t), u ? d(p) : a;
  }
  function w(p) {
    var P = p - l, S = p - c, k = t - P;
    return g ? $c(k, i - S) : k;
  }
  function b(p) {
    var P = p - l, S = p - c;
    return l === void 0 || P >= t || P < 0 || g && S >= i;
  }
  function f() {
    var p = Jt();
    if (b(p))
      return v(p);
    s = setTimeout(f, w(p));
  }
  function v(p) {
    return s = void 0, m && o ? d(p) : (o = r = void 0, a);
  }
  function x() {
    s !== void 0 && clearTimeout(s), c = 0, o = l = r = s = void 0;
  }
  function y() {
    return s === void 0 ? a : v(Jt());
  }
  function h() {
    var p = Jt(), P = b(p);
    if (o = arguments, r = this, l = p, P) {
      if (s === void 0)
        return E(l);
      if (g)
        return clearTimeout(s), s = setTimeout(f, t), d(l);
    }
    return s === void 0 && (s = setTimeout(f, t)), a;
  }
  return h.cancel = x, h.flush = y, h;
}
function mn(e, t, n) {
  var o;
  const r = e.createSVGPoint();
  r.x = n.x, r.y = n.y;
  const i = r.matrixTransform((o = t.getCTM()) == null ? void 0 : o.inverse());
  return { x: i.x, y: i.y };
}
function Ic(e, t, n) {
  const o = e.createSVGPoint();
  o.x = n.x, o.y = n.y;
  const r = o.matrixTransform(t.getCTM());
  return { x: r.x, y: r.y };
}
function Ac(e, t, n, o, r, i) {
  const a = M(
    () => !!i.node.selectable && i.view.boxSelectionEnabled
  ), s = M(() => t.viewMode.value === "box-selection"), l = A(), c = A(), u = {
    pointers: /* @__PURE__ */ new Set(),
    points: /* @__PURE__ */ new Map(),
    startPoint: null,
    selectedNodesAtSelectStarted: /* @__PURE__ */ new Set(),
    selectionType: "append",
    options: {
      stopTrigger: "pointerup",
      selectionType: "append",
      selectionTypeWithShiftKey: "same"
    }
  }, g = zc(
    () => {
      jc(
        F(e.value, "container"),
        F(l.value, "viewport"),
        c,
        n.nodes,
        o,
        r,
        u.selectedNodesAtSelectStarted,
        u.selectionType
      );
    },
    50,
    { maxWait: 100 }
  ), m = new Lc(
    e,
    E,
    w,
    b,
    d,
    f
  );
  function d(p) {
    if (u.options.stopTrigger !== "click" || u.pointers.size > 0)
      return;
    const P = { x: p.offsetX, y: p.offsetY };
    u.startPoint && N.fromObject(u.startPoint).distance(P) > 10 || h();
  }
  function E(p) {
    p.stopPropagation();
    const P = { x: p.offsetX, y: p.offsetY };
    u.pointers.size === 0 && (u.startPoint = P, m.activate(), u.selectedNodesAtSelectStarted.clear(), r.forEach((S) => u.selectedNodesAtSelectStarted.add(S)), u.options.selectionTypeWithShiftKey === "same" ? u.selectionType = u.options.selectionType : u.selectionType = p.shiftKey ? u.options.selectionTypeWithShiftKey : u.options.selectionType), u.pointers.has(p.pointerId) || u.pointers.add(p.pointerId), u.points.set(p.pointerId, P), v();
  }
  function w(p) {
    if (u.pointers.delete(p.pointerId), u.pointers.size === 1) {
      const P = F(e.value).getBoundingClientRect(), S = { x: p.x - P.x, y: p.y - P.y };
      u.startPoint = S;
    } else
      u.pointers.size === 0 && (m.deactivate(), u.options.stopTrigger === "pointerup" && h(), u.selectedNodesAtSelectStarted.clear());
    v();
  }
  function b(p) {
    const P = F(e.value).getBoundingClientRect(), S = { x: p.x - P.x, y: p.y - P.y };
    u.points.set(p.pointerId, S), v(), g();
  }
  function f(p) {
    p.key === "Escape" && u.options.stopTrigger !== "manual" && (p.stopPropagation(), h());
  }
  function v() {
    let p, P;
    const S = Array.from(u.pointers);
    if (S.length >= 2) {
      const k = S[0], I = S[S.length - 1];
      p = u.points.get(k), P = u.points.get(I);
    } else if (u.startPoint && S.length === 1) {
      const k = S[0];
      p = u.startPoint, P = u.points.get(k);
    } else
      p = void 0, P = void 0;
    p && P ? (c.value = {
      pos: {
        x: Math.min(p.x, P.x),
        y: Math.min(p.y, P.y)
      },
      size: {
        width: Math.abs(P.x - p.x),
        height: Math.abs(P.y - p.y)
      }
    }, c.value.size.width === 0 && (c.value.size.width = 1), c.value.size.height === 0 && (c.value.size.height = 1)) : c.value && (c.value = void 0);
  }
  const x = new Dc(
    e,
    (p) => {
      !a.value || i.view.selection.detector(p) && (y({
        stop: "manual",
        type: "append",
        withShiftKey: "invert"
      }), x.activate());
    },
    (p) => {
      !a.value || i.view.selection.detector(p) && (u.pointers.size === 0 ? h() : u.options.stopTrigger = "pointerup", x.deactivate());
    }
  );
  q(a, (p) => {
    p ? x.register() : x.unregister();
  }), tt(() => {
    var p;
    l.value = (p = e.value) == null ? void 0 : p.querySelector(".v-viewport"), a.value && x.register();
  }), dt(() => {
    h(), a.value && x.unregister();
  });
  function y(p = {}) {
    var P, S, k;
    u.options = {
      stopTrigger: (P = p.stop) != null ? P : "pointerup",
      selectionType: (S = p.type) != null ? S : "append",
      selectionTypeWithShiftKey: (k = p.withShiftKey) != null ? k : "same"
    }, t.viewMode.value !== "box-selection" && (t.viewMode.value = "box-selection", u.pointers.clear(), m.register());
  }
  function h() {
    t.viewMode.value === "box-selection" && (t.viewMode.value = "default", m.unregister());
  }
  return { isBoxSelectionMode: s, selectionBox: c, startBoxSelection: y, stopBoxSelection: h };
}
function jc(e, t, n, o, r, i, a, s) {
  if (!n.value)
    return;
  const l = n.value, c = mn(e, t, l.pos), u = mn(e, t, {
    x: l.pos.x + l.size.width,
    y: l.pos.y + l.size.height
  }), g = new Set(
    Object.entries(o).filter(([m, d]) => c.x <= d.x && d.x <= u.x && c.y <= d.y && d.y <= u.y).map(([m, d]) => m)
  );
  if (s === "append")
    i.forEach((m) => {
      g.has(m) || i.delete(m);
    }), g.forEach((m) => {
      var d, E;
      const w = (E = (d = r[m]) == null ? void 0 : d.selectable) != null ? E : !1;
      (w === !0 || typeof w == "number" && i.size < w) && i.add(m);
    });
  else {
    const m = new Set(a);
    m.forEach((d) => {
      g.has(d) && m.delete(d);
    }), g.forEach((d) => {
      var E, w;
      if (!a.has(d)) {
        const b = (w = (E = r[d]) == null ? void 0 : E.selectable) != null ? w : !1;
        (b === !0 || typeof b == "number" && m.size < b) && m.add(d);
      }
    }), i.clear(), m.forEach((d) => i.add(d));
  }
}
class Lc {
  constructor(t, n, o, r, i, a) {
    this._container = t, this._handlePointerDownEvent = n, this._handlePointerUpEvent = o, this._handlePointerMoveEvent = r, this._handleClickEvent = i, this._handleKeyDownEvent = a, this._ignoreEvent = (s) => s.stopPropagation();
  }
  register() {
    const t = { capture: !0, passive: !1 }, n = F(this._container.value, "container");
    n.addEventListener("pointerdown", this._handlePointerDownEvent, t), n.addEventListener("click", this._handleClickEvent, t), n.addEventListener("pointerenter", this._ignoreEvent, t), n.addEventListener("pointerleave", this._ignoreEvent, t), document.addEventListener("keydown", this._handleKeyDownEvent, t);
  }
  activate() {
    const t = { capture: !0, passive: !1 };
    document.addEventListener("pointermove", this._handlePointerMoveEvent, t), document.addEventListener("pointerup", this._handlePointerUpEvent, t);
  }
  deactivate() {
    const t = { capture: !0 };
    document.removeEventListener("pointermove", this._handlePointerMoveEvent, t), document.removeEventListener("pointerup", this._handlePointerUpEvent, t);
  }
  unregister() {
    this.deactivate();
    const t = { capture: !0 };
    if (this._container.value) {
      const n = this._container.value;
      n.removeEventListener("pointerdown", this._handlePointerDownEvent, t), n.removeEventListener("click", this._handleClickEvent, t), n.removeEventListener("pointerenter", this._ignoreEvent, t), n.removeEventListener("pointerleave", this._ignoreEvent, t), document.removeEventListener("keydown", this._handleKeyDownEvent, t);
    }
  }
}
class Dc {
  constructor(t, n, o) {
    this._container = t, this._handleKeyDownEvent = n, this._handleKeyUpEvent = o, this._preventDefault = (r) => {
      r.stopPropagation(), r.preventDefault();
    };
  }
  register() {
    document.addEventListener("keydown", this._handleKeyDownEvent, { capture: !0, passive: !0 });
  }
  activate() {
    document.addEventListener("keyup", this._handleKeyUpEvent, { capture: !0, passive: !0 }), F(this._container.value, "container").addEventListener("contextmenu", this._preventDefault, { passive: !1 });
  }
  deactivate() {
    document.removeEventListener("keyup", this._handleKeyUpEvent, { capture: !0 }), this._container.value && this._container.value.removeEventListener("contextmenu", this._preventDefault);
  }
  unregister() {
    this.deactivate(), document.removeEventListener("keydown", this._handleKeyDownEvent, { capture: !0 });
  }
}
var Zc = Object.defineProperty, Lo = Object.getOwnPropertySymbols, Nc = Object.prototype.hasOwnProperty, Bc = Object.prototype.propertyIsEnumerable, Do = (e, t, n) => t in e ? Zc(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, bt = (e, t) => {
  for (var n in t || (t = {}))
    Nc.call(t, n) && Do(e, n, t[n]);
  if (Lo)
    for (var n of Lo(t))
      Bc.call(t, n) && Do(e, n, t[n]);
  return e;
};
const Br = Symbol("mouseEventHandlers");
function Rc(e, t, n, o, r, i, a, s, l, c, u, g, m, d, E, w) {
  const b = {
    selectionMode: A("container"),
    viewMode: A("default")
  };
  a.size > 0 ? b.selectionMode.value = "node" : s.size > 0 ? b.selectionMode.value = "edge" : l.size > 0 && (b.selectionMode.value = "path"), q(b.viewMode, (v) => {
    w.emit("view:mode", v);
  }), Pc(e, b, d, w);
  const f = bt(bt(bt(bt({
    selectedNodes: a,
    hoveredNodes: c,
    selectedEdges: s,
    hoveredEdges: u,
    selectedPaths: l,
    hoveredPaths: g
  }, Ec(
    o,
    t,
    b,
    c,
    a,
    n,
    w
  )), xc(r, b, u, s, w)), _c(
    i,
    b,
    g,
    l,
    m,
    w
  )), Ac(
    e,
    b,
    t,
    o,
    a,
    E
  ));
  return Je(Br, f), f;
}
function Zt() {
  return F(et(Br), "mouseEventHandlers");
}
function Vc(e) {
  return { all: e = e || /* @__PURE__ */ new Map(), on: function(t, n) {
    var o = e.get(t);
    o ? o.push(n) : e.set(t, [n]);
  }, off: function(t, n) {
    var o = e.get(t);
    o && (n ? o.splice(o.indexOf(n) >>> 0, 1) : e.set(t, []));
  }, emit: function(t, n) {
    var o = e.get(t);
    o && o.slice().map(function(r) {
      r(n);
    }), (o = e.get("*")) && o.slice().map(function(r) {
      r(t, n);
    });
  } };
}
const Rr = Symbol("emitter");
function qc() {
  const e = Vc();
  return Je(Rr, e), e;
}
function Hc() {
  return F(et(Rr), "event emitter");
}
var $t = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {}, Nt = {
  getGlobalThis: function() {
    if (typeof globalThis != "undefined")
      return globalThis;
    if (typeof self != "undefined")
      return self;
    if (typeof window != "undefined")
      return window;
    if (typeof $t != "undefined")
      return $t;
    if (typeof this != "undefined")
      return this;
    throw new Error("Unable to locate global `this`");
  },
  extend: function(e, t) {
    e = e || {};
    for (var n in t)
      this.isObject(t[n]) ? e[n] = this.extend(e[n], t[n]) : e[n] = t[n];
    return e;
  },
  isElement: function(e) {
    return e instanceof HTMLElement || e instanceof SVGElement || e instanceof SVGSVGElement || e && typeof e == "object" && e !== null && e.nodeType === 1 && typeof e.nodeName == "string";
  },
  isObject: function(e) {
    return Object.prototype.toString.call(e) === "[object Object]";
  },
  isNumber: function(e) {
    return !isNaN(parseFloat(e)) && isFinite(e);
  },
  getSvg: function(e) {
    var t, n;
    if (this.isElement(e))
      t = e;
    else if (typeof e == "string" || e instanceof String) {
      if (t = document.querySelector(e), !t)
        throw new Error(
          "Provided selector did not find any elements. Selector: " + e
        );
    } else
      throw new Error("Provided selector is not an HTML object nor String");
    if (t.tagName.toLowerCase() === "svg")
      n = t;
    else if (t.tagName.toLowerCase() === "object")
      n = t.contentDocument.documentElement;
    else if (t.tagName.toLowerCase() === "embed")
      n = t.getSVGDocument().documentElement;
    else
      throw t.tagName.toLowerCase() === "img" ? new Error(
        'Cannot script an SVG in an "img" element. Please use an "object" element or an in-line SVG.'
      ) : new Error("Cannot get SVG.");
    return n;
  },
  proxy: function(e, t) {
    return function() {
      return e.apply(t, arguments);
    };
  },
  getType: function(e) {
    return Object.prototype.toString.apply(e).replace(/^\[object\s/, "").replace(/\]$/, "");
  },
  mouseAndTouchNormalize: function(e, t) {
    if (e.clientX === void 0 || e.clientX === null)
      if (e.clientX = 0, e.clientY = 0, e.touches !== void 0 && e.touches.length) {
        if (e.touches[0].clientX !== void 0)
          e.clientX = e.touches[0].clientX, e.clientY = e.touches[0].clientY;
        else if (e.touches[0].pageX !== void 0) {
          var n = t.getBoundingClientRect();
          e.clientX = e.touches[0].pageX - n.left, e.clientY = e.touches[0].pageY - n.top;
        }
      } else
        e.originalEvent !== void 0 && e.originalEvent.clientX !== void 0 && (e.clientX = e.originalEvent.clientX, e.clientY = e.originalEvent.clientY);
  },
  touchNormalize: function(e, t, n) {
    if (e.touches !== void 0 && e.touches.length) {
      if (e.touches[n].clientX !== void 0)
        e.clientX = e.touches[n].clientX, e.clientY = e.touches[n].clientY;
      else if (e.touches[n].pageX !== void 0) {
        var o = t.getBoundingClientRect();
        e.clientX = e.touches[n].pageX - o.left, e.clientY = e.touches[n].pageY - o.top;
      }
    } else
      (e.clientX === void 0 || e.clientX === null) && (e.clientX = 0, e.clientY = 0, e.originalEvent !== void 0 && e.originalEvent.clientX !== void 0 && (e.clientX = e.originalEvent.clientX, e.clientY = e.originalEvent.clientY));
  },
  isDblClick: function(e, t) {
    if (e.detail === 2)
      return !0;
    if (t != null) {
      var n = e.timeStamp - t.timeStamp, o = Math.sqrt(
        Math.pow(e.clientX - t.clientX, 2) + Math.pow(e.clientY - t.clientY, 2)
      );
      return n < 250 && o < 10;
    }
    return !1;
  },
  now: Date.now || function() {
    return new Date().getTime();
  },
  throttle: function(e, t, n) {
    var o = this, r, i, a, s = null, l = 0;
    n || (n = {});
    var c = function() {
      l = n.leading === !1 ? 0 : o.now(), s = null, a = e.apply(r, i), s || (r = i = null);
    };
    return function() {
      var u = o.now();
      !l && n.leading === !1 && (l = u);
      var g = t - (u - l);
      return r = this, i = arguments, g <= 0 || g > t ? (clearTimeout(s), s = null, l = u, a = e.apply(r, i), s || (r = i = null)) : !s && n.trailing !== !1 && (s = setTimeout(c, g)), a;
    };
  },
  createRequestAnimationFrame: function(e) {
    var t = null;
    return e !== "auto" && e < 60 && e > 1 && (t = Math.floor(1e3 / e)), t === null ? window.requestAnimationFrame || Zo(33) : Zo(t);
  },
  calculateDistance: function(e, t) {
    var n = e.x - t.x, o = e.y - t.y;
    return Math.sqrt(n * n + o * o);
  }
};
function Zo(e) {
  return function(t) {
    window.setTimeout(t, e);
  };
}
var Wc = Nt, Fc = function() {
  var e = "", t, n, o, r = [], i = { passive: !0 }, a = { passive: !1 };
  Wc.getGlobalThis().addEventListener ? (t = "addEventListener", n = "removeEventListener") : (t = "attachEvent", n = "detachEvent", e = "on");
  function s() {
    return o || (o = "onwheel" in document.createElement("div") ? "wheel" : document.onmousewheel !== void 0 ? "mousewheel" : "DOMMouseScroll"), o;
  }
  function l(w, b) {
    var f = function(v) {
      !v && (v = window.event);
      var x = {
        originalEvent: v,
        target: v.target || v.srcElement,
        type: "wheel",
        deltaMode: v.type == "MozMousePixelScroll" ? 0 : 1,
        deltaX: 0,
        delatZ: 0,
        preventDefault: function() {
          v.preventDefault ? v.preventDefault() : v.returnValue = !1;
        }
      };
      return s() == "mousewheel" ? (x.deltaY = -0.025 * v.wheelDelta, v.wheelDeltaX && (x.deltaX = -0.025 * v.wheelDeltaX)) : x.deltaY = v.detail, b(x);
    };
    return r.push({
      element: w,
      fn: f
    }), f;
  }
  function c(w) {
    for (var b = 0; b < r.length; b++)
      if (r[b].element === w)
        return r[b].fn;
    return function() {
    };
  }
  function u(w) {
    for (var b = 0; b < r.length; b++)
      if (r[b].element === w)
        return r.splice(b, 1);
  }
  function g(w, b, f, v) {
    var x;
    s() === "wheel" ? x = f : x = l(w, f), w[t](
      e + b,
      x,
      v ? i : a
    );
  }
  function m(w, b, f, v) {
    var x;
    s() === "wheel" ? x = f : x = c(w), w[n](
      e + b,
      x,
      v ? i : a
    ), u(w);
  }
  function d(w, b, f) {
    g(w, s(), b, f), s() == "DOMMouseScroll" && g(
      w,
      "MozMousePixelScroll",
      b,
      f
    );
  }
  function E(w, b, f) {
    m(w, s(), b, f), s() == "DOMMouseScroll" && m(
      w,
      "MozMousePixelScroll",
      b,
      f
    );
  }
  return {
    on: d,
    off: E
  };
}(), wt = Nt, Vr = "unknown";
typeof document != "undefined" && !!document.documentMode && (Vr = "ie");
var An = {
  svgNS: "http://www.w3.org/2000/svg",
  xmlNS: "http://www.w3.org/XML/1998/namespace",
  xmlnsNS: "http://www.w3.org/2000/xmlns/",
  xlinkNS: "http://www.w3.org/1999/xlink",
  evNS: "http://www.w3.org/2001/xml-events",
  getBoundingClientRectNormalized: function(e) {
    if (e.clientWidth && e.clientHeight)
      return { width: e.clientWidth, height: e.clientHeight };
    if (e.getBoundingClientRect())
      return e.getBoundingClientRect();
    throw new Error("Cannot get BoundingClientRect for SVG.");
  },
  getOrCreateViewport: function(e, t) {
    var n = null;
    if (wt.isElement(t) ? n = t : n = e.querySelector(t), !n) {
      var o = Array.prototype.slice.call(e.childNodes || e.children).filter(function(l) {
        return l.nodeName !== "defs" && l.nodeName !== "#text";
      });
      o.length === 1 && o[0].nodeName === "g" && o[0].getAttribute("transform") === null && (n = o[0]);
    }
    if (!n) {
      var r = "viewport-" + new Date().toISOString().replace(/\D/g, "");
      n = document.createElementNS(this.svgNS, "g"), n.setAttribute("id", r);
      var i = e.childNodes || e.children;
      if (!!i && i.length > 0)
        for (var a = i.length; a > 0; a--)
          i[i.length - a].nodeName !== "defs" && n.appendChild(i[i.length - a]);
      e.appendChild(n);
    }
    var s = [];
    return n.getAttribute("class") && (s = n.getAttribute("class").split(" ")), ~s.indexOf("svg-pan-zoom_viewport") || (s.push("svg-pan-zoom_viewport"), n.setAttribute("class", s.join(" "))), n;
  },
  setupSvgAttributes: function(e) {
    if (e.setAttribute("xmlns", this.svgNS), e.setAttributeNS(this.xmlnsNS, "xmlns:xlink", this.xlinkNS), e.setAttributeNS(this.xmlnsNS, "xmlns:ev", this.evNS), e.parentNode !== null) {
      var t = e.getAttribute("style") || "";
      t.toLowerCase().indexOf("overflow") === -1 && e.setAttribute("style", "overflow: hidden; " + t);
    }
  },
  internetExplorerRedisplayInterval: 300,
  refreshDefsGlobal: wt.throttle(
    function() {
      for (var e = document.querySelectorAll("defs"), t = e.length, n = 0; n < t; n++) {
        var o = e[n];
        o.parentNode.insertBefore(o, o);
      }
    },
    $t ? $t.internetExplorerRedisplayInterval : null
  ),
  setCTM: function(e, t, n) {
    var o = this, r = "matrix(" + t.a + "," + t.b + "," + t.c + "," + t.d + "," + t.e + "," + t.f + ")";
    e.setAttributeNS(null, "transform", r), "transform" in e.style ? e.style.transform = r : "-ms-transform" in e.style ? e.style["-ms-transform"] = r : "-webkit-transform" in e.style && (e.style["-webkit-transform"] = r), Vr === "ie" && !!n && (n.parentNode.insertBefore(n, n), window.setTimeout(function() {
      o.refreshDefsGlobal();
    }, o.internetExplorerRedisplayInterval));
  },
  getEventPoint: function(e, t) {
    var n = t.createSVGPoint();
    return wt.mouseAndTouchNormalize(e, t), n.x = e.clientX, n.y = e.clientY, n;
  },
  getTouchPoint: function(e, t, n) {
    var o = t.createSVGPoint();
    return wt.touchNormalize(e, t, n), o.x = e.clientX, o.y = e.clientY, o;
  },
  getSvgCenterPoint: function(e, t, n) {
    return this.createSVGPoint(e, t / 2, n / 2);
  },
  createSVGPoint: function(e, t, n) {
    var o = e.createSVGPoint();
    return o.x = t, o.y = n, o;
  }
}, ce = An, Uc = {
  enable: function(e) {
    var t = e.svg.querySelector("defs");
    t || (t = document.createElementNS(ce.svgNS, "defs"), e.svg.appendChild(t));
    var n = t.querySelector("style#svg-pan-zoom-controls-styles");
    if (!n) {
      var o = document.createElementNS(ce.svgNS, "style");
      o.setAttribute("id", "svg-pan-zoom-controls-styles"), o.setAttribute("type", "text/css"), o.textContent = ".svg-pan-zoom-control { cursor: pointer; fill: black; fill-opacity: 0.333; } .svg-pan-zoom-control:hover { fill-opacity: 0.8; } .svg-pan-zoom-control-background { fill: white; fill-opacity: 0.5; } .svg-pan-zoom-control-background { fill-opacity: 0.8; }", t.appendChild(o);
    }
    var r = document.createElementNS(ce.svgNS, "g");
    r.setAttribute("id", "svg-pan-zoom-controls"), r.setAttribute(
      "transform",
      "translate(" + (e.width - 70) + " " + (e.height - 76) + ") scale(0.75)"
    ), r.setAttribute("class", "svg-pan-zoom-control"), r.appendChild(this._createZoomIn(e)), r.appendChild(this._createZoomReset(e)), r.appendChild(this._createZoomOut(e)), e.svg.appendChild(r), e.controlIcons = r;
  },
  _createZoomIn: function(e) {
    var t = document.createElementNS(ce.svgNS, "g");
    t.setAttribute("id", "svg-pan-zoom-zoom-in"), t.setAttribute("transform", "translate(30.5 5) scale(0.015)"), t.setAttribute("class", "svg-pan-zoom-control"), t.addEventListener(
      "click",
      function() {
        e.getPublicInstance().zoomIn();
      },
      !1
    ), t.addEventListener(
      "touchstart",
      function() {
        e.getPublicInstance().zoomIn();
      },
      !1
    );
    var n = document.createElementNS(ce.svgNS, "rect");
    n.setAttribute("x", "0"), n.setAttribute("y", "0"), n.setAttribute("width", "1500"), n.setAttribute("height", "1400"), n.setAttribute("class", "svg-pan-zoom-control-background"), t.appendChild(n);
    var o = document.createElementNS(ce.svgNS, "path");
    return o.setAttribute(
      "d",
      "M1280 576v128q0 26 -19 45t-45 19h-320v320q0 26 -19 45t-45 19h-128q-26 0 -45 -19t-19 -45v-320h-320q-26 0 -45 -19t-19 -45v-128q0 -26 19 -45t45 -19h320v-320q0 -26 19 -45t45 -19h128q26 0 45 19t19 45v320h320q26 0 45 19t19 45zM1536 1120v-960 q0 -119 -84.5 -203.5t-203.5 -84.5h-960q-119 0 -203.5 84.5t-84.5 203.5v960q0 119 84.5 203.5t203.5 84.5h960q119 0 203.5 -84.5t84.5 -203.5z"
    ), o.setAttribute("class", "svg-pan-zoom-control-element"), t.appendChild(o), t;
  },
  _createZoomReset: function(e) {
    var t = document.createElementNS(ce.svgNS, "g");
    t.setAttribute("id", "svg-pan-zoom-reset-pan-zoom"), t.setAttribute("transform", "translate(5 35) scale(0.4)"), t.setAttribute("class", "svg-pan-zoom-control"), t.addEventListener(
      "click",
      function() {
        e.getPublicInstance().reset();
      },
      !1
    ), t.addEventListener(
      "touchstart",
      function() {
        e.getPublicInstance().reset();
      },
      !1
    );
    var n = document.createElementNS(
      ce.svgNS,
      "rect"
    );
    n.setAttribute("x", "2"), n.setAttribute("y", "2"), n.setAttribute("width", "182"), n.setAttribute("height", "58"), n.setAttribute(
      "class",
      "svg-pan-zoom-control-background"
    ), t.appendChild(n);
    var o = document.createElementNS(
      ce.svgNS,
      "path"
    );
    o.setAttribute(
      "d",
      "M33.051,20.632c-0.742-0.406-1.854-0.609-3.338-0.609h-7.969v9.281h7.769c1.543,0,2.701-0.188,3.473-0.562c1.365-0.656,2.048-1.953,2.048-3.891C35.032,22.757,34.372,21.351,33.051,20.632z"
    ), o.setAttribute(
      "class",
      "svg-pan-zoom-control-element"
    ), t.appendChild(o);
    var r = document.createElementNS(
      ce.svgNS,
      "path"
    );
    return r.setAttribute(
      "d",
      "M170.231,0.5H15.847C7.102,0.5,0.5,5.708,0.5,11.84v38.861C0.5,56.833,7.102,61.5,15.847,61.5h154.384c8.745,0,15.269-4.667,15.269-10.798V11.84C185.5,5.708,178.976,0.5,170.231,0.5z M42.837,48.569h-7.969c-0.219-0.766-0.375-1.383-0.469-1.852c-0.188-0.969-0.289-1.961-0.305-2.977l-0.047-3.211c-0.03-2.203-0.41-3.672-1.142-4.406c-0.732-0.734-2.103-1.102-4.113-1.102h-7.05v13.547h-7.055V14.022h16.524c2.361,0.047,4.178,0.344,5.45,0.891c1.272,0.547,2.351,1.352,3.234,2.414c0.731,0.875,1.31,1.844,1.737,2.906s0.64,2.273,0.64,3.633c0,1.641-0.414,3.254-1.242,4.84s-2.195,2.707-4.102,3.363c1.594,0.641,2.723,1.551,3.387,2.73s0.996,2.98,0.996,5.402v2.32c0,1.578,0.063,2.648,0.19,3.211c0.19,0.891,0.635,1.547,1.333,1.969V48.569z M75.579,48.569h-26.18V14.022h25.336v6.117H56.454v7.336h16.781v6H56.454v8.883h19.125V48.569z M104.497,46.331c-2.44,2.086-5.887,3.129-10.34,3.129c-4.548,0-8.125-1.027-10.731-3.082s-3.909-4.879-3.909-8.473h6.891c0.224,1.578,0.662,2.758,1.316,3.539c1.196,1.422,3.246,2.133,6.15,2.133c1.739,0,3.151-0.188,4.236-0.562c2.058-0.719,3.087-2.055,3.087-4.008c0-1.141-0.504-2.023-1.512-2.648c-1.008-0.609-2.607-1.148-4.796-1.617l-3.74-0.82c-3.676-0.812-6.201-1.695-7.576-2.648c-2.328-1.594-3.492-4.086-3.492-7.477c0-3.094,1.139-5.664,3.417-7.711s5.623-3.07,10.036-3.07c3.685,0,6.829,0.965,9.431,2.895c2.602,1.93,3.966,4.73,4.093,8.402h-6.938c-0.128-2.078-1.057-3.555-2.787-4.43c-1.154-0.578-2.587-0.867-4.301-0.867c-1.907,0-3.428,0.375-4.565,1.125c-1.138,0.75-1.706,1.797-1.706,3.141c0,1.234,0.561,2.156,1.682,2.766c0.721,0.406,2.25,0.883,4.589,1.43l6.063,1.43c2.657,0.625,4.648,1.461,5.975,2.508c2.059,1.625,3.089,3.977,3.089,7.055C108.157,41.624,106.937,44.245,104.497,46.331z M139.61,48.569h-26.18V14.022h25.336v6.117h-18.281v7.336h16.781v6h-16.781v8.883h19.125V48.569z M170.337,20.14h-10.336v28.43h-7.266V20.14h-10.383v-6.117h27.984V20.14z"
    ), r.setAttribute(
      "class",
      "svg-pan-zoom-control-element"
    ), t.appendChild(r), t;
  },
  _createZoomOut: function(e) {
    var t = document.createElementNS(ce.svgNS, "g");
    t.setAttribute("id", "svg-pan-zoom-zoom-out"), t.setAttribute("transform", "translate(30.5 70) scale(0.015)"), t.setAttribute("class", "svg-pan-zoom-control"), t.addEventListener(
      "click",
      function() {
        e.getPublicInstance().zoomOut();
      },
      !1
    ), t.addEventListener(
      "touchstart",
      function() {
        e.getPublicInstance().zoomOut();
      },
      !1
    );
    var n = document.createElementNS(ce.svgNS, "rect");
    n.setAttribute("x", "0"), n.setAttribute("y", "0"), n.setAttribute("width", "1500"), n.setAttribute("height", "1400"), n.setAttribute("class", "svg-pan-zoom-control-background"), t.appendChild(n);
    var o = document.createElementNS(ce.svgNS, "path");
    return o.setAttribute(
      "d",
      "M1280 576v128q0 26 -19 45t-45 19h-896q-26 0 -45 -19t-19 -45v-128q0 -26 19 -45t45 -19h896q26 0 45 19t19 45zM1536 1120v-960q0 -119 -84.5 -203.5t-203.5 -84.5h-960q-119 0 -203.5 84.5t-84.5 203.5v960q0 119 84.5 203.5t203.5 84.5h960q119 0 203.5 -84.5 t84.5 -203.5z"
    ), o.setAttribute("class", "svg-pan-zoom-control-element"), t.appendChild(o), t;
  },
  disable: function(e) {
    e.controlIcons && (e.controlIcons.parentNode.removeChild(e.controlIcons), e.controlIcons = null);
  }
}, Gc = An, ze = Nt, oe = function(e, t) {
  this.init(e, t);
};
oe.prototype.init = function(e, t) {
  this.viewport = e, this.options = t, this.originalState = { zoom: 1, x: 0, y: 0 }, this.activeState = { zoom: 1, x: 0, y: 0 }, this.updateCTMCached = ze.proxy(this.updateCTM, this), this.requestAnimationFrame = ze.createRequestAnimationFrame(
    this.options.refreshRate
  ), this.viewBox = { x: 0, y: 0, width: 0, height: 0 }, this.cacheViewBox();
  var n = this.processCTM();
  this.setCTM(n), this.updateCTM();
};
oe.prototype.cacheViewBox = function() {
  var e = this.options.svg.getAttribute("viewBox");
  if (e) {
    var t = e.split(/[\s\,]/).filter(function(o) {
      return o;
    }).map(parseFloat);
    this.viewBox.x = t[0], this.viewBox.y = t[1], this.viewBox.width = t[2], this.viewBox.height = t[3];
    var n = Math.min(
      this.options.width / this.viewBox.width,
      this.options.height / this.viewBox.height
    );
    this.activeState.zoom = isFinite(n) ? n : 1, this.activeState.x = (this.options.width - this.viewBox.width * n) / 2, this.activeState.y = (this.options.height - this.viewBox.height * n) / 2, this.updateCTMOnNextFrame(), this.options.svg.removeAttribute("viewBox");
  } else
    this.simpleViewBoxCache();
};
oe.prototype.simpleViewBoxCache = function() {
  var e = this.viewport.getBBox();
  this.viewBox.x = e.x, this.viewBox.y = e.y, this.viewBox.width = e.width, this.viewBox.height = e.height;
};
oe.prototype.getViewBox = function() {
  return ze.extend({}, this.viewBox);
};
oe.prototype.processCTM = function() {
  var e = this.getCTM();
  if (this.options.fit || this.options.contain) {
    var t;
    this.options.fit ? t = Math.min(
      this.options.width / this.viewBox.width,
      this.options.height / this.viewBox.height
    ) : t = Math.max(
      this.options.width / this.viewBox.width,
      this.options.height / this.viewBox.height
    ), t = isFinite(t) ? t : 1, e.a = t, e.d = t, e.e = -this.viewBox.x * t, e.f = -this.viewBox.y * t;
  }
  if (this.options.center) {
    var n = (this.options.width - (this.viewBox.width + this.viewBox.x * 2) * e.a) * 0.5, o = (this.options.height - (this.viewBox.height + this.viewBox.y * 2) * e.a) * 0.5;
    e.e = n, e.f = o;
  }
  return this.originalState.zoom = e.a, this.originalState.x = e.e, this.originalState.y = e.f, e;
};
oe.prototype.getOriginalState = function() {
  return ze.extend({}, this.originalState);
};
oe.prototype.getState = function() {
  return ze.extend({}, this.activeState);
};
oe.prototype.getZoom = function() {
  return this.activeState.zoom;
};
oe.prototype.getRelativeZoom = function() {
  return this.activeState.zoom / this.originalState.zoom;
};
oe.prototype.computeRelativeZoom = function(e) {
  return e / this.originalState.zoom;
};
oe.prototype.getPan = function() {
  return { x: this.activeState.x, y: this.activeState.y };
};
oe.prototype.getCTM = function() {
  var e = this.options.svg.createSVGMatrix();
  return e.a = this.activeState.zoom, e.b = 0, e.c = 0, e.d = this.activeState.zoom, e.e = this.activeState.x, e.f = this.activeState.y, e;
};
oe.prototype.setCTM = function(e) {
  var t = this.isZoomDifferent(e), n = this.isPanDifferent(e);
  if (t || n) {
    if (t && (this.options.beforeZoom(
      this.getRelativeZoom(),
      this.computeRelativeZoom(e.a)
    ) === !1 ? (e.a = e.d = this.activeState.zoom, t = !1) : (this.updateCache(e), this.options.onZoom(this.getRelativeZoom()))), n) {
      var o = this.options.beforePan(this.getPan(), {
        x: e.e,
        y: e.f
      }), r = !1, i = !1;
      o === !1 ? (e.e = this.getPan().x, e.f = this.getPan().y, r = i = !0) : ze.isObject(o) && (o.x === !1 ? (e.e = this.getPan().x, r = !0) : ze.isNumber(o.x) && (e.e = o.x), o.y === !1 ? (e.f = this.getPan().y, i = !0) : ze.isNumber(o.y) && (e.f = o.y)), r && i || !this.isPanDifferent(e) ? n = !1 : (this.updateCache(e), this.options.onPan(this.getPan()));
    }
    (t || n) && this.updateCTMOnNextFrame();
  }
};
oe.prototype.isZoomDifferent = function(e) {
  return this.activeState.zoom !== e.a;
};
oe.prototype.isPanDifferent = function(e) {
  return this.activeState.x !== e.e || this.activeState.y !== e.f;
};
oe.prototype.updateCache = function(e) {
  this.activeState.zoom = e.a, this.activeState.x = e.e, this.activeState.y = e.f;
};
oe.prototype.pendingUpdate = !1;
oe.prototype.updateCTMOnNextFrame = function() {
  this.pendingUpdate || (this.pendingUpdate = !0, this.requestAnimationFrame.call(window, this.updateCTMCached));
};
oe.prototype.updateCTM = function() {
  var e = this.getCTM();
  Gc.setCTM(this.viewport, e, this.defs), this.pendingUpdate = !1, this.options.onUpdatedCTM && this.options.onUpdatedCTM(e);
};
var Xc = function(e, t) {
  return new oe(e, t);
}, qr = Fc, yn = Uc, le = Nt, re = An, Kc = Xc, V = function(e, t) {
  this.init(e, t);
}, Yc = {
  viewportSelector: ".svg-pan-zoom_viewport",
  panEnabled: !0,
  controlIconsEnabled: !1,
  zoomEnabled: !0,
  dblClickZoomEnabled: !0,
  mouseWheelZoomEnabled: !0,
  preventMouseEventsDefault: !0,
  zoomScaleSensitivity: 0.1,
  minZoom: 0.5,
  maxZoom: 10,
  fit: !0,
  contain: !1,
  center: !0,
  refreshRate: "auto",
  beforeZoom: null,
  onZoom: null,
  beforePan: null,
  onPan: null,
  customEventsHandler: null,
  eventsListenerElement: null,
  onUpdatedCTM: null
}, Hr = { passive: !0 }, Wr = { passive: !1 };
V.prototype.init = function(e, t) {
  var n = this;
  this.svg = e, this.defs = e.querySelector("defs"), re.setupSvgAttributes(this.svg), this.options = le.extend(le.extend({}, Yc), t), this.state = "none";
  var o = re.getBoundingClientRectNormalized(e);
  this.width = o.width, this.height = o.height, this.viewport = Kc(
    re.getOrCreateViewport(this.svg, this.options.viewportSelector),
    {
      svg: this.svg,
      width: this.width,
      height: this.height,
      fit: this.options.fit,
      contain: this.options.contain,
      center: this.options.center,
      refreshRate: this.options.refreshRate,
      beforeZoom: function(i, a) {
        if (n.viewport && n.options.beforeZoom)
          return n.options.beforeZoom(i, a);
      },
      onZoom: function(i) {
        if (n.viewport && n.options.onZoom)
          return n.options.onZoom(i);
      },
      beforePan: function(i, a) {
        if (n.viewport && n.options.beforePan)
          return n.options.beforePan(i, a);
      },
      onPan: function(i) {
        if (n.viewport && n.options.onPan)
          return n.options.onPan(i);
      },
      onUpdatedCTM: function(i) {
        if (n.viewport && n.options.onUpdatedCTM)
          return n.options.onUpdatedCTM(i);
      }
    }
  );
  var r = this.getPublicInstance();
  r.setBeforeZoom(this.options.beforeZoom), r.setOnZoom(this.options.onZoom), r.setBeforePan(this.options.beforePan), r.setOnPan(this.options.onPan), r.setOnUpdatedCTM(this.options.onUpdatedCTM), this.options.controlIconsEnabled && yn.enable(this), this.lastMouseWheelEventTime = Date.now(), this.setupHandlers();
};
V.prototype.setupHandlers = function() {
  var e = this, t = null;
  if (this.eventListeners = {
    pointerdown: function(i) {
      if (i.pointerType !== "touch") {
        var a = e.handleMouseDown(i, t);
        return t = i, a;
      }
    },
    touchstart: function(i) {
      var a = e.handleTouchStart(i, t);
      return t = i, a;
    },
    pointerup: function(i) {
      if (i.pointerType !== "touch")
        return e.handleMouseUp(i);
    },
    touchend: function(i) {
      return e.handleTouchEnd(i);
    },
    pointermove: function(i) {
      if (i.pointerType !== "touch")
        return e.handleMouseMove(i);
    },
    touchmove: function(i) {
      return e.handleTouchMove(i);
    },
    pointerleave: function(i) {
      if (i.pointerType !== "touch")
        return e.handleMouseUp(i);
    },
    pointercancel: function(i) {
      if (i.pointerType !== "touch")
        return e.handleMouseUp(i);
    },
    touchleave: function(i) {
      return e.handleTouchEnd(i);
    },
    touchcancel: function(i) {
      return e.handleTouchEnd(i);
    }
  }, this.options.customEventsHandler != null) {
    this.options.customEventsHandler.init({
      svgElement: this.svg,
      eventsListenerElement: this.options.eventsListenerElement,
      instance: this.getPublicInstance()
    });
    var n = this.options.customEventsHandler.haltEventListeners;
    if (n && n.length)
      for (var o = n.length - 1; o >= 0; o--)
        this.eventListeners.hasOwnProperty(n[o]) && delete this.eventListeners[n[o]];
  }
  for (var r in this.eventListeners)
    (this.options.eventsListenerElement || this.svg).addEventListener(
      r,
      this.eventListeners[r],
      this.options.preventMouseEventsDefault ? Wr : Hr
    );
  this.options.mouseWheelZoomEnabled && (this.options.mouseWheelZoomEnabled = !1, this.enableMouseWheelZoom());
};
V.prototype.enableMouseWheelZoom = function() {
  if (!this.options.mouseWheelZoomEnabled) {
    var e = this;
    this.wheelListener = function(n) {
      return e.handleMouseWheel(n);
    };
    var t = !this.options.preventMouseEventsDefault;
    qr.on(
      this.options.eventsListenerElement || this.svg,
      this.wheelListener,
      t
    ), this.options.mouseWheelZoomEnabled = !0;
  }
};
V.prototype.disableMouseWheelZoom = function() {
  if (this.options.mouseWheelZoomEnabled) {
    var e = !this.options.preventMouseEventsDefault;
    qr.off(
      this.options.eventsListenerElement || this.svg,
      this.wheelListener,
      e
    ), this.options.mouseWheelZoomEnabled = !1;
  }
};
V.prototype.handleMouseWheel = function(e) {
  if (!(!this.options.zoomEnabled || this.state !== "none")) {
    this.options.preventMouseEventsDefault && (e.preventDefault ? e.preventDefault() : e.returnValue = !1);
    var t = e.deltaY || 1, n = Date.now() - this.lastMouseWheelEventTime, o = 3 + Math.max(0, 30 - n);
    this.lastMouseWheelEventTime = Date.now(), "deltaMode" in e && e.deltaMode === 0 && e.wheelDelta && (t = e.deltaY === 0 ? 0 : Math.abs(e.wheelDelta) / e.deltaY), t = -0.3 < t && t < 0.3 ? t : (t > 0 ? 1 : -1) * Math.log(Math.abs(t) + 10) / o;
    var r = this.svg.getScreenCTM().inverse(), i = re.getEventPoint(e, this.svg).matrixTransform(
      r
    ), a = Math.pow(1 + this.options.zoomScaleSensitivity, -1 * t);
    this.zoomAtPoint(a, i);
  }
};
V.prototype.zoomAtPoint = function(e, t, n) {
  var o = this.viewport.getOriginalState();
  n ? (e = Math.max(
    this.options.minZoom * o.zoom,
    Math.min(this.options.maxZoom * o.zoom, e)
  ), e = e / this.getZoom()) : this.getZoom() * e < this.options.minZoom * o.zoom ? e = this.options.minZoom * o.zoom / this.getZoom() : this.getZoom() * e > this.options.maxZoom * o.zoom && (e = this.options.maxZoom * o.zoom / this.getZoom());
  var r = this.viewport.getCTM(), i = t.matrixTransform(r.inverse()), a = this.svg.createSVGMatrix().translate(i.x, i.y).scale(e).translate(-i.x, -i.y), s = r.multiply(a);
  s.a !== r.a && this.viewport.setCTM(s);
};
V.prototype.zoom = function(e, t) {
  this.zoomAtPoint(
    e,
    re.getSvgCenterPoint(this.svg, this.width, this.height),
    t
  );
};
V.prototype.publicZoom = function(e, t) {
  t && (e = this.computeFromRelativeZoom(e)), this.zoom(e, t);
};
V.prototype.publicZoomAtPoint = function(e, t, n) {
  if (n && (e = this.computeFromRelativeZoom(e)), le.getType(t) !== "SVGPoint")
    if ("x" in t && "y" in t)
      t = re.createSVGPoint(this.svg, t.x, t.y);
    else
      throw new Error("Given point is invalid");
  this.zoomAtPoint(e, t, n);
};
V.prototype.getZoom = function() {
  return this.viewport.getZoom();
};
V.prototype.getRelativeZoom = function() {
  return this.viewport.getRelativeZoom();
};
V.prototype.computeFromRelativeZoom = function(e) {
  return e * this.viewport.getOriginalState().zoom;
};
V.prototype.resetZoom = function() {
  var e = this.viewport.getOriginalState();
  this.zoom(e.zoom, !0);
};
V.prototype.resetPan = function() {
  this.pan(this.viewport.getOriginalState());
};
V.prototype.reset = function() {
  this.resetZoom(), this.resetPan();
};
V.prototype.handleDblClick = function(e) {
  if (this.options.preventMouseEventsDefault && (e.preventDefault ? e.preventDefault() : e.returnValue = !1), this.options.controlIconsEnabled) {
    var t = e.target.getAttribute("class") || "";
    if (t.indexOf("svg-pan-zoom-control") > -1)
      return !1;
  }
  var n;
  e.shiftKey ? n = 1 / ((1 + this.options.zoomScaleSensitivity) * 2) : n = (1 + this.options.zoomScaleSensitivity) * 2;
  var o = re.getEventPoint(e, this.svg).matrixTransform(
    this.svg.getScreenCTM().inverse()
  );
  this.zoomAtPoint(n, o);
};
V.prototype.handleMouseDown = function(e, t) {
  this.options.preventMouseEventsDefault && (e.preventDefault ? e.preventDefault() : e.returnValue = !1), le.mouseAndTouchNormalize(e, this.svg), this.options.dblClickZoomEnabled && le.isDblClick(e, t) ? this.handleDblClick(e) : (this.state = "pan", this.firstEventCTM = this.viewport.getCTM(), this.stateOrigin = re.getEventPoint(e, this.svg).matrixTransform(
    this.firstEventCTM.inverse()
  ));
};
V.prototype.handleMouseMove = function(e) {
  if (this.options.preventMouseEventsDefault && (e.preventDefault ? e.preventDefault() : e.returnValue = !1), this.state === "pan" && this.options.panEnabled) {
    var t = re.getEventPoint(e, this.svg).matrixTransform(
      this.firstEventCTM.inverse()
    ), n = this.firstEventCTM.translate(
      t.x - this.stateOrigin.x,
      t.y - this.stateOrigin.y
    );
    this.viewport.setCTM(n);
  }
};
V.prototype.handleMouseUp = function(e) {
  this.options.preventMouseEventsDefault && (e.preventDefault ? e.preventDefault() : e.returnValue = !1), this.state === "pan" && (this.state = "none");
};
V.prototype.handleTouchStart = function(e, t) {
  if (e.touches.length == 1)
    this.handleMouseDown(e, t);
  else {
    this.options.preventMouseEventsDefault && (e.preventDefault ? e.preventDefault() : e.returnValue = !1), this.firstEventCTM = this.viewport.getCTM();
    var n = re.getTouchPoint(e, this.svg, 0), o = re.getTouchPoint(e, this.svg, 1);
    this.firstDistance = le.calculateDistance(n, o), n.x = (n.x + o.x) / 2, n.y = (n.y + o.y) / 2, this.stateOrigin = n.matrixTransform(this.firstEventCTM.inverse()), this.firstZoomLevel = this.getZoom();
  }
};
V.prototype.handleTouchMove = function(e) {
  if (e.touches.length == 1)
    this.handleMouseMove(e);
  else {
    if (this.options.preventMouseEventsDefault && (e.preventDefault ? e.preventDefault() : e.returnValue = !1), !this.options.panEnabled && !this.options.zoomEnabled)
      return;
    var t = re.getTouchPoint(e, this.svg, 0), n = re.getTouchPoint(e, this.svg, 1), o = this.svg.createSVGPoint();
    if (o.x = (t.x + n.x) / 2, o.y = (t.y + n.y) / 2, this.state === "pan" && this.options.panEnabled) {
      var r = o.matrixTransform(this.firstEventCTM.inverse()), i = this.firstEventCTM.translate(
        r.x - this.stateOrigin.x,
        r.y - this.stateOrigin.y
      );
      this.viewport.setCTM(i);
    }
    if (this.options.zoomEnabled) {
      var a = le.calculateDistance(t, n), s = a / this.firstDistance, l = this.svg.getScreenCTM().inverse(), c = o.matrixTransform(l);
      this.zoomAtPoint(this.firstZoomLevel * s, c, !0);
    }
  }
};
V.prototype.handleTouchEnd = function(e) {
  if (e.touches.length == 0)
    this.handleMouseUp(e);
  else if (this.options.preventMouseEventsDefault && (e.preventDefault ? e.preventDefault() : e.returnValue = !1), this.firstEventCTM = this.viewport.getCTM(), e.touches.length == 1)
    this.stateOrigin = re.getEventPoint(e, this.svg).matrixTransform(
      this.firstEventCTM.inverse()
    );
  else {
    var t = re.getTouchPoint(e, this.svg, 0), n = re.getTouchPoint(e, this.svg, 1);
    this.firstDistance = le.calculateDistance(t, n), t.x = (t.x + n.x) / 2, t.y = (t.y + n.y) / 2, this.stateOrigin = t.matrixTransform(this.firstEventCTM.inverse());
  }
};
V.prototype.fit = function() {
  var e = this.viewport.getViewBox(), t = Math.min(
    this.width / e.width,
    this.height / e.height
  );
  this.zoom(t, !0);
};
V.prototype.contain = function() {
  var e = this.viewport.getViewBox(), t = Math.max(
    this.width / e.width,
    this.height / e.height
  );
  this.zoom(t, !0);
};
V.prototype.center = function() {
  var e = this.viewport.getViewBox(), t = (this.width - (e.width + e.x * 2) * this.getZoom()) * 0.5, n = (this.height - (e.height + e.y * 2) * this.getZoom()) * 0.5;
  this.getPublicInstance().pan({ x: t, y: n });
};
V.prototype.updateBBox = function() {
  this.viewport.simpleViewBoxCache();
};
V.prototype.pan = function(e) {
  var t = this.viewport.getCTM();
  t.e = e.x, t.f = e.y, this.viewport.setCTM(t);
};
V.prototype.panBy = function(e) {
  var t = this.viewport.getCTM();
  t.e += e.x, t.f += e.y, this.viewport.setCTM(t);
};
V.prototype.getPan = function() {
  var e = this.viewport.getState();
  return { x: e.x, y: e.y };
};
V.prototype.resize = function() {
  var e = re.getBoundingClientRectNormalized(
    this.svg
  );
  this.width = e.width, this.height = e.height;
  var t = this.viewport;
  t.options.width = this.width, t.options.height = this.height, t.processCTM(), this.options.controlIconsEnabled && (this.getPublicInstance().disableControlIcons(), this.getPublicInstance().enableControlIcons());
};
V.prototype.destroy = function() {
  var e = this;
  this.beforeZoom = null, this.onZoom = null, this.beforePan = null, this.onPan = null, this.onUpdatedCTM = null, this.options.customEventsHandler != null && this.options.customEventsHandler.destroy({
    svgElement: this.svg,
    eventsListenerElement: this.options.eventsListenerElement,
    instance: this.getPublicInstance()
  });
  for (var t in this.eventListeners)
    (this.options.eventsListenerElement || this.svg).removeEventListener(
      t,
      this.eventListeners[t],
      this.options.preventMouseEventsDefault ? Wr : Hr
    );
  this.disableMouseWheelZoom(), this.getPublicInstance().disableControlIcons(), Te = Te.filter(function(n) {
    return n.svg !== e.svg;
  }), delete this.options, delete this.viewport, delete this.publicInstance, delete this.pi, this.getPublicInstance = function() {
    return null;
  };
};
V.prototype.getPublicInstance = function() {
  var e = this;
  return this.publicInstance || (this.publicInstance = this.pi = {
    enablePan: function() {
      return e.options.panEnabled = !0, e.pi;
    },
    disablePan: function() {
      return e.options.panEnabled = !1, e.pi;
    },
    isPanEnabled: function() {
      return !!e.options.panEnabled;
    },
    pan: function(t) {
      return e.pan(t), e.pi;
    },
    panBy: function(t) {
      return e.panBy(t), e.pi;
    },
    getPan: function() {
      return e.getPan();
    },
    setBeforePan: function(t) {
      return e.options.beforePan = t === null ? null : le.proxy(t, e.publicInstance), e.pi;
    },
    setOnPan: function(t) {
      return e.options.onPan = t === null ? null : le.proxy(t, e.publicInstance), e.pi;
    },
    enableZoom: function() {
      return e.options.zoomEnabled = !0, e.pi;
    },
    disableZoom: function() {
      return e.options.zoomEnabled = !1, e.pi;
    },
    isZoomEnabled: function() {
      return !!e.options.zoomEnabled;
    },
    enableControlIcons: function() {
      return e.options.controlIconsEnabled || (e.options.controlIconsEnabled = !0, yn.enable(e)), e.pi;
    },
    disableControlIcons: function() {
      return e.options.controlIconsEnabled && (e.options.controlIconsEnabled = !1, yn.disable(e)), e.pi;
    },
    isControlIconsEnabled: function() {
      return !!e.options.controlIconsEnabled;
    },
    enableDblClickZoom: function() {
      return e.options.dblClickZoomEnabled = !0, e.pi;
    },
    disableDblClickZoom: function() {
      return e.options.dblClickZoomEnabled = !1, e.pi;
    },
    isDblClickZoomEnabled: function() {
      return !!e.options.dblClickZoomEnabled;
    },
    enableMouseWheelZoom: function() {
      return e.enableMouseWheelZoom(), e.pi;
    },
    disableMouseWheelZoom: function() {
      return e.disableMouseWheelZoom(), e.pi;
    },
    isMouseWheelZoomEnabled: function() {
      return !!e.options.mouseWheelZoomEnabled;
    },
    setZoomScaleSensitivity: function(t) {
      return e.options.zoomScaleSensitivity = t, e.pi;
    },
    setMinZoom: function(t) {
      return e.options.minZoom = t, e.pi;
    },
    setMaxZoom: function(t) {
      return e.options.maxZoom = t, e.pi;
    },
    setBeforeZoom: function(t) {
      return e.options.beforeZoom = t === null ? null : le.proxy(t, e.publicInstance), e.pi;
    },
    setOnZoom: function(t) {
      return e.options.onZoom = t === null ? null : le.proxy(t, e.publicInstance), e.pi;
    },
    zoom: function(t) {
      return e.publicZoom(t, !0), e.pi;
    },
    zoomBy: function(t) {
      return e.publicZoom(t, !1), e.pi;
    },
    zoomAtPoint: function(t, n) {
      return e.publicZoomAtPoint(t, n, !0), e.pi;
    },
    zoomAtPointBy: function(t, n) {
      return e.publicZoomAtPoint(t, n, !1), e.pi;
    },
    zoomIn: function() {
      return this.zoomBy(1 + e.options.zoomScaleSensitivity), e.pi;
    },
    zoomOut: function() {
      return this.zoomBy(1 / (1 + e.options.zoomScaleSensitivity)), e.pi;
    },
    getZoom: function() {
      return e.getRelativeZoom();
    },
    setOnUpdatedCTM: function(t) {
      return e.options.onUpdatedCTM = t === null ? null : le.proxy(t, e.publicInstance), e.pi;
    },
    resetZoom: function() {
      return e.resetZoom(), e.pi;
    },
    resetPan: function() {
      return e.resetPan(), e.pi;
    },
    reset: function() {
      return e.reset(), e.pi;
    },
    fit: function() {
      return e.fit(), e.pi;
    },
    contain: function() {
      return e.contain(), e.pi;
    },
    center: function() {
      return e.center(), e.pi;
    },
    updateBBox: function() {
      return e.updateBBox(), e.pi;
    },
    resize: function() {
      return e.resize(), e.pi;
    },
    getSizes: function() {
      return {
        width: e.width,
        height: e.height,
        realZoom: e.getZoom(),
        viewBox: e.viewport.getViewBox()
      };
    },
    destroy: function() {
      return e.destroy(), e.pi;
    }
  }), this.publicInstance;
};
var Te = [], Qc = function(e, t) {
  var n = le.getSvg(e);
  if (n === null)
    return null;
  for (var o = Te.length - 1; o >= 0; o--)
    if (Te[o].svg === n)
      return Te[o].instance.getPublicInstance();
  return Te.push({
    svg: n,
    instance: new V(n, t)
  }), Te[Te.length - 1].instance.getPublicInstance();
}, Jc = Qc;
const ed = {
  fitToContents() {
    return this.fit().center().zoomOut().zoomOut(), this;
  },
  getViewArea() {
    const e = this.getSizes(), t = this.getPan(), n = e.realZoom;
    t.x /= n, t.y /= n;
    const o = {
      width: e.width / n,
      height: e.height / n
    };
    return {
      box: {
        top: -t.y,
        bottom: o.height - t.y,
        left: -t.x,
        right: o.width - t.x
      },
      center: {
        x: o.width / 2 - t.x,
        y: o.height / 2 - t.y
      }
    };
  },
  getViewBox() {
    return this.getViewArea().box;
  },
  setViewBox(e) {
    const t = e.right - e.left, n = e.bottom - e.top, { width: o, height: r } = this.getSizes(), i = t / n, a = o / r, s = i < a ? n * a : t, l = i > a ? t / a : n, c = Math.min(
      o / s,
      r / l
    ), u = this.getRealZoom(), g = this.getZoom(), m = u / g;
    this.zoom(c / m);
    const d = {
      x: (e.left + t / 2) * c,
      y: (e.top + n / 2) * c
    };
    this.pan({
      x: -d.x + s / 2 * c,
      y: -d.y + l / 2 * c
    });
  },
  getRealZoom() {
    return this.getSizes().realZoom;
  },
  applyAbsoluteZoomLevel(e, t, n) {
    const o = Math.max(1e-4, t), r = Math.max(o, n), i = Math.max(Math.min(r, e), o), a = this.getRealZoom(), s = this.getZoom(), l = a / s;
    this.setMinZoom(o / l).setMaxZoom(r / l).zoom(i / l);
  },
  isPanEnabled() {
    return this._isPanEnabled;
  },
  enablePan() {
    return this._isPanEnabled = !0, this._internalEnablePan(), this;
  },
  disablePan() {
    return this._isPanEnabled = !1, this._internalDisablePan(), this;
  },
  isZoomEnabled() {
    return this._isZoomEnabled;
  },
  enableZoom() {
    return this._isZoomEnabled = !0, this._internalEnableZoom(), this;
  },
  disableZoom() {
    return this._isZoomEnabled = !1, this._internalDisableZoom(), this;
  },
  setPanEnabled(e) {
    return e ? this.enablePan() : this.disablePan(), this;
  },
  setZoomEnabled(e) {
    return e ? (this.enableZoom(), this.enableDblClickZoom()) : (this.disableZoom(), this.disableDblClickZoom()), this;
  }
};
function td(e, t) {
  var n, o;
  const r = e;
  return r._isPanEnabled = (n = t.panEnabled) != null ? n : !0, r._isZoomEnabled = (o = t == null ? void 0 : t.zoomEnabled) != null ? o : !0, r._internalIsPanEnabled = r.isPanEnabled, r._internalEnablePan = r.enablePan, r._internalDisablePan = r.disablePan, r._internalIsZoomEnabled = r.isZoomEnabled, r._internalEnableZoom = r.enableZoom, r._internalDisableZoom = r.disableZoom, Object.assign(e, ed), r;
}
function nd(e, t) {
  var n, o, r, i, a, s;
  const l = (o = (n = t.customEventsHandler) == null ? void 0 : n.init) != null ? o : (g) => {
  }, c = (i = (r = t.customEventsHandler) == null ? void 0 : r.destroy) != null ? i : (g) => {
  }, u = (s = (a = t.customEventsHandler) == null ? void 0 : a.haltEventListeners) != null ? s : [];
  return t.mouseWheelZoomEnabled === void 0 && (t.mouseWheelZoomEnabled = t.zoomEnabled), t.customEventsHandler = {
    init: (g) => {
      td(g.instance, t), l(g);
    },
    destroy: (g) => c(g),
    haltEventListeners: u
  }, Jc(e, t);
}
function od(e, t) {
  const n = A();
  let o = 0;
  const r = [], i = [], a = () => {
    o = 1, r.forEach((u) => u()), r.length = 0;
  }, s = () => {
    o = 2, i.forEach((u) => u()), i.length = 0;
  };
  return tt(() => {
    var u, g, m, d, E, w;
    const b = F(e.value, "<svg>"), f = (g = (u = t.customEventsHandler) == null ? void 0 : u.init) != null ? g : (h) => {
    }, v = (d = (m = t.customEventsHandler) == null ? void 0 : m.destroy) != null ? d : (h) => {
    }, x = (w = (E = t.customEventsHandler) == null ? void 0 : E.haltEventListeners) != null ? w : [];
    t.customEventsHandler = {
      init: (h) => {
        n.value = h.instance, f(h), a();
      },
      destroy: (h) => {
        s(), v(h);
      },
      haltEventListeners: x
    };
    const y = () => {
      const h = b.getBoundingClientRect();
      h.width !== 0 && h.height !== 0 ? nd(b, t) : setTimeout(y, 200);
    };
    y();
  }), dt(() => {
    var u;
    (u = n.value) == null || u.destroy(), n.value = void 0;
  }), { svgPanZoom: n, onSvgPanZoomMounted: (u) => {
    o === 0 ? r.push(u) : o === 1 && u();
  }, onSvgPanZoomUnmounted: (u) => {
    o === 0 || o === 1 ? i.push(u) : u();
  } };
}
const Fr = Symbol("zoomLevel");
function rd(e, t) {
  const n = M(() => t.scalingObjects ? 1 : 1 / e.value);
  return Je(Fr, {
    zoomLevel: e,
    scale: n
  }), { scale: n };
}
function ge() {
  return F(et(Fr), "zoomLevel");
}
var id = (e, t, n) => new Promise((o, r) => {
  var i = (l) => {
    try {
      s(n.next(l));
    } catch (c) {
      r(c);
    }
  }, a = (l) => {
    try {
      s(n.throw(l));
    } catch (c) {
      r(c);
    }
  }, s = (l) => l.done ? o(l.value) : Promise.resolve(l.value).then(i, a);
  s((n = n.apply(e, t)).next());
});
function sd(e) {
  return e instanceof Promise || e && typeof e.then == "function";
}
function ad() {
  let e = null;
  const t = A({
    enabled: !1,
    duration: 300,
    timingFunction: "linear"
  });
  function n(o, r = 300, i = "linear") {
    e && (clearTimeout(e), e = null), t.value = {
      enabled: !0,
      duration: r,
      timingFunction: i
    }, nn(() => id(this, null, function* () {
      const a = o();
      sd(a) && (yield a), e && clearTimeout(e), e = window == null ? void 0 : window.setTimeout(() => {
        t.value.enabled = !1, e = null;
      }, r);
    }));
  }
  return { transitionWhile: n, transitionOption: t };
}
function ld(e) {
  const t = A({}), n = A(!1);
  let o = 1;
  const r = /* @__PURE__ */ new Map();
  return ve(() => {
    if (e.value instanceof Array) {
      const i = /* @__PURE__ */ new Set([]);
      if (t.value = Object.fromEntries(
        e.value.map((a) => {
          let s = a.id;
          return s || (n.value || (n.value = !0, console.warn(
            "[v-network-graph] Please specify the `id` field for the `Path` object. Currently, this works for compatibility, but in the future, the id field will be required."
          )), s = r.get(a), s || (s = "path-" + o++, r.set(a, s))), i.add(s), [s, a];
        })
      ), n.value)
        for (const [a, s] of Array.from(r.entries()))
          i.has(s) || r.delete(a);
    } else
      t.value = e.value;
  }), { objects: t, isInCompatibilityModeForPath: n };
}
function ud(e, t, n, o) {
  if (o) {
    const i = A(o(e[t])), a = (s) => {
      Re(s, i.value) || (i.value = s), Re(s, e[t]) || n(`update:${t}`, s);
    };
    return q(() => o(i.value), a), q(() => e[t], (s) => a(o(s))), i.value !== e[t] && n(`update:${t}`, i.value), i;
  }
  const r = A(e[t]);
  return q(
    () => e[t],
    (i) => {
      Re(i, r.value) || (r.value = i);
    }
  ), q(r, (i) => {
    Re(i, e[t]) || n(`update:${t}`, i);
  }), r;
}
function en(e, t, n, o) {
  const r = Se(/* @__PURE__ */ new Set());
  return q(
    () => e[t],
    () => {
      const a = e[t].filter((s) => s in n.value);
      Re(a, Array.from(r)) || (r.clear(), a.forEach(r.add, r));
    },
    { deep: !0, immediate: !0 }
  ), q(r, () => {
    const i = Array.from(r);
    Re(e[t], i) || o(`update:${t}`, i);
  }), Be(r);
}
const cd = ["cx", "cy", "r", "fill", "stroke", "stroke-width", "stroke-dasharray"], dd = ["x", "y", "width", "height", "rx", "ry", "fill", "stroke", "stroke-width", "stroke-dasharray"], Bt = /* @__PURE__ */ K({
  props: {
    baseX: {
      type: Number,
      default: 0
    },
    baseY: {
      type: Number,
      default: 0
    },
    config: {
      type: Object,
      required: !0
    }
  },
  setup(e, { expose: t }) {
    const n = e, { scale: o } = ge(), r = A(n.baseX), i = A(n.baseY), a = A(0), s = A("#000000"), l = A(void 0), c = A(0), u = A(0), g = A(0), m = A(0);
    return ve(() => {
      var d;
      const E = o.value;
      a.value = n.config.strokeWidth * E, s.value = (d = n.config.strokeColor) != null ? d : "none", l.value = ht(n.config.strokeDasharray, E), n.config.type === "circle" ? (r.value = n.baseX, i.value = n.baseY, c.value = n.config.radius * E) : (u.value = n.config.width * E, g.value = n.config.height * E, m.value = n.config.borderRadius * E, r.value = n.baseX - u.value / 2, i.value = n.baseY - g.value / 2);
    }), t({
      x: r,
      y: i,
      strokeWidth: a,
      strokeColor: s,
      strokeDasharray: l,
      radius: c,
      width: u,
      height: g,
      borderRadius: m
    }), (d, E) => e.config.type === "circle" ? (O(), T("circle", {
      key: 0,
      class: "v-shape-circle",
      cx: r.value,
      cy: i.value,
      r: c.value,
      fill: e.config.color,
      stroke: s.value,
      "stroke-width": a.value,
      "stroke-dasharray": l.value
    }, null, 8, cd)) : (O(), T("rect", {
      key: 1,
      class: "v-shape-rect",
      x: r.value,
      y: i.value,
      width: u.value,
      height: g.value,
      rx: m.value,
      ry: m.value,
      fill: e.config.color,
      stroke: s.value,
      "stroke-width": a.value,
      "stroke-dasharray": l.value
    }, null, 8, dd));
  }
}), fd = ["rx", "ry", "fill", "transform"], hd = ["x", "y", "dominant-baseline", "font-family", "font-size", "fill"], vd = ["x", "dy", "dominant-baseline"], Rt = /* @__PURE__ */ K({
  props: {
    text: {
      type: String,
      required: !0
    },
    x: {
      type: Number,
      required: !0
    },
    y: {
      type: Number,
      required: !0
    },
    dominantBaseline: {
      type: String,
      required: !1,
      default: "central"
    },
    config: {
      type: Object,
      required: !0
    }
  },
  setup(e, { expose: t }) {
    const n = e;
    function o(f, v, x) {
      var y;
      const h = f.getBBox();
      v.x = h.x, v.y = h.y, v.width = h.width, v.height = h.height, x.value = (y = f.getAttribute("transform")) != null ? y : void 0;
    }
    function r(f, v, x) {
      const y = new MutationObserver(() => {
        o(f, v, x);
      });
      return y.observe(f, {
        attributes: !0,
        attributeFilter: ["x", "y", "transform", "font-size"]
      }), o(f, v, x), y;
    }
    const i = li(), { scale: a } = ge(), s = M(() => {
      var f, v;
      return (v = (f = n.text) == null ? void 0 : f.toString().split(/\r?\n/)) != null ? v : "";
    }), l = M(() => {
      var f;
      return (f = i["font-size"]) != null ? f : n.config.fontSize * a.value;
    }), c = M(() => l.value * n.config.lineHeight), u = M(() => {
      const f = n.dominantBaseline;
      return f === "hanging" ? 0 : f === "central" ? -(c.value * (s.value.length - 1)) / 2 : -c.value * (s.value.length - 1);
    }), g = A(), m = A(""), d = Se({ x: 0, y: 0, width: 0, height: 0 }), E = M(() => {
      var f, v;
      const x = n.config.background;
      if (!x)
        return d;
      let y, h;
      x.padding instanceof Object ? (y = x.padding.vertical, h = x.padding.horizontal) : (y = (f = x.padding) != null ? f : 0, h = (v = x.padding) != null ? v : 0);
      const p = c.value - l.value;
      return {
        x: d.x - h * a.value,
        y: d.y - y * a.value - p / 2,
        width: d.width + h * 2 * a.value,
        height: d.height + y * 2 * a.value + p
      };
    });
    let w;
    const b = () => {
      n.config.background && n.config.background.visible ? !w && g.value && (w = r(g.value, d, m)) : (w == null || w.disconnect(), w = void 0);
    };
    return tt(() => b()), q(
      () => n.config.background && n.config.background.visible,
      (f, v) => {
        f != v && b();
      }
    ), dt(() => {
      w == null || w.disconnect(), w = void 0;
    }), t({ fontSize: l, element: g, transform: m, backgroundRectPos: E, scale: a }), (f, v) => {
      var x, y, h, p, P, S;
      return O(), T(R, null, [
        e.config.background && e.config.background.visible ? (O(), T("rect", Pe({
          key: 0,
          class: "v-text-background"
        }, _(E), {
          rx: ((y = (x = e.config.background) == null ? void 0 : x.borderRadius) != null ? y : 0) * _(a),
          ry: ((p = (h = e.config.background) == null ? void 0 : h.borderRadius) != null ? p : 0) * _(a),
          fill: (S = (P = e.config.background) == null ? void 0 : P.color) != null ? S : "#ffffff",
          transform: m.value
        }), null, 16, fd)) : ae("", !0),
        on("text", Pe({
          ref_key: "element",
          ref: g,
          class: "v-text"
        }, f.$attrs, {
          x: e.x,
          y: e.y,
          "dominant-baseline": e.dominantBaseline,
          "font-family": f.$attrs["font-family"] ? `${f.$attrs["font-family"]}` : e.config.fontFamily,
          "font-size": _(l),
          fill: f.$attrs.fill ? `${f.$attrs.fill}` : e.config.color
        }), [
          _(s).length <= 1 ? (O(), T(R, { key: 0 }, [
            ui(Rn(e.text), 1)
          ], 64)) : (O(!0), T(R, { key: 1 }, Y(_(s), (k, I) => (O(), T("tspan", {
            key: I,
            x: e.x,
            dy: I == 0 ? _(u) : _(c),
            "dominant-baseline": e.dominantBaseline
          }, Rn(k), 9, vd))), 128))
        ], 16, hd)
      ], 64);
    };
  }
});
var No = Math.pow;
const pd = ["transform"], gd = /* @__PURE__ */ K({
  props: {
    id: {
      type: String,
      required: !0
    },
    state: {
      type: Object,
      required: !0
    },
    pos: {
      type: Object,
      required: !1,
      default: void 0
    }
  },
  setup(e, { expose: t }) {
    const n = e, o = M(() => {
      var P;
      return ((P = n.pos) == null ? void 0 : P.x) || 0;
    }), r = M(() => {
      var P;
      return ((P = n.pos) == null ? void 0 : P.y) || 0;
    }), i = Pr(), { scale: a } = ge(), {
      handleNodePointerDownEvent: s,
      handleNodePointerOverEvent: l,
      handleNodePointerOutEvent: c,
      handleNodeClickEvent: u,
      handleNodeDoubleClickEvent: g,
      handleNodeContextMenu: m
    } = Zt(), d = M(() => {
      var P;
      return n.state.label.visible && (P = n.state.labelText) != null ? P : !1;
    }), E = M(() => n.state.label.direction === Z.CENTER ? 0 : n.state.label.margin * a.value), w = A(0), b = A(0), f = A(0), v = A(0);
    ve(() => {
      const P = a.value, S = n.state.shape;
      if (S.type == "circle") {
        const k = S.radius * P, I = k + E.value, z = Math.sqrt(No(I, 2) / 2);
        w.value = k + E.value, b.value = k + E.value, f.value = z, v.value = z;
      } else {
        const k = S.borderRadius * P, I = S.width * P, z = S.height * P, j = k + E.value, B = Math.sqrt(No(j, 2) / 2);
        w.value = z / 2 + E.value, b.value = I / 2 + E.value, f.value = z / 2 - k + B, v.value = I / 2 - k + B;
      }
    });
    const x = M(() => {
      switch (n.state.label.direction) {
        case Z.CENTER:
        case Z.NORTH:
        case Z.SOUTH:
          return "middle";
        case Z.EAST:
        case Z.NORTH_EAST:
        case Z.SOUTH_EAST:
          return "start";
        case Z.WEST:
        case Z.NORTH_WEST:
        case Z.SOUTH_WEST:
        default:
          return "end";
      }
    }), y = M(() => {
      switch (n.state.label.direction) {
        case Z.NORTH:
        case Z.NORTH_EAST:
        case Z.NORTH_WEST:
          return "text-top";
        case Z.SOUTH:
        case Z.SOUTH_EAST:
        case Z.SOUTH_WEST:
          return "hanging";
        case Z.CENTER:
        case Z.EAST:
        case Z.WEST:
        default:
          return "central";
      }
    }), h = M(() => {
      switch (n.state.label.direction) {
        case Z.CENTER:
        case Z.NORTH:
        case Z.SOUTH:
          return 0;
        case Z.EAST:
          return b.value;
        case Z.WEST:
          return -b.value;
        case Z.NORTH_EAST:
        case Z.SOUTH_EAST:
          return v.value;
        case Z.NORTH_WEST:
        case Z.SOUTH_WEST:
        default:
          return -v.value;
      }
    }), p = M(() => {
      switch (n.state.label.direction) {
        case Z.NORTH:
          return -w.value;
        case Z.SOUTH:
          return w.value;
        case Z.CENTER:
        case Z.EAST:
        case Z.WEST:
          return 0;
        case Z.NORTH_EAST:
        case Z.NORTH_WEST:
          return -f.value;
        case Z.SOUTH_EAST:
        case Z.SOUTH_WEST:
        default:
          return f.value;
      }
    });
    return t({
      x: o,
      y: r,
      config: i,
      labelVisibility: d,
      handleNodePointerDownEvent: s,
      handleNodePointerOverEvent: l,
      handleNodePointerOutEvent: c,
      handleNodeClickEvent: u,
      handleNodeDoubleClickEvent: g,
      handleNodeContextMenu: m,
      textAnchor: x,
      dominantBaseline: y,
      labelX: h,
      labelY: p,
      scale: a
    }), (P, S) => (O(), T("g", {
      class: de({ "v-node": !0, hover: e.state.hovered, selected: e.state.selected }),
      transform: `translate(${_(o)} ${_(r)})`,
      onPointerdown: S[0] || (S[0] = ye((k) => _(s)(e.id, k), ["stop"])),
      onPointerenterPassive: S[1] || (S[1] = (k) => _(l)(e.id, k)),
      onPointerleavePassive: S[2] || (S[2] = (k) => _(c)(e.id, k)),
      onClick: S[3] || (S[3] = ye((k) => _(u)(e.id, k), ["stop"])),
      onDblclick: S[4] || (S[4] = ye((k) => _(g)(e.id, k), ["stop"])),
      onContextmenu: S[5] || (S[5] = (k) => _(m)(e.id, k))
    }, [
      te(P.$slots, "override-node", {
        nodeId: e.id,
        scale: _(a),
        config: e.state.shape,
        class: de({ draggable: e.state.draggable, selectable: e.state.selectable })
      }, () => [
        Ve(Bt, {
          config: e.state.shape,
          class: de({ draggable: e.state.draggable, selectable: e.state.selectable })
        }, null, 8, ["config", "class"])
      ], !0),
      _(d) ? te(P.$slots, "override-node-label", {
        key: 0,
        nodeId: e.id,
        scale: _(a),
        text: e.state.labelText,
        x: _(h),
        y: _(p),
        config: e.state.label,
        shape: e.state.shape,
        textAnchor: _(x),
        dominantBaseline: _(y)
      }, () => [
        Ve(Rt, {
          text: e.state.labelText,
          x: _(h),
          y: _(p),
          config: e.state.label,
          "text-anchor": _(x),
          "dominant-baseline": _(y)
        }, null, 8, ["text", "x", "y", "config", "text-anchor", "dominant-baseline"])
      ], !0) : ae("", !0)
    ], 42, pd));
  }
});
const fe = (e, t) => {
  const n = e.__vccOpts || e;
  for (const [o, r] of t)
    n[o] = r;
  return n;
}, md = /* @__PURE__ */ fe(gd, [["__scopeId", "data-v-04860034"]]), yd = /* @__PURE__ */ K({
  props: {
    id: {
      type: String,
      required: !0
    },
    state: {
      type: Object,
      required: !0
    },
    pos: {
      type: Object,
      required: !1,
      default: void 0
    }
  },
  setup(e, { expose: t }) {
    const n = e, o = M(() => {
      var s;
      return ((s = n.pos) == null ? void 0 : s.x) || 0;
    }), r = M(() => {
      var s;
      return ((s = n.pos) == null ? void 0 : s.y) || 0;
    }), i = Pr(), a = Se({});
    return ve(() => {
      var s, l, c;
      const u = n.state.shape;
      if (u.type === "circle") {
        const g = {
          type: "circle",
          radius: u.radius + ((s = u.strokeWidth) != null ? s : 0) / 2 + i.focusring.padding + i.focusring.width / 2,
          color: "none",
          strokeWidth: i.focusring.width,
          strokeColor: i.focusring.color,
          strokeDasharray: i.focusring.dasharray
        };
        Object.assign(a, g);
      } else {
        const g = {
          type: "rect",
          width: u.width + ((l = u.strokeWidth) != null ? l : 0) + i.focusring.padding * 2 + i.focusring.width,
          height: u.height + ((c = u.strokeWidth) != null ? c : 0) + i.focusring.padding * 2 + i.focusring.width,
          borderRadius: u.borderRadius > 0 ? u.borderRadius + i.focusring.padding : 0,
          color: "none",
          strokeWidth: i.focusring.width,
          strokeColor: i.focusring.color,
          strokeDasharray: i.focusring.dasharray
        };
        Object.assign(a, g);
      }
    }), t({ x: o, y: r, shapeConfig: a }), (s, l) => (O(), Q(Bt, {
      class: "v-node-focus-ring",
      "base-x": _(o),
      "base-y": _(r),
      config: _(a)
    }, null, 8, ["base-x", "base-y", "config"]));
  }
});
const bd = /* @__PURE__ */ fe(yd, [["__scopeId", "data-v-fd3ea0b1"]]), wd = ["d", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap"], Ed = /* @__PURE__ */ K({
  props: {
    p1: {
      type: Object,
      required: !0
    },
    p2: {
      type: Object,
      required: !0
    },
    config: {
      type: Object,
      required: !0
    }
  },
  setup(e, { expose: t }) {
    const n = e, { scale: o } = ge(), r = M(() => n.config.width * o.value), i = M(() => ht(n.config.dasharray, o.value)), a = M(() => {
      const s = n.config.animate ? zt(n.config.dasharray) * n.config.animationSpeed * o.value : !1;
      return s ? `--animation-speed:${s}` : void 0;
    });
    return t({ strokeWidth: r, strokeDasharray: i, animationSpeed: a }), (s, l) => (O(), T("path", {
      class: de({ "v-line": !0, animate: e.config.animate }),
      d: `M ${e.p1.x} ${e.p1.y} L ${e.p2.x} ${e.p2.y}`,
      stroke: e.config.color,
      "stroke-width": _(r),
      "stroke-dasharray": _(i),
      "stroke-linecap": e.config.linecap,
      style: ft(_(a))
    }, null, 14, wd));
  }
});
const Ur = /* @__PURE__ */ fe(Ed, [["__scopeId", "data-v-ce56a701"]]), xd = ["d", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap"], Pd = /* @__PURE__ */ K({
  props: {
    p1: {
      type: Object,
      required: !0
    },
    p2: {
      type: Object,
      required: !0
    },
    radius: {
      type: Array,
      required: !0
    },
    isLargeArc: {
      type: Boolean,
      required: !0
    },
    isClockwise: {
      type: Boolean,
      required: !0
    },
    config: {
      type: Object,
      required: !0
    }
  },
  setup(e, { expose: t }) {
    const n = e, { scale: o } = ge(), r = M(() => n.config.width * o.value), i = M(() => ht(n.config.dasharray, o.value)), a = M(() => {
      const l = n.config.animate ? zt(n.config.dasharray) * n.config.animationSpeed * o.value : !1;
      return l ? `--animation-speed:${l}` : void 0;
    }), s = M(() => {
      const { p1: l, p2: c, radius: u, isLargeArc: g, isClockwise: m } = n, [d, E] = u, w = g ? 1 : 0, b = m ? 1 : 0;
      return `M ${l.x} ${l.y} A ${d} ${E} 0 ${w} ${b} ${c.x} ${c.y}`;
    });
    return t({ strokeWidth: r, strokeDasharray: i, animationSpeed: a }), (l, c) => (O(), T("path", {
      class: de({ "v-line": !0, animate: e.config.animate }),
      d: _(s),
      stroke: e.config.color,
      "stroke-width": _(r),
      "stroke-dasharray": _(i),
      "stroke-linecap": e.config.linecap,
      style: ft(_(a)),
      fill: "none"
    }, null, 14, xd));
  }
});
const _d = /* @__PURE__ */ fe(Pd, [["__scopeId", "data-v-4c37d668"]]), Sd = ["d", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "marker-start", "marker-end"], Od = /* @__PURE__ */ K({
  props: {
    state: {
      type: Object,
      required: !0
    },
    config: {
      type: Object,
      required: !0
    },
    markerStart: {
      type: String,
      required: !1,
      default: void 0
    },
    markerEnd: {
      type: String,
      required: !1,
      default: void 0
    }
  },
  setup(e, { expose: t }) {
    const n = e, { scale: o } = ge(), r = M(() => {
      var l, c;
      const u = n.state.position, g = [...(c = (l = n.state.curve) == null ? void 0 : l.control) != null ? c : [], { x: u.p2.x, y: u.p2.y }], m = [];
      return m.push(`M ${u.p1.x} ${u.p1.y}`), In(g, 2).forEach(([d, E]) => m.push(`Q ${d.x} ${d.y} ${E.x} ${E.y}`)), m.join(" ");
    }), i = M(() => n.config.width * o.value), a = M(() => ht(n.config.dasharray, o.value)), s = M(() => {
      const l = n.config.animate ? zt(n.config.dasharray) * n.config.animationSpeed * o.value : !1;
      return l ? `--animation-speed:${l}` : void 0;
    });
    return t({ strokeWidth: i, strokeDasharray: a, animationSpeed: s }), (l, c) => (O(), T("path", {
      class: de({ "v-line": !0, animate: e.config.animate }),
      d: _(r),
      fill: "none",
      stroke: e.config.color,
      "stroke-width": _(i),
      "stroke-dasharray": _(a),
      "stroke-linecap": e.config.linecap,
      style: ft(_(s)),
      "marker-start": e.markerStart,
      "marker-end": e.markerEnd
    }, null, 14, Sd));
  }
});
const kd = /* @__PURE__ */ fe(Od, [["__scopeId", "data-v-07a0a855"]]), Md = /* @__PURE__ */ K({
  props: {
    id: {
      type: String,
      required: !0
    },
    state: {
      type: Object,
      required: !0
    },
    sourcePos: {
      type: Object,
      required: !1,
      default: void 0
    },
    targetPos: {
      type: Object,
      required: !1,
      default: void 0
    }
  },
  setup(e, { expose: t }) {
    const n = pt();
    return t({ config: n }), (o, r) => e.state.loop ? (O(), Q(_d, Pe({ key: 0 }, e.state.position, {
      radius: e.state.loop.radius,
      "is-large-arc": e.state.loop.isLargeArc,
      "is-clockwise": e.state.loop.isClockwise,
      class: { selectable: e.state.selectable, hover: e.state.hovered, selected: e.state.selected },
      config: e.state.line.stroke,
      "marker-start": e.state.sourceMarkerId ? `url('#${e.state.sourceMarkerId}')` : void 0,
      "marker-end": e.state.targetMarkerId ? `url('#${e.state.targetMarkerId}')` : void 0
    }), null, 16, ["radius", "is-large-arc", "is-clockwise", "class", "config", "marker-start", "marker-end"])) : _(n).type == "straight" || !e.state.curve ? (O(), Q(Ur, Pe({
      key: 1,
      "data-edge-id": e.id
    }, e.state.position, {
      class: { selectable: e.state.selectable, hover: e.state.hovered, selected: e.state.selected },
      config: e.state.line.stroke,
      "marker-start": e.state.sourceMarkerId ? `url('#${e.state.sourceMarkerId}')` : void 0,
      "marker-end": e.state.targetMarkerId ? `url('#${e.state.targetMarkerId}')` : void 0
    }), null, 16, ["data-edge-id", "class", "config", "marker-start", "marker-end"])) : (O(), Q(kd, {
      key: 2,
      "data-edge-id": e.id,
      class: de({ selectable: e.state.selectable, hover: e.state.hovered, selected: e.state.selected }),
      state: e.state,
      config: e.state.line.stroke,
      "marker-start": e.state.sourceMarkerId ? `url('#${e.state.sourceMarkerId}')` : void 0,
      "marker-end": e.state.targetMarkerId ? `url('#${e.state.targetMarkerId}')` : void 0
    }, null, 8, ["data-edge-id", "class", "state", "config", "marker-start", "marker-end"]));
  }
});
const Td = /* @__PURE__ */ fe(Md, [["__scopeId", "data-v-5bc28572"]]), Cd = /* @__PURE__ */ K({
  props: {
    edges: {
      type: Object,
      required: !0
    },
    layouts: {
      type: Object,
      required: !0
    }
  },
  setup(e, { expose: t }) {
    const n = e, o = pt(), {
      handleEdgesPointerDownEvent: r,
      handleEdgesPointerOverEvent: i,
      handleEdgesPointerOutEvent: a,
      handleEdgesClickEvent: s,
      handleEdgesDoubleClickEvent: l,
      handleEdgesContextMenu: c
    } = Zt(), { edgeStates: u } = gt(), g = A({ p1: { x: 0, y: 0 }, p2: { x: 0, y: 0 } }), m = A({ x: 0, y: 0 });
    ve(() => {
      const y = Object.keys(n.edges).find((h) => h in u);
      y && (g.value = u[y].position, m.value = {
        x: (g.value.p1.x + g.value.p2.x) / 2,
        y: (g.value.p1.y + g.value.p2.y) / 2
      });
    });
    const d = M(() => Object.keys(n.edges)), E = M(() => $.values(o.summarized.label, n.edges)), w = M(() => $.values(o.summarized.shape, n.edges)), b = M(() => $.values(o.summarized.stroke, n.edges)), f = M(() => d.value.some((y) => u[y].hovered)), v = M(() => d.value.some((y) => u[y].selectable)), x = M(() => d.value.some((y) => u[y].selected));
    return t({
      config: o,
      pos: g,
      centerPos: m,
      handleEdgesPointerDownEvent: r,
      handleEdgesPointerOverEvent: i,
      handleEdgesPointerOutEvent: a,
      handleEdgesClickEvent: s,
      handleEdgesDoubleClickEvent: l,
      handleEdgesContextMenu: c,
      hovered: f,
      selectable: v,
      selected: x
    }), (y, h) => (O(), T("g", {
      class: de({ "v-line-summarized": !0, hovered: _(f), selectable: _(v), selected: _(x) }),
      onPointerdown: h[0] || (h[0] = ye((p) => _(r)(_(d), p), ["stop"])),
      onPointerenterPassive: h[1] || (h[1] = (p) => _(i)(_(d), p)),
      onPointerleavePassive: h[2] || (h[2] = (p) => _(a)(_(d), p)),
      onClick: h[3] || (h[3] = ye((p) => _(s)(_(d), p), ["stop"])),
      onDblclick: h[4] || (h[4] = ye((p) => _(l)(_(d), p), ["stop"])),
      onContextmenu: h[5] || (h[5] = (p) => _(c)(_(d), p))
    }, [
      Ve(Ur, Pe(g.value, {
        config: _(b),
        "data-edge-id": _(d)[0]
      }), null, 16, ["config", "data-edge-id"]),
      Ve(Bt, {
        "base-x": m.value.x,
        "base-y": m.value.y,
        config: _(w)
      }, null, 8, ["base-x", "base-y", "config"]),
      Ve(Rt, {
        text: Object.keys(e.edges).length.toString(),
        x: m.value.x,
        y: m.value.y,
        config: _(E),
        "text-anchor": "middle",
        "dominant-baseline": "central"
      }, null, 8, ["text", "x", "y", "config"])
    ], 34));
  }
});
const $d = /* @__PURE__ */ fe(Cd, [["__scopeId", "data-v-3b995162"]]), zd = { class: "v-edge-overlay" }, Bo = /* @__PURE__ */ K({
  props: {
    edgeId: {
      type: String,
      required: !1,
      default: void 0
    },
    edge: {
      type: Object,
      required: !1,
      default: void 0
    },
    edges: {
      type: Object,
      required: !1,
      default: () => {
      }
    },
    state: {
      type: Object,
      required: !0
    },
    isSummarized: {
      type: Boolean,
      required: !0
    }
  },
  setup(e) {
    const t = e, { svg: n } = wn(), { scale: o } = ge(), r = pt();
    function i() {
      return t.isSummarized ? $.values(r.summarized.stroke, t.edges) : t.state.line.stroke;
    }
    function a(u) {
      return { source: u.p1, target: u.p2 };
    }
    function s(u) {
      if (u.curve)
        return u.curve.center;
      {
        const g = u.origin.p1, m = u.origin.p2;
        return {
          x: (g.x + m.x) / 2,
          y: (g.y + m.y) / 2
        };
      }
    }
    function l() {
      var u;
      if (!n.value)
        return 0;
      const g = (u = t.edgeId) != null ? u : Object.keys(t.edges)[0], m = n.value.querySelector(`path[data-edge-id="${g}"]`);
      return m ? m.getTotalLength() : 0;
    }
    function c(u) {
      var g;
      if (!n.value || !isFinite(u))
        return t.state.position.p1;
      t.state;
      const m = (g = t.edgeId) != null ? g : Object.keys(t.edges)[0], d = n.value.querySelector(`path[data-edge-id="${m}"]`);
      if (!d)
        return t.state.position.p1;
      const E = d.getPointAtLength(u);
      return { x: E.x, y: E.y };
    }
    return (u, g) => (O(), T("g", zd, [
      e.isSummarized ? te(u.$slots, "default", {
        key: 0,
        edges: e.edges,
        isSummarized: e.isSummarized,
        stroke: i(),
        position: a(e.state.origin),
        center: s(e.state),
        hovered: e.state.hovered,
        selected: e.state.selected,
        scale: _(o),
        length: l(),
        pointAtLength: c
      }) : te(u.$slots, "default", {
        key: 1,
        edgeId: e.edgeId,
        edge: e.edge,
        edges: { [e.edgeId]: e.edge },
        isSummarized: e.isSummarized,
        stroke: i(),
        position: a(e.state.origin),
        center: s(e.state),
        hovered: e.state.hovered,
        selected: e.state.selected,
        scale: _(o),
        length: l(),
        pointAtLength: c
      })
    ]));
  }
}), Id = /* @__PURE__ */ K({
  props: {
    hasEdgeOverlaySlot: {
      type: Boolean,
      required: !0
    }
  },
  setup(e, { expose: t }) {
    const { edgeStates: n, edgeZOrderedList: o, edgeGroupStates: r, layouts: i } = gt();
    return t({ edgeStates: n, edgeZOrderedList: o, edgeGroupStates: r, layouts: i }), (a, s) => (O(!0), T(R, null, Y(_(o), (l) => (O(), T(R, null, [
      _(ac)(l) ? (O(), T(R, { key: 0 }, [
        (O(), Q($d, {
          key: l.key,
          edges: l.group.edges,
          layouts: _(i).nodes
        }, null, 8, ["edges", "layouts"])),
        e.hasEdgeOverlaySlot ? (O(), Q(Bo, {
          key: l.key,
          edges: l.group.edges,
          state: _(n)[Object.keys(l.group.edges)[0]],
          "is-summarized": !0
        }, {
          default: me((c) => [
            te(a.$slots, "default", Ze(Ne(c)))
          ]),
          _: 2
        }, 1032, ["edges", "state"])) : ae("", !0)
      ], 64)) : (O(), T(R, { key: 1 }, [
        (O(), Q(Td, {
          key: l.key,
          id: l.key,
          state: _(n)[l.key],
          "source-pos": _(i).nodes[l.edge.source],
          "target-pos": _(i).nodes[l.edge.target]
        }, null, 8, ["id", "state", "source-pos", "target-pos"])),
        e.hasEdgeOverlaySlot ? (O(), Q(Bo, {
          key: l.key,
          "edge-id": l.key,
          edge: l.edge,
          state: _(n)[l.key],
          "is-summarized": !1
        }, {
          default: me((c) => [
            te(a.$slots, "default", Ze(Ne(c)))
          ]),
          _: 2
        }, 1032, ["edge-id", "edge", "state"])) : ae("", !0)
      ], 64))
    ], 64))), 256));
  }
}), Ad = ["d", "stroke-width"], jd = /* @__PURE__ */ K({
  props: {
    id: {
      type: String,
      required: !0
    },
    state: {
      type: Object,
      required: !0
    },
    sourcePos: {
      type: Object,
      required: !1,
      default: void 0
    },
    targetPos: {
      type: Object,
      required: !1,
      default: void 0
    }
  },
  setup(e, { expose: t }) {
    const n = e, { scale: o } = ge(), r = pt(), {
      handleEdgePointerDownEvent: i,
      handleEdgePointerOverEvent: a,
      handleEdgePointerOutEvent: s,
      handleEdgeClickEvent: l,
      handleEdgeDoubleClickEvent: c,
      handleEdgeContextMenu: u
    } = Zt(), g = M(() => {
      const d = n.state.position;
      if (n.state.loop) {
        const { radius: E, isLargeArc: w, isClockwise: b } = n.state.loop, [f, v] = E, x = w ? 1 : 0, y = b ? 1 : 0;
        return `M ${d.p1.x} ${d.p1.y} A ${f} ${v} 0 ${x} ${y} ${d.p2.x} ${d.p2.y}`;
      } else {
        if (r.type === "straight" || !n.state.curve)
          return `M ${d.p1.x} ${d.p1.y} L ${d.p2.x} ${d.p2.y}`;
        {
          const E = [...n.state.curve.control, { x: d.p2.x, y: d.p2.y }], w = [];
          return w.push(`M ${d.p1.x} ${d.p1.y}`), In(E, 2).forEach(([b, f]) => w.push(`Q ${b.x} ${b.y} ${f.x} ${f.y}`)), w.join(" ");
        }
      }
    }), m = M(() => (n.state.line.stroke.width + 10) * o.value);
    return t({
      config: r,
      handleEdgePointerDownEvent: i,
      handleEdgePointerOverEvent: a,
      handleEdgePointerOutEvent: s,
      handleEdgeClickEvent: l,
      handleEdgeDoubleClickEvent: c,
      handleEdgeContextMenu: u
    }), (d, E) => (O(), T("path", {
      class: de({ "v-line-background": !0, selectable: e.state.selectable }),
      d: _(g),
      stroke: "transparent",
      "stroke-width": _(m),
      fill: "none",
      onPointerdown: E[0] || (E[0] = ye((w) => _(i)(e.id, w), ["stop"])),
      onPointerenterPassive: E[1] || (E[1] = (w) => _(a)(e.id, w)),
      onPointerleavePassive: E[2] || (E[2] = (w) => _(s)(e.id, w)),
      onClick: E[3] || (E[3] = ye((w) => _(l)(e.id, w), ["stop"])),
      onDblclick: E[4] || (E[4] = ye((w) => _(c)(e.id, w), ["stop"])),
      onContextmenu: E[5] || (E[5] = (w) => _(u)(e.id, w))
    }, null, 42, Ad));
  }
});
const Ld = /* @__PURE__ */ fe(jd, [["__scopeId", "data-v-db4af818"]]), Dd = /* @__PURE__ */ K({
  setup(e, { expose: t }) {
    const { edgeStates: n, edgeGroupStates: o, layouts: r } = gt();
    return t({ edgeStates: n, edgeGroupStates: o, layouts: r }), (i, a) => (O(!0), T(R, null, Y(_(o).edgeGroups, ({ summarize: s, edges: l }) => (O(), T(R, null, [
      s ? ae("", !0) : (O(!0), T(R, { key: 0 }, Y(l, (c, u) => (O(), Q(Ld, {
        key: u,
        id: u,
        state: _(n)[u],
        "source-pos": _(r).nodes[c.source],
        "target-pos": _(r).nodes[c.target]
      }, null, 8, ["id", "state", "source-pos", "target-pos"]))), 128))
    ], 64))), 256));
  }
}), Zd = { class: "v-edge-labels" }, Nd = /* @__PURE__ */ K({
  setup(e, { expose: t }) {
    const n = pt(), { nodeStates: o, edgeStates: r, edgeGroupStates: i, summarizedEdgeStates: a, layouts: s } = gt(), { scale: l } = ge(), c = M(
      () => Object.fromEntries(
        Object.entries(i.edgeGroups).filter(
          ([w, b]) => !b.summarize && Object.keys(b.edges).length > 0
        )
      )
    ), u = M(() => {
      const w = {}, b = {};
      return Object.entries(i.edgeGroups).forEach(([f, v]) => {
        Object.keys(v.edges).length > 0 && (v.summarize ? b[f] = v : w[f] = v);
      }), { individual: w, summarized: b };
    }), g = M(() => (w) => {
      var b;
      return {
        pos: (b = s.nodes[w]) != null ? b : { x: 0, y: 0 },
        shape: o[w].shape
      };
    }), m = M(() => (w, b) => Co(
      r[w].labelPosition,
      b,
      n.label.margin,
      n.label.padding,
      l.value
    )), d = M(() => (w, b) => {
      var f, v;
      const x = Object.keys(b.edges)[0];
      return Co(
        r[x].labelPosition,
        (v = (f = a[w]) == null ? void 0 : f.stroke) != null ? v : r[x].line.stroke,
        n.label.margin,
        n.label.padding,
        l.value
      );
    }), E = M(() => (w) => r[Object.keys(w.edges)[0]]);
    return t({
      individualEdgeGroups: c,
      edgeGroups: u,
      nodeShape: g,
      labelAreaPosition: m,
      groupLabelAreaPosition: d,
      representativeEdgeState: E,
      edgeStates: r,
      edgeConfig: n,
      scale: l
    }), (w, b) => (O(), T("g", Zd, [
      (O(!0), T(R, null, Y(_(u).individual, (f, v) => (O(), T(R, { key: v }, [
        (O(!0), T(R, null, Y(f.edges, (x, y) => (O(), T(R, { key: y }, [
          _(r)[y].loop ? ae("", !0) : te(w.$slots, "edge-label", {
            key: 0,
            edgeId: y,
            edge: x,
            config: _(n).label,
            area: _(m)(y, _(r)[y].line.stroke),
            hovered: _(r)[y].hovered,
            selected: _(r)[y].selected,
            scale: _(l)
          }, void 0, !0)
        ], 64))), 128))
      ], 64))), 128)),
      (O(!0), T(R, null, Y(_(u).summarized, (f, v) => (O(), T(R, { key: v }, [
        _(E)(f).loop ? ae("", !0) : te(w.$slots, "edges-label", {
          key: 0,
          edges: f.edges,
          config: _(n).label,
          area: _(d)(v, f),
          hovered: _(E)(f).hovered,
          selected: _(E)(f).selected,
          scale: _(l)
        }, void 0, !0)
      ], 64))), 128))
    ]));
  }
});
const Bd = /* @__PURE__ */ fe(Nd, [["__scopeId", "data-v-2f3af414"]]), Rd = /* @__PURE__ */ K({
  setup(e, { expose: t }) {
    const { viewport: n } = wn(), o = A(), r = (a, s, l) => {
      a.forEach((c) => {
        var u;
        return s.setAttribute(c, (u = l.getAttribute(c)) != null ? u : "");
      });
    }, i = new MutationObserver((a) => {
      if (!o.value)
        return;
      const s = a.map((l) => {
        var c;
        return (c = l.attributeName) != null ? c : "";
      }).filter(Boolean);
      r(s, o.value, n.value);
    });
    return tt(() => {
      const a = ["transform", "style"];
      i.observe(n.value, {
        attributes: !0,
        attributeFilter: a
      }), o.value && r(a, o.value, n.value);
    }), dt(() => {
      i.disconnect();
    }), t({ background: o }), (a, s) => (O(), T("g", {
      ref_key: "background",
      ref: o,
      class: "v-background-viewport"
    }, [
      te(a.$slots, "default")
    ], 512));
  }
});
var Vd = Object.defineProperty, Ro = Object.getOwnPropertySymbols, qd = Object.prototype.hasOwnProperty, Hd = Object.prototype.propertyIsEnumerable, Vo = (e, t, n) => t in e ? Vd(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, qo = (e, t) => {
  for (var n in t || (t = {}))
    qd.call(t, n) && Vo(e, n, t[n]);
  if (Ro)
    for (var n of Ro(t))
      Hd.call(t, n) && Vo(e, n, t[n]);
  return e;
};
const Wd = {
  class: "v-background-grid",
  "shape-rendering": "crispEdges"
}, Fd = ["d"], Ud = ["d"], Gd = ["d"], Xd = ["d"], Kd = /* @__PURE__ */ K({
  setup(e, { expose: t }) {
    const { container: n, svgPanZoom: o } = wn(), { zoomLevel: r } = ge(), i = Hc(), a = Sl(), s = A({ x: 0, y: 0 }), l = A({ width: 500, height: 500 });
    tt(() => {
      var d;
      const E = (d = o.value) == null ? void 0 : d.getPan();
      E && (s.value = {
        x: -E.x,
        y: -E.y
      });
      const w = n.value.getBoundingClientRect();
      l.value = {
        width: w.width,
        height: w.height
      };
    }), i.on("view:resize", (d) => {
      l.value = { width: d.width, height: d.height };
    }), i.on("view:pan", (d) => {
      s.value = { x: -d.x, y: -d.y };
    }), i.on("view:zoom", () => {
      var d;
      const E = (d = o.value) == null ? void 0 : d.getPan();
      E && (s.value = { x: -E.x, y: -E.y });
    });
    const c = A([]), u = A([]), g = A([]), m = A([]);
    return ve(() => {
      const d = [], E = [], w = [], b = [], f = 1 / r.value, v = a.grid.interval, x = s.value.x * f, y = s.value.y * f, h = Math.floor(l.value.width / v + 1) * v, p = Math.floor(l.value.height / v + 1) * v, P = (s.value.x + h) * f, S = (s.value.y + p) * f, k = a.grid.thickIncrements, I = a.grid.line.dasharray, z = a.grid.thick.dasharray;
      let j = {
        stroke: a.grid.thick.color,
        "stroke-width": a.grid.thick.width,
        "stroke-dasharray": z,
        "stroke-dashoffset": z ? x / f : void 0
      }, B = {
        stroke: a.grid.line.color,
        "stroke-width": a.grid.line.width,
        "stroke-dasharray": I,
        "stroke-dashoffset": I ? x / f : void 0
      };
      const U = (s.value.x + h) * f;
      for (let H = y; H <= S; H += v) {
        const W = Math.floor(H / v);
        k && W % k === 0 ? d.push([W, W * v, x, U, j]) : w.push([W, W * v, x, U, B]);
      }
      j = qo({}, j), j["stroke-dashoffset"] = z ? y / f : void 0, B = qo({}, B), B["stroke-dashoffset"] = I ? y / f : void 0;
      const L = (s.value.y + p) * f;
      for (let H = x; H <= P; H += v) {
        const W = Math.floor(H / v);
        k && W % k === 0 ? E.push([W, W * v, y, L, j]) : b.push([W, W * v, y, L, B]);
      }
      u.value = d, c.value = E, m.value = w, g.value = b;
    }), t({
      thickVerticals: c,
      thickHorizontals: u,
      normalVerticals: g,
      normalHorizontals: m
    }), (d, E) => (O(), T("g", Wd, [
      (O(!0), T(R, null, Y(m.value, ([w, b, f, v, x]) => (O(), T("path", Pe({
        key: `nv${w}`,
        d: `M ${f} ${b} L ${v} ${b}`
      }, x, { style: { "vector-effect": "non-scaling-stroke" } }), null, 16, Fd))), 128)),
      (O(!0), T(R, null, Y(g.value, ([w, b, f, v, x]) => (O(), T("path", Pe({
        key: `nh${w}`,
        d: `M ${b} ${f} L ${b} ${v}`
      }, x, { style: { "vector-effect": "non-scaling-stroke" } }), null, 16, Ud))), 128)),
      (O(!0), T(R, null, Y(u.value, ([w, b, f, v, x]) => (O(), T("path", Pe({
        key: `tv${w}`,
        d: `M ${f} ${b} L ${v} ${b}`
      }, x, { style: { "vector-effect": "non-scaling-stroke" } }), null, 16, Gd))), 128)),
      (O(!0), T(R, null, Y(c.value, ([w, b, f, v, x]) => (O(), T("path", Pe({
        key: `th${w}`,
        d: `M ${b} ${f} L ${b} ${v}`
      }, x, { style: { "vector-effect": "non-scaling-stroke" } }), null, 16, Xd))), 128))
    ]));
  }
});
function Et(...e) {
  return e.find((t) => !!t);
}
var Yd = Object.defineProperty, Qd = Object.defineProperties, Jd = Object.getOwnPropertyDescriptors, Ho = Object.getOwnPropertySymbols, ef = Object.prototype.hasOwnProperty, tf = Object.prototype.propertyIsEnumerable, Wo = (e, t, n) => t in e ? Yd(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, nf = (e, t) => {
  for (var n in t || (t = {}))
    ef.call(t, n) && Wo(e, n, t[n]);
  if (Ho)
    for (var n of Ho(t))
      tf.call(t, n) && Wo(e, n, t[n]);
  return e;
}, of = (e, t) => Qd(e, Jd(t));
const rf = Number.EPSILON * 100;
function sf(e, t, n, o, r, i, a, s) {
  var l, c;
  const u = e.edges, g = af(u), m = u.map((f, v) => uf(f, g[v], o[f.edgeId])), d = [];
  let E = !1, w = !1;
  {
    const f = m[0];
    let v = Ke(t[f.source].shape) * r;
    const x = s + (a === "edgeOfNode" ? v : 0), y = x <= 0 ? f.line.source : Fo(f, x, n, !0);
    d.push(y), v = Ke(t[f.target].shape) * r, s > 0 && ee.distance(f.line.source, f.line.target) <= x + v && (E = !0);
  }
  const b = u.length;
  for (let f = 1; f < b; f++) {
    const v = m[f - 1], x = m[f], y = x.source, h = N.fromObject((l = n[y]) != null ? l : { x: 0, y: 0 }), p = lf(v, x, h), P = Ke(t[y].shape) * r, S = Math.max(P * (2 / 3), P - 4 * r), k = bn(v), I = bn(x), z = xt(v, h, S, k), j = xt(x, h, S, !I), B = xt(v, h, P, k), U = xt(x, h, P, !I);
    let L;
    if (p) {
      const H = ee.distance(p, h);
      if (H < S)
        L = [
          Et(z, B, v.line.target),
          p,
          Et(j, U, x.line.source)
        ];
      else if (H <= P) {
        let W, ie;
        B && z ? W = ee.distance(p, z) < ee.distance(p, B) ? z : B : W = B || v.line.target, U && j ? ie = ee.distance(p, j) < ee.distance(p, U) ? j : U : ie = U || x.line.source, L = [W, p, ie];
      } else
        z && j ? L = [z, h, j] : B && U ? L = [B, h, U] : L = [
          Et(z, B, v.line.target),
          h,
          Et(j, U, x.line.source)
        ];
    } else
      z && j ? L = [z, h, j] : B && U ? L = [B, h, U] : L = [v.line.target, h, x.line.source];
    if (v.curve) {
      const H = d[d.length - 1];
      if (H) {
        const W = H instanceof Array ? H[H.length - 1] : H;
        let ie;
        L instanceof Array ? ie = i ? L[0] : L[1] : ie = L;
        const ke = pn(
          W,
          v.curve.circle.center,
          ie,
          v.curve.theta
        );
        L instanceof Array && i ? d.push([...ke, ...L]) : d.push([...ke, ie]);
      }
    } else if (v.loop) {
      const [H, W, ie] = Go(h, v, P);
      d.push(H), d.push(ie), L instanceof Array && i ? d.push([W, L[1], L[2]]) : d.push(L[2]);
    } else
      i || !(L instanceof Array) ? d.push(L) : x.curve ? d.push(L[1]) : x.loop ? d.push(L[0]) : d.push(L[0], L[2]);
  }
  {
    const f = m[m.length - 1];
    let v = Ke(t[f.target].shape) * r;
    const x = s + (a === "edgeOfNode" ? v : 0), y = x <= 0 ? f.line.target : Fo(f, x, n, !1);
    if (v = Ke(t[f.source].shape) * r, f.loop) {
      const h = N.fromObject((c = n[f.target]) != null ? c : { x: 0, y: 0 }), [p, P, S] = Go(h, f, v);
      d.push(p), d.push(S);
    } else if (f.curve) {
      const h = d[d.length - 1], p = h instanceof Array ? h[h.length - 1] : h, P = pn(
        p,
        f.curve.circle.center,
        y,
        f.curve.theta
      );
      d.push([...P, y]);
    } else
      d.push(y);
    s > 0 && ee.distance(f.line.source, f.line.target) <= x + v && (w = !0);
  }
  return E && (d.shift(), d[0] instanceof Array && d.unshift(d[0][0])), w && d.pop(), d;
}
function af(e) {
  const t = e.length;
  if (t <= 1)
    return [!0];
  const n = [];
  let o = null, r = !0;
  for (let i = 0; i < t; i++) {
    const a = e[i].edge.source, s = e[i].edge.target;
    if (i === 0)
      if (t > 2) {
        const l = [a, s].sort(), c = [e[1].edge.source, e[1].edge.target].sort();
        l[0] === c[0] && l[1] === c[1] ? [e[2].edge.source, e[2].edge.target].includes(e[1].edge.target) ? r = s === e[1].edge.source : r = s === e[1].edge.target : r = [e[1].edge.source, e[1].edge.target].includes(s);
      } else
        r = [e[1].edge.source, e[1].edge.target].includes(s);
    else
      a === s || (r = o === a);
    n.push(r), o = r ? s : a;
  }
  return n;
}
function Fo(e, t, n, o) {
  const r = o ? e.source : e.target, i = e.curve;
  if (i) {
    let a = t / i.circle.radius;
    return i.theta > 0 && (a *= -1), o || (a *= -1), N.fromObject(
      $e(
        o ? e.line.source : e.line.target,
        i.circle.center,
        a
      )
    );
  } else {
    let a, s;
    if (o ? (a = e.line.target, s = e.line.source) : (a = e.line.source, s = e.line.target), n[r]) {
      const l = Dt(
        a,
        s,
        N.fromObject(n[r]),
        t
      );
      return l === null ? a : l;
    } else
      return a;
  }
}
function lf(e, t, n) {
  let o = null;
  if (e.loop || t.loop)
    o = null;
  else if (e.curve)
    if (t.curve) {
      if (e.line.target.isEqualTo(t.line.source))
        return e.line.target.clone();
      o = ct(
        e.curve.circle.center,
        e.curve.circle.radius,
        t.curve.circle.center,
        t.curve.circle.radius,
        e.curve.center
      );
    } else
      o = Vu(
        t.line.target,
        t.line.source,
        e.curve.circle.center,
        e.curve.circle.radius,
        n
      );
  else if (t.curve)
    o = Dt(
      e.line.source,
      e.line.target,
      t.curve.circle.center,
      t.curve.circle.radius
    );
  else {
    const r = Uo(e.line), i = Uo(t.line);
    !isFinite(r) && !isFinite(i) || Math.abs(r - i) < rf ? o = null : o = De(e.line, t.line);
  }
  return o;
}
function xt(e, t, n, o) {
  if (e.loop) {
    const r = ct(
      t,
      n,
      e.loop.center,
      e.loop.radius[0]
    );
    return r ? o ? r[0] : r[1] : null;
  } else
    return e.curve ? ct(
      t,
      n,
      e.curve.circle.center,
      e.curve.circle.radius,
      N.fromObject(e.curve.center)
    ) : Dt(
      o ? e.line.source : e.line.target,
      o ? e.line.target : e.line.source,
      t,
      n
    );
}
function uf(e, t, n) {
  let o = n.origin, r = e.edge.source, i = e.edge.target, a = n.curve;
  const s = n.loop;
  s ? o = n.position : t || (o = Ru(o), r = e.edge.target, i = e.edge.source, a && (a = of(nf({}, a), { theta: -a.theta })));
  const l = X.fromLinePosition(o);
  return {
    edgeId: e.edgeId,
    source: r,
    target: i,
    line: l,
    direction: t,
    curve: a,
    loop: s
  };
}
function Uo(e) {
  return (e.target.y - e.source.y) / (e.target.x - e.source.x);
}
function Go(e, t, n) {
  const { radius: o, center: r } = F(t.loop, "Loop of edge parameter"), [i, a] = o, s = ct(e, n, r, o[0]);
  let [l, c] = s ? s.reverse() : [t.line.source, t.line.target];
  const u = bn(t);
  u || ([l, c] = [c, l]);
  const g = l, m = c, d = N.fromObject(g).subtract(r).angleDegree();
  let b = (N.fromObject(m).subtract(r).angleDegree() + 360 - d) % 360 >= 180;
  return b = u ? b : !b, [g, m, `A ${i} ${a} 0 ${b ? 1 : 0} ${u ? 1 : 0} ${m.x} ${m.y}`];
}
function bn(e) {
  return e.loop ? e.direction ? e.loop.isClockwise : !e.loop.isClockwise : !0;
}
const cf = ["d", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin"], df = /* @__PURE__ */ K({
  props: {
    points: {
      type: Array,
      required: !0
    },
    path: {
      type: Object,
      required: !0
    }
  },
  setup(e, { expose: t }) {
    const n = e, { scale: o } = ge(), r = _r(), i = M(() => {
      let c = !0;
      return n.points.map((u) => {
        if (u === null)
          c = !0;
        else {
          if (typeof u == "string")
            return u;
          if (u instanceof Array) {
            u = [...u];
            const g = [];
            if (u.length % 2 === 1) {
              const m = u[0];
              u = u.slice(1), g.push(`L ${m.x} ${m.y}`);
            }
            return In(u, 2).map(([m, d]) => g.push(`Q ${m.x} ${m.y} ${d.x} ${d.y}`)), g.join(" ");
          } else {
            const g = c;
            return c = !1, `${g ? "M " : "L "}${u.x} ${u.y}`;
          }
        }
      }).join(" ");
    }), a = M(() => {
      const c = n.path;
      return c.selected ? $.values(r.selected, c.path) : c.hovered && r.hover ? $.values(r.hover, c.path) : $.values(r.normal, c.path);
    }), s = M(() => ht(a.value.dasharray, o.value)), l = M(() => {
      const c = a.value.animate ? zt(a.value.dasharray) * a.value.animationSpeed * o.value : !1;
      return c ? `--animation-speed:${c}` : void 0;
    });
    return t({ d: i, scale: o, config: a, strokeDasharray: s, animationSpeed: l }), (c, u) => (O(), T("path", {
      class: de({ "v-path-line": !0, animate: _(a).animate }),
      d: _(i),
      fill: "none",
      stroke: _(a).color,
      "stroke-width": _(a).width * _(o),
      "stroke-dasharray": _(s),
      "stroke-linecap": _(a).linecap,
      "stroke-linejoin": _(a).linejoin,
      style: ft(_(l))
    }, null, 14, cf));
  }
});
const ff = /* @__PURE__ */ fe(df, [["__scopeId", "data-v-b2aa6c6f"]]), hf = /* @__PURE__ */ K({
  setup(e, { expose: t }) {
    const { pathZOrderedList: n, nodeStates: o, edgeStates: r, layouts: i } = gt(), { scale: a } = ge(), s = _r(), {
      handlePathPointerDownEvent: l,
      handlePathPointerOverEvent: c,
      handlePathPointerOutEvent: u,
      handlePathClickEvent: g,
      handlePathDoubleClickEvent: m,
      handlePathContextMenu: d
    } = Zt(), E = M(() => (w) => {
      if (w.edges.length === 0)
        return [];
      const b = $.value(s.margin, w.path) * a.value;
      return sf(
        w,
        o,
        i.nodes,
        r,
        a.value,
        s.curveInNode,
        s.end,
        b
      );
    });
    return t({
      pathConfig: s,
      pathZOrderedList: n,
      calcPathPoints: E,
      handlePathPointerDownEvent: l,
      handlePathPointerOverEvent: c,
      handlePathPointerOutEvent: u,
      handlePathClickEvent: g,
      handlePathDoubleClickEvent: m,
      handlePathContextMenu: d
    }), (w, b) => (O(), Q(rn, {
      name: _(s).transition,
      css: !!_(s).transition,
      tag: "g",
      class: "v-paths"
    }, {
      default: me(() => [
        (O(!0), T(R, null, Y(_(n), (f) => (O(), Q(ff, {
          key: f.id,
          points: _(E)(f),
          class: de({ clickable: f.clickable, hoverable: f.hoverable }),
          path: f,
          onPointerdown: (v) => _(l)(f.id, v),
          onPointerenterPassive: (v) => _(c)(f.id, v),
          onPointerleavePassive: (v) => _(u)(f.id, v),
          onClick: ye((v) => _(g)(f.id, v), ["stop"]),
          onDblclick: ye((v) => _(m)(f.id, v), ["stop"]),
          onContextmenu: (v) => _(d)(f.id, v)
        }, null, 8, ["points", "class", "path", "onPointerdown", "onPointerenterPassive", "onPointerleavePassive", "onClick", "onDblclick", "onContextmenu"]))), 128))
      ]),
      _: 1
    }, 8, ["name", "css"]));
  }
});
const vf = /* @__PURE__ */ fe(hf, [["__scopeId", "data-v-e4553f35"]]), pf = ["points", "fill"], gf = /* @__PURE__ */ K({
  props: {
    width: {
      type: Number,
      required: !0
    },
    height: {
      type: Number,
      required: !0
    },
    refX: {
      type: Number,
      required: !0
    },
    color: {
      type: String,
      required: !0
    },
    isSource: {
      type: Boolean,
      required: !0
    },
    units: {
      type: String,
      required: !0
    }
  },
  setup(e) {
    const t = e, n = M(() => {
      const o = t.width, r = t.height;
      return t.isSource ? `${o} ${r}, 0 ${r / 2}, ${o} 0` : `0 0, ${o} ${r / 2}, 0 ${r}`;
    });
    return (o, r) => (O(), T("polygon", {
      points: _(n),
      fill: e.color
    }, null, 8, pf));
  }
}), mf = ["points", "stroke-width", "stroke"], yf = /* @__PURE__ */ K({
  props: {
    width: {
      type: Number,
      required: !0
    },
    height: {
      type: Number,
      required: !0
    },
    refX: {
      type: Number,
      required: !0
    },
    color: {
      type: String,
      required: !0
    },
    isSource: {
      type: Boolean,
      required: !0
    },
    units: {
      type: String,
      required: !0
    }
  },
  setup(e) {
    const t = e, n = M(() => t.units === "strokeWidth" ? 1 : Math.min(t.width, t.height) / 5), o = M(() => {
      const r = n.value / 2, i = t.width, a = t.height;
      return t.isSource ? `${i - r} ${a - r}, ${r} ${a / 2}, ${i - r} ${r}` : `${r} ${r}, ${i - r} ${a / 2}, ${r} ${a - r}`;
    });
    return (r, i) => (O(), T("polyline", {
      points: _(o),
      fill: "none",
      "stroke-width": _(n),
      stroke: e.color,
      "stroke-linecap": "round",
      "stroke-linejoin": "round"
    }, null, 8, mf));
  }
}), bf = ["fill", "cx", "cy", "rx", "ry"], wf = /* @__PURE__ */ K({
  props: {
    width: {
      type: Number,
      required: !0
    },
    height: {
      type: Number,
      required: !0
    },
    refX: {
      type: Number,
      required: !0
    },
    color: {
      type: String,
      required: !0
    },
    isSource: {
      type: Boolean,
      required: !0
    },
    units: {
      type: String,
      required: !0
    }
  },
  setup(e) {
    return (t, n) => (O(), T("ellipse", {
      fill: e.color,
      cx: e.width / 2,
      cy: e.height / 2,
      rx: e.width / 2,
      ry: e.height / 2
    }, null, 8, bf));
  }
}), Ef = ["id", "markerWidth", "markerHeight", "refX", "refY", "markerUnits"], xf = /* @__PURE__ */ K({
  props: {
    id: {
      type: String,
      required: !0
    },
    marker: {
      type: Object,
      required: !0
    },
    scale: {
      type: Number,
      required: !0
    }
  },
  setup(e) {
    const t = e, n = {
      arrow: gf,
      angle: yf,
      circle: wf
    }, o = M(
      () => t.marker.width * (t.marker.units === "strokeWidth" ? 1 : t.scale)
    ), r = M(
      () => t.marker.height * (t.marker.units === "strokeWidth" ? 1 : t.scale)
    ), i = M(() => {
      const a = t.marker.margin * (t.marker.units === "strokeWidth" ? 1 : t.scale);
      return t.marker.isSource ? o.value + a : -a;
    });
    return (a, s) => e.marker.type !== "none" && e.marker.type !== "custom" ? (O(), T("marker", {
      key: 0,
      id: e.id,
      markerWidth: _(o),
      markerHeight: _(r),
      refX: _(i),
      refY: _(r) / 2,
      orient: "auto",
      markerUnits: e.marker.units,
      class: "v-marker"
    }, [
      (O(), Q(ci(n[e.marker.type]), {
        width: _(o),
        height: _(r),
        refX: _(i),
        color: e.marker.color,
        "is-source": e.marker.isSource,
        units: e.marker.units
      }, null, 8, ["width", "height", "refX", "color", "is-source", "units"]))
    ], 8, Ef)) : ae("", !0);
  }
}), Pf = ["x", "y", "width", "height", "fill", "stroke", "stroke-width", "stroke-dasharray"], _f = /* @__PURE__ */ K({
  props: {
    box: {
      type: Object,
      required: !0
    },
    config: {
      type: Object,
      required: !0
    }
  },
  setup(e) {
    return (t, n) => (O(), T("rect", {
      class: "selection-box",
      x: Math.round(e.box.pos.x),
      y: Math.round(e.box.pos.y),
      width: Math.ceil(e.box.size.width),
      height: Math.ceil(e.box.size.height),
      fill: e.config.color,
      stroke: e.config.strokeColor,
      "stroke-width": e.config.strokeWidth,
      "stroke-dasharray": e.config.strokeDasharray
    }, null, 8, Pf));
  }
});
const Sf = /* @__PURE__ */ fe(_f, [["__scopeId", "data-v-3b18ff1c"]]), Of = [
  "override-node",
  "override-node-label",
  "edge-overlay",
  "edge-label",
  "edges-label"
], kf = K({
  components: {
    VNode: md,
    VNodeFocusRing: bd,
    VEdgeGroups: Id,
    VEdgeBackgrounds: Dd,
    VEdgeLabels: Bd,
    VBackgroundViewport: Rd,
    VBackgroundGrid: Kd,
    VPaths: vf,
    VMarkerHead: xf,
    VSelectionBox: Sf
  },
  props: {
    nodes: {
      type: Object,
      default: () => ({})
    },
    edges: {
      type: Object,
      default: () => ({})
    },
    paths: {
      type: [Object, Array],
      default: () => ({})
    },
    layouts: {
      type: Object,
      default: () => ({})
    },
    zoomLevel: {
      type: Number,
      default: 1
    },
    selectedNodes: {
      type: Array,
      default: () => []
    },
    selectedEdges: {
      type: Array,
      default: () => []
    },
    selectedPaths: {
      type: Array,
      default: () => []
    },
    configs: {
      type: Object,
      default: () => ({})
    },
    layers: {
      type: Object,
      default: () => ({})
    },
    eventHandlers: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [
    "update:zoomLevel",
    "update:selectedNodes",
    "update:selectedEdges",
    "update:selectedPaths",
    "update:layouts"
  ],
  setup(e, { emit: t, slots: n }) {
    const o = Ce(e, "nodes"), r = Ce(e, "edges"), { objects: i, isInCompatibilityModeForPath: a } = ld(
      Ce(e, "paths")
    ), s = qc();
    Object.entries(e.eventHandlers).forEach(([C, D]) => {
      s.on(C, D);
    });
    const l = _l(Ce(e, "configs")), c = M(() => {
      const C = new Set(Object.keys(n));
      Of.forEach((ne) => C.delete(ne));
      const D = Object.fromEntries(di.map((ne) => [ne, []]));
      return Object.assign(
        D,
        Object.entries(e.layers).reduce((ne, [J, be]) => (C.delete(J), be in ne ? ne[be].push(J) : ne[be] = [J], ne), {})
      ), D.root.push(...C), D;
    }), u = M(() => l.view.grid.visible), g = M(() => {
      const C = c.value;
      return u.value || C.background.length > 0 || C.grid.length > 0;
    }), m = M(() => "override-node" in n), d = M(() => "override-node-label" in n), E = M(() => "edge-overlay" in n), w = M(() => "edge-label" in n), b = M(() => "edges-label" in n), f = A(), v = A(), x = A(), y = A(0), h = M(() => y.value !== 0), p = ud(e, "zoomLevel", t, (C) => (C = Math.max(C, l.view.minZoomLevel), C = Math.min(C, l.view.maxZoomLevel), C)), { svgPanZoom: P, onSvgPanZoomMounted: S, onSvgPanZoomUnmounted: k } = od(v, {
      viewportSelector: ".v-viewport",
      minZoom: l.view.minZoomLevel,
      maxZoom: l.view.maxZoomLevel,
      dblClickZoomEnabled: Xo(l.view),
      mouseWheelZoomEnabled: tn(l.view),
      fit: !0,
      center: !0,
      zoomEnabled: l.view.zoomEnabled,
      preventMouseEventsDefault: !1,
      onZoom: (C) => {
        var D, ne;
        if (y.value === 2)
          return;
        const J = (ne = (D = P.value) == null ? void 0 : D.getRealZoom()) != null ? ne : 1;
        Math.abs(p.value - J) >= 1e-6 && (p.value = J, s.emit("view:zoom", J));
      },
      panEnabled: l.view.panEnabled,
      onPan: (C) => {
        y.value !== 2 && s.emit("view:pan", C);
      }
    });
    fi({ container: f, svg: v, viewport: x, svgPanZoom: P });
    const I = { width: 0, height: 0 }, z = globalThis.ResizeObserver ? new ResizeObserver(() => {
      var C, D, ne;
      if ((C = P.value) == null || C.resize(), !l.view.autoPanOnResize)
        return;
      const J = (D = f.value) == null ? void 0 : D.getBoundingClientRect();
      if (J) {
        const be = -(I.width - J.width) / 2, qt = -(I.height - J.height) / 2;
        (ne = P.value) == null || ne.panBy({ x: be, y: qt });
        const { width: nt, height: Ht } = J;
        (I.width !== nt || I.height !== Ht) && (Object.assign(I, { width: nt, height: Ht }), s.emit("view:resize", { x: J.x, y: J.y, width: nt, height: Ht }));
      }
    }) : void 0;
    S(() => {
      var C, D, ne;
      const J = F(f.value, "svg-pan-zoom container");
      z == null || z.observe(J), (D = (C = l.view).onSvgPanZoomInitialized) == null || D.call(C, F(P.value, "svg-pan-zoom instance"));
      const be = J.getBoundingClientRect(), { width: qt, height: nt } = be;
      Object.assign(I, { width: qt, height: nt }), (ne = x.value) == null || ne.addEventListener("touchstart", Ko, { passive: !1 });
    }), k(() => {
      var C;
      z == null || z.disconnect(), (C = x.value) == null || C.removeEventListener("touchstart", Ko);
    });
    const j = (C) => {
      var D;
      (D = P.value) == null || D.applyAbsoluteZoomLevel(
        C,
        l.view.minZoomLevel,
        l.view.maxZoomLevel
      );
    };
    q(
      () => l.view.panEnabled,
      (C) => {
        var D;
        (D = P.value) == null || D.setPanEnabled(C);
      }
    ), q(
      () => [
        l.view.zoomEnabled,
        Xo(l.view),
        tn(l.view)
      ],
      (C) => {
        Mf(
          P.value,
          l.view.zoomEnabled,
          l.view.doubleClickZoomEnabled,
          l.view.mouseWheelZoomEnabled
        );
      }
    ), q(p, (C) => j(C)), q(
      () => [l.view.minZoomLevel, l.view.maxZoomLevel],
      (C) => {
        j(p.value);
      }
    );
    const { scale: B } = rd(p, l.view);
    S(() => {
      const C = e.zoomLevel;
      j(C);
    });
    const U = (C) => {
      var D;
      Object.keys(e.nodes).length > 0 ? ((D = P.value) == null || D.updateBBox(), nn(C)) : C();
    }, L = () => {
      U(() => {
        P.value && (P.value.fitToContents(), s.emit("view:fit", void 0));
      });
    }, H = () => {
      U(() => {
        var C;
        (C = P.value) == null || C.center();
      });
    }, W = () => {
      var C, D;
      return (D = (C = P.value) == null ? void 0 : C.getViewBox()) != null ? D : {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
    }, ie = (C) => {
      var D;
      return (D = P.value) == null ? void 0 : D.setViewBox(C);
    }, ke = en(e, "selectedNodes", o, t);
    q(ke, (C) => s.emit("node:select", Array.from(C)));
    const se = en(e, "selectedEdges", r, t);
    q(se, (C) => s.emit("edge:select", Array.from(C)));
    const je = en(e, "selectedPaths", i, t);
    q(je, (C) => s.emit("path:select", Array.from(C)));
    const Xe = Be(/* @__PURE__ */ new Set()), jn = Be(/* @__PURE__ */ new Set()), Ln = Be(/* @__PURE__ */ new Set()), Me = Be({ nodes: {} });
    q(
      () => e.layouts,
      () => Object.assign(Me, e.layouts),
      { deep: !0, immediate: !0 }
    ), q(Me, () => t("update:layouts", Me), { deep: !0 });
    const Gr = M(() => l.node.focusring.visible), Dn = Ju(), Vt = A(!1);
    s.on("node:dragstart", (C) => Vt.value = !0), s.on("node:dragend", (C) => Vt.value = !1), s.on("view:mode", (C) => {
      var D, ne, J, be;
      l.view.panEnabled && (C === "default" ? (D = P.value) == null || D.enablePan() : (ne = P.value) == null || ne.disablePan()), l.view.zoomEnabled && (C === "default" ? (J = P.value) == null || J.enableZoom() : (be = P.value) == null || be.disableZoom());
    });
    const Xr = M(() => l.view.panEnabled || l.view.zoomEnabled || l.node.draggable), { nodeStates: Zn, nodeZOrderedList: Kr, edgeStates: Yr, pathStates: Qr } = sc(
      Yt(o, ke, Xe),
      Yt(r, se, jn),
      Yt(i, je, Ln),
      ot(l),
      Me,
      Dn,
      B
    ), Jr = M(() => tn(l.view)), { isBoxSelectionMode: ei, selectionBox: ti, startBoxSelection: ni, stopBoxSelection: oi } = Rc(
      v,
      ot(Me),
      ot(p),
      Zn,
      Yr,
      Qr,
      ke,
      se,
      je,
      Xe,
      jn,
      Ln,
      a,
      Jr,
      l,
      s
    ), ri = M(() => l.path.visible), Nn = () => ({
      layouts: Be(Me.nodes),
      nodePositions: Ce(Me, "nodes"),
      nodes: o,
      edges: r,
      configs: ot(l),
      scale: ot(B),
      emitter: s,
      svgPanZoom: F(P.value)
    });
    q(
      () => l.view.layoutHandler,
      (C, D) => {
        D.deactivate(), C.activate(Nn());
      }
    );
    const { transitionWhile: ii, transitionOption: Bn } = ad(), si = M(() => {
      const C = Bn.value;
      return C.enabled ? {
        "--transition-duration": C.duration + "ms",
        "--transition-function": C.timingFunction
      } : {};
    });
    return S(() => {
      U(() => {
        const C = F(P.value, "svg-pan-zoom");
        l.view.layoutHandler.activate(Nn()), nn(() => {
          const D = l.view.autoPanAndZoomOnLoad;
          if (l.view.fit || D !== !1)
            if (Object.keys(e.nodes).length == 0 || D === "center-zero") {
              const J = C.getSizes();
              C.pan({
                x: J.width / 2,
                y: J.height / 2
              });
            } else
              D === "fit-content" || l.view.fit ? L() : D === "center-content" && H();
          s.emit("view:load"), y.value = 1;
        });
      });
    }), k(() => {
      y.value = 2, s.emit("view:unload"), l.view.layoutHandler.deactivate();
    }), {
      container: f,
      svg: v,
      viewport: x,
      show: h,
      svgPanZoom: P,
      allConfigs: l,
      layerDefs: c,
      isShowGrid: u,
      isShowBackgroundViewport: g,
      hasOverrideNodeSlot: m,
      hasOverrideNodeLabelSlot: d,
      hasEdgeOverlaySlot: E,
      hasEdgeLabelSlot: w,
      hasEdgesLabelSlot: b,
      scale: B,
      nodeStates: Zn,
      nodeZOrderedList: Kr,
      currentSelectedNodes: ke,
      markers: Dn.markers,
      dragging: Vt,
      touches: Xr,
      currentLayouts: Me,
      visibleNodeFocusRing: Gr,
      visiblePaths: ri,
      transitionOption: Bn,
      transitionStyles: si,
      isBoxSelectionMode: ei,
      selectionBox: ti,
      fitToContents: L,
      panToCenter: H,
      getViewBox: W,
      setViewBox: ie,
      transitionWhile: ii,
      startBoxSelection: ni,
      stopBoxSelection: oi
    };
  },
  methods: {
    zoomIn() {
      var e;
      (e = this.svgPanZoom) == null || e.zoomIn();
    },
    zoomOut() {
      var e;
      (e = this.svgPanZoom) == null || e.zoomOut();
    },
    panTo(e) {
      var t;
      (t = this.svgPanZoom) == null || t.pan(e);
    },
    panBy(e) {
      var t;
      (t = this.svgPanZoom) == null || t.panBy(e);
    },
    getPan() {
      return F(this.svgPanZoom).getPan();
    },
    getSizes() {
      const e = F(this.svgPanZoom).getSizes();
      return {
        width: e.width,
        height: e.height,
        viewBox: e.viewBox
      };
    },
    translateFromDomToSvgCoordinates(e) {
      return mn(
        F(this.svg, "svg"),
        F(this.viewport, "viewport"),
        e
      );
    },
    translateFromSvgToDomCoordinates(e) {
      return Ic(
        F(this.svg, "svg"),
        F(this.viewport, "viewport"),
        e
      );
    },
    getAsSvg() {
      const e = F(this.svg, "svg"), t = F(this.viewport, "svg viewport"), n = e.cloneNode(!0), o = t.getBBox(), r = 1 / this.scale, i = {
        x: Math.floor((o.x - 10) * r),
        y: Math.floor((o.y - 10) * r),
        width: Math.ceil((o.width + 20) * r),
        height: Math.ceil((o.height + 20) * r)
      };
      n.setAttribute("width", i.width.toString()), n.setAttribute("height", i.height.toString());
      const a = n.querySelector(".v-viewport");
      a.setAttribute("transform", `translate(${-i.x} ${-i.y}), scale(${r})`), a.removeAttribute("style"), n.setAttribute("viewBox", `0 0 ${i.width} ${i.height}`), n.removeAttribute("style");
      let s = n.outerHTML;
      return s = s.replaceAll(/ data-v-[0-9a-z]+=""/g, ""), s = s.replaceAll(/<!--[\s\S]*?-->/gm, ""), s;
    }
  }
});
function Mf(e, t, n, o) {
  e.setZoomEnabled(t), t && n ? e.enableDblClickZoom() : e.disableDblClickZoom(), t && o ? e.enableMouseWheelZoom() : e.disableMouseWheelZoom();
}
function Xo(e) {
  return e.zoomEnabled && e.doubleClickZoomEnabled;
}
function tn(e) {
  return e.zoomEnabled && e.mouseWheelZoomEnabled;
}
function Ko(e) {
  e.stopPropagation();
}
const Tf = {
  ref: "container",
  class: "v-network-graph"
}, Cf = { key: 0 }, $f = { class: "v-layer-edges" }, zf = {
  key: 1,
  class: "v-layer-nodes-selections"
};
function If(e, t, n, o, r, i) {
  const a = we("v-marker-head"), s = we("v-background-grid"), l = we("v-background-viewport"), c = we("v-edge-backgrounds"), u = we("v-edge-groups"), g = we("v-edge-labels"), m = we("v-node-focus-ring"), d = we("v-node"), E = we("v-paths"), w = we("v-selection-box");
  return O(), T("div", Tf, [
    (O(), T("svg", {
      ref: "svg",
      class: de(["v-canvas", { show: e.show, dragging: e.dragging, touches: e.touches, "box-selection-mode": e.isBoxSelectionMode }]),
      width: "100%",
      height: "100%"
    }, [
      (O(!0), T(R, null, Y(e.layerDefs.root, (b) => te(e.$slots, b, {
        key: b,
        scale: e.scale
      }, void 0, !0)), 128)),
      Object.keys(e.markers).length > 0 ? (O(), T("defs", Cf, [
        (O(!0), T(R, null, Y(e.markers, (b, f) => (O(), Q(a, {
          id: f,
          key: f,
          marker: b,
          scale: e.scale
        }, null, 8, ["id", "marker", "scale"]))), 128))
      ])) : ae("", !0),
      e.isShowBackgroundViewport ? (O(), Q(l, { key: 1 }, {
        default: me(() => [
          (O(!0), T(R, null, Y(e.layerDefs.background, (b) => (O(), T("g", {
            key: b,
            class: "v-layer"
          }, [
            te(e.$slots, b, { scale: e.scale }, void 0, !0)
          ]))), 128)),
          e.isShowGrid ? (O(), Q(s, { key: 0 })) : ae("", !0),
          (O(!0), T(R, null, Y(e.layerDefs.grid, (b) => (O(), T("g", {
            key: b,
            class: "v-layer"
          }, [
            te(e.$slots, b, { scale: e.scale }, void 0, !0)
          ]))), 128))
        ]),
        _: 3
      })) : ae("", !0),
      on("g", {
        ref: "viewport",
        class: de(["v-viewport", { "v-transition": e.transitionOption.enabled }]),
        style: ft(e.transitionStyles)
      }, [
        (O(!0), T(R, null, Y(e.layerDefs.base, (b) => (O(), T("g", {
          key: b,
          class: "v-layer"
        }, [
          te(e.$slots, b, { scale: e.scale }, void 0, !0)
        ]))), 128)),
        on("g", $f, [
          Ve(c),
          Ve(u, { hasEdgeOverlaySlot: e.hasEdgeOverlaySlot }, {
            default: me((b) => [
              te(e.$slots, "edge-overlay", Ze(Ne(b)), void 0, !0)
            ]),
            _: 3
          }, 8, ["hasEdgeOverlaySlot"])
        ]),
        (O(!0), T(R, null, Y(e.layerDefs.edges, (b) => (O(), T("g", {
          key: b,
          class: "v-layer"
        }, [
          te(e.$slots, b, { scale: e.scale }, void 0, !0)
        ]))), 128)),
        e.hasEdgeLabelSlot || e.hasEdgesLabelSlot ? (O(), Q(g, { key: 0 }, Vn({ _: 2 }, [
          e.hasEdgeLabelSlot ? {
            name: "edge-label",
            fn: me((b) => [
              te(e.$slots, "edge-label", Ze(Ne(b)), void 0, !0)
            ])
          } : void 0,
          e.hasEdgesLabelSlot ? {
            name: "edges-label",
            fn: me((b) => [
              te(e.$slots, "edges-label", Ze(Ne(b)), void 0, !0)
            ])
          } : void 0
        ]), 1024)) : ae("", !0),
        e.visibleNodeFocusRing ? (O(), T("g", zf, [
          (O(!0), T(R, null, Y(e.currentSelectedNodes, (b) => (O(), Q(m, {
            id: b,
            key: b,
            state: e.nodeStates[b],
            pos: e.currentLayouts.nodes[b]
          }, null, 8, ["id", "state", "pos"]))), 128))
        ])) : ae("", !0),
        (O(!0), T(R, null, Y(e.layerDefs.focusring, (b) => (O(), T("g", {
          key: b,
          class: "v-layer"
        }, [
          te(e.$slots, b, { scale: e.scale }, void 0, !0)
        ]))), 128)),
        e.hasOverrideNodeSlot || e.hasOverrideNodeLabelSlot ? (O(), Q(rn, {
          key: 2,
          name: e.allConfigs.node.transition,
          css: !!e.allConfigs.node.transition,
          tag: "g",
          class: "v-layer-nodes"
        }, {
          default: me(() => [
            (O(!0), T(R, null, Y(e.nodeZOrderedList, (b) => (O(), Q(d, {
              id: b.id,
              key: b.id,
              state: b,
              pos: e.currentLayouts.nodes[b.id]
            }, Vn({ _: 2 }, [
              e.hasOverrideNodeSlot ? {
                name: "override-node",
                fn: me((f) => [
                  te(e.$slots, "override-node", Ze(Ne(f)), void 0, !0)
                ])
              } : void 0,
              e.hasOverrideNodeLabelSlot ? {
                name: "override-node-label",
                fn: me((f) => [
                  te(e.$slots, "override-node-label", Ze(Ne(f)), void 0, !0)
                ])
              } : void 0
            ]), 1032, ["id", "state", "pos"]))), 128))
          ]),
          _: 3
        }, 8, ["name", "css"])) : (O(), Q(rn, {
          key: 3,
          name: e.allConfigs.node.transition,
          css: !!e.allConfigs.node.transition,
          tag: "g",
          class: "v-layer-nodes"
        }, {
          default: me(() => [
            (O(!0), T(R, null, Y(e.nodeZOrderedList, (b) => (O(), Q(d, {
              id: b.id,
              key: b.id,
              state: b,
              pos: e.currentLayouts.nodes[b.id]
            }, null, 8, ["id", "state", "pos"]))), 128))
          ]),
          _: 1
        }, 8, ["name", "css"])),
        (O(!0), T(R, null, Y(e.layerDefs.nodes, (b) => (O(), T("g", {
          key: b,
          class: "v-layer"
        }, [
          te(e.$slots, b, { scale: e.scale }, void 0, !0)
        ]))), 128)),
        e.visiblePaths ? (O(), Q(E, { key: 4 })) : ae("", !0),
        (O(!0), T(R, null, Y(e.layerDefs.paths, (b) => (O(), T("g", {
          key: b,
          class: "v-layer"
        }, [
          te(e.$slots, b, { scale: e.scale }, void 0, !0)
        ]))), 128))
      ], 6),
      e.selectionBox ? (O(), Q(w, {
        key: 2,
        box: e.selectionBox,
        config: e.allConfigs.view.selection.box
      }, null, 8, ["box", "config"])) : ae("", !0)
    ], 2))
  ], 512);
}
const Af = /* @__PURE__ */ fe(kf, [["render", If], ["__scopeId", "data-v-3040d3ab"]]);
var jf = Object.defineProperty, Lf = Object.defineProperties, Df = Object.getOwnPropertyDescriptors, Yo = Object.getOwnPropertySymbols, Zf = Object.prototype.hasOwnProperty, Nf = Object.prototype.propertyIsEnumerable, Qo = (e, t, n) => t in e ? jf(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, Bf = (e, t) => {
  for (var n in t || (t = {}))
    Zf.call(t, n) && Qo(e, n, t[n]);
  if (Yo)
    for (var n of Yo(t))
      Nf.call(t, n) && Qo(e, n, t[n]);
  return e;
}, Rf = (e, t) => Lf(e, Df(t));
const Vf = /* @__PURE__ */ K({
  props: {
    area: {
      type: Object,
      required: !0
    },
    config: {
      type: Object,
      required: !0
    },
    text: {
      type: String,
      required: !1,
      default: ""
    },
    align: {
      type: String,
      required: !1,
      default: "center"
    },
    verticalAlign: {
      type: String,
      required: !1,
      default: "center"
    },
    edge: {
      type: Object,
      required: !1,
      default: void 0
    },
    hovered: {
      type: Boolean,
      required: !1,
      default: !1
    },
    selected: {
      type: Boolean,
      required: !1,
      default: !1
    },
    scale: {
      type: Number,
      required: !1,
      default: void 0
    }
  },
  setup(e, { expose: t }) {
    const n = e, o = A(0), r = A(0), i = A("middle"), a = A("central"), s = A(0);
    ve(() => {
      const c = n.area.source, u = n.area.target;
      n.align === "source" ? (c.above.x == u.above.x ? i.value = c.above.y > u.above.y ? "start" : "end" : i.value = c.above.x < u.above.x ? "start" : "end", n.verticalAlign === "above" ? (o.value = c.above.x, r.value = c.above.y, a.value = "text-top") : n.verticalAlign === "below" ? (o.value = c.below.x, r.value = c.below.y, a.value = "hanging") : (o.value = (c.above.x + c.below.x) / 2, r.value = (c.above.y + c.below.y) / 2, a.value = "central")) : n.align === "target" ? (c.above.x == u.above.x ? i.value = c.above.y < u.above.y ? "start" : "end" : i.value = c.above.x > u.above.x ? "start" : "end", n.verticalAlign === "above" ? (o.value = u.above.x, r.value = u.above.y, a.value = "text-top") : n.verticalAlign === "below" ? (o.value = u.below.x, r.value = u.below.y, a.value = "hanging") : (o.value = (u.above.x + u.below.x) / 2, r.value = (u.above.y + u.below.y) / 2, a.value = "central")) : (i.value = "middle", n.verticalAlign === "above" ? (o.value = (c.above.x + u.above.x) / 2, r.value = (c.above.y + u.above.y) / 2, a.value = "text-top") : n.verticalAlign === "below" ? (o.value = (c.below.x + u.below.x) / 2, r.value = (c.below.y + u.below.y) / 2, a.value = "hanging") : (o.value = (c.above.x + u.below.x) / 2, r.value = (c.above.y + u.below.y) / 2, a.value = "central"));
      let g = X.fromPositions(c.above, u.above).v.angleDegree();
      (g < -90 || g >= 90) && (g = g + 180, g > 180 && (g -= 360)), s.value = g;
    });
    const l = M(() => a.value === "central" && !n.config.background ? Rf(Bf({}, n.config), {
      background: {
        visible: !0,
        color: "#ffffff",
        padding: {
          vertical: 1,
          horizontal: 4
        },
        borderRadius: 2
      }
    }) : n.config);
    return t({ x: o, y: r, textAnchor: i, dominantBaseline: a, angle: s, updatedConfig: l }), (c, u) => (O(), Q(Rt, {
      class: "v-edge-label",
      text: e.text,
      x: o.value,
      y: r.value,
      config: _(l),
      "text-anchor": i.value,
      "dominant-baseline": a.value,
      transform: `rotate(${s.value} ${o.value} ${r.value})`
    }, null, 8, ["text", "x", "y", "config", "text-anchor", "dominant-baseline", "transform"]));
  }
}), qf = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  VNetworkGraph: Af,
  VShape: Bt,
  VEdgeLabel: Vf,
  VLabelText: Rt
}, Symbol.toStringTag, { value: "Module" })), Hf = 10;
class Xf extends ir {
  constructor(t = {}) {
    super(), this.options = t;
  }
  setNodePosition(t, n) {
    const o = this.options.grid || Hf;
    t.value.x = Math.floor(n.x / o) * o, t.value.y = Math.floor(n.y / o) * o;
  }
}
const Kf = function(e) {
  Object.entries(qf).forEach(([t, n]) => {
    e.component(t, n);
  });
};
export {
  $ as Config,
  Xf as GridLayout,
  di as LayerPositions,
  Z as NodeLabelDirection,
  ir as SimpleLayout,
  Vf as VEdgeLabel,
  Rt as VLabelText,
  Af as VNetworkGraph,
  Bt as VShape,
  N as Vector2D,
  Ff as configsWithType,
  Kf as default,
  Uf as defineConfigs,
  Gf as getFullConfigs,
  gt as useStates,
  Wt as withSelf
};
//# sourceMappingURL=index.mjs.map

{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/web.dom-exception.stack.js\";\nimport \"core-js/modules/es.array.includes.js\";\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __pow = Math.pow;\n\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\n\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\n\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\n\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = value => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n\n    var rejected = value => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n\n    var step = x => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\nimport { isReactive, reactive, provide, inject, watch, toRef, watchEffect, computed, unref, ref, onMounted, onUnmounted, nextTick, defineComponent, openBlock, createElementBlock, useAttrs, Fragment, mergeProps, createCommentVNode, createElementVNode, createTextVNode, toDisplayString, renderList, normalizeClass, withModifiers, renderSlot, createVNode, createBlock, normalizeStyle, withCtx, normalizeProps, guardReactiveProps, TransitionGroup, resolveDynamicComponent, readonly, resolveComponent, createSlots } from \"vue\";\nconst LayerPositions = [\"paths\", \"nodes\", \"focusring\", \"edges\", \"base\", \"grid\", \"background\", \"root\"];\n\nfunction Reactive(value) {\n  if (isReactive(value)) {\n    return value;\n  } else {\n    return reactive(value);\n  }\n}\n\nfunction nonNull(val, name = \"Parameter\") {\n  if (val === void 0 || val === null) {\n    throw new Error(`${name} is null`);\n  }\n\n  return val;\n}\n\nconst containersKey = Symbol(\"containers\");\n\nfunction provideContainers(containers) {\n  provide(containersKey, containers);\n}\n\nfunction useContainers() {\n  const containers = nonNull(inject(containersKey), \"containers\");\n  return {\n    container: containers.container,\n    svg: containers.svg,\n    viewport: containers.viewport,\n    svgPanZoom: containers.svgPanZoom\n  };\n}\n\nclass Config {\n  static value(value, target) {\n    return value instanceof Function ? value(target) : value;\n  }\n\n  static values(value, target) {\n    if (Object.values(value).filter(v => v instanceof Function).length === 0) {\n      return value;\n    }\n\n    return Object.fromEntries(Object.entries(value).map(([k, v]) => [k, v instanceof Function ? v(target) : v]));\n  }\n\n}\n\nvar NodeLabelDirection = /* @__PURE__ */(NodeLabelDirection2 => {\n  NodeLabelDirection2[\"CENTER\"] = \"center\";\n  NodeLabelDirection2[\"NORTH\"] = \"north\";\n  NodeLabelDirection2[\"NORTH_EAST\"] = \"north-east\";\n  NodeLabelDirection2[\"EAST\"] = \"east\";\n  NodeLabelDirection2[\"SOUTH_EAST\"] = \"south-east\";\n  NodeLabelDirection2[\"SOUTH\"] = \"south\";\n  NodeLabelDirection2[\"SOUTH_WEST\"] = \"south-west\";\n  NodeLabelDirection2[\"WEST\"] = \"west\";\n  NodeLabelDirection2[\"NORTH_WEST\"] = \"north-west\";\n  return NodeLabelDirection2;\n})(NodeLabelDirection || {});\n\nfunction withSelf(callback) {\n  const self2 = {};\n  return Object.assign(self2, callback(self2));\n}\n\nfunction configsWithType(configs) {\n  return configs;\n}\n\nfunction defineConfigs(configs) {\n  return configs;\n}\n\nfunction getNodeSize(node, style, scale) {\n  const shape = Config.values(style.normal, node);\n\n  if (shape.type == \"circle\") {\n    return {\n      width: shape.radius * 2 * scale,\n      height: shape.radius * 2 * scale\n    };\n  } else {\n    return {\n      width: shape.width * scale,\n      height: shape.height * scale\n    };\n  }\n}\n\nfunction areNodesCollision(nodePos, nodeSize, targetNodePos, targetNodeSize) {\n  const distanceX = Math.abs(nodePos.x - targetNodePos.x);\n  const collisionX = distanceX < nodeSize.width / 2 + targetNodeSize.width / 2;\n  const distanceY = Math.abs(nodePos.y - targetNodePos.y);\n  const collisionY = distanceY < nodeSize.height / 2 + targetNodeSize.height / 2;\n  return collisionX && collisionY;\n}\n\nfunction applyScaleToDasharray(dasharray, scale) {\n  let result = 0;\n\n  if (scale === 1 || dasharray === void 0 || dasharray === \"none\") {\n    result = dasharray != null ? dasharray : 0;\n  } else if (typeof dasharray === \"string\") {\n    result = dasharray.split(/\\s+/).map(v => parseInt(v) * scale).filter(v => !isNaN(v)).join(\" \");\n  } else {\n    result = dasharray * scale;\n  }\n\n  return result && result !== \"0\" ? result : void 0;\n}\n\nfunction getDasharrayUnit(dasharray) {\n  let result = 0;\n\n  if (dasharray === void 0 || dasharray === \"none\") {\n    result = 0;\n  } else if (typeof dasharray === \"string\") {\n    const array = dasharray.split(/\\s+/).map(v => parseInt(v)).filter(v => !isNaN(v));\n\n    if (array.length % 2 === 0) {\n      result = array.reduce((s, n) => s + n, 0);\n    } else {\n      result = array.reduce((s, n) => s + n, 0) * 2;\n    }\n  } else {\n    result = dasharray * 2;\n  }\n\n  return result;\n}\n\nvar freeGlobal = typeof global == \"object\" && global && global.Object === Object && global;\nvar freeGlobal$1 = freeGlobal;\nvar freeSelf = typeof self == \"object\" && self && self.Object === Object && self;\nvar root = freeGlobal$1 || freeSelf || Function(\"return this\")();\nvar root$1 = root;\nvar reWhitespace = /\\s/;\n\nfunction trimmedEndIndex(string) {\n  var index = string.length;\n\n  while (index-- && reWhitespace.test(string.charAt(index))) {}\n\n  return index;\n}\n\nvar reTrimStart = /^\\s+/;\n\nfunction baseTrim(string) {\n  return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, \"\") : string;\n}\n\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == \"object\" || type == \"function\");\n}\n\nvar Symbol$1 = root$1.Symbol;\nvar Symbol$2 = Symbol$1;\nvar objectProto$e = Object.prototype;\nvar hasOwnProperty$b = objectProto$e.hasOwnProperty;\nvar nativeObjectToString$1 = objectProto$e.toString;\nvar symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : void 0;\n\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty$b.call(value, symToStringTag$1),\n      tag = value[symToStringTag$1];\n\n  try {\n    value[symToStringTag$1] = void 0;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString$1.call(value);\n\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag$1] = tag;\n    } else {\n      delete value[symToStringTag$1];\n    }\n  }\n\n  return result;\n}\n\nvar objectProto$d = Object.prototype;\nvar nativeObjectToString = objectProto$d.toString;\n\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nvar nullTag = \"[object Null]\",\n    undefinedTag = \"[object Undefined]\";\nvar symToStringTag = Symbol$2 ? Symbol$2.toStringTag : void 0;\n\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === void 0 ? undefinedTag : nullTag;\n  }\n\n  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);\n}\n\nfunction isObjectLike(value) {\n  return value != null && typeof value == \"object\";\n}\n\nvar symbolTag$1 = \"[object Symbol]\";\n\nfunction isSymbol(value) {\n  return typeof value == \"symbol\" || isObjectLike(value) && baseGetTag(value) == symbolTag$1;\n}\n\nvar NAN = 0 / 0;\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\nvar reIsBinary = /^0b[01]+$/i;\nvar reIsOctal = /^0o[0-7]+$/i;\nvar freeParseInt = parseInt;\n\nfunction toNumber(value) {\n  if (typeof value == \"number\") {\n    return value;\n  }\n\n  if (isSymbol(value)) {\n    return NAN;\n  }\n\n  if (isObject(value)) {\n    var other = typeof value.valueOf == \"function\" ? value.valueOf() : value;\n    value = isObject(other) ? other + \"\" : other;\n  }\n\n  if (typeof value != \"string\") {\n    return value === 0 ? value : +value;\n  }\n\n  value = baseTrim(value);\n  var isBinary = reIsBinary.test(value);\n  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;\n}\n\nvar INFINITY$1 = 1 / 0,\n    MAX_INTEGER = 17976931348623157e292;\n\nfunction toFinite(value) {\n  if (!value) {\n    return value === 0 ? value : 0;\n  }\n\n  value = toNumber(value);\n\n  if (value === INFINITY$1 || value === -INFINITY$1) {\n    var sign = value < 0 ? -1 : 1;\n    return sign * MAX_INTEGER;\n  }\n\n  return value === value ? value : 0;\n}\n\nfunction toInteger(value) {\n  var result = toFinite(value),\n      remainder = result % 1;\n  return result === result ? remainder ? result - remainder : result : 0;\n}\n\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length2 = array == null ? 0 : array.length,\n      result = Array(length2);\n\n  while (++index < length2) {\n    result[index] = iteratee(array[index], index, array);\n  }\n\n  return result;\n}\n\nvar isArray = Array.isArray;\nvar isArray$1 = isArray;\nvar INFINITY = 1 / 0;\nvar symbolProto$1 = Symbol$2 ? Symbol$2.prototype : void 0,\n    symbolToString = symbolProto$1 ? symbolProto$1.toString : void 0;\n\nfunction baseToString(value) {\n  if (typeof value == \"string\") {\n    return value;\n  }\n\n  if (isArray$1(value)) {\n    return arrayMap(value, baseToString) + \"\";\n  }\n\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : \"\";\n  }\n\n  var result = value + \"\";\n  return result == \"0\" && 1 / value == -INFINITY ? \"-0\" : result;\n}\n\nfunction toString(value) {\n  return value == null ? \"\" : baseToString(value);\n}\n\nvar nativeIsFinite = root$1.isFinite,\n    nativeMin$1 = Math.min;\n\nfunction createRound(methodName) {\n  var func = Math[methodName];\n  return function (number, precision) {\n    number = toNumber(number);\n    precision = precision == null ? 0 : nativeMin$1(toInteger(precision), 292);\n\n    if (precision && nativeIsFinite(number)) {\n      var pair = (toString(number) + \"e\").split(\"e\"),\n          value = func(pair[0] + \"e\" + (+pair[1] + precision));\n      pair = (toString(value) + \"e\").split(\"e\");\n      return +(pair[0] + \"e\" + (+pair[1] - precision));\n    }\n\n    return func(number);\n  };\n}\n\nvar round = createRound(\"round\");\nvar round$1 = round;\nconst NEW_NODE_POSITION_MARGIN = 20;\n\nclass SimpleLayout {\n  activate(parameters) {\n    const {\n      nodePositions,\n      nodes,\n      configs,\n      emitter,\n      scale,\n      svgPanZoom: svgPanZoom2\n    } = parameters;\n\n    const onDrag = positions => {\n      for (const [id, pos] of Object.entries(positions)) {\n        const layout = this.getOrCreateNodePosition(nodePositions, id);\n        this.setNodePosition(layout, pos);\n      }\n    };\n\n    const setNewNodePositions = nodeIds => {\n      const newNodes = nodeIds.filter(n => !(n in nodePositions.value));\n      const area = svgPanZoom2.getViewArea();\n      const s = scale.value;\n\n      for (const nodeId of newNodes) {\n        const node = nodes.value[nodeId];\n        const nodeSize = getNodeSize(node, configs.node, s);\n\n        const candidate = __spreadValues({}, area.center);\n\n        for (;;) {\n          let collision = false;\n\n          for (const [id, pos] of Object.entries(nodePositions.value)) {\n            if (nodeId === id) continue;\n            const targetNode = nodes.value[id];\n            if (!targetNode) continue;\n            const targetNodeSize = getNodeSize(targetNode, configs.node, s);\n            collision = areNodesCollision(candidate, nodeSize, pos, targetNodeSize);\n\n            if (collision) {\n              break;\n            }\n          }\n\n          if (collision) {\n            candidate.x += nodeSize.width + NEW_NODE_POSITION_MARGIN * s;\n\n            if (candidate.x + nodeSize.width / 2 > area.box.right) {\n              candidate.x = area.center.x;\n              candidate.y += nodeSize.height + NEW_NODE_POSITION_MARGIN * s;\n            }\n          } else {\n            break;\n          }\n        }\n\n        const layout = this.getOrCreateNodePosition(nodePositions, nodeId);\n        this.setNodePosition(layout, candidate);\n      }\n    };\n\n    setNewNodePositions(Object.keys(nodes.value));\n    const stopNodeWatch = watch(() => Object.keys(nodes.value), setNewNodePositions);\n    emitter.on(\"node:dragstart\", onDrag);\n    emitter.on(\"node:pointermove\", onDrag);\n    emitter.on(\"node:dragend\", onDrag);\n\n    this.onDeactivate = () => {\n      stopNodeWatch();\n      emitter.off(\"node:dragstart\", onDrag);\n      emitter.off(\"node:pointermove\", onDrag);\n      emitter.off(\"node:dragend\", onDrag);\n    };\n  }\n\n  deactivate() {\n    if (this.onDeactivate) {\n      this.onDeactivate();\n    }\n  }\n\n  setNodePosition(nodeLayout, pos) {\n    nodeLayout.value.x = round$1(pos.x, 3);\n    nodeLayout.value.y = round$1(pos.y, 3);\n  }\n\n  getOrCreateNodePosition(nodePositions, node) {\n    const layout = toRef(nodePositions.value, node);\n\n    if (!layout.value) {\n      layout.value = {\n        x: 0,\n        y: 0\n      };\n    }\n\n    return layout;\n  }\n\n}\n\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\nfunction eq(value, other) {\n  return value === other || value !== value && other !== other;\n}\n\nfunction assocIndexOf(array, key) {\n  var length2 = array.length;\n\n  while (length2--) {\n    if (eq(array[length2][0], key)) {\n      return length2;\n    }\n  }\n\n  return -1;\n}\n\nvar arrayProto = Array.prototype;\nvar splice = arrayProto.splice;\n\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n\n  var lastIndex = data.length - 1;\n\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n\n  --this.size;\n  return true;\n}\n\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n  return index < 0 ? void 0 : data[index][1];\n}\n\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n\n  return this;\n}\n\nfunction ListCache(entries) {\n  var index = -1,\n      length2 = entries == null ? 0 : entries.length;\n  this.clear();\n\n  while (++index < length2) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\nListCache.prototype.clear = listCacheClear;\nListCache.prototype[\"delete\"] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\nfunction stackClear() {\n  this.__data__ = new ListCache();\n  this.size = 0;\n}\n\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data[\"delete\"](key);\n  this.size = data.size;\n  return result;\n}\n\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\nvar asyncTag = \"[object AsyncFunction]\",\n    funcTag$1 = \"[object Function]\",\n    genTag = \"[object GeneratorFunction]\",\n    proxyTag = \"[object Proxy]\";\n\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n\n  var tag = baseGetTag(value);\n  return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\nvar coreJsData = root$1[\"__core-js_shared__\"];\nvar coreJsData$1 = coreJsData;\n\nvar maskSrcKey = function () {\n  var uid = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || \"\");\n  return uid ? \"Symbol(src)_1.\" + uid : \"\";\n}();\n\nfunction isMasked(func) {\n  return !!maskSrcKey && maskSrcKey in func;\n}\n\nvar funcProto$2 = Function.prototype;\nvar funcToString$2 = funcProto$2.toString;\n\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString$2.call(func);\n    } catch (e) {}\n\n    try {\n      return func + \"\";\n    } catch (e) {}\n  }\n\n  return \"\";\n}\n\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\nvar funcProto$1 = Function.prototype,\n    objectProto$c = Object.prototype;\nvar funcToString$1 = funcProto$1.toString;\nvar hasOwnProperty$a = objectProto$c.hasOwnProperty;\nvar reIsNative = RegExp(\"^\" + funcToString$1.call(hasOwnProperty$a).replace(reRegExpChar, \"\\\\$&\").replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, \"$1.*?\") + \"$\");\n\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\nfunction getValue(object, key) {\n  return object == null ? void 0 : object[key];\n}\n\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : void 0;\n}\n\nvar Map$1 = getNative(root$1, \"Map\");\nvar Map$2 = Map$1;\nvar nativeCreate = getNative(Object, \"create\");\nvar nativeCreate$1 = nativeCreate;\n\nfunction hashClear() {\n  this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {};\n  this.size = 0;\n}\n\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nvar HASH_UNDEFINED$2 = \"__lodash_hash_undefined__\";\nvar objectProto$b = Object.prototype;\nvar hasOwnProperty$9 = objectProto$b.hasOwnProperty;\n\nfunction hashGet(key) {\n  var data = this.__data__;\n\n  if (nativeCreate$1) {\n    var result = data[key];\n    return result === HASH_UNDEFINED$2 ? void 0 : result;\n  }\n\n  return hasOwnProperty$9.call(data, key) ? data[key] : void 0;\n}\n\nvar objectProto$a = Object.prototype;\nvar hasOwnProperty$8 = objectProto$a.hasOwnProperty;\n\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate$1 ? data[key] !== void 0 : hasOwnProperty$8.call(data, key);\n}\n\nvar HASH_UNDEFINED$1 = \"__lodash_hash_undefined__\";\n\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = nativeCreate$1 && value === void 0 ? HASH_UNDEFINED$1 : value;\n  return this;\n}\n\nfunction Hash(entries) {\n  var index = -1,\n      length2 = entries == null ? 0 : entries.length;\n  this.clear();\n\n  while (++index < length2) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\nHash.prototype.clear = hashClear;\nHash.prototype[\"delete\"] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    \"hash\": new Hash(),\n    \"map\": new (Map$2 || ListCache)(),\n    \"string\": new Hash()\n  };\n}\n\nfunction isKeyable(value) {\n  var type = typeof value;\n  return type == \"string\" || type == \"number\" || type == \"symbol\" || type == \"boolean\" ? value !== \"__proto__\" : value === null;\n}\n\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key) ? data[typeof key == \"string\" ? \"string\" : \"hash\"] : data.map;\n}\n\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)[\"delete\"](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\nfunction MapCache(entries) {\n  var index = -1,\n      length2 = entries == null ? 0 : entries.length;\n  this.clear();\n\n  while (++index < length2) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype[\"delete\"] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\nvar LARGE_ARRAY_SIZE = 200;\n\nfunction stackSet(key, value) {\n  var data = this.__data__;\n\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n\n    if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE - 1) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n\n    data = this.__data__ = new MapCache(pairs);\n  }\n\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\n\nStack.prototype.clear = stackClear;\nStack.prototype[\"delete\"] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\nvar defineProperty = function () {\n  try {\n    var func = getNative(Object, \"defineProperty\");\n    func({}, \"\", {});\n    return func;\n  } catch (e) {}\n}();\n\nvar defineProperty$1 = defineProperty;\n\nfunction baseAssignValue(object, key, value) {\n  if (key == \"__proto__\" && defineProperty$1) {\n    defineProperty$1(object, key, {\n      \"configurable\": true,\n      \"enumerable\": true,\n      \"value\": value,\n      \"writable\": true\n    });\n  } else {\n    object[key] = value;\n  }\n}\n\nfunction assignMergeValue(object, key, value) {\n  if (value !== void 0 && !eq(object[key], value) || value === void 0 && !(key in object)) {\n    baseAssignValue(object, key, value);\n  }\n}\n\nfunction createBaseFor(fromRight) {\n  return function (object, iteratee, keysFunc) {\n    var index = -1,\n        iterable = Object(object),\n        props = keysFunc(object),\n        length2 = props.length;\n\n    while (length2--) {\n      var key = props[fromRight ? length2 : ++index];\n\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n\n    return object;\n  };\n}\n\nvar baseFor = createBaseFor();\nvar baseFor$1 = baseFor;\nvar freeExports$2 = typeof exports == \"object\" && exports && !exports.nodeType && exports;\nvar freeModule$2 = freeExports$2 && typeof module == \"object\" && module && !module.nodeType && module;\nvar moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;\nvar Buffer$2 = moduleExports$2 ? root$1.Buffer : void 0,\n    allocUnsafe = Buffer$2 ? Buffer$2.allocUnsafe : void 0;\n\nfunction cloneBuffer(buffer, isDeep) {\n  if (isDeep) {\n    return buffer.slice();\n  }\n\n  var length2 = buffer.length,\n      result = allocUnsafe ? allocUnsafe(length2) : new buffer.constructor(length2);\n  buffer.copy(result);\n  return result;\n}\n\nvar Uint8Array2 = root$1.Uint8Array;\nvar Uint8Array$1 = Uint8Array2;\n\nfunction cloneArrayBuffer(arrayBuffer) {\n  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n  new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer));\n  return result;\n}\n\nfunction cloneTypedArray(typedArray, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n}\n\nfunction copyArray(source, array) {\n  var index = -1,\n      length2 = source.length;\n  array || (array = Array(length2));\n\n  while (++index < length2) {\n    array[index] = source[index];\n  }\n\n  return array;\n}\n\nvar objectCreate = Object.create;\n\nvar baseCreate = function () {\n  function object() {}\n\n  return function (proto) {\n    if (!isObject(proto)) {\n      return {};\n    }\n\n    if (objectCreate) {\n      return objectCreate(proto);\n    }\n\n    object.prototype = proto;\n    var result = new object();\n    object.prototype = void 0;\n    return result;\n  };\n}();\n\nvar baseCreate$1 = baseCreate;\n\nfunction overArg(func, transform) {\n  return function (arg) {\n    return func(transform(arg));\n  };\n}\n\nvar getPrototype = overArg(Object.getPrototypeOf, Object);\nvar getPrototype$1 = getPrototype;\nvar objectProto$9 = Object.prototype;\n\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = typeof Ctor == \"function\" && Ctor.prototype || objectProto$9;\n  return value === proto;\n}\n\nfunction initCloneObject(object) {\n  return typeof object.constructor == \"function\" && !isPrototype(object) ? baseCreate$1(getPrototype$1(object)) : {};\n}\n\nvar argsTag$2 = \"[object Arguments]\";\n\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag$2;\n}\n\nvar objectProto$8 = Object.prototype;\nvar hasOwnProperty$7 = objectProto$8.hasOwnProperty;\nvar propertyIsEnumerable$1 = objectProto$8.propertyIsEnumerable;\nvar isArguments = baseIsArguments(function () {\n  return arguments;\n}()) ? baseIsArguments : function (value) {\n  return isObjectLike(value) && hasOwnProperty$7.call(value, \"callee\") && !propertyIsEnumerable$1.call(value, \"callee\");\n};\nvar isArguments$1 = isArguments;\nvar MAX_SAFE_INTEGER$1 = 9007199254740991;\n\nfunction isLength(value) {\n  return typeof value == \"number\" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;\n}\n\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\nfunction isArrayLikeObject(value) {\n  return isObjectLike(value) && isArrayLike(value);\n}\n\nfunction stubFalse() {\n  return false;\n}\n\nvar freeExports$1 = typeof exports == \"object\" && exports && !exports.nodeType && exports;\nvar freeModule$1 = freeExports$1 && typeof module == \"object\" && module && !module.nodeType && module;\nvar moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;\nvar Buffer$1 = moduleExports$1 ? root$1.Buffer : void 0;\nvar nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : void 0;\nvar isBuffer = nativeIsBuffer || stubFalse;\nvar isBuffer$1 = isBuffer;\nvar objectTag$3 = \"[object Object]\";\nvar funcProto = Function.prototype,\n    objectProto$7 = Object.prototype;\nvar funcToString = funcProto.toString;\nvar hasOwnProperty$6 = objectProto$7.hasOwnProperty;\nvar objectCtorString = funcToString.call(Object);\n\nfunction isPlainObject(value) {\n  if (!isObjectLike(value) || baseGetTag(value) != objectTag$3) {\n    return false;\n  }\n\n  var proto = getPrototype$1(value);\n\n  if (proto === null) {\n    return true;\n  }\n\n  var Ctor = hasOwnProperty$6.call(proto, \"constructor\") && proto.constructor;\n  return typeof Ctor == \"function\" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;\n}\n\nvar argsTag$1 = \"[object Arguments]\",\n    arrayTag$1 = \"[object Array]\",\n    boolTag$1 = \"[object Boolean]\",\n    dateTag$1 = \"[object Date]\",\n    errorTag$1 = \"[object Error]\",\n    funcTag = \"[object Function]\",\n    mapTag$2 = \"[object Map]\",\n    numberTag$1 = \"[object Number]\",\n    objectTag$2 = \"[object Object]\",\n    regexpTag$1 = \"[object RegExp]\",\n    setTag$2 = \"[object Set]\",\n    stringTag$1 = \"[object String]\",\n    weakMapTag$1 = \"[object WeakMap]\";\nvar arrayBufferTag$1 = \"[object ArrayBuffer]\",\n    dataViewTag$2 = \"[object DataView]\",\n    float32Tag = \"[object Float32Array]\",\n    float64Tag = \"[object Float64Array]\",\n    int8Tag = \"[object Int8Array]\",\n    int16Tag = \"[object Int16Array]\",\n    int32Tag = \"[object Int32Array]\",\n    uint8Tag = \"[object Uint8Array]\",\n    uint8ClampedTag = \"[object Uint8ClampedArray]\",\n    uint16Tag = \"[object Uint16Array]\",\n    uint32Tag = \"[object Uint32Array]\";\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$1] = typedArrayTags[boolTag$1] = typedArrayTags[dataViewTag$2] = typedArrayTags[dateTag$1] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag] = typedArrayTags[mapTag$2] = typedArrayTags[numberTag$1] = typedArrayTags[objectTag$2] = typedArrayTags[regexpTag$1] = typedArrayTags[setTag$2] = typedArrayTags[stringTag$1] = typedArrayTags[weakMapTag$1] = false;\n\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\nfunction baseUnary(func) {\n  return function (value) {\n    return func(value);\n  };\n}\n\nvar freeExports = typeof exports == \"object\" && exports && !exports.nodeType && exports;\nvar freeModule = freeExports && typeof module == \"object\" && module && !module.nodeType && module;\nvar moduleExports = freeModule && freeModule.exports === freeExports;\nvar freeProcess = moduleExports && freeGlobal$1.process;\n\nvar nodeUtil = function () {\n  try {\n    var types = freeModule && freeModule.require && freeModule.require(\"util\").types;\n\n    if (types) {\n      return types;\n    }\n\n    return freeProcess && freeProcess.binding && freeProcess.binding(\"util\");\n  } catch (e) {}\n}();\n\nvar nodeUtil$1 = nodeUtil;\nvar nodeIsTypedArray = nodeUtil$1 && nodeUtil$1.isTypedArray;\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\nvar isTypedArray$1 = isTypedArray;\n\nfunction safeGet(object, key) {\n  if (key === \"constructor\" && typeof object[key] === \"function\") {\n    return;\n  }\n\n  if (key == \"__proto__\") {\n    return;\n  }\n\n  return object[key];\n}\n\nvar objectProto$6 = Object.prototype;\nvar hasOwnProperty$5 = objectProto$6.hasOwnProperty;\n\nfunction assignValue(object, key, value) {\n  var objValue = object[key];\n\n  if (!(hasOwnProperty$5.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {\n    baseAssignValue(object, key, value);\n  }\n}\n\nfunction copyObject(source, props, object, customizer) {\n  var isNew = !object;\n  object || (object = {});\n  var index = -1,\n      length2 = props.length;\n\n  while (++index < length2) {\n    var key = props[index];\n    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;\n\n    if (newValue === void 0) {\n      newValue = source[key];\n    }\n\n    if (isNew) {\n      baseAssignValue(object, key, newValue);\n    } else {\n      assignValue(object, key, newValue);\n    }\n  }\n\n  return object;\n}\n\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n\n  return result;\n}\n\nvar MAX_SAFE_INTEGER = 9007199254740991;\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\nfunction isIndex(value, length2) {\n  var type = typeof value;\n  length2 = length2 == null ? MAX_SAFE_INTEGER : length2;\n  return !!length2 && (type == \"number\" || type != \"symbol\" && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length2;\n}\n\nvar objectProto$5 = Object.prototype;\nvar hasOwnProperty$4 = objectProto$5.hasOwnProperty;\n\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray$1(value),\n      isArg = !isArr && isArguments$1(value),\n      isBuff = !isArr && !isArg && isBuffer$1(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray$1(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length2 = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty$4.call(value, key)) && !(skipIndexes && (key == \"length\" || isBuff && (key == \"offset\" || key == \"parent\") || isType && (key == \"buffer\" || key == \"byteLength\" || key == \"byteOffset\") || isIndex(key, length2)))) {\n      result.push(key);\n    }\n  }\n\n  return result;\n}\n\nfunction nativeKeysIn(object) {\n  var result = [];\n\n  if (object != null) {\n    for (var key in Object(object)) {\n      result.push(key);\n    }\n  }\n\n  return result;\n}\n\nvar objectProto$4 = Object.prototype;\nvar hasOwnProperty$3 = objectProto$4.hasOwnProperty;\n\nfunction baseKeysIn(object) {\n  if (!isObject(object)) {\n    return nativeKeysIn(object);\n  }\n\n  var isProto = isPrototype(object),\n      result = [];\n\n  for (var key in object) {\n    if (!(key == \"constructor\" && (isProto || !hasOwnProperty$3.call(object, key)))) {\n      result.push(key);\n    }\n  }\n\n  return result;\n}\n\nfunction keysIn(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n}\n\nfunction toPlainObject(value) {\n  return copyObject(value, keysIn(value));\n}\n\nfunction baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {\n  var objValue = safeGet(object, key),\n      srcValue = safeGet(source, key),\n      stacked = stack.get(srcValue);\n\n  if (stacked) {\n    assignMergeValue(object, key, stacked);\n    return;\n  }\n\n  var newValue = customizer ? customizer(objValue, srcValue, key + \"\", object, source, stack) : void 0;\n  var isCommon = newValue === void 0;\n\n  if (isCommon) {\n    var isArr = isArray$1(srcValue),\n        isBuff = !isArr && isBuffer$1(srcValue),\n        isTyped = !isArr && !isBuff && isTypedArray$1(srcValue);\n    newValue = srcValue;\n\n    if (isArr || isBuff || isTyped) {\n      if (isArray$1(objValue)) {\n        newValue = objValue;\n      } else if (isArrayLikeObject(objValue)) {\n        newValue = copyArray(objValue);\n      } else if (isBuff) {\n        isCommon = false;\n        newValue = cloneBuffer(srcValue, true);\n      } else if (isTyped) {\n        isCommon = false;\n        newValue = cloneTypedArray(srcValue, true);\n      } else {\n        newValue = [];\n      }\n    } else if (isPlainObject(srcValue) || isArguments$1(srcValue)) {\n      newValue = objValue;\n\n      if (isArguments$1(objValue)) {\n        newValue = toPlainObject(objValue);\n      } else if (!isObject(objValue) || isFunction(objValue)) {\n        newValue = initCloneObject(srcValue);\n      }\n    } else {\n      isCommon = false;\n    }\n  }\n\n  if (isCommon) {\n    stack.set(srcValue, newValue);\n    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);\n    stack[\"delete\"](srcValue);\n  }\n\n  assignMergeValue(object, key, newValue);\n}\n\nfunction baseMerge(object, source, srcIndex, customizer, stack) {\n  if (object === source) {\n    return;\n  }\n\n  baseFor$1(source, function (srcValue, key) {\n    stack || (stack = new Stack());\n\n    if (isObject(srcValue)) {\n      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);\n    } else {\n      var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + \"\", object, source, stack) : void 0;\n\n      if (newValue === void 0) {\n        newValue = srcValue;\n      }\n\n      assignMergeValue(object, key, newValue);\n    }\n  }, keysIn);\n}\n\nfunction identity(value) {\n  return value;\n}\n\nfunction apply(func, thisArg, args) {\n  switch (args.length) {\n    case 0:\n      return func.call(thisArg);\n\n    case 1:\n      return func.call(thisArg, args[0]);\n\n    case 2:\n      return func.call(thisArg, args[0], args[1]);\n\n    case 3:\n      return func.call(thisArg, args[0], args[1], args[2]);\n  }\n\n  return func.apply(thisArg, args);\n}\n\nvar nativeMax$2 = Math.max;\n\nfunction overRest(func, start, transform) {\n  start = nativeMax$2(start === void 0 ? func.length - 1 : start, 0);\n  return function () {\n    var args = arguments,\n        index = -1,\n        length2 = nativeMax$2(args.length - start, 0),\n        array = Array(length2);\n\n    while (++index < length2) {\n      array[index] = args[start + index];\n    }\n\n    index = -1;\n    var otherArgs = Array(start + 1);\n\n    while (++index < start) {\n      otherArgs[index] = args[index];\n    }\n\n    otherArgs[start] = transform(array);\n    return apply(func, this, otherArgs);\n  };\n}\n\nfunction constant(value) {\n  return function () {\n    return value;\n  };\n}\n\nvar baseSetToString = !defineProperty$1 ? identity : function (func, string) {\n  return defineProperty$1(func, \"toString\", {\n    \"configurable\": true,\n    \"enumerable\": false,\n    \"value\": constant(string),\n    \"writable\": true\n  });\n};\nvar baseSetToString$1 = baseSetToString;\nvar HOT_COUNT = 800,\n    HOT_SPAN = 16;\nvar nativeNow = Date.now;\n\nfunction shortOut(func) {\n  var count = 0,\n      lastCalled = 0;\n  return function () {\n    var stamp = nativeNow(),\n        remaining = HOT_SPAN - (stamp - lastCalled);\n    lastCalled = stamp;\n\n    if (remaining > 0) {\n      if (++count >= HOT_COUNT) {\n        return arguments[0];\n      }\n    } else {\n      count = 0;\n    }\n\n    return func.apply(void 0, arguments);\n  };\n}\n\nvar setToString = shortOut(baseSetToString$1);\nvar setToString$1 = setToString;\n\nfunction baseRest(func, start) {\n  return setToString$1(overRest(func, start, identity), func + \"\");\n}\n\nfunction isIterateeCall(value, index, object) {\n  if (!isObject(object)) {\n    return false;\n  }\n\n  var type = typeof index;\n\n  if (type == \"number\" ? isArrayLike(object) && isIndex(index, object.length) : type == \"string\" && index in object) {\n    return eq(object[index], value);\n  }\n\n  return false;\n}\n\nfunction createAssigner(assigner) {\n  return baseRest(function (object, sources) {\n    var index = -1,\n        length2 = sources.length,\n        customizer = length2 > 1 ? sources[length2 - 1] : void 0,\n        guard = length2 > 2 ? sources[2] : void 0;\n    customizer = assigner.length > 3 && typeof customizer == \"function\" ? (length2--, customizer) : void 0;\n\n    if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n      customizer = length2 < 3 ? void 0 : customizer;\n      length2 = 1;\n    }\n\n    object = Object(object);\n\n    while (++index < length2) {\n      var source = sources[index];\n\n      if (source) {\n        assigner(object, source, index, customizer);\n      }\n    }\n\n    return object;\n  });\n}\n\nvar merge = createAssigner(function (object, source, srcIndex) {\n  baseMerge(object, source, srcIndex);\n});\nvar merge$1 = merge;\n\nfunction getConfigDefaults() {\n  return {\n    view: {\n      scalingObjects: false,\n      panEnabled: true,\n      zoomEnabled: true,\n      minZoomLevel: 0.1,\n      maxZoomLevel: 64,\n      doubleClickZoomEnabled: true,\n      mouseWheelZoomEnabled: true,\n      boxSelectionEnabled: false,\n      autoPanAndZoomOnLoad: \"center-content\",\n      autoPanOnResize: true,\n      layoutHandler: new SimpleLayout(),\n      onSvgPanZoomInitialized: void 0,\n      grid: {\n        visible: false,\n        interval: 10,\n        thickIncrements: 5,\n        line: {\n          color: \"#e0e0e0\",\n          width: 1,\n          dasharray: 1\n        },\n        thick: {\n          color: \"#cccccc\",\n          width: 1,\n          dasharray: 0\n        }\n      },\n      selection: {\n        box: {\n          color: \"#0000ff20\",\n          strokeWidth: 1,\n          strokeColor: \"#aaaaff\",\n          strokeDasharray: 0\n        },\n        detector: event => {\n          const detect = /Mac OS/.test(navigator.userAgent) ? event.metaKey : event.ctrlKey;\n          return event.type === \"keydown\" ? detect : !detect;\n        }\n      }\n    },\n    node: withSelf(self2 => ({\n      normal: {\n        type: \"circle\",\n        radius: 16,\n        width: 32,\n        height: 32,\n        borderRadius: 4,\n        color: \"#4466cc\",\n        strokeWidth: 0,\n        strokeColor: \"#000000\",\n        strokeDasharray: 0\n      },\n      hover: {\n        type: node => Config.value(self2.normal.type, node),\n        radius: node => {\n          var _a;\n\n          return ((_a = Config.value(self2.normal.radius, node)) != null ? _a : 0) + 2;\n        },\n        width: node => {\n          var _a;\n\n          return ((_a = Config.value(self2.normal.width, node)) != null ? _a : 0) + 2;\n        },\n        height: node => {\n          var _a;\n\n          return ((_a = Config.value(self2.normal.height, node)) != null ? _a : 0) + 2;\n        },\n        borderRadius: node => {\n          var _a;\n\n          return (_a = Config.value(self2.normal.borderRadius, node)) != null ? _a : 0;\n        },\n        strokeWidth: node => Config.value(self2.normal.strokeWidth, node),\n        strokeColor: node => Config.value(self2.normal.strokeColor, node),\n        strokeDasharray: node => Config.value(self2.normal.strokeDasharray, node),\n        color: \"#3355bb\"\n      },\n      selected: void 0,\n      draggable: true,\n      selectable: false,\n      label: {\n        visible: true,\n        fontFamily: void 0,\n        fontSize: 11,\n        lineHeight: 1.1,\n        color: \"#000000\",\n        background: void 0,\n        margin: 4,\n        direction: NodeLabelDirection.SOUTH,\n        text: \"name\"\n      },\n      focusring: {\n        visible: true,\n        width: 4,\n        padding: 3,\n        color: \"#eebb00\"\n      },\n      zOrder: {\n        enabled: false,\n        zIndex: 0,\n        bringToFrontOnHover: true,\n        bringToFrontOnSelected: true\n      },\n      transition: void 0\n    })),\n    edge: withSelf(self2 => ({\n      normal: {\n        width: 2,\n        color: \"#4466cc\",\n        dasharray: 0,\n        linecap: \"butt\",\n        animate: false,\n        animationSpeed: 50\n      },\n      hover: {\n        width: edge => Config.value(self2.normal.width, edge) + 1,\n        color: \"#3355bb\",\n        dasharray: edge => Config.value(self2.normal.dasharray, edge),\n        linecap: edge => Config.value(self2.normal.linecap, edge),\n        animate: edge => Config.value(self2.normal.animate, edge),\n        animationSpeed: edge => Config.value(self2.normal.animationSpeed, edge)\n      },\n      selected: {\n        width: edge => Config.value(self2.normal.width, edge) + 1,\n        color: \"#dd8800\",\n        dasharray: edge => {\n          const w = Config.value(self2.normal.width, edge);\n          return `${w * 1.5} ${w * 2}`;\n        },\n        linecap: edge => Config.value(self2.normal.linecap, edge),\n        animate: edge => Config.value(self2.normal.animate, edge),\n        animationSpeed: edge => Config.value(self2.normal.animationSpeed, edge)\n      },\n      selectable: false,\n      gap: 3,\n      type: \"straight\",\n      marker: {\n        source: {\n          type: \"none\",\n          width: 5,\n          height: 5,\n          margin: -1,\n          units: \"strokeWidth\",\n          color: null\n        },\n        target: {\n          type: \"none\",\n          width: 5,\n          height: 5,\n          margin: -1,\n          units: \"strokeWidth\",\n          color: null\n        }\n      },\n      margin: null,\n      summarize: (_edges, configs) => {\n        return configs.edge.type == \"curve\" ? false : null;\n      },\n      summarized: {\n        label: {\n          fontSize: 10,\n          lineHeight: 1,\n          color: \"#4466cc\"\n        },\n        shape: {\n          type: \"rect\",\n          radius: 6,\n          width: 12,\n          height: 12,\n          borderRadius: 3,\n          color: \"#ffffff\",\n          strokeWidth: 1,\n          strokeColor: \"#4466cc\",\n          strokeDasharray: void 0\n        },\n        stroke: {\n          width: 5,\n          color: \"#4466cc\",\n          dasharray: void 0,\n          linecap: void 0,\n          animate: false,\n          animationSpeed: 50\n        }\n      },\n      keepOrder: \"clock\",\n      label: {\n        fontFamily: void 0,\n        fontSize: 11,\n        lineHeight: 1.1,\n        color: \"#000000\",\n        background: void 0,\n        margin: 4,\n        padding: 4\n      },\n      zOrder: {\n        enabled: false,\n        zIndex: 0,\n        bringToFrontOnHover: true,\n        bringToFrontOnSelected: true\n      }\n    })),\n    path: withSelf(self2 => ({\n      visible: false,\n      clickable: false,\n      hoverable: false,\n      curveInNode: false,\n      end: \"centerOfNode\",\n      margin: 0,\n      path: reactive({\n        width: 6,\n        color: p => {\n          const list = [\"#d5000088\", \"#c5116288\", \"#aa00ff88\", \"#6200ea88\", \"#304ffe88\", \"#2962ff88\", \"#0091ea88\", \"#00b8d488\", \"#00bfa588\", \"#00c85388\", \"#64dd1788\", \"#aeea0088\", \"#ffd60088\", \"#ffab0088\", \"#ff6d0088\", \"#dd2c0088\"];\n          const hash = p.edges.map(s => s.split(\"\").reduce((a, b) => {\n            a = (a << 5) - a + b.charCodeAt(0);\n            return a & a;\n          }, 0)).reduce((a, b) => a + b, 0);\n          return list[Math.abs(hash) % list.length];\n        },\n        dasharray: void 0,\n        linecap: \"round\",\n        linejoin: \"round\",\n        animate: false,\n        animationSpeed: 50\n      }),\n      normal: {\n        width: path => Config.value(self2.path.width, path),\n        color: path => Config.value(self2.path.color, path),\n        dasharray: path => Config.value(self2.path.dasharray, path),\n        linecap: path => Config.value(self2.path.linecap, path),\n        linejoin: path => Config.value(self2.path.linejoin, path),\n        animate: path => Config.value(self2.path.animate, path),\n        animationSpeed: path => Config.value(self2.path.animationSpeed, path)\n      },\n      hover: {\n        width: path => Config.value(self2.normal.width, path) + 2,\n        color: path => Config.value(self2.normal.color, path),\n        dasharray: path => Config.value(self2.normal.dasharray, path),\n        linecap: path => Config.value(self2.normal.linecap, path),\n        linejoin: path => Config.value(self2.normal.linejoin, path),\n        animate: path => Config.value(self2.normal.animate, path),\n        animationSpeed: path => Config.value(self2.normal.animationSpeed, path)\n      },\n      selected: {\n        width: path => Config.value(self2.normal.width, path) + 2,\n        color: path => Config.value(self2.normal.color, path),\n        dasharray: \"6 12\",\n        linecap: path => Config.value(self2.normal.linecap, path),\n        linejoin: path => Config.value(self2.normal.linejoin, path),\n        animate: path => Config.value(self2.normal.animate, path),\n        animationSpeed: path => Config.value(self2.normal.animationSpeed, path)\n      },\n      selectable: false,\n      zOrder: {\n        enabled: false,\n        zIndex: 0,\n        bringToFrontOnHover: true,\n        bringToFrontOnSelected: true\n      },\n      transition: void 0\n    }))\n  };\n}\n\nfunction getFullConfigs(config) {\n  const configs = getConfigDefaults();\n\n  if (config) {\n    merge$1(configs, config);\n  }\n\n  return configs;\n}\n\nconst injectionKey = Symbol(\"style\");\n\nfunction provideConfigs(configs) {\n  const results = reactive(getConfigDefaults());\n  const styleKeys = Object.keys(results);\n\n  for (const key of styleKeys) {\n    watch(() => configs.value[key], () => {\n      merge$1(results[key], configs.value[key] || {});\n    }, {\n      immediate: true,\n      deep: true\n    });\n  }\n\n  provide(injectionKey, results);\n  return results;\n}\n\nfunction injectConfig(key) {\n  return nonNull(inject(injectionKey), `Configs(${key})`)[key];\n}\n\nfunction useViewConfig() {\n  return injectConfig(\"view\");\n}\n\nfunction useNodeConfig() {\n  return injectConfig(\"node\");\n}\n\nfunction useEdgeConfig() {\n  return injectConfig(\"edge\");\n}\n\nfunction usePathConfig() {\n  return injectConfig(\"path\");\n}\n\nlet nextId = 1;\n\nfunction useId() {\n  return nextId++;\n}\n\nvar HASH_UNDEFINED = \"__lodash_hash_undefined__\";\n\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n\n  return this;\n}\n\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\nfunction SetCache(values) {\n  var index = -1,\n      length2 = values == null ? 0 : values.length;\n  this.__data__ = new MapCache();\n\n  while (++index < length2) {\n    this.add(values[index]);\n  }\n}\n\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\n\nfunction arraySome(array, predicate) {\n  var index = -1,\n      length2 = array == null ? 0 : array.length;\n\n  while (++index < length2) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction cacheHas(cache, key) {\n  return cache.has(key);\n}\n\nvar COMPARE_PARTIAL_FLAG$3 = 1,\n    COMPARE_UNORDERED_FLAG$1 = 2;\n\nfunction equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n    return false;\n  }\n\n  var arrStacked = stack.get(array);\n  var othStacked = stack.get(other);\n\n  if (arrStacked && othStacked) {\n    return arrStacked == other && othStacked == array;\n  }\n\n  var index = -1,\n      result = true,\n      seen = bitmask & COMPARE_UNORDERED_FLAG$1 ? new SetCache() : void 0;\n  stack.set(array, other);\n  stack.set(other, array);\n\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index];\n\n    if (customizer) {\n      var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);\n    }\n\n    if (compared !== void 0) {\n      if (compared) {\n        continue;\n      }\n\n      result = false;\n      break;\n    }\n\n    if (seen) {\n      if (!arraySome(other, function (othValue2, othIndex) {\n        if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {\n          return seen.push(othIndex);\n        }\n      })) {\n        result = false;\n        break;\n      }\n    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n      result = false;\n      break;\n    }\n  }\n\n  stack[\"delete\"](array);\n  stack[\"delete\"](other);\n  return result;\n}\n\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n  map.forEach(function (value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n  set.forEach(function (value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\nvar COMPARE_PARTIAL_FLAG$2 = 1,\n    COMPARE_UNORDERED_FLAG = 2;\nvar boolTag = \"[object Boolean]\",\n    dateTag = \"[object Date]\",\n    errorTag = \"[object Error]\",\n    mapTag$1 = \"[object Map]\",\n    numberTag = \"[object Number]\",\n    regexpTag = \"[object RegExp]\",\n    setTag$1 = \"[object Set]\",\n    stringTag = \"[object String]\",\n    symbolTag = \"[object Symbol]\";\nvar arrayBufferTag = \"[object ArrayBuffer]\",\n    dataViewTag$1 = \"[object DataView]\";\nvar symbolProto = Symbol$2 ? Symbol$2.prototype : void 0,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;\n\nfunction equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n  switch (tag) {\n    case dataViewTag$1:\n      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {\n        return false;\n      }\n\n      object = object.buffer;\n      other = other.buffer;\n\n    case arrayBufferTag:\n      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array$1(object), new Uint8Array$1(other))) {\n        return false;\n      }\n\n      return true;\n\n    case boolTag:\n    case dateTag:\n    case numberTag:\n      return eq(+object, +other);\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case regexpTag:\n    case stringTag:\n      return object == other + \"\";\n\n    case mapTag$1:\n      var convert = mapToArray;\n\n    case setTag$1:\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2;\n      convert || (convert = setToArray);\n\n      if (object.size != other.size && !isPartial) {\n        return false;\n      }\n\n      var stacked = stack.get(object);\n\n      if (stacked) {\n        return stacked == other;\n      }\n\n      bitmask |= COMPARE_UNORDERED_FLAG;\n      stack.set(object, other);\n      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n      stack[\"delete\"](object);\n      return result;\n\n    case symbolTag:\n      if (symbolValueOf) {\n        return symbolValueOf.call(object) == symbolValueOf.call(other);\n      }\n\n  }\n\n  return false;\n}\n\nfunction arrayPush(array, values) {\n  var index = -1,\n      length2 = values.length,\n      offset = array.length;\n\n  while (++index < length2) {\n    array[offset + index] = values[index];\n  }\n\n  return array;\n}\n\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray$1(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\nfunction arrayFilter(array, predicate) {\n  var index = -1,\n      length2 = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length2) {\n    var value = array[index];\n\n    if (predicate(value, index, array)) {\n      result[resIndex++] = value;\n    }\n  }\n\n  return result;\n}\n\nfunction stubArray() {\n  return [];\n}\n\nvar objectProto$3 = Object.prototype;\nvar propertyIsEnumerable = objectProto$3.propertyIsEnumerable;\nvar nativeGetSymbols = Object.getOwnPropertySymbols;\nvar getSymbols = !nativeGetSymbols ? stubArray : function (object) {\n  if (object == null) {\n    return [];\n  }\n\n  object = Object(object);\n  return arrayFilter(nativeGetSymbols(object), function (symbol) {\n    return propertyIsEnumerable.call(object, symbol);\n  });\n};\nvar getSymbols$1 = getSymbols;\nvar nativeKeys = overArg(Object.keys, Object);\nvar nativeKeys$1 = nativeKeys;\nvar objectProto$2 = Object.prototype;\nvar hasOwnProperty$2 = objectProto$2.hasOwnProperty;\n\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys$1(object);\n  }\n\n  var result = [];\n\n  for (var key in Object(object)) {\n    if (hasOwnProperty$2.call(object, key) && key != \"constructor\") {\n      result.push(key);\n    }\n  }\n\n  return result;\n}\n\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols$1);\n}\n\nvar COMPARE_PARTIAL_FLAG$1 = 1;\nvar objectProto$1 = Object.prototype;\nvar hasOwnProperty$1 = objectProto$1.hasOwnProperty;\n\nfunction equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1,\n      objProps = getAllKeys(object),\n      objLength = objProps.length,\n      othProps = getAllKeys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isPartial) {\n    return false;\n  }\n\n  var index = objLength;\n\n  while (index--) {\n    var key = objProps[index];\n\n    if (!(isPartial ? key in other : hasOwnProperty$1.call(other, key))) {\n      return false;\n    }\n  }\n\n  var objStacked = stack.get(object);\n  var othStacked = stack.get(other);\n\n  if (objStacked && othStacked) {\n    return objStacked == other && othStacked == object;\n  }\n\n  var result = true;\n  stack.set(object, other);\n  stack.set(other, object);\n  var skipCtor = isPartial;\n\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key];\n\n    if (customizer) {\n      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);\n    }\n\n    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {\n      result = false;\n      break;\n    }\n\n    skipCtor || (skipCtor = key == \"constructor\");\n  }\n\n  if (result && !skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    if (objCtor != othCtor && \"constructor\" in object && \"constructor\" in other && !(typeof objCtor == \"function\" && objCtor instanceof objCtor && typeof othCtor == \"function\" && othCtor instanceof othCtor)) {\n      result = false;\n    }\n  }\n\n  stack[\"delete\"](object);\n  stack[\"delete\"](other);\n  return result;\n}\n\nvar DataView = getNative(root$1, \"DataView\");\nvar DataView$1 = DataView;\nvar Promise$1 = getNative(root$1, \"Promise\");\nvar Promise$2 = Promise$1;\nvar Set$1 = getNative(root$1, \"Set\");\nvar Set$2 = Set$1;\nvar WeakMap = getNative(root$1, \"WeakMap\");\nvar WeakMap$1 = WeakMap;\nvar mapTag = \"[object Map]\",\n    objectTag$1 = \"[object Object]\",\n    promiseTag = \"[object Promise]\",\n    setTag = \"[object Set]\",\n    weakMapTag = \"[object WeakMap]\";\nvar dataViewTag = \"[object DataView]\";\nvar dataViewCtorString = toSource(DataView$1),\n    mapCtorString = toSource(Map$2),\n    promiseCtorString = toSource(Promise$2),\n    setCtorString = toSource(Set$2),\n    weakMapCtorString = toSource(WeakMap$1);\nvar getTag = baseGetTag;\n\nif (DataView$1 && getTag(new DataView$1(new ArrayBuffer(1))) != dataViewTag || Map$2 && getTag(new Map$2()) != mapTag || Promise$2 && getTag(Promise$2.resolve()) != promiseTag || Set$2 && getTag(new Set$2()) != setTag || WeakMap$1 && getTag(new WeakMap$1()) != weakMapTag) {\n  getTag = function (value) {\n    var result = baseGetTag(value),\n        Ctor = result == objectTag$1 ? value.constructor : void 0,\n        ctorString = Ctor ? toSource(Ctor) : \"\";\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString:\n          return dataViewTag;\n\n        case mapCtorString:\n          return mapTag;\n\n        case promiseCtorString:\n          return promiseTag;\n\n        case setCtorString:\n          return setTag;\n\n        case weakMapCtorString:\n          return weakMapTag;\n      }\n    }\n\n    return result;\n  };\n}\n\nvar getTag$1 = getTag;\nvar COMPARE_PARTIAL_FLAG = 1;\nvar argsTag = \"[object Arguments]\",\n    arrayTag = \"[object Array]\",\n    objectTag = \"[object Object]\";\nvar objectProto = Object.prototype;\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\nfunction baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n  var objIsArr = isArray$1(object),\n      othIsArr = isArray$1(other),\n      objTag = objIsArr ? arrayTag : getTag$1(object),\n      othTag = othIsArr ? arrayTag : getTag$1(other);\n  objTag = objTag == argsTag ? objectTag : objTag;\n  othTag = othTag == argsTag ? objectTag : othTag;\n  var objIsObj = objTag == objectTag,\n      othIsObj = othTag == objectTag,\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && isBuffer$1(object)) {\n    if (!isBuffer$1(other)) {\n      return false;\n    }\n\n    objIsArr = true;\n    objIsObj = false;\n  }\n\n  if (isSameTag && !objIsObj) {\n    stack || (stack = new Stack());\n    return objIsArr || isTypedArray$1(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n  }\n\n  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, \"__wrapped__\"),\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, \"__wrapped__\");\n\n    if (objIsWrapped || othIsWrapped) {\n      var objUnwrapped = objIsWrapped ? object.value() : object,\n          othUnwrapped = othIsWrapped ? other.value() : other;\n      stack || (stack = new Stack());\n      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n    }\n  }\n\n  if (!isSameTag) {\n    return false;\n  }\n\n  stack || (stack = new Stack());\n  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n}\n\nfunction baseIsEqual(value, other, bitmask, customizer, stack) {\n  if (value === other) {\n    return true;\n  }\n\n  if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {\n    return value !== value && other !== other;\n  }\n\n  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n}\n\nfunction isEqual(value, other) {\n  return baseIsEqual(value, other);\n}\n\nfunction entriesOf(obj) {\n  return Object.entries(obj);\n}\n\nfunction updateObjectDiff(target, from) {\n  const keys2 = new Set(Object.keys(target));\n  entriesOf(from).forEach(([key, value]) => {\n    if (!isEqual(target[key], value)) {\n      target[key] = value;\n    }\n\n    keys2.delete(key);\n  });\n  keys2.forEach(k => delete target[k]);\n}\n\nfunction makeEdgeGroupStates(nodes, edges, configs) {\n  const state = Reactive({\n    edgeLayoutPoints: {},\n    edgeGroups: {},\n    summarizedEdges: {}\n  });\n  watchEffect(() => {\n    const {\n      edgeLayoutPoints,\n      edgeGroups\n    } = calculateEdgeGroupAndPositions(configs, nodes.value, edges.value);\n    updateObjectDiff(state.edgeLayoutPoints, edgeLayoutPoints);\n    updateObjectDiff(state.edgeGroups, edgeGroups);\n  });\n  watchEffect(() => {\n    const summarizedEdges = {};\n\n    for (const [id, {\n      edges: edges2,\n      groupWidth\n    }] of Object.entries(state.edgeGroups)) {\n      let summarize = false;\n\n      if (groupWidth == 0) {\n        summarize = false;\n      } else if (configs.edge.summarize instanceof Function) {\n        const s = configs.edge.summarize(edges2, configs);\n\n        if (s === null) {\n          summarize = defaultCheckSummarize(nodes.value, edges2, configs, groupWidth);\n        } else {\n          summarize = s;\n        }\n      } else if (configs.edge.summarize) {\n        summarize = defaultCheckSummarize(nodes.value, edges2, configs, groupWidth);\n      } else {\n        summarize = false;\n      }\n\n      state.edgeGroups[id].summarize = summarize;\n\n      if (summarize) {\n        Object.keys(edges2).forEach(id2 => summarizedEdges[id2] = true);\n      }\n    }\n\n    updateObjectDiff(state.summarizedEdges, summarizedEdges);\n  });\n  return state;\n}\n\nfunction calculateEdgeShiftedPosition(p, isSummarized, source, target, scale, keepOrder) {\n  if (!p) {\n    return {\n      p1: {\n        x: 0,\n        y: 0\n      },\n      p2: {\n        x: 0,\n        y: 0\n      }\n    };\n  }\n\n  if (isSummarized) {\n    return calculateEdgePositionInner(p.edge, source, target, scale, 0, 0, keepOrder);\n  } else {\n    return calculateEdgePositionInner(p.edge, source, target, scale, p.groupWidth, p.pointInGroup, keepOrder);\n  }\n}\n\nfunction calculateEdgeGroupAndPositions(configs, nodes, edges) {\n  const edgeLayoutPoints = {};\n  const edgeGroups = {};\n  const map = {};\n\n  for (const [id, edge] of Object.entries(edges)) {\n    if (!(edge.source in nodes && edge.target in nodes)) {\n      continue;\n    }\n\n    const key = [edge.source, edge.target].sort().join(\"<=>\");\n    const values = map[key] || {};\n    values[id] = edge;\n    map[key] = values;\n  }\n\n  const calcGap = configs.edge.gap instanceof Function ? configs.edge.gap : (_e, _c) => configs.edge.gap;\n\n  for (const [key, edges2] of Object.entries(map)) {\n    const edgeLen = Object.keys(edges2).length;\n    if (edgeLen == 0) continue;\n    const gap = calcGap(edges2, configs);\n    const [edgeId, edge] = Object.entries(edges2)[0];\n\n    if (edgeLen === 1) {\n      edgeLayoutPoints[edgeId] = {\n        edge,\n        pointInGroup: 0,\n        groupWidth: 0\n      };\n      edgeGroups[key] = {\n        edges: edges2,\n        groupWidth: 0,\n        summarize: false\n      };\n    } else {\n      let pointInGroup = 0;\n      const lineHalfWidths = Object.entries(edges2).map(([id, edge2]) => {\n        let width = Config.value(configs.edge.normal.width, edge2);\n\n        if (isNaN(+width)) {\n          console.warn(\"[v-network-graph] Edge width is invalid value. id=[%s] value=[%s]\", id, width);\n          width = 1;\n        }\n\n        return width / 2;\n      });\n      const points = Object.entries(edges2).map(([edgeId2, edge2], i) => {\n        if (i > 0) {\n          pointInGroup += lineHalfWidths[i - 1] + gap + lineHalfWidths[i];\n        }\n\n        return [edgeId2, edge2, pointInGroup];\n      });\n      const groupWidth = pointInGroup;\n      points.forEach(([edgeId2, edge2, pointInGroup2]) => {\n        edgeLayoutPoints[edgeId2] = {\n          edge: edge2,\n          pointInGroup: pointInGroup2,\n          groupWidth\n        };\n      });\n      edgeGroups[key] = {\n        edges: edges2,\n        groupWidth,\n        summarize: false\n      };\n    }\n  }\n\n  return {\n    edgeLayoutPoints,\n    edgeGroups\n  };\n}\n\nfunction defaultCheckSummarize(nodes, edges, configs, width) {\n  const edgeCount = Object.entries(edges).length;\n  if (edgeCount === 1) return false;\n  const minWidth = Math.min(...Object.values(edges).flatMap(e => [nodes[e.source], nodes[e.target]]).filter(v => v).map(node => {\n    const shape = Config.values(configs.node.normal, node);\n\n    if (shape.type === \"circle\") {\n      return shape.radius * 2;\n    } else {\n      return Math.min(shape.width, shape.height);\n    }\n  }));\n  return width > minWidth;\n}\n\nfunction calculateEdgePositionInner(edge, source, target, scale, groupWidth, pointInGroup, keepOrder) {\n  var _a, _b, _c, _d, _e, _f, _g, _h;\n\n  let x1, y1, x2, y2;\n\n  if (edge.source < edge.target) {\n    [x1, y1, x2, y2] = calculateLinePosition((_a = source == null ? void 0 : source.x) != null ? _a : 0, (_b = source == null ? void 0 : source.y) != null ? _b : 0, (_c = target == null ? void 0 : target.x) != null ? _c : 0, (_d = target == null ? void 0 : target.y) != null ? _d : 0, scale, groupWidth, pointInGroup, keepOrder);\n  } else {\n    [x2, y2, x1, y1] = calculateLinePosition((_e = target == null ? void 0 : target.x) != null ? _e : 0, (_f = target == null ? void 0 : target.y) != null ? _f : 0, (_g = source == null ? void 0 : source.x) != null ? _g : 0, (_h = source == null ? void 0 : source.y) != null ? _h : 0, scale, groupWidth, pointInGroup, keepOrder);\n  }\n\n  return {\n    p1: {\n      x: x1,\n      y: y1\n    },\n    p2: {\n      x: x2,\n      y: y2\n    }\n  };\n}\n\nfunction calculateLinePosition(x1, y1, x2, y2, scale, groupWidth, pointInGroup, keepOrder) {\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  let diff = (groupWidth / 2 - pointInGroup) * scale;\n\n  if (diff !== 0 && keepOrder !== \"clock\") {\n    const radian = Math.atan2(y2 - y1, x2 - x1);\n\n    if (keepOrder === \"vertical\") {\n      const perpendicular = Math.PI / 2;\n\n      if (radian < -perpendicular || radian >= perpendicular) {\n        diff *= -1;\n      }\n    } else if (keepOrder === \"horizontal\") {\n      if (radian < 0) {\n        diff *= -1;\n      }\n    }\n  }\n\n  if (dx === 0) {\n    const sign = dy < 0 ? -1 : 1;\n    return [x1 + diff * sign, y1, x2 + diff * sign, y2];\n  } else if (dy === 0) {\n    const sign = dx < 0 ? 1 : -1;\n    return [x1, y1 + diff * sign, x2, y2 + diff * sign];\n  } else {\n    const slope = dy / dx;\n    const moveSlope = -1 / slope;\n\n    if (dy < 0) {\n      diff = -diff;\n    }\n\n    const diffX = diff / Math.sqrt(1 + Math.pow(moveSlope, 2));\n    return [x1 + diffX, y1 + diffX * moveSlope, x2 + diffX, y2 + diffX * moveSlope];\n  }\n}\n\nfunction add(v1, v2, target) {\n  if (!target) {\n    target = {\n      x: 0,\n      y: 0\n    };\n  }\n\n  target.x = v1.x + v2.x;\n  target.y = v1.y + v2.y;\n  return target;\n}\n\nfunction subtract(v1, v2, target) {\n  if (!target) {\n    target = {\n      x: 0,\n      y: 0\n    };\n  }\n\n  target.x = v1.x - v2.x;\n  target.y = v1.y - v2.y;\n  return target;\n}\n\nfunction multiply(v1, v2, target) {\n  if (!target) {\n    target = {\n      x: 0,\n      y: 0\n    };\n  }\n\n  target.x = v1.x * v2.x;\n  target.y = v1.y * v2.y;\n  return target;\n}\n\nfunction multiplyScalar(v, scalar, target) {\n  if (!target) {\n    target = {\n      x: 0,\n      y: 0\n    };\n  }\n\n  target.x = v.x * scalar;\n  target.y = v.y * scalar;\n  return target;\n}\n\nfunction divide(v1, v2, target) {\n  if (!target) {\n    target = {\n      x: 0,\n      y: 0\n    };\n  }\n\n  target.x = v1.x / v2.x;\n  target.y = v1.y / v2.y;\n  return target;\n}\n\nfunction dot(v1, v2) {\n  return v1.x * v2.x + v1.y * v2.y;\n}\n\nfunction cross(v1, v2) {\n  return v1.x * v2.y - v1.y * v2.x;\n}\n\nfunction lengthSquared(v) {\n  return v.x * v.x + v.y * v.y;\n}\n\nfunction length(v) {\n  return Math.sqrt(lengthSquared(v));\n}\n\nfunction distanceSquared(v1, v2) {\n  const dx = v1.x - v2.x;\n  const dy = v1.y - v2.y;\n  return dx * dx + dy * dy;\n}\n\nfunction distance(v1, v2) {\n  return Math.sqrt(distanceSquared(v1, v2));\n}\n\nfunction normalize(v, target) {\n  if (!target) {\n    target = {\n      x: 0,\n      y: 0\n    };\n  }\n\n  const len = length(v);\n\n  if (len === 0) {\n    target.x = 1;\n    target.y = 0;\n  } else {\n    divide(v, {\n      x: len,\n      y: len\n    }, target);\n  }\n\n  return target;\n}\n\nfunction rotate(v, angle2, target) {\n  if (!target) {\n    target = {\n      x: 0,\n      y: 0\n    };\n  }\n\n  const newX = v.x * Math.cos(angle2) - v.y * Math.sin(angle2);\n  const newY = v.x * Math.sin(angle2) + v.y * Math.cos(angle2);\n  target.x = newX;\n  target.y = newY;\n  return target;\n}\n\nconst DEGREES = 180 / Math.PI;\n\nfunction rad2deg(rad) {\n  return rad * DEGREES;\n}\n\nfunction angle(v) {\n  return Math.atan2(v.y, v.x);\n}\n\nfunction angleDegree(v) {\n  return rad2deg(angle(v));\n}\n\nvar V$1 = /* @__PURE__ */Object.freeze({\n  __proto__: null,\n  [Symbol.toStringTag]: \"Module\",\n  add,\n  subtract,\n  multiply,\n  multiplyScalar,\n  divide,\n  dot,\n  cross,\n  lengthSquared,\n  length,\n  distanceSquared,\n  distance,\n  normalize,\n  rotate,\n  angle,\n  angleDegree\n});\n\nclass Vector2D {\n  static fromArray(array) {\n    return new Vector2D(array[0] || 0, array[1] || 0);\n  }\n\n  static fromObject(obj) {\n    return new Vector2D(obj.x, obj.y);\n  }\n\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  add(v) {\n    return add(this, v, this);\n  }\n\n  subtract(v) {\n    return subtract(this, v, this);\n  }\n\n  multiply(v) {\n    return multiply(this, v, this);\n  }\n\n  multiplyScalar(scalar) {\n    return multiplyScalar(this, scalar, this);\n  }\n\n  divide(v) {\n    return divide(this, v, this);\n  }\n\n  dot(v) {\n    return dot(this, v);\n  }\n\n  cross(v) {\n    return cross(this, v);\n  }\n\n  lengthSquared() {\n    return lengthSquared(this);\n  }\n\n  length() {\n    return length(this);\n  }\n\n  distanceSquared(v) {\n    return distanceSquared(this, v);\n  }\n\n  distance(v) {\n    return distance(this, v);\n  }\n\n  normalize() {\n    return normalize(this, this);\n  }\n\n  angle() {\n    return angle(this);\n  }\n\n  angleDegree() {\n    return angleDegree(this);\n  }\n\n  rotate(angle2) {\n    return rotate(this, angle2, this);\n  }\n\n  isEqualTo(v) {\n    return this.x === v.x && this.y === v.y;\n  }\n\n  clone() {\n    return new Vector2D(this.x, this.y);\n  }\n\n  toObject() {\n    return {\n      x: this.x,\n      y: this.y\n    };\n  }\n\n  toArray() {\n    return [this.x, this.y];\n  }\n\n}\n\nvar V = __spreadValues({\n  Vector2D\n}, V$1);\n\nclass VectorLine {\n  constructor(source, target, v) {\n    this.source = source;\n    this.target = target;\n    this.v = v;\n  }\n\n  static fromLinePosition(line) {\n    const source = Vector2D.fromObject(line.p1);\n    const target = Vector2D.fromObject(line.p2);\n    return new VectorLine(source, target, toLineVector(source, target));\n  }\n\n  static fromPositions(sourcePos, targetPos) {\n    const source = Vector2D.fromObject(sourcePos);\n    const target = Vector2D.fromObject(targetPos);\n    return new VectorLine(source, target, toLineVector(source, target));\n  }\n\n  static fromVectors(source, target) {\n    return new VectorLine(source, target, toLineVector(source, target));\n  }\n\n}\n\nfunction toLineVector(source, target) {\n  return target.clone().subtract(source);\n}\n\nfunction toVectorsFromLinePosition(line) {\n  return [Vector2D.fromObject(line.p1), Vector2D.fromObject(line.p2)];\n}\n\nfunction getCenterOfLinePosition(line) {\n  return new Vector2D((line.p1.x + line.p2.x) / 2, (line.p1.y + line.p2.y) / 2);\n}\n\nfunction toLinePosition(p1, p2) {\n  return {\n    p1,\n    p2\n  };\n}\n\nfunction applyMargin(linePos, sourceMargin, targetMargin) {\n  const line = VectorLine.fromLinePosition(linePos);\n  return applyMarginInner(line, sourceMargin, targetMargin);\n}\n\nfunction applyMarginInner(line, sourceMargin, targetMargin) {\n  const normalized = line.v.clone().normalize();\n  const sv = line.source.clone().add(normalized.clone().multiplyScalar(sourceMargin));\n  const tv = line.target.clone().subtract(normalized.clone().multiplyScalar(targetMargin));\n  let p1 = sv.toObject();\n  let p2 = tv.toObject();\n  const check = toLineVector(sv, tv);\n\n  if (line.v.angle() * check.angle() < 0) {\n    const c1 = new Vector2D((p1.x + p2.x) / 2, (p1.y + p2.y) / 2);\n    const c2 = c1.clone().add(normalized.multiplyScalar(0.5));\n    p1 = c1.toObject();\n    p2 = c2.toObject();\n  }\n\n  return {\n    p1,\n    p2\n  };\n}\n\nfunction inverseLine(line) {\n  return {\n    p1: line.p2,\n    p2: line.p1\n  };\n}\n\nfunction calculatePerpendicularLine(line) {\n  const n1 = line.v.clone().normalize().rotate(Math.PI / 2);\n  return VectorLine.fromVectors(line.target, line.target.clone().add(n1));\n}\n\nfunction getNearestPoint(p, line) {\n  const n = line.v.clone().normalize();\n  const lp = line.source;\n  const a = V.subtract(p, lp);\n  const dot2 = n.dot(a);\n  const near = lp.clone().add(n.multiplyScalar(dot2));\n  return near;\n}\n\nfunction getIntersectionOfLineTargetAndCircle(source, target, center, radius) {\n  const length2 = V.lengthSquared(V.subtract(target, center));\n  const contains = length2 - radius * radius <= Math.pow(1, -10);\n  if (!contains) return null;\n  const line = VectorLine.fromVectors(source, target);\n  const h = getNearestPoint(center, line);\n  const hpLen = V.length(V.subtract(h, center));\n  if (radius < hpLen) return null;\n  if (radius === hpLen) return h;\n  const t = Math.sqrt(__pow(radius, 2) - __pow(hpLen, 2));\n  const tv = line.v.normalize().multiplyScalar(t);\n  return h.subtract(tv);\n}\n\nfunction getIntersectionOfLineTargetAndCircle2(source, target, center, radius, nearBy) {\n  const length2 = V.lengthSquared(V.subtract(target, center));\n  const contains = length2 - radius * radius <= Math.pow(1, -10);\n  if (!contains) return null;\n  const line = VectorLine.fromVectors(source, target);\n  const h = getNearestPoint(center, line);\n  const hpLen = V.length(V.subtract(h, center));\n  if (radius < hpLen) return null;\n  if (radius === hpLen) return h;\n  const t = Math.sqrt(__pow(radius, 2) - __pow(hpLen, 2));\n  const tv = line.v.normalize().multiplyScalar(t);\n  const ip1 = h.clone().add(tv);\n  const ip2 = h.clone().subtract(tv);\n  const d1 = nearBy.distance(ip1);\n  const d2 = nearBy.distance(ip2);\n\n  if (Math.abs(d1 - d2) < 2) {\n    return ip2;\n  }\n\n  return d1 < d2 ? ip1 : ip2;\n}\n\nfunction getIntersectionPointOfLines(line1, line2) {\n  const v = V.subtract(line2.source, line1.source);\n  const v1 = line1.v;\n  const v2 = line2.v;\n  const t2 = V.cross(v, v1) / V.cross(v1, v2);\n  return line2.source.clone().add(v2.clone().multiplyScalar(t2));\n}\n\nfunction getIntersectionOfCircles(center1, radius1, center2, radius2, near) {\n  const c1 = center1;\n  const c2 = center2;\n  const vC1C2 = c2.clone().subtract(c1);\n  const a = vC1C2.length();\n  const sumR = radius1 + radius2;\n  if (sumR < a) return null;\n  const subR = Math.abs(radius1 - radius2);\n  if (a < subR) return null;\n\n  if (a === sumR) {\n    const n = vC1C2.clone().normalize();\n    const p = center1.clone().add(n.multiplyScalar(radius1));\n    return p;\n  }\n\n  if (a === subR) {\n    const n = vC1C2.clone().normalize();\n    const isLarge = radius1 > radius2;\n    const p = center1.clone().add(n.multiplyScalar(isLarge ? radius1 : -radius1));\n    return p;\n  }\n\n  const b = radius1;\n  const c = radius2;\n  const cos = (__pow(a, 2) + __pow(b, 2) - __pow(c, 2)) / (2 * a * b);\n  const rc = b * cos;\n  const rs = Math.sqrt(__pow(b, 2) - __pow(rc, 2));\n  const n1 = vC1C2.clone().normalize();\n  const n2 = new Vector2D(-n1.y, n1.x);\n  const tn1 = n1.clone().multiplyScalar(rc);\n  const sn2 = n2.clone().multiplyScalar(rs);\n  const result1 = center1.clone().add(tn1).add(sn2);\n  const result2 = center1.clone().add(tn1).subtract(sn2);\n  const d1 = result1.distance(near);\n  const d2 = result2.distance(near);\n  return d1 < d2 ? result1 : result2;\n}\n\nfunction calculateDistanceToAvoidOverlapsWithRect(sourcePos, targetPos, rect, scale) {\n  const centerLine = VectorLine.fromPositions(sourcePos, targetPos);\n  const halfWidth = (rect.width + rect.strokeWidth) / 2 * scale;\n  const halfHeight = (rect.height + rect.strokeWidth) / 2 * scale;\n  const borderRadius = rect.borderRadius > 0 ? (rect.borderRadius + rect.strokeWidth / 2) * scale : 0;\n  const angleVRad = (centerLine.v.angle() - Math.PI / 2) % Math.PI;\n  const angleHRad = Math.PI / 2 - angleVRad % Math.PI;\n  const w = halfHeight * Math.abs(Math.tan(angleVRad));\n  const h = halfWidth * Math.abs(Math.tan(angleHRad));\n  const isCrossedVLine = w <= halfWidth - borderRadius;\n  const isCrossedHLine = h <= halfHeight - borderRadius;\n\n  if (isCrossedVLine || isCrossedHLine || borderRadius === 0) {\n    if (isCrossedVLine) {\n      return Math.sqrt(__pow(halfHeight, 2) + __pow(w, 2));\n    } else {\n      return Math.sqrt(__pow(halfWidth, 2) + __pow(h, 2));\n    }\n  } else {\n    const left = targetPos.x - halfWidth + borderRadius;\n    const top = targetPos.y - halfHeight + borderRadius;\n    const right = targetPos.x + halfWidth - borderRadius;\n    const bottom = targetPos.y + halfHeight - borderRadius;\n    const vertexes = [new Vector2D(left, top), new Vector2D(right, top), new Vector2D(right, bottom), new Vector2D(left, bottom)];\n    const index = Math.floor((centerLine.v.angleDegree() + 360) % 360 / 90);\n    const centerOfNearestCircle = vertexes[index];\n    const point = getIntersectionOfLineTargetAndCircle(centerLine.source, getNearestPoint(centerOfNearestCircle, centerLine), centerOfNearestCircle, borderRadius);\n    return point ? toLineVector(point, centerLine.target).length() : toLineVector(centerOfNearestCircle, centerLine.target).length() + borderRadius;\n  }\n}\n\nfunction calculateEdgeLabelArea(linePos, edgeStyle, margin, padding, scale) {\n  const line = VectorLine.fromLinePosition(linePos);\n  const normalized = line.v.clone().normalize();\n  const sv = padding === 0 ? line.source : line.source.clone().add(normalized.clone().multiplyScalar(padding * scale));\n  const tv = padding === 0 ? line.target : line.target.clone().subtract(normalized.clone().multiplyScalar(padding * scale));\n  const labelMargin = (edgeStyle.width / 2 + margin) * scale;\n  const vMargin = new Vector2D(-normalized.y, normalized.x).multiplyScalar(labelMargin);\n  let sourceAbove = V.subtract(sv, vMargin);\n  let sourceBelow = V.add(sv, vMargin);\n  let targetAbove = V.subtract(tv, vMargin);\n  let targetBelow = V.add(tv, vMargin);\n  const angle2 = line.v.angleDegree();\n\n  if (angle2 < -90 || angle2 >= 90) {\n    [sourceAbove, sourceBelow] = [sourceBelow, sourceAbove];\n    [targetAbove, targetBelow] = [targetBelow, targetAbove];\n  }\n\n  return {\n    source: {\n      above: sourceAbove,\n      below: sourceBelow\n    },\n    target: {\n      above: targetAbove,\n      below: targetBelow\n    }\n  };\n}\n\nfunction calculateDistancesFromCenterOfNodeToEndOfNode(sourceNodePos, targetNodePos, sourceNodeShape, targetNodeShape) {\n  let distance1;\n\n  if (sourceNodeShape.type === \"circle\") {\n    distance1 = sourceNodeShape.radius + sourceNodeShape.strokeWidth / 2;\n  } else {\n    distance1 = calculateDistanceToAvoidOverlapsWithRect(targetNodePos, sourceNodePos, sourceNodeShape, 1);\n  }\n\n  let distance2;\n\n  if (targetNodeShape.type === \"circle\") {\n    distance2 = targetNodeShape.radius + targetNodeShape.strokeWidth / 2;\n  } else {\n    distance2 = calculateDistanceToAvoidOverlapsWithRect(sourceNodePos, targetNodePos, targetNodeShape, 1);\n  }\n\n  return [distance1, distance2];\n}\n\nfunction moveOnCircumference(pos, center, radian) {\n  const {\n    x,\n    y\n  } = pos;\n  const dx = x - center.x;\n  const dy = y - center.y;\n  return {\n    x: dx * Math.cos(radian) - dy * Math.sin(radian) + center.x,\n    y: dx * Math.sin(radian) + dy * Math.cos(radian) + center.y\n  };\n}\n\nfunction reverseAngleRadian(theta) {\n  if (theta > 0) {\n    return -(Math.PI * 2 - theta);\n  } else {\n    return Math.PI * 2 + theta;\n  }\n}\n\nfunction calculateBezierCurveControlPoint(p1, center, p2, theta0) {\n  const control = [];\n  const centerToSource = VectorLine.fromVectors(center, p1);\n  const centerToTarget = VectorLine.fromVectors(center, p2);\n  let theta = calculateRelativeAngleRadian(centerToSource, centerToTarget);\n\n  if (theta0 * theta < 0) {\n    theta = reverseAngleRadian(theta);\n  }\n\n  const middle = Vector2D.fromObject(moveOnCircumference(p1, center, -theta / 2));\n  const centerToMp = VectorLine.fromVectors(center, middle);\n  const mpTangent = calculatePerpendicularLine(centerToMp);\n  const theta1 = calculateRelativeAngleRadian(centerToSource, centerToMp);\n  let tangent = calculatePerpendicularLine(centerToSource);\n\n  if (Math.abs(theta1) < Math.PI / 2) {\n    const cp = getIntersectionPointOfLines(tangent, mpTangent);\n    control.push(cp);\n  } else {\n    const mp = Vector2D.fromObject(moveOnCircumference(middle, center, theta1 / 2));\n    const tangent2 = calculatePerpendicularLine(VectorLine.fromVectors(center, Vector2D.fromObject(mp)));\n    const cp1 = getIntersectionPointOfLines(tangent, tangent2);\n    const cp2 = getIntersectionPointOfLines(tangent2, mpTangent);\n    control.push(cp1, mp, cp2);\n  }\n\n  control.push(middle);\n  const theta2 = calculateRelativeAngleRadian(centerToTarget, centerToMp);\n  tangent = calculatePerpendicularLine(centerToTarget);\n\n  if (Math.abs(theta2) < Math.PI / 2) {\n    const cp = getIntersectionPointOfLines(tangent, mpTangent);\n    control.push(cp);\n  } else {\n    const mp = Vector2D.fromObject(moveOnCircumference(middle, center, theta2 / 2));\n    const tangent2 = calculatePerpendicularLine(VectorLine.fromVectors(center, Vector2D.fromObject(mp)));\n    const cp1 = getIntersectionPointOfLines(mpTangent, tangent2);\n    const cp2 = getIntersectionPointOfLines(tangent2, tangent);\n    control.push(cp1, mp, cp2);\n  }\n\n  return control;\n}\n\nfunction calculateRelativeAngleRadian(line1, line2) {\n  return Math.atan2(line1.v.y * line2.v.x - line1.v.x * line2.v.y, line1.v.x * line2.v.x + line1.v.y * line2.v.y);\n}\n\nfunction calculateCircleCenterAndRadiusBy3Points(p1, p2, p3) {\n  const x1 = p1.x;\n  const y1 = p1.y;\n  const x2 = p2.x;\n  const y2 = p2.y;\n  const x3 = p3.x;\n  const y3 = p3.y;\n  const x12 = x1 - x2;\n  const y12 = y1 - y2;\n  const x32 = x3 - x2;\n  const y32 = y3 - y2;\n  const x = (y32 * (x12 * (x1 + x2) + y12 * (y1 + y2)) - y12 * (x32 * (x3 + x2) + y32 * (y3 + y2))) / (2 * x12 * y32 - 2 * y12 * x32);\n  const y = (-x32 * (x12 * (x1 + x2) + y12 * (y1 + y2)) + x12 * (x32 * (x3 + x2) + y32 * (y3 + y2))) / (2 * x12 * y32 - 2 * y12 * x32);\n  const radius = Math.sqrt(Math.pow(x1 - x, 2) + Math.pow(y1 - y, 2));\n  const center = new Vector2D(x, y);\n  return [center, radius];\n}\n\nfunction convertToAscii(source) {\n  if (typeof btoa === void 0) {\n    return Buffer.from(source).toString(\"base64\").replaceAll(\"=\", \"\");\n  } else {\n    return btoa(source).replaceAll(\"=\", \"\");\n  }\n}\n\nfunction makeMarkerState() {\n  const markers = reactive({});\n  const referenceCount = {};\n  return {\n    markers,\n    referenceCount\n  };\n}\n\nfunction useMarker(markerState) {\n  const {\n    markers,\n    referenceCount\n  } = markerState;\n\n  function addMarker(key, marker) {\n    var _a;\n\n    const m = (_a = referenceCount[key]) != null ? _a : 0;\n    referenceCount[key] = m + 1;\n\n    if (!m) {\n      markers[key] = marker;\n    }\n  }\n\n  function removeMarker(key) {\n    var _a;\n\n    const m = (_a = referenceCount[key]) != null ? _a : 0;\n\n    if (m) {\n      if (m - 1 === 0) {\n        delete markers[key];\n        delete referenceCount[key];\n      } else {\n        referenceCount[key] = m - 1;\n      }\n    }\n  }\n\n  function clearMarker(id) {\n    if (id) {\n      removeMarker(id);\n    }\n  }\n\n  function makeMarker(marker, isSource, previousId, strokeColor, instanceId) {\n    if (marker.type === \"none\") {\n      clearMarker(previousId);\n      return void 0;\n    }\n\n    if (marker.type === \"custom\") {\n      clearMarker(previousId);\n      return marker.customId;\n    }\n\n    const headMarker = toHeadMarker(marker, isSource, strokeColor);\n    const id = buildKey(headMarker, instanceId);\n\n    if (id === previousId) {\n      return id;\n    }\n\n    clearMarker(previousId);\n    addMarker(id, headMarker);\n    return id;\n  }\n\n  return {\n    makeMarker,\n    clearMarker\n  };\n}\n\nfunction toHeadMarker(marker, isSource, strokeColor) {\n  var _a;\n\n  return __spreadProps(__spreadValues({}, marker), {\n    color: (_a = marker.color) != null ? _a : strokeColor,\n    isSource\n  });\n}\n\nfunction buildKey(m, instanceId) {\n  const c = convertToAscii(m.color);\n  const d = m.isSource ? \"L\" : \"R\";\n  const u = m.units === \"strokeWidth\" ? \"rel\" : \"abs\";\n  return `marker_${instanceId}_${m.type}_${m.width}_${m.height}_${m.margin}_${c}_${d}_${u}`;\n}\n\nfunction useObjectState(objects, config, selected, hovered, createState, terminateState, entriesForZOrder) {\n  const states = reactive({});\n  watch(() => new Set(Object.keys(objects.value)), (idSet, prev) => {\n    if (!prev) prev = /* @__PURE__ */new Set([]);\n\n    for (const id of idSet) {\n      if (prev.has(id)) continue;\n      createNewState(objects, states, id, false, config, createState);\n    }\n\n    for (const id of prev) {\n      if (idSet.has(id)) continue;\n      selected.delete(id);\n      hovered.delete(id);\n      terminateState == null ? void 0 : terminateState(id, states[id]);\n      delete states[id];\n    }\n  }, {\n    immediate: true\n  });\n  watch(() => [...selected], (objects2, prev) => {\n    const append = prev ? objects2.filter(n => !prev.includes(n)) : objects2;\n    const removed = prev ? prev.filter(n => !objects2.includes(n)) : [];\n    append.forEach(id => {\n      const state = states[id];\n      if (state && !state.selected) state.selected = true;\n    });\n    removed.forEach(id => {\n      const state = states[id];\n      if (state && state.selected) state.selected = false;\n    });\n  }, {\n    immediate: true\n  });\n  watch(() => [...hovered], (nodes, prev) => {\n    const append = nodes.filter(n => !prev.includes(n));\n    const removed = prev.filter(n => !nodes.includes(n));\n    append.forEach(id => {\n      const state = states[id];\n      if (state && !state.hovered) state.hovered = true;\n    });\n    removed.forEach(id => {\n      const state = states[id];\n      if (state && state.hovered) state.hovered = false;\n    });\n  });\n  const zOrderedList = computed(() => {\n    const list = entriesForZOrder ? entriesForZOrder() : Object.values(states);\n\n    if (config.zOrder.enabled) {\n      return makeZOrderedList(list, config.zOrder, hovered, selected);\n    } else {\n      return list;\n    }\n  });\n  return {\n    states,\n    zOrderedList\n  };\n}\n\nfunction createNewState(objects, states, id, selected, config, createState) {\n  const stateObject = {\n    id,\n    selected,\n    hovered: false,\n    selectable: computed(() => {\n      if (!objects.value[id]) return unref(stateObject.selectable);\n      return Config.value(config.selectable, objects.value[id]);\n    }),\n    zIndex: computed(() => {\n      if (!objects.value[id]) return unref(stateObject.zIndex);\n      return Config.value(config.zOrder.zIndex, objects.value[id]);\n    })\n  };\n  states[id] = stateObject;\n  createState(objects, id, states[id]);\n}\n\nfunction makeZOrderedList(states, zOrder, hovered, selected) {\n  if (zOrder.bringToFrontOnHover && zOrder.bringToFrontOnSelected) {\n    return states.sort((a, b) => {\n      const hover1 = hovered.has(a.id);\n      const hover2 = hovered.has(b.id);\n\n      if (hover1 != hover2) {\n        return hover1 ? 1 : -1;\n      }\n\n      const selected1 = selected.has(a.id);\n      const selected2 = selected.has(b.id);\n\n      if (selected1 != selected2) {\n        return selected1 ? 1 : -1;\n      }\n\n      return a.zIndex - b.zIndex;\n    });\n  } else if (zOrder.bringToFrontOnHover) {\n    return states.sort((a, b) => {\n      const hover1 = hovered.has(a.id);\n      const hover2 = hovered.has(b.id);\n\n      if (hover1 != hover2) {\n        return hover1 ? 1 : -1;\n      }\n\n      return a.zIndex - b.zIndex;\n    });\n  } else if (zOrder.bringToFrontOnSelected) {\n    return states.sort((a, b) => {\n      const selected1 = selected.has(a.id);\n      const selected2 = selected.has(b.id);\n\n      if (selected1 != selected2) {\n        return selected1 ? 1 : -1;\n      }\n\n      return a.zIndex - b.zIndex;\n    });\n  } else {\n    return states.sort((a, b) => {\n      return a.zIndex - b.zIndex;\n    });\n  }\n}\n\nfunction makeStateInput(objects, selected, hovered) {\n  return {\n    objects,\n    selected,\n    hovered\n  };\n}\n\nconst statesKey = Symbol(\"states\");\nconst NONE_MARKER = {\n  type: \"none\",\n  width: 0,\n  height: 0,\n  margin: 0,\n  units: \"strokeWidth\",\n  color: null\n};\n\nfunction provideStates(nodes, edges, paths, configs, layouts, makerState, scale) {\n  const summarizedEdgeStates = reactive({});\n  const {\n    states: nodeStates,\n    zOrderedList: nodeZOrderedList\n  } = useObjectState(nodes.objects, configs.node, nodes.selected, nodes.hovered, (nodes2, id, newState) => {\n    createNewNodeState(nodes2, id, newState, configs.node);\n  }, (nodeId, _state) => {\n    const positions = layouts.nodes;\n    delete positions[nodeId];\n  });\n  const instanceId = useId();\n  const edgeGroupStates = makeEdgeGroupStates(nodes.objects, edges.objects, configs);\n  const edgeEntries = ref([]);\n  const {\n    states: edgeStates,\n    zOrderedList: edgeZOrderedList\n  } = useObjectState(edges.objects, configs.edge, edges.selected, edges.hovered, (edges2, id, newState) => {\n    createNewEdgeState(edges2, id, newState, configs.edge, makerState, nodeStates, edgeGroupStates, layouts, scale, instanceId);\n  }, (_edgeId, state) => {\n    var _a;\n\n    (_a = state.stopWatchHandle) == null ? void 0 : _a.call(state);\n  }, () => edgeEntries.value);\n  watchEffect(() => {\n    edgeEntries.value = createEdgeEntries(edgeGroupStates.edgeGroups, edgeStates);\n  });\n  watch(edgeGroupStates.edgeGroups, _ => createSummarizedEdgeStates(summarizedEdgeStates, edgeGroupStates, configs), {\n    immediate: true\n  });\n  const {\n    states: pathStates,\n    zOrderedList: pathZOrderedList\n  } = useObjectState(paths.objects, configs.path, paths.selected, paths.hovered, (paths2, id, newState) => {\n    const state = newState;\n    state.clickable = computed(() => {\n      if (!paths2.value[id]) return false;\n      return Config.value(configs.path.clickable, paths2.value[id]);\n    });\n    state.hoverable = computed(() => {\n      if (!paths2.value[id]) return false;\n      return Config.value(configs.path.hoverable, paths2.value[id]);\n    });\n    state.path = paths2.value[id];\n    state.edges = computed(() => {\n      const path = paths2.value[id];\n      return path.edges.map(edgeId => ({\n        edgeId,\n        edge: edges.objects.value[edgeId]\n      })).filter(e => e.edge);\n    });\n  });\n  const states = {\n    nodeStates,\n    edgeStates,\n    edgeGroupStates,\n    summarizedEdgeStates,\n    pathStates,\n    layouts,\n    nodeZOrderedList,\n    edgeZOrderedList,\n    pathZOrderedList\n  };\n  provide(statesKey, states);\n  return states;\n}\n\nfunction isSummarizedEdges(item) {\n  return item.summarized;\n}\n\nfunction useStates() {\n  return nonNull(inject(statesKey), \"states\");\n}\n\nfunction getNodeShape(node, selected, hovered, config) {\n  if (hovered && config.hover) {\n    return Config.values(config.hover, node);\n  } else {\n    return getNodeStaticShape(node, selected, config);\n  }\n}\n\nfunction getNodeStaticShape(node, selected, config) {\n  if (selected && config.selected) {\n    return Config.values(config.selected, node);\n  } else {\n    return Config.values(config.normal, node);\n  }\n}\n\nfunction createNewNodeState(nodes, id, state, config) {\n  state.shape = computed(() => {\n    if (!nodes.value[id]) return unref(state.shape);\n    return getNodeShape(nodes.value[id], state.selected, state.hovered, config);\n  });\n  state.staticShape = computed(() => {\n    if (!nodes.value[id]) return unref(state.staticShape);\n    return getNodeStaticShape(nodes.value[id], state.selected, config);\n  });\n  state.label = computed(() => {\n    if (!nodes.value[id]) return unref(state.label);\n    return Config.values(config.label, nodes.value[id]);\n  });\n  state.labelText = computed(() => {\n    var _a, _b;\n\n    if (config.label.text instanceof Function) {\n      return unref(state.label).text;\n    } else {\n      if (!nodes.value[id]) return unref(state.labelText);\n      return (_b = (_a = nodes.value[id]) == null ? void 0 : _a[unref(state.label).text]) != null ? _b : \"\";\n    }\n  });\n  state.draggable = computed(() => {\n    if (!nodes.value[id]) return unref(state.draggable);\n    return Config.value(config.draggable, nodes.value[id]);\n  });\n}\n\nfunction getEdgeStroke(edge, selected, hovered, config) {\n  if (selected) {\n    return Config.values(config.selected, edge);\n  } else if (hovered && config.hover) {\n    return Config.values(config.hover, edge);\n  } else {\n    return Config.values(config.normal, edge);\n  }\n}\n\nfunction toEdgeMarker(marker) {\n  if (marker.type === \"none\") {\n    return NONE_MARKER;\n  } else {\n    return marker;\n  }\n}\n\nfunction createNewEdgeState(edges, id, state, config, makerState, nodeStates, edgeGroupStates, layouts, scale, instanceId) {\n  const {\n    makeMarker,\n    clearMarker\n  } = useMarker(makerState);\n  Object.assign(state, {\n    origin: {\n      p1: {\n        x: 0,\n        y: 0\n      },\n      p2: {\n        x: 0,\n        y: 0\n      }\n    },\n    labelPosition: {\n      p1: {\n        x: 0,\n        y: 0\n      },\n      p2: {\n        x: 0,\n        y: 0\n      }\n    },\n    position: {\n      p1: {\n        x: 0,\n        y: 0\n      },\n      p2: {\n        x: 0,\n        y: 0\n      }\n    }\n  });\n  const line = computed(() => {\n    const edge = edges.value[id];\n    const stroke = getEdgeStroke(edge, state.selected, state.hovered, config);\n\n    if (isNaN(+stroke.width)) {\n      console.warn(\"[v-network-graph] Edge width is invalid value. id=[%s] value=[%s]\", id, stroke.width);\n      stroke.width = 1;\n    }\n\n    if (stroke.color === void 0 || stroke.color === null) {\n      console.warn(\"[v-network-graph] Edge color is invalid value. id=[%s] value=[%s]\", id, stroke.color);\n      stroke.color = \"#000000\";\n    }\n\n    let normalWidth = Config.value(config.normal.width, edge);\n\n    if (isNaN(+normalWidth)) {\n      normalWidth = 1;\n    }\n\n    const source = toEdgeMarker(Config.values(config.marker.source, [edge, stroke]));\n    const target = toEdgeMarker(Config.values(config.marker.target, [edge, stroke]));\n    return {\n      stroke,\n      normalWidth,\n      source,\n      target\n    };\n  });\n  state.line = line;\n  const edgeLayoutPoint = toRef(edgeGroupStates.edgeLayoutPoints, id);\n  const isEdgeSummarized = toRef(edgeGroupStates.summarizedEdges, id);\n  const stopCalcHandle = watchEffect(() => {\n    var _a, _b, _c;\n\n    const edge = edges.value[id];\n    if (!edge) return;\n    const source = layouts.nodes[edge == null ? void 0 : edge.source];\n    const target = layouts.nodes[edge == null ? void 0 : edge.target];\n    const sourceShape = (_a = nodeStates[edge == null ? void 0 : edge.source]) == null ? void 0 : _a.staticShape;\n    const targetShape = (_b = nodeStates[edge == null ? void 0 : edge.target]) == null ? void 0 : _b.staticShape;\n\n    if (!source || !target || !sourceShape || !targetShape) {\n      return;\n    }\n\n    const shiftedPosition = calculateEdgeShiftedPosition(edgeLayoutPoint.value, (_c = isEdgeSummarized.value) != null ? _c : false, source, target, scale.value, config.keepOrder);\n    const [sourceShapeMargin, targetShapeMargin] = calculateDistancesFromCenterOfNodeToEndOfNode(source, target, sourceShape, targetShape);\n    const s = scale.value;\n    state.labelPosition = applyMargin(shiftedPosition, sourceShapeMargin * s, targetShapeMargin * s);\n    let sourceMargin = 0;\n    let targetMargin = 0;\n    const l = line.value;\n\n    if (l.source.type !== \"none\") {\n      const marker = l.source;\n      sourceMargin = marker.margin + marker.width;\n\n      if (marker.units === \"strokeWidth\") {\n        sourceMargin *= l.normalWidth;\n      }\n    }\n\n    if (l.target.type !== \"none\") {\n      const marker = l.target;\n      targetMargin = marker.margin + marker.width;\n\n      if (marker.units === \"strokeWidth\") {\n        targetMargin *= l.normalWidth;\n      }\n    }\n\n    if (config.margin === null || config.margin === void 0) {\n      if (l.source.type !== \"none\" || l.target.type !== \"none\") {\n        sourceMargin += sourceShapeMargin;\n        targetMargin += targetShapeMargin;\n      }\n    } else {\n      sourceMargin += config.margin + sourceShapeMargin;\n      targetMargin += config.margin + targetShapeMargin;\n    }\n\n    const type = config.type;\n\n    if (type === \"straight\") {\n      state.origin = shiftedPosition;\n      state.curve = void 0;\n\n      if (sourceMargin === 0 && targetMargin === 0) {\n        state.position = state.origin;\n      } else {\n        state.position = applyMargin(state.origin, sourceMargin * s, targetMargin * s);\n      }\n    } else {\n      state.origin = toLinePosition(source, target);\n      const shift = edgeLayoutPoint.value ? edgeLayoutPoint.value.groupWidth / 2 - edgeLayoutPoint.value.pointInGroup : 0;\n      const [position, curve] = calculateCurvePositionAndState(state.origin, shiftedPosition, shift, sourceMargin * s, targetMargin * s);\n      state.position = position;\n      state.curve = curve;\n    }\n  });\n  const stopUpdateMarkerHandle = watchEffect(() => {\n    if (!edges.value[id]) return;\n    state.sourceMarkerId = makeMarker(line.value.source, true, state.sourceMarkerId, line.value.stroke.color, instanceId);\n    state.targetMarkerId = makeMarker(line.value.target, false, state.targetMarkerId, line.value.stroke.color, instanceId);\n  });\n\n  state.stopWatchHandle = () => {\n    stopCalcHandle();\n    stopUpdateMarkerHandle();\n    clearMarker(state.sourceMarkerId);\n    clearMarker(state.targetMarkerId);\n  };\n}\n\nfunction createEdgeEntries(edgeGroups, edgeStates) {\n  return Object.entries(edgeGroups).map(([key, group]) => {\n    var _a;\n\n    if (group.summarize) {\n      return {\n        id: (_a = Object.keys(group.edges)[0]) != null ? _a : key,\n        summarized: true,\n        key,\n        group,\n        zIndex: Object.keys(group.edges).map(id => {\n          var _a2, _b;\n\n          return (_b = (_a2 = edgeStates[id]) == null ? void 0 : _a2.zIndex) != null ? _b : 0;\n        }).reduce((s, z) => Math.max(s, z))\n      };\n    } else {\n      return Object.entries(group.edges).map(([id, edge]) => {\n        var _a2, _b;\n\n        return {\n          id,\n          summarized: false,\n          key: id,\n          edge,\n          zIndex: (_b = (_a2 = edgeStates[id]) == null ? void 0 : _a2.zIndex) != null ? _b : 0\n        };\n      });\n    }\n  }).flat();\n}\n\nfunction calculateCurvePositionAndState(originPosition, shiftedPosition, shift, sourceMargin, targetMargin) {\n  const origin = VectorLine.fromLinePosition(originPosition);\n  const shifted = VectorLine.fromLinePosition(shiftedPosition);\n  const shiftedCenter = getCenterOfLinePosition(shiftedPosition);\n  const [center, radius] = calculateCircleCenterAndRadiusBy3Points(origin.source, origin.target, shiftedCenter);\n  let position;\n  let curve = void 0;\n\n  if (shift === 0) {\n    if (sourceMargin === 0 && targetMargin === 0) {\n      position = originPosition;\n    } else {\n      position = applyMargin(originPosition, sourceMargin, targetMargin);\n    }\n\n    return [position, curve];\n  }\n\n  const centerToTop = VectorLine.fromVectors(center, shiftedCenter);\n  const theta0 = calculateRelativeAngleRadian(VectorLine.fromVectors(center, origin.source), centerToTop);\n\n  if (sourceMargin === 0 && targetMargin === 0) {\n    position = originPosition;\n  } else {\n    let sourceMoveRad = sourceMargin / radius;\n    let targetMoveRad = targetMargin / radius;\n\n    if (theta0 > 0) {\n      sourceMoveRad *= -1;\n      targetMoveRad *= -1;\n    }\n\n    position = toLinePosition(moveOnCircumference(origin.source, center, sourceMoveRad), moveOnCircumference(origin.target, center, -targetMoveRad));\n    let theta1 = calculateRelativeAngleRadian(VectorLine.fromVectors(center, origin.source), VectorLine.fromVectors(center, origin.target));\n    let theta2 = calculateRelativeAngleRadian(VectorLine.fromPositions(center, position.p1), VectorLine.fromPositions(center, position.p2));\n\n    if (theta0 * theta1 < 0) {\n      theta1 = reverseAngleRadian(theta1);\n\n      if (theta0 * theta2 < 0) {\n        theta2 = reverseAngleRadian(theta2);\n      }\n    }\n\n    if (theta1 * theta2 < 0) {\n      const c = shiftedCenter.clone().add(shifted.v.normalize().multiplyScalar(0.5));\n      position = toLinePosition(shiftedCenter, c);\n      return [position, curve];\n    }\n  }\n\n  const [p1, p2] = toVectorsFromLinePosition(position);\n  const control = calculateBezierCurveControlPoint(p1, center, p2, theta0).map(p => p.toObject());\n  curve = {\n    center: shiftedCenter,\n    theta: theta0,\n    circle: {\n      center,\n      radius\n    },\n    control\n  };\n  return [position, curve];\n}\n\nfunction createSummarizedEdgeStates(summarizedEdgeStates, edgeGroupStates, configs) {\n  const groups = edgeGroupStates.edgeGroups;\n  Object.entries(groups).filter(([id, group]) => group.summarize && !(id in summarizedEdgeStates)).forEach(([id, group]) => {\n    const state = {\n      stroke: void 0\n    };\n    state.stroke = computed(() => Config.values(configs.edge.summarized.stroke, group.edges));\n    summarizedEdgeStates[id] = state;\n  });\n  Object.keys(summarizedEdgeStates).forEach(id => {\n    var _a;\n\n    if (!((_a = edgeGroupStates.edgeGroups[id]) == null ? void 0 : _a.summarize)) {\n      delete summarizedEdgeStates[id];\n    }\n  });\n}\n\nclass MapUtil {\n  static valueOf(map) {\n    return Array.from(map.values());\n  }\n\n}\n\nconst MOUSE_MOVE_DETECTION_THRESHOLD = 3;\nconst TOUCH_MOVE_DETECTION_THRESHOLD = 6;\nconst DOUBLE_CLICK_THRESHOLD = 500;\n\nfunction getPointerMoveDetectionThreshold(type) {\n  return type === \"touch\" ? TOUCH_MOVE_DETECTION_THRESHOLD : MOUSE_MOVE_DETECTION_THRESHOLD;\n}\n\nfunction detectClicks(clickStates, pointerId, id, event) {\n  let clickState = clickStates.get(pointerId);\n\n  if (clickState) {\n    if (clickState.id !== id) {\n      clickState = void 0;\n    }\n  } else {\n    const idAndState = Array.from(clickStates.entries()).find(([_, state]) => state.id === id);\n\n    if (idAndState) {\n      const [oldPointerId, state] = idAndState;\n      clickStates.delete(oldPointerId);\n      clickState = state;\n    }\n  }\n\n  let clickEvent, doubleClickEvent;\n  [clickState, clickEvent, doubleClickEvent] = createClickEvents(clickState, event, id);\n  clickStates.set(pointerId, clickState);\n  return [clickEvent, doubleClickEvent];\n}\n\nfunction createClickEvents(clickState, event, id) {\n  const now2 = Date.now();\n\n  if (clickState && now2 - clickState.lastTime <= DOUBLE_CLICK_THRESHOLD) {\n    clickState.count++;\n    clickState.lastTime = now2;\n  } else {\n    clickState = {\n      count: 1,\n      lastTime: now2,\n      id\n    };\n  }\n\n  const initDict = {\n    view: window,\n    screenX: event.screenX,\n    screenY: event.screenY,\n    clientX: event.clientX,\n    clientY: event.clientY,\n    ctrlKey: event.ctrlKey,\n    shiftKey: event.shiftKey,\n    altKey: event.altKey,\n    metaKey: event.metaKey,\n    button: event.button,\n    buttons: event.buttons,\n    detail: clickState.count\n  };\n  let clickEvent;\n  let doubleClickEvent = void 0;\n\n  if (event instanceof PointerEvent) {\n    Object.assign(initDict, {\n      pointerId: event.pointerId,\n      width: event.width,\n      height: event.height,\n      pressure: event.pressure,\n      tangentialPressure: event.tangentialPressure,\n      tiltX: event.tiltX,\n      tiltY: event.tiltY,\n      twist: event.twist,\n      pointerType: event.pointerType,\n      isPrimary: event.isPrimary\n    });\n    clickEvent = new PointerEvent(\"click\", initDict);\n\n    if (clickState.count === 2) {\n      doubleClickEvent = new PointerEvent(\"dblclick\", initDict);\n    }\n  } else {\n    clickEvent = new MouseEvent(\"click\", initDict);\n\n    if (clickState.count === 2) {\n      doubleClickEvent = new MouseEvent(\"dblclick\", initDict);\n    }\n  }\n\n  return [clickState, clickEvent, doubleClickEvent];\n}\n\nfunction cleanClickState(states) {\n  const now2 = Date.now();\n  Array.from(states.entries()).filter(([_, state]) => now2 - state.lastTime > DOUBLE_CLICK_THRESHOLD).map(([pointerId, _]) => states.delete(pointerId));\n}\n\nfunction makeNodeInteractionHandlers(nodeStates, layouts, modes, hoveredNodes, selectedNodes, zoomLevel, emitter) {\n  const state = {\n    pointers: /* @__PURE__ */new Map(),\n    follow: {\n      followedPointerId: -1,\n      nodeBasePositions: {}\n    },\n    hoveredNodesPre: /* @__PURE__ */new Set(),\n    clicks: /* @__PURE__ */new Map()\n  };\n  const nodePointerHandlers = {\n    pointermove: handleNodePointerMoveEvent,\n    pointerup: handleNodePointerUpEvent,\n    pointercancel: handleNodePointerCancelEvent\n  };\n\n  function _updateFollowNodes(pointerState) {\n    const isFollowed = state.follow.followedPointerId === pointerState.pointerId;\n    const isSelectedNode = selectedNodes.has(pointerState.nodeId);\n    const removed = !(pointerState.pointerId in state.pointers);\n\n    if (isFollowed && removed || isFollowed && !isSelectedNode) {\n      const candidate = MapUtil.valueOf(state.pointers).find(p => selectedNodes.has(p.nodeId));\n\n      if (!candidate) {\n        state.follow = {\n          followedPointerId: -1,\n          nodeBasePositions: {}\n        };\n        return;\n      }\n\n      pointerState = candidate;\n      state.follow.followedPointerId = pointerState.pointerId;\n    } else {\n      const followed = state.pointers.get(state.follow.followedPointerId);\n\n      if (!followed) {\n        state.follow = {\n          followedPointerId: -1,\n          nodeBasePositions: {}\n        };\n        return;\n      }\n\n      pointerState = followed;\n    }\n\n    if (isFollowed || isSelectedNode) {\n      const userGrabs = MapUtil.valueOf(state.pointers).map(n => n.nodeId);\n      state.follow.nodeBasePositions = Object.fromEntries(Array.from(selectedNodes).filter(n => !userGrabs.includes(n)).filter(n => {\n        var _a;\n\n        return (_a = nodeStates[n]) == null ? void 0 : _a.draggable;\n      }).map(n => [n, _unwrapNodePosition(layouts.nodes, n)]));\n      pointerState.dragBasePosition = __spreadValues({}, pointerState.latestPosition);\n      pointerState.nodeBasePosition = _unwrapNodePosition(layouts.nodes, pointerState.nodeId);\n    }\n  }\n\n  watch(selectedNodes, selected => {\n    const pointerState = state.pointers.get(state.follow.followedPointerId);\n\n    if (pointerState) {\n      _updateFollowNodes(pointerState);\n    }\n\n    if (selected.size > 0 && modes.selectionMode.value !== \"node\") {\n      modes.selectionMode.value = \"node\";\n    } else if (selected.size === 0 && modes.selectionMode.value === \"node\") {\n      modes.selectionMode.value = \"container\";\n    }\n  });\n  watch(modes.selectionMode, mode => {\n    if (mode !== \"node\") {\n      selectedNodes.clear();\n    }\n  });\n\n  function _calculateNodeNewPosition(pointerState, event) {\n    const dx = pointerState.dragBasePosition.x - event.pageX;\n    const dy = pointerState.dragBasePosition.y - event.pageY;\n    const positions = state.follow.followedPointerId == pointerState.pointerId ? __spreadValues({\n      [pointerState.nodeId]: pointerState.nodeBasePosition\n    }, state.follow.nodeBasePositions) : {\n      [pointerState.nodeId]: pointerState.nodeBasePosition\n    };\n    const z = zoomLevel.value;\n    return Object.fromEntries(Object.entries(positions).map(([node, pos]) => [node, {\n      x: pos.x - dx / z,\n      y: pos.y - dy / z\n    }]));\n  }\n\n  function handleNodeClickEvent(node, event) {\n    var _a, _b;\n\n    if (event.isTrusted) return;\n\n    if (event.shiftKey && ![\"container\", \"node\"].includes(modes.selectionMode.value)) {\n      return;\n    }\n\n    modes.selectionMode.value = \"node\";\n    const selectable = (_b = (_a = nodeStates[node]) == null ? void 0 : _a.selectable) != null ? _b : false;\n\n    if (selectable) {\n      const isTouchAnySelectedNode = MapUtil.valueOf(state.pointers).filter(p => selectedNodes.has(p.nodeId)).length > 0;\n\n      if (event.shiftKey || isTouchAnySelectedNode) {\n        if (selectedNodes.has(node)) {\n          selectedNodes.delete(node);\n        } else if (!(typeof selectable === \"number\" && selectedNodes.size >= selectable)) {\n          selectedNodes.add(node);\n        }\n      } else if (!selectedNodes.has(node)) {\n        selectedNodes.clear();\n        selectedNodes.add(node);\n      }\n    }\n\n    emitter.emit(\"node:click\", {\n      node,\n      event\n    });\n  }\n\n  function handleNodeDoubleClickEvent(node, event) {\n    if (event.isTrusted) return;\n    emitter.emit(\"node:dblclick\", {\n      node,\n      event\n    });\n  }\n\n  function handleNodePointerMoveEvent(event) {\n    var _a;\n\n    event.stopPropagation();\n    const pointerState = state.pointers.get(event.pointerId);\n\n    if (!pointerState) {\n      return;\n    }\n\n    pointerState.latestPosition = {\n      x: event.pageX,\n      y: event.pageY\n    };\n    pointerState.moveCounter++;\n    const threshold = getPointerMoveDetectionThreshold(event.pointerType);\n\n    if (pointerState.moveCounter <= threshold) {\n      return;\n    }\n\n    if (!((_a = nodeStates[pointerState.nodeId]) == null ? void 0 : _a.draggable)) {\n      return;\n    }\n\n    if (pointerState.moveCounter === threshold + 1) {\n      const draggingNodes2 = _calculateNodeNewPosition(pointerState, {\n        pointerId: pointerState.pointerId,\n        pageX: pointerState.dragBasePosition.x,\n        pageY: pointerState.dragBasePosition.y\n      });\n\n      emitter.emit(\"node:dragstart\", draggingNodes2);\n    }\n\n    const draggingNodes = _calculateNodeNewPosition(pointerState, event);\n\n    emitter.emit(\"node:pointermove\", draggingNodes);\n  }\n\n  function handleNodePointerCancelEvent(event) {\n    event.stopPropagation();\n    let pointerState = state.pointers.get(event.pointerId);\n\n    if (!pointerState) {\n      return;\n    }\n\n    for (pointerState of state.pointers.values()) {\n      const node = pointerState.nodeId;\n      const threshold = getPointerMoveDetectionThreshold(event.pointerType);\n      const isMoved = pointerState.moveCounter > threshold;\n\n      if (isMoved) {\n        const draggingNodes = _calculateNodeNewPosition(pointerState, {\n          pointerId: pointerState.pointerId,\n          pageX: pointerState.latestPosition.x,\n          pageY: pointerState.latestPosition.y\n        });\n\n        emitter.emit(\"node:dragend\", draggingNodes);\n      }\n\n      emitter.emit(\"node:pointerup\", {\n        node,\n        event\n      });\n    }\n\n    state.pointers.clear();\n    state.follow = {\n      followedPointerId: -1,\n      nodeBasePositions: {}\n    };\n    entriesOf(nodePointerHandlers).forEach(([ev, handler]) => {\n      document.removeEventListener(ev, handler);\n    });\n    modes.viewMode.value = \"default\";\n  }\n\n  function handleNodePointerUpEvent(event) {\n    var _a, _b, _c;\n\n    event.stopPropagation();\n    const pointerState = state.pointers.get(event.pointerId);\n\n    if (!pointerState) {\n      return;\n    }\n\n    state.pointers.delete(event.pointerId);\n    const node = pointerState.nodeId;\n    const threshold = getPointerMoveDetectionThreshold(event.pointerType);\n    const isMoved = pointerState.moveCounter > threshold;\n\n    if (isMoved) {\n      if ((_a = nodeStates[pointerState.nodeId]) == null ? void 0 : _a.draggable) {\n        const draggingNodes = _calculateNodeNewPosition(pointerState, event);\n\n        emitter.emit(\"node:dragend\", draggingNodes);\n        emitter.emit(\"node:pointerup\", {\n          node,\n          event\n        });\n      }\n    } else {\n      emitter.emit(\"node:pointerup\", {\n        node,\n        event\n      });\n    }\n\n    if (!isMoved) {\n      const [clickEvent, doubleClickEvent] = detectClicks(state.clicks, pointerState.pointerId, node, event);\n      (_b = pointerState.eventTarget) == null ? void 0 : _b.dispatchEvent(clickEvent);\n\n      if (doubleClickEvent) {\n        (_c = pointerState.eventTarget) == null ? void 0 : _c.dispatchEvent(doubleClickEvent);\n      }\n    }\n\n    if (state.pointers.size === 0) {\n      state.follow = {\n        followedPointerId: -1,\n        nodeBasePositions: {}\n      };\n      entriesOf(nodePointerHandlers).forEach(([ev, handler]) => {\n        document.removeEventListener(ev, handler);\n      });\n      cleanClickState(state.clicks);\n      modes.viewMode.value = \"default\";\n    } else {\n      _updateFollowNodes(pointerState);\n    }\n\n    hoveredNodes.clear();\n    state.hoveredNodesPre.forEach(hoveredNodes.add, hoveredNodes);\n  }\n\n  function handleNodePointerDownEvent(node, event) {\n    if (event.button == 2) {\n      return;\n    }\n\n    event.stopPropagation();\n\n    if (![\"default\", \"node\"].includes(modes.viewMode.value)) {\n      return;\n    }\n\n    if (state.pointers.size == 0) {\n      modes.viewMode.value = \"node\";\n      entriesOf(nodePointerHandlers).forEach(([ev, handler]) => {\n        document.addEventListener(ev, handler);\n      });\n    }\n\n    const pointerState = {\n      pointerId: event.pointerId,\n      nodeId: node,\n      moveCounter: 0,\n      nodeBasePosition: _unwrapNodePosition(layouts.nodes, node),\n      dragBasePosition: {\n        x: event.pageX,\n        y: event.pageY\n      },\n      latestPosition: {\n        x: event.pageX,\n        y: event.pageY\n      },\n      eventTarget: event.currentTarget\n    };\n    state.pointers.set(event.pointerId, pointerState);\n\n    if (selectedNodes.has(node)) {\n      if (state.follow.followedPointerId < 0) {\n        state.follow.followedPointerId = event.pointerId;\n\n        _updateFollowNodes(pointerState);\n      } else {\n        delete state.follow.nodeBasePositions[pointerState.nodeId];\n      }\n    }\n\n    emitter.emit(\"node:pointerdown\", {\n      node,\n      event\n    });\n  }\n\n  function handleNodePointerOverEvent(node, event) {\n    state.hoveredNodesPre.add(node);\n\n    if (state.pointers.size > 0) {\n      return;\n    }\n\n    hoveredNodes.add(node);\n    emitter.emit(\"node:pointerover\", {\n      node,\n      event\n    });\n  }\n\n  function handleNodePointerOutEvent(node, event) {\n    state.hoveredNodesPre.delete(node);\n\n    if (state.pointers.size > 0) {\n      return;\n    }\n\n    hoveredNodes.delete(node);\n    emitter.emit(\"node:pointerout\", {\n      node,\n      event\n    });\n  }\n\n  function handleNodeContextMenu(node, event) {\n    event.stopPropagation();\n    emitter.emit(\"node:contextmenu\", {\n      node,\n      event\n    });\n  }\n\n  return {\n    handleNodePointerDownEvent,\n    handleNodePointerOverEvent,\n    handleNodePointerOutEvent,\n    handleNodeClickEvent,\n    handleNodeDoubleClickEvent,\n    handleNodeContextMenu\n  };\n}\n\nfunction _unwrapNodePosition(nodes, node) {\n  var _a;\n\n  const pos = (_a = nodes[node]) != null ? _a : {\n    x: 0,\n    y: 0\n  };\n  return __spreadValues({}, pos);\n}\n\nfunction makeEdgeInteractionHandlers(edgeStates, modes, hoveredEdges, selectedEdges, emitter) {\n  const state = {\n    pointers: /* @__PURE__ */new Map(),\n    pointerPeekCount: 0,\n    clicks: /* @__PURE__ */new Map()\n  };\n  const edgePointerHandlers = {\n    pointerup: handleEdgePointerUpEvent,\n    pointercancel: handleEdgePointerCancelEvent\n  };\n  watch(selectedEdges, selected => {\n    if (selected.size > 0 && modes.selectionMode.value !== \"edge\") {\n      modes.selectionMode.value = \"edge\";\n    } else if (selected.size === 0 && modes.selectionMode.value === \"edge\") {\n      modes.selectionMode.value = \"container\";\n    }\n  });\n  watch(modes.selectionMode, mode => {\n    if (mode !== \"edge\") {\n      selectedEdges.clear();\n    }\n  });\n\n  function handleEdgePointerDownEvent(edge, event) {\n    if (event.button == 2) {\n      return;\n    }\n\n    event.stopPropagation();\n\n    if (![\"default\", \"edge\"].includes(modes.viewMode.value)) {\n      return;\n    }\n\n    if (state.pointers.size == 0) {\n      modes.viewMode.value = \"edge\";\n      entriesOf(edgePointerHandlers).forEach(([ev, handler]) => {\n        document.addEventListener(ev, handler);\n      });\n      state.pointerPeekCount = 0;\n    }\n\n    state.pointerPeekCount++;\n    const pointerState = {\n      pointerId: event.pointerId,\n      id: edge,\n      eventTarget: event.currentTarget\n    };\n    state.pointers.set(event.pointerId, pointerState);\n    emitter.emit(\"edge:pointerdown\", _makeEdgeEventObject(edge, event));\n  }\n\n  function handleEdgePointerUpEvent(event) {\n    var _a, _b;\n\n    event.stopPropagation();\n    const pointerState = state.pointers.get(event.pointerId);\n\n    if (!pointerState) {\n      return;\n    }\n\n    state.pointers.delete(event.pointerId);\n    const edge = pointerState.id;\n    emitter.emit(\"edge:pointerup\", _makeEdgeEventObject(edge, event));\n    const [clickEvent, doubleClickEvent] = detectClicks(state.clicks, pointerState.pointerId, edge instanceof Array ? edge.join(\",\") : edge, event);\n    (_a = pointerState.eventTarget) == null ? void 0 : _a.dispatchEvent(clickEvent);\n\n    if (doubleClickEvent) {\n      (_b = pointerState.eventTarget) == null ? void 0 : _b.dispatchEvent(doubleClickEvent);\n    }\n\n    if (state.pointers.size === 0) {\n      state.pointerPeekCount = 0;\n      entriesOf(edgePointerHandlers).forEach(([ev, handler]) => {\n        document.removeEventListener(ev, handler);\n      });\n      cleanClickState(state.clicks);\n      modes.viewMode.value = \"default\";\n    }\n  }\n\n  function handleEdgePointerCancelEvent(event) {\n    event.stopPropagation();\n    const pointerState = state.pointers.get(event.pointerId);\n\n    if (!pointerState) {\n      return;\n    }\n\n    for (const pointerState2 of state.pointers.values()) {\n      const edge = pointerState2.id;\n      emitter.emit(\"edge:pointerup\", _makeEdgeEventObject(edge, event));\n    }\n\n    state.pointers.clear();\n    state.pointerPeekCount = 0;\n    entriesOf(edgePointerHandlers).forEach(([ev, handler]) => {\n      document.removeEventListener(ev, handler);\n    });\n    emitter.emit(\"view:mode\", \"default\");\n  }\n\n  function handleEdgeClickEvent(edge, event) {\n    var _a;\n\n    if (event.isTrusted) return;\n\n    if (event.shiftKey && ![\"container\", \"edge\"].includes(modes.selectionMode.value)) {\n      return;\n    }\n\n    modes.selectionMode.value = \"edge\";\n    const edges = edge instanceof Array ? edge : [edge];\n    const isTouchAnySelectedEdge = MapUtil.valueOf(state.pointers).filter(p => {\n      const edges2 = p.id instanceof Array ? p.id : [p.id];\n      return edges2.every(edge2 => selectedEdges.has(edge2));\n    }).length > 0;\n\n    if (edge instanceof Array) {\n      const selectableEdges = edges.find(edge2 => {\n        var _a2;\n\n        return (_a2 = edgeStates[edge2]) == null ? void 0 : _a2.selectable;\n      });\n\n      if (selectableEdges) {\n        if (event.shiftKey || isTouchAnySelectedEdge) {\n          if (edges.some(edge2 => selectedEdges.has(edge2))) {\n            edges.forEach(edge2 => selectedEdges.delete(edge2));\n          } else {\n            edges.forEach(edge2 => {\n              var _a2;\n\n              const selectable = (_a2 = edgeStates[edge2]) == null ? void 0 : _a2.selectable;\n\n              if (!(typeof selectable === \"number\" && selectedEdges.size >= selectable)) {\n                selectedEdges.add(edge2);\n              }\n            });\n          }\n        } else {\n          selectedEdges.clear();\n          edges.forEach(edge2 => selectedEdges.add(edge2));\n        }\n      }\n    } else {\n      const selectable = (_a = edgeStates[edge]) == null ? void 0 : _a.selectable;\n\n      if (selectable) {\n        if (event.shiftKey || isTouchAnySelectedEdge) {\n          if (selectedEdges.has(edge)) {\n            selectedEdges.delete(edge);\n          } else if (!(typeof selectable === \"number\" && selectedEdges.size >= selectable)) {\n            selectedEdges.add(edge);\n          }\n        } else if (!selectedEdges.has(edge)) {\n          selectedEdges.clear();\n          selectedEdges.add(edge);\n        }\n      }\n    }\n\n    emitter.emit(\"edge:click\", _makeEdgeEventObject(edge, event));\n  }\n\n  function handleEdgeDoubleClickEvent(edge, event) {\n    if (event.isTrusted) return;\n    emitter.emit(\"edge:dblclick\", _makeEdgeEventObject(edge, event));\n  }\n\n  function handleEdgePointerOverEvent(edge, event) {\n    hoveredEdges.add(edge);\n    emitter.emit(\"edge:pointerover\", _makeEdgeEventObject(edge, event));\n  }\n\n  function handleEdgePointerOutEvent(edge, event) {\n    hoveredEdges.delete(edge);\n    emitter.emit(\"edge:pointerout\", _makeEdgeEventObject(edge, event));\n  }\n\n  function handleEdgeContextMenu(edge, event) {\n    event.stopPropagation();\n    emitter.emit(\"edge:contextmenu\", _makeEdgeEventObject(edge, event));\n  }\n\n  function handleEdgesPointerDownEvent(edges, event) {\n    if (event.button == 2) {\n      return;\n    }\n\n    event.stopPropagation();\n\n    if (![\"default\", \"edge\"].includes(modes.viewMode.value)) {\n      return;\n    }\n\n    if (state.pointers.size == 0) {\n      modes.viewMode.value = \"edge\";\n      entriesOf(edgePointerHandlers).forEach(([ev, handler]) => {\n        document.addEventListener(ev, handler);\n      });\n      state.pointerPeekCount = 0;\n    }\n\n    state.pointerPeekCount++;\n    const pointerState = {\n      pointerId: event.pointerId,\n      id: edges,\n      eventTarget: event.currentTarget\n    };\n    state.pointers.set(event.pointerId, pointerState);\n    emitter.emit(\"edge:pointerdown\", _makeEdgeEventObject(edges, event));\n  }\n\n  function handleEdgesPointerOverEvent(edges, event) {\n    edges.forEach(edge => hoveredEdges.add(edge));\n    emitter.emit(\"edge:pointerover\", _makeEdgeEventObject(edges, event));\n  }\n\n  function handleEdgesPointerOutEvent(edges, event) {\n    edges.forEach(edge => hoveredEdges.delete(edge));\n    emitter.emit(\"edge:pointerout\", _makeEdgeEventObject(edges, event));\n  }\n\n  function handleEdgesClickEvent(edges, event) {\n    handleEdgeClickEvent(edges, event);\n  }\n\n  function handleEdgesDoubleClickEvent(edges, event) {\n    handleEdgeDoubleClickEvent(edges, event);\n  }\n\n  function handleEdgesContextMenu(edges, event) {\n    event.stopPropagation();\n    emitter.emit(\"edge:contextmenu\", _makeEdgeEventObject(edges, event));\n  }\n\n  return {\n    handleEdgePointerDownEvent,\n    handleEdgePointerOverEvent,\n    handleEdgePointerOutEvent,\n    handleEdgeClickEvent,\n    handleEdgeDoubleClickEvent,\n    handleEdgeContextMenu,\n    handleEdgesPointerDownEvent,\n    handleEdgesPointerOverEvent,\n    handleEdgesPointerOutEvent,\n    handleEdgesClickEvent,\n    handleEdgesDoubleClickEvent,\n    handleEdgesContextMenu\n  };\n}\n\nfunction _makeEdgeEventObject(edge, event) {\n  if (edge instanceof Array) {\n    return {\n      edges: edge,\n      event,\n      summarized: true\n    };\n  } else {\n    return {\n      edge,\n      edges: [edge],\n      event,\n      summarized: false\n    };\n  }\n}\n\nfunction setupContainerInteractionHandlers(container, modes, isSvgWheelZoomEnabled, emitter) {\n  const state = {\n    moveCounter: 0,\n    pointerCounter: 0,\n    clickState: void 0\n  };\n  const containerPointerHandlers = {\n    pointermove: handleContainerPointerMoveEvent,\n    pointerup: handleContainerPointerUpEvent,\n    pointercancel: handleContainerPointerUpEvent\n  };\n\n  function handleContainerPointerDownEvent(_) {\n    state.moveCounter = 0;\n\n    if (state.pointerCounter === 0) {\n      entriesOf(containerPointerHandlers).forEach(([ev, handler]) => {\n        document.addEventListener(ev, handler, {\n          passive: true\n        });\n      });\n    }\n\n    state.pointerCounter++;\n  }\n\n  function handleContainerPointerMoveEvent(_) {\n    state.moveCounter++;\n  }\n\n  function handleContainerPointerUpEvent(event) {\n    state.pointerCounter--;\n\n    if (state.pointerCounter <= 0) {\n      state.pointerCounter = 0;\n      entriesOf(containerPointerHandlers).forEach(([ev, handler]) => {\n        document.removeEventListener(ev, handler);\n      });\n      const threshold = getPointerMoveDetectionThreshold(event.pointerType);\n\n      if (state.moveCounter <= threshold) {\n        if (event.shiftKey && modes.selectionMode.value !== \"container\") {\n          return;\n        }\n\n        modes.selectionMode.value = \"container\";\n        const [clickState, clickEvent, doubleClickEvent] = createClickEvents(state.clickState, event, \"view\");\n        state.clickState = clickState;\n        container.value.dispatchEvent(clickEvent);\n\n        if (doubleClickEvent) {\n          container.value.dispatchEvent(doubleClickEvent);\n        }\n      }\n    }\n  }\n\n  function handleContainerClickEvent(event) {\n    if (event.isTrusted) return;\n    event.stopPropagation();\n    emitter.emit(\"view:click\", {\n      event\n    });\n  }\n\n  function handleContainerDoubleClickEvent(event) {\n    if (event.isTrusted) return;\n    event.stopPropagation();\n    emitter.emit(\"view:dblclick\", {\n      event\n    });\n  }\n\n  function handleContainerContextMenuEvent(event) {\n    emitter.emit(\"view:contextmenu\", {\n      event\n    });\n\n    if (state.pointerCounter > 0) {\n      state.pointerCounter = 0;\n      entriesOf(containerPointerHandlers).forEach(([ev, handler]) => {\n        var _a;\n\n        (_a = container.value) == null ? void 0 : _a.removeEventListener(ev, handler);\n      });\n    }\n  }\n\n  const preventDefault = e => {\n    e.preventDefault();\n  };\n\n  onMounted(() => {\n    const c = container.value;\n    if (!c) return;\n    c.addEventListener(\"pointerdown\", handleContainerPointerDownEvent, {\n      passive: true\n    });\n    c.addEventListener(\"click\", handleContainerClickEvent, {\n      passive: false\n    });\n    c.addEventListener(\"dblclick\", handleContainerDoubleClickEvent, {\n      passive: false\n    });\n    c.addEventListener(\"contextmenu\", handleContainerContextMenuEvent, {\n      passive: false\n    });\n\n    if (isSvgWheelZoomEnabled.value) {\n      c.addEventListener(\"wheel\", preventDefault, {\n        passive: false\n      });\n    }\n  });\n  onUnmounted(() => {\n    const c = container.value;\n    if (!c) return;\n    c.removeEventListener(\"pointerdown\", handleContainerPointerDownEvent);\n    c.removeEventListener(\"click\", handleContainerClickEvent);\n    c.removeEventListener(\"dblclick\", handleContainerDoubleClickEvent);\n    c.removeEventListener(\"contextmenu\", handleContainerContextMenuEvent);\n\n    if (isSvgWheelZoomEnabled.value) {\n      c.removeEventListener(\"wheel\", preventDefault);\n    }\n  });\n  watch(isSvgWheelZoomEnabled, (enabled, old) => {\n    const c = container.value;\n    if (!c || enabled === old) return;\n\n    if (enabled) {\n      c.addEventListener(\"wheel\", preventDefault, {\n        passive: false\n      });\n    } else {\n      c.removeEventListener(\"wheel\", preventDefault);\n    }\n  });\n}\n\nfunction makePathInteractionHandlers(pathStates, modes, hoveredPaths, selectedPaths, isInCompatibilityModeForPath, emitter) {\n  const state = {\n    pointers: /* @__PURE__ */new Map(),\n    pointerPeekCount: 0,\n    clicks: /* @__PURE__ */new Map()\n  };\n\n  function _makePathEventObject(path, event) {\n    var _a, _b;\n\n    if (isInCompatibilityModeForPath.value) {\n      return {\n        path: (_b = (_a = pathStates[path]) == null ? void 0 : _a.path) != null ? _b : path,\n        event\n      };\n    } else {\n      return {\n        path,\n        event\n      };\n    }\n  }\n\n  const pathPointerHandlers = {\n    pointerup: handlePathPointerUpEvent,\n    pointercancel: handlePathPointerCancelEvent\n  };\n  watch(selectedPaths, selected => {\n    if (selected.size > 0 && modes.selectionMode.value !== \"path\") {\n      modes.selectionMode.value = \"path\";\n    } else if (selected.size === 0 && modes.selectionMode.value === \"path\") {\n      modes.selectionMode.value = \"container\";\n    }\n  });\n  watch(modes.selectionMode, mode => {\n    if (mode !== \"path\") {\n      selectedPaths.clear();\n    }\n  });\n\n  function handlePathPointerDownEvent(path, event) {\n    var _a;\n\n    if (!((_a = pathStates[path]) == null ? void 0 : _a.clickable)) {\n      return;\n    }\n\n    if (event.button == 2) {\n      return;\n    }\n\n    event.stopPropagation();\n\n    if (![\"default\", \"path\"].includes(modes.viewMode.value)) {\n      return;\n    }\n\n    if (state.pointers.size == 0) {\n      modes.viewMode.value = \"path\";\n      entriesOf(pathPointerHandlers).forEach(([ev, handler]) => {\n        document.addEventListener(ev, handler);\n      });\n      state.pointerPeekCount = 0;\n    }\n\n    state.pointerPeekCount++;\n    const pointerState = {\n      pointerId: event.pointerId,\n      id: path,\n      eventTarget: event.currentTarget\n    };\n    state.pointers.set(event.pointerId, pointerState);\n    emitter.emit(\"path:pointerdown\", _makePathEventObject(path, event));\n  }\n\n  function handlePathPointerUpEvent(event) {\n    var _a, _b;\n\n    const pointerState = state.pointers.get(event.pointerId);\n\n    if (!pointerState) {\n      return;\n    }\n\n    event.stopPropagation();\n    state.pointers.delete(event.pointerId);\n    const path = pointerState.id;\n    emitter.emit(\"path:pointerup\", _makePathEventObject(path, event));\n    const [clickEvent, doubleClickEvent] = detectClicks(state.clicks, pointerState.pointerId, path, event);\n    (_a = pointerState.eventTarget) == null ? void 0 : _a.dispatchEvent(clickEvent);\n\n    if (doubleClickEvent) {\n      (_b = pointerState.eventTarget) == null ? void 0 : _b.dispatchEvent(doubleClickEvent);\n    }\n\n    if (state.pointers.size === 0) {\n      state.pointerPeekCount = 0;\n      entriesOf(pathPointerHandlers).forEach(([ev, handler]) => {\n        document.removeEventListener(ev, handler);\n      });\n      cleanClickState(state.clicks);\n      modes.viewMode.value = \"default\";\n    }\n  }\n\n  function handlePathPointerCancelEvent(event) {\n    const pointerState = state.pointers.get(event.pointerId);\n\n    if (!pointerState) {\n      return;\n    }\n\n    event.stopPropagation();\n\n    for (const pointerState2 of state.pointers.values()) {\n      const path = pointerState2.id;\n      emitter.emit(\"path:pointerup\", _makePathEventObject(path, event));\n    }\n\n    state.pointers.clear();\n    state.pointerPeekCount = 0;\n    entriesOf(pathPointerHandlers).forEach(([ev, handler]) => {\n      document.removeEventListener(ev, handler);\n    });\n    emitter.emit(\"view:mode\", \"default\");\n  }\n\n  function handlePathPointerOverEvent(path, event) {\n    var _a;\n\n    if (!((_a = pathStates[path]) == null ? void 0 : _a.hoverable)) {\n      return;\n    }\n\n    hoveredPaths.add(path);\n    emitter.emit(\"path:pointerover\", _makePathEventObject(path, event));\n  }\n\n  function handlePathPointerOutEvent(path, event) {\n    var _a;\n\n    if (!((_a = pathStates[path]) == null ? void 0 : _a.hoverable)) {\n      return;\n    }\n\n    hoveredPaths.delete(path);\n    emitter.emit(\"path:pointerout\", _makePathEventObject(path, event));\n  }\n\n  function handlePathClickEvent(path, event) {\n    var _a, _b, _c;\n\n    if (event.isTrusted) return;\n\n    if (!((_a = pathStates[path]) == null ? void 0 : _a.clickable)) {\n      return;\n    }\n\n    if (event.shiftKey && ![\"container\", \"path\"].includes(modes.selectionMode.value)) {\n      return;\n    }\n\n    modes.selectionMode.value = \"path\";\n    const selectable = (_c = (_b = pathStates[path]) == null ? void 0 : _b.selectable) != null ? _c : false;\n\n    if (selectable) {\n      const isTouchAnySelectedPath = MapUtil.valueOf(state.pointers).filter(p => selectedPaths.has(p.id)).length > 0;\n\n      if (event.shiftKey || isTouchAnySelectedPath) {\n        if (selectedPaths.has(path)) {\n          selectedPaths.delete(path);\n        } else if (!(typeof selectable === \"number\" && selectedPaths.size >= selectable)) {\n          selectedPaths.add(path);\n        }\n      } else if (!selectedPaths.has(path)) {\n        selectedPaths.clear();\n        selectedPaths.add(path);\n      }\n    }\n\n    emitter.emit(\"path:click\", _makePathEventObject(path, event));\n  }\n\n  function handlePathDoubleClickEvent(path, event) {\n    var _a;\n\n    if (event.isTrusted) return;\n\n    if (!((_a = pathStates[path]) == null ? void 0 : _a.clickable)) {\n      return;\n    }\n\n    emitter.emit(\"path:dblclick\", _makePathEventObject(path, event));\n  }\n\n  function handlePathContextMenu(path, event) {\n    var _a;\n\n    if (!((_a = pathStates[path]) == null ? void 0 : _a.clickable)) {\n      return;\n    }\n\n    event.stopPropagation();\n    emitter.emit(\"path:contextmenu\", _makePathEventObject(path, event));\n  }\n\n  return {\n    handlePathPointerDownEvent,\n    handlePathPointerOverEvent,\n    handlePathPointerOutEvent,\n    handlePathClickEvent,\n    handlePathDoubleClickEvent,\n    handlePathContextMenu\n  };\n}\n\nfunction baseSlice(array, start, end) {\n  var index = -1,\n      length2 = array.length;\n\n  if (start < 0) {\n    start = -start > length2 ? 0 : length2 + start;\n  }\n\n  end = end > length2 ? length2 : end;\n\n  if (end < 0) {\n    end += length2;\n  }\n\n  length2 = start > end ? 0 : end - start >>> 0;\n  start >>>= 0;\n  var result = Array(length2);\n\n  while (++index < length2) {\n    result[index] = array[index + start];\n  }\n\n  return result;\n}\n\nvar nativeCeil = Math.ceil,\n    nativeMax$1 = Math.max;\n\nfunction chunk(array, size, guard) {\n  if (guard ? isIterateeCall(array, size, guard) : size === void 0) {\n    size = 1;\n  } else {\n    size = nativeMax$1(toInteger(size), 0);\n  }\n\n  var length2 = array == null ? 0 : array.length;\n\n  if (!length2 || size < 1) {\n    return [];\n  }\n\n  var index = 0,\n      resIndex = 0,\n      result = Array(nativeCeil(length2 / size));\n\n  while (index < length2) {\n    result[resIndex++] = baseSlice(array, index, index += size);\n  }\n\n  return result;\n}\n\nvar now = function () {\n  return root$1.Date.now();\n};\n\nvar now$1 = now;\nvar FUNC_ERROR_TEXT = \"Expected a function\";\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != \"function\") {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n\n  wait = toNumber(wait) || 0;\n\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = \"maxWait\" in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = \"trailing\" in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n    lastArgs = lastThis = void 0;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    lastInvokeTime = time;\n    timerId = setTimeout(timerExpired, wait);\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        timeWaiting = wait - timeSinceLastCall;\n    return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n    return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;\n  }\n\n  function timerExpired() {\n    var time = now$1();\n\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = void 0;\n\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n\n    lastArgs = lastThis = void 0;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== void 0) {\n      clearTimeout(timerId);\n    }\n\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = void 0;\n  }\n\n  function flush() {\n    return timerId === void 0 ? result : trailingEdge(now$1());\n  }\n\n  function debounced() {\n    var time = now$1(),\n        isInvoking = shouldInvoke(time);\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === void 0) {\n        return leadingEdge(lastCallTime);\n      }\n\n      if (maxing) {\n        clearTimeout(timerId);\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n\n    if (timerId === void 0) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n\n    return result;\n  }\n\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\nfunction translateFromDomToSvgCoordinates(svg, viewport, coordinates) {\n  var _a;\n\n  const point = svg.createSVGPoint();\n  point.x = coordinates.x;\n  point.y = coordinates.y;\n  const svgPoint = point.matrixTransform((_a = viewport.getCTM()) == null ? void 0 : _a.inverse());\n  return {\n    x: svgPoint.x,\n    y: svgPoint.y\n  };\n}\n\nfunction translateFromSvgToDomCoordinates(svg, viewport, coordinates) {\n  const point = svg.createSVGPoint();\n  point.x = coordinates.x;\n  point.y = coordinates.y;\n  const domPoint = point.matrixTransform(viewport.getCTM());\n  return {\n    x: domPoint.x,\n    y: domPoint.y\n  };\n}\n\nfunction makeBoxSelectionMethods(container, modes, layouts, nodeStates, selectedNodes, configs) {\n  const isBoxSelectionEnabled = computed(() => !!configs.node.selectable && configs.view.boxSelectionEnabled);\n  const isBoxSelectionMode = computed(() => modes.viewMode.value === \"box-selection\");\n  const viewport = ref();\n  const selectionBox = ref();\n  const states = {\n    pointers: /* @__PURE__ */new Set(),\n    points: /* @__PURE__ */new Map(),\n    startPoint: null,\n    selectedNodesAtSelectStarted: /* @__PURE__ */new Set(),\n    selectionType: \"append\",\n    options: {\n      stopTrigger: \"pointerup\",\n      selectionType: \"append\",\n      selectionTypeWithShiftKey: \"same\"\n    }\n  };\n  const updateNodesSelection = debounce(() => {\n    _updateNodesSelection(nonNull(container.value, \"container\"), nonNull(viewport.value, \"viewport\"), selectionBox, layouts.nodes, nodeStates, selectedNodes, states.selectedNodesAtSelectStarted, states.selectionType);\n  }, 50, {\n    maxWait: 100\n  });\n  const pointerEventHandler = new PointerEventRegistrar(container, handlePointerDownEvent, handlePointerUpEvent, handlePointerMoveEvent, handleClickEvent, handleKeyDownEvent);\n\n  function handleClickEvent(event) {\n    if (states.options.stopTrigger !== \"click\") return;\n    if (states.pointers.size > 0) return;\n    const point = {\n      x: event.offsetX,\n      y: event.offsetY\n    };\n\n    if (states.startPoint && Vector2D.fromObject(states.startPoint).distance(point) > 10) {\n      return;\n    }\n\n    stopBoxSelection();\n  }\n\n  function handlePointerDownEvent(event) {\n    event.stopPropagation();\n    const point = {\n      x: event.offsetX,\n      y: event.offsetY\n    };\n\n    if (states.pointers.size === 0) {\n      states.startPoint = point;\n      pointerEventHandler.activate();\n      states.selectedNodesAtSelectStarted.clear();\n      selectedNodes.forEach(nodeId => states.selectedNodesAtSelectStarted.add(nodeId));\n\n      if (states.options.selectionTypeWithShiftKey === \"same\") {\n        states.selectionType = states.options.selectionType;\n      } else {\n        states.selectionType = event.shiftKey ? states.options.selectionTypeWithShiftKey : states.options.selectionType;\n      }\n    }\n\n    if (!states.pointers.has(event.pointerId)) {\n      states.pointers.add(event.pointerId);\n    }\n\n    states.points.set(event.pointerId, point);\n    updateRectangle();\n  }\n\n  function handlePointerUpEvent(event) {\n    states.pointers.delete(event.pointerId);\n\n    if (states.pointers.size === 1) {\n      const rect = nonNull(container.value).getBoundingClientRect();\n      const point = {\n        x: event.x - rect.x,\n        y: event.y - rect.y\n      };\n      states.startPoint = point;\n    } else if (states.pointers.size === 0) {\n      pointerEventHandler.deactivate();\n\n      if (states.options.stopTrigger === \"pointerup\") {\n        stopBoxSelection();\n      }\n\n      states.selectedNodesAtSelectStarted.clear();\n    }\n\n    updateRectangle();\n  }\n\n  function handlePointerMoveEvent(event) {\n    const rect = nonNull(container.value).getBoundingClientRect();\n    const point = {\n      x: event.x - rect.x,\n      y: event.y - rect.y\n    };\n    states.points.set(event.pointerId, point);\n    updateRectangle();\n    updateNodesSelection();\n  }\n\n  function handleKeyDownEvent(event) {\n    if (event.key === \"Escape\" && states.options.stopTrigger !== \"manual\") {\n      event.stopPropagation();\n      stopBoxSelection();\n    }\n  }\n\n  function updateRectangle() {\n    let pos1;\n    let pos2;\n    const pointerArray = Array.from(states.pointers);\n\n    if (pointerArray.length >= 2) {\n      const first = pointerArray[0];\n      const last = pointerArray[pointerArray.length - 1];\n      pos1 = states.points.get(first);\n      pos2 = states.points.get(last);\n    } else if (states.startPoint && pointerArray.length === 1) {\n      const first = pointerArray[0];\n      pos1 = states.startPoint;\n      pos2 = states.points.get(first);\n    } else {\n      pos1 = void 0;\n      pos2 = void 0;\n    }\n\n    if (pos1 && pos2) {\n      selectionBox.value = {\n        pos: {\n          x: Math.min(pos1.x, pos2.x),\n          y: Math.min(pos1.y, pos2.y)\n        },\n        size: {\n          width: Math.abs(pos2.x - pos1.x),\n          height: Math.abs(pos2.y - pos1.y)\n        }\n      };\n\n      if (selectionBox.value.size.width === 0) {\n        selectionBox.value.size.width = 1;\n      }\n\n      if (selectionBox.value.size.height === 0) {\n        selectionBox.value.size.height = 1;\n      }\n    } else if (selectionBox.value) {\n      selectionBox.value = void 0;\n    }\n  }\n\n  const keyEventRegistrar = new KeyEventRegistrar(container, event => {\n    if (!isBoxSelectionEnabled.value) return;\n\n    if (configs.view.selection.detector(event)) {\n      startBoxSelection({\n        stop: \"manual\",\n        type: \"append\",\n        withShiftKey: \"invert\"\n      });\n      keyEventRegistrar.activate();\n    }\n  }, event => {\n    if (!isBoxSelectionEnabled.value) return;\n\n    if (configs.view.selection.detector(event)) {\n      if (states.pointers.size === 0) {\n        stopBoxSelection();\n      } else {\n        states.options.stopTrigger = \"pointerup\";\n      }\n\n      keyEventRegistrar.deactivate();\n    }\n  });\n  watch(isBoxSelectionEnabled, value => {\n    if (value) {\n      keyEventRegistrar.register();\n    } else {\n      keyEventRegistrar.unregister();\n    }\n  });\n  onMounted(() => {\n    var _a;\n\n    viewport.value = (_a = container.value) == null ? void 0 : _a.querySelector(\".v-viewport\");\n\n    if (isBoxSelectionEnabled.value) {\n      keyEventRegistrar.register();\n    }\n  });\n  onUnmounted(() => {\n    stopBoxSelection();\n\n    if (isBoxSelectionEnabled.value) {\n      keyEventRegistrar.unregister();\n    }\n  });\n\n  function startBoxSelection(options = {}) {\n    var _a, _b, _c;\n\n    states.options = {\n      stopTrigger: (_a = options.stop) != null ? _a : \"pointerup\",\n      selectionType: (_b = options.type) != null ? _b : \"append\",\n      selectionTypeWithShiftKey: (_c = options.withShiftKey) != null ? _c : \"same\"\n    };\n    if (modes.viewMode.value === \"box-selection\") return;\n    modes.viewMode.value = \"box-selection\";\n    states.pointers.clear();\n    pointerEventHandler.register();\n  }\n\n  function stopBoxSelection() {\n    if (modes.viewMode.value !== \"box-selection\") return;\n    modes.viewMode.value = \"default\";\n    pointerEventHandler.unregister();\n  }\n\n  return {\n    isBoxSelectionMode,\n    selectionBox,\n    startBoxSelection,\n    stopBoxSelection\n  };\n}\n\nfunction _updateNodesSelection(svg, viewport, selectionBox, nodePositions, nodeStates, selectedNodes, selectedNodesAtSelectStarted, selectionType) {\n  if (!selectionBox.value) return;\n  const box = selectionBox.value;\n  const pos1 = translateFromDomToSvgCoordinates(svg, viewport, box.pos);\n  const pos2 = translateFromDomToSvgCoordinates(svg, viewport, {\n    x: box.pos.x + box.size.width,\n    y: box.pos.y + box.size.height\n  });\n  const enclosedNodes = new Set(Object.entries(nodePositions).filter(([_, pos]) => {\n    return pos1.x <= pos.x && pos.x <= pos2.x && pos1.y <= pos.y && pos.y <= pos2.y;\n  }).map(([nodeId, _]) => nodeId));\n\n  if (selectionType === \"append\") {\n    selectedNodes.forEach(nodeId => {\n      if (!enclosedNodes.has(nodeId)) {\n        selectedNodes.delete(nodeId);\n      }\n    });\n    enclosedNodes.forEach(nodeId => {\n      var _a, _b;\n\n      const selectable = (_b = (_a = nodeStates[nodeId]) == null ? void 0 : _a.selectable) != null ? _b : false;\n\n      if (selectable === true || typeof selectable === \"number\" && selectedNodes.size < selectable) {\n        selectedNodes.add(nodeId);\n      }\n    });\n  } else {\n    const temporary = new Set(selectedNodesAtSelectStarted);\n    temporary.forEach(nodeId => {\n      if (enclosedNodes.has(nodeId)) {\n        temporary.delete(nodeId);\n      }\n    });\n    enclosedNodes.forEach(nodeId => {\n      var _a, _b;\n\n      if (!selectedNodesAtSelectStarted.has(nodeId)) {\n        const selectable = (_b = (_a = nodeStates[nodeId]) == null ? void 0 : _a.selectable) != null ? _b : false;\n\n        if (selectable === true || typeof selectable === \"number\" && temporary.size < selectable) {\n          temporary.add(nodeId);\n        }\n      }\n    });\n    selectedNodes.clear();\n    temporary.forEach(nodeId => selectedNodes.add(nodeId));\n  }\n}\n\nclass PointerEventRegistrar {\n  constructor(container, handlePointerDownEvent, handlePointerUpEvent, handlePointerMoveEvent, handleClickEvent, handleKeyDownEvent) {\n    this._container = container;\n    this._handlePointerDownEvent = handlePointerDownEvent;\n    this._handlePointerUpEvent = handlePointerUpEvent;\n    this._handlePointerMoveEvent = handlePointerMoveEvent;\n    this._handleClickEvent = handleClickEvent;\n    this._handleKeyDownEvent = handleKeyDownEvent;\n\n    this._ignoreEvent = event => event.stopPropagation();\n  }\n\n  register() {\n    const options = {\n      capture: true,\n      passive: false\n    };\n    const container = nonNull(this._container.value, \"container\");\n    container.addEventListener(\"pointerdown\", this._handlePointerDownEvent, options);\n    container.addEventListener(\"click\", this._handleClickEvent, options);\n    container.addEventListener(\"pointerenter\", this._ignoreEvent, options);\n    container.addEventListener(\"pointerleave\", this._ignoreEvent, options);\n    document.addEventListener(\"keydown\", this._handleKeyDownEvent, options);\n  }\n\n  activate() {\n    const options = {\n      capture: true,\n      passive: false\n    };\n    document.addEventListener(\"pointermove\", this._handlePointerMoveEvent, options);\n    document.addEventListener(\"pointerup\", this._handlePointerUpEvent, options);\n  }\n\n  deactivate() {\n    const options = {\n      capture: true\n    };\n    document.removeEventListener(\"pointermove\", this._handlePointerMoveEvent, options);\n    document.removeEventListener(\"pointerup\", this._handlePointerUpEvent, options);\n  }\n\n  unregister() {\n    this.deactivate();\n    const options = {\n      capture: true\n    };\n\n    if (this._container.value) {\n      const container = this._container.value;\n      container.removeEventListener(\"pointerdown\", this._handlePointerDownEvent, options);\n      container.removeEventListener(\"click\", this._handleClickEvent, options);\n      container.removeEventListener(\"pointerenter\", this._ignoreEvent, options);\n      container.removeEventListener(\"pointerleave\", this._ignoreEvent, options);\n      document.removeEventListener(\"keydown\", this._handleKeyDownEvent, options);\n    }\n  }\n\n}\n\nclass KeyEventRegistrar {\n  constructor(container, handleKeyDownEvent, handleKeyUpEvent) {\n    this._container = container;\n    this._handleKeyDownEvent = handleKeyDownEvent;\n    this._handleKeyUpEvent = handleKeyUpEvent;\n\n    this._preventDefault = event => {\n      event.stopPropagation();\n      event.preventDefault();\n    };\n  }\n\n  register() {\n    document.addEventListener(\"keydown\", this._handleKeyDownEvent, {\n      capture: true,\n      passive: true\n    });\n  }\n\n  activate() {\n    document.addEventListener(\"keyup\", this._handleKeyUpEvent, {\n      capture: true,\n      passive: true\n    });\n    const container = nonNull(this._container.value, \"container\");\n    container.addEventListener(\"contextmenu\", this._preventDefault, {\n      passive: false\n    });\n  }\n\n  deactivate() {\n    document.removeEventListener(\"keyup\", this._handleKeyUpEvent, {\n      capture: true\n    });\n\n    if (this._container.value) {\n      const container = this._container.value;\n      container.removeEventListener(\"contextmenu\", this._preventDefault);\n    }\n  }\n\n  unregister() {\n    this.deactivate();\n    document.removeEventListener(\"keydown\", this._handleKeyDownEvent, {\n      capture: true\n    });\n  }\n\n}\n\nconst mouseEventHandlersKey = Symbol(\"mouseEventHandlers\");\n\nfunction provideMouseOperation(container, layouts, zoomLevel, nodeStates, edgeStates, pathStates, selectedNodes, selectedEdges, selectedPaths, hoveredNodes, hoveredEdges, hoveredPaths, isInCompatibilityModeForPath, isSvgWheelZoomEnabled, configs, emitter) {\n  const modes = {\n    selectionMode: ref(\"container\"),\n    viewMode: ref(\"default\")\n  };\n\n  if (selectedNodes.size > 0) {\n    modes.selectionMode.value = \"node\";\n  } else if (selectedEdges.size > 0) {\n    modes.selectionMode.value = \"edge\";\n  } else if (selectedPaths.size > 0) {\n    modes.selectionMode.value = \"path\";\n  }\n\n  watch(modes.viewMode, mode => {\n    emitter.emit(\"view:mode\", mode);\n  });\n  setupContainerInteractionHandlers(container, modes, isSvgWheelZoomEnabled, emitter);\n\n  const provides = __spreadValues(__spreadValues(__spreadValues(__spreadValues({\n    selectedNodes,\n    hoveredNodes,\n    selectedEdges,\n    hoveredEdges,\n    selectedPaths,\n    hoveredPaths\n  }, makeNodeInteractionHandlers(nodeStates, layouts, modes, hoveredNodes, selectedNodes, zoomLevel, emitter)), makeEdgeInteractionHandlers(edgeStates, modes, hoveredEdges, selectedEdges, emitter)), makePathInteractionHandlers(pathStates, modes, hoveredPaths, selectedPaths, isInCompatibilityModeForPath, emitter)), makeBoxSelectionMethods(container, modes, layouts, nodeStates, selectedNodes, configs));\n\n  provide(mouseEventHandlersKey, provides);\n  return provides;\n}\n\nfunction useMouseOperation() {\n  return nonNull(inject(mouseEventHandlersKey), \"mouseEventHandlers\");\n}\n\nfunction mitt(n) {\n  return {\n    all: n = n || /* @__PURE__ */new Map(),\n    on: function (t, e) {\n      var i = n.get(t);\n      i ? i.push(e) : n.set(t, [e]);\n    },\n    off: function (t, e) {\n      var i = n.get(t);\n      i && (e ? i.splice(i.indexOf(e) >>> 0, 1) : n.set(t, []));\n    },\n    emit: function (t, e) {\n      var i = n.get(t);\n      i && i.slice().map(function (n2) {\n        n2(e);\n      }), (i = n.get(\"*\")) && i.slice().map(function (n2) {\n        n2(t, e);\n      });\n    }\n  };\n}\n\nconst eventEmitterKey = Symbol(\"emitter\");\n\nfunction provideEventEmitter() {\n  const emitter = mitt();\n  provide(eventEmitterKey, emitter);\n  return emitter;\n}\n\nfunction useEventEmitter() {\n  return nonNull(inject(eventEmitterKey), \"event emitter\");\n}\n\nvar commonjsGlobal = typeof globalThis !== \"undefined\" ? globalThis : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : {};\nvar utilities = {\n  getGlobalThis: function () {\n    if (typeof globalThis !== \"undefined\") return globalThis;\n    if (typeof self !== \"undefined\") return self;\n    if (typeof window !== \"undefined\") return window;\n    if (typeof commonjsGlobal !== \"undefined\") return commonjsGlobal;\n    if (typeof this !== \"undefined\") return this;\n    throw new Error(\"Unable to locate global `this`\");\n  },\n  extend: function (target, source) {\n    target = target || {};\n\n    for (var prop in source) {\n      if (this.isObject(source[prop])) {\n        target[prop] = this.extend(target[prop], source[prop]);\n      } else {\n        target[prop] = source[prop];\n      }\n    }\n\n    return target;\n  },\n  isElement: function (o) {\n    return o instanceof HTMLElement || o instanceof SVGElement || o instanceof SVGSVGElement || o && typeof o === \"object\" && o !== null && o.nodeType === 1 && typeof o.nodeName === \"string\";\n  },\n  isObject: function (o) {\n    return Object.prototype.toString.call(o) === \"[object Object]\";\n  },\n  isNumber: function (n) {\n    return !isNaN(parseFloat(n)) && isFinite(n);\n  },\n  getSvg: function (elementOrSelector) {\n    var element, svg;\n\n    if (!this.isElement(elementOrSelector)) {\n      if (typeof elementOrSelector === \"string\" || elementOrSelector instanceof String) {\n        element = document.querySelector(elementOrSelector);\n\n        if (!element) {\n          throw new Error(\"Provided selector did not find any elements. Selector: \" + elementOrSelector);\n        }\n      } else {\n        throw new Error(\"Provided selector is not an HTML object nor String\");\n      }\n    } else {\n      element = elementOrSelector;\n    }\n\n    if (element.tagName.toLowerCase() === \"svg\") {\n      svg = element;\n    } else {\n      if (element.tagName.toLowerCase() === \"object\") {\n        svg = element.contentDocument.documentElement;\n      } else {\n        if (element.tagName.toLowerCase() === \"embed\") {\n          svg = element.getSVGDocument().documentElement;\n        } else {\n          if (element.tagName.toLowerCase() === \"img\") {\n            throw new Error('Cannot script an SVG in an \"img\" element. Please use an \"object\" element or an in-line SVG.');\n          } else {\n            throw new Error(\"Cannot get SVG.\");\n          }\n        }\n      }\n    }\n\n    return svg;\n  },\n  proxy: function (fn, context) {\n    return function () {\n      return fn.apply(context, arguments);\n    };\n  },\n  getType: function (o) {\n    return Object.prototype.toString.apply(o).replace(/^\\[object\\s/, \"\").replace(/\\]$/, \"\");\n  },\n  mouseAndTouchNormalize: function (evt, svg) {\n    if (evt.clientX === void 0 || evt.clientX === null) {\n      evt.clientX = 0;\n      evt.clientY = 0;\n\n      if (evt.touches !== void 0 && evt.touches.length) {\n        if (evt.touches[0].clientX !== void 0) {\n          evt.clientX = evt.touches[0].clientX;\n          evt.clientY = evt.touches[0].clientY;\n        } else if (evt.touches[0].pageX !== void 0) {\n          var rect = svg.getBoundingClientRect();\n          evt.clientX = evt.touches[0].pageX - rect.left;\n          evt.clientY = evt.touches[0].pageY - rect.top;\n        }\n      } else if (evt.originalEvent !== void 0) {\n        if (evt.originalEvent.clientX !== void 0) {\n          evt.clientX = evt.originalEvent.clientX;\n          evt.clientY = evt.originalEvent.clientY;\n        }\n      }\n    }\n  },\n  touchNormalize: function (evt, svg, touch) {\n    if (evt.touches !== void 0 && evt.touches.length) {\n      if (evt.touches[touch].clientX !== void 0) {\n        evt.clientX = evt.touches[touch].clientX;\n        evt.clientY = evt.touches[touch].clientY;\n      } else if (evt.touches[touch].pageX !== void 0) {\n        var rect = svg.getBoundingClientRect();\n        evt.clientX = evt.touches[touch].pageX - rect.left;\n        evt.clientY = evt.touches[touch].pageY - rect.top;\n      }\n    } else {\n      if (evt.clientX === void 0 || evt.clientX === null) {\n        evt.clientX = 0;\n        evt.clientY = 0;\n\n        if (evt.originalEvent !== void 0) {\n          if (evt.originalEvent.clientX !== void 0) {\n            evt.clientX = evt.originalEvent.clientX;\n            evt.clientY = evt.originalEvent.clientY;\n          }\n        }\n      }\n    }\n  },\n  isDblClick: function (evt, prevEvt) {\n    if (evt.detail === 2) {\n      return true;\n    } else if (prevEvt !== void 0 && prevEvt !== null) {\n      var timeStampDiff = evt.timeStamp - prevEvt.timeStamp,\n          touchesDistance = Math.sqrt(Math.pow(evt.clientX - prevEvt.clientX, 2) + Math.pow(evt.clientY - prevEvt.clientY, 2));\n      return timeStampDiff < 250 && touchesDistance < 10;\n    }\n\n    return false;\n  },\n  now: Date.now || function () {\n    return new Date().getTime();\n  },\n  throttle: function (func, wait, options) {\n    var that = this;\n    var context, args, result;\n    var timeout = null;\n    var previous = 0;\n\n    if (!options) {\n      options = {};\n    }\n\n    var later = function () {\n      previous = options.leading === false ? 0 : that.now();\n      timeout = null;\n      result = func.apply(context, args);\n\n      if (!timeout) {\n        context = args = null;\n      }\n    };\n\n    return function () {\n      var now2 = that.now();\n\n      if (!previous && options.leading === false) {\n        previous = now2;\n      }\n\n      var remaining = wait - (now2 - previous);\n      context = this;\n      args = arguments;\n\n      if (remaining <= 0 || remaining > wait) {\n        clearTimeout(timeout);\n        timeout = null;\n        previous = now2;\n        result = func.apply(context, args);\n\n        if (!timeout) {\n          context = args = null;\n        }\n      } else if (!timeout && options.trailing !== false) {\n        timeout = setTimeout(later, remaining);\n      }\n\n      return result;\n    };\n  },\n  createRequestAnimationFrame: function (refreshRate) {\n    var timeout = null;\n\n    if (refreshRate !== \"auto\" && refreshRate < 60 && refreshRate > 1) {\n      timeout = Math.floor(1e3 / refreshRate);\n    }\n\n    if (timeout === null) {\n      return window.requestAnimationFrame || requestTimeout(33);\n    } else {\n      return requestTimeout(timeout);\n    }\n  },\n  calculateDistance: function (point1, point2) {\n    var dx = point1.x - point2.x;\n    var dy = point1.y - point2.y;\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n};\n\nfunction requestTimeout(timeout) {\n  return function (callback) {\n    window.setTimeout(callback, timeout);\n  };\n}\n\nvar Utils$3 = utilities;\n\nvar uniwheel = function () {\n  var prefix = \"\",\n      _addEventListener,\n      _removeEventListener,\n      support,\n      fns = [];\n\n  var passiveTrueOption = {\n    passive: true\n  };\n  var passiveFalseOption = {\n    passive: false\n  };\n\n  if (Utils$3.getGlobalThis().addEventListener) {\n    _addEventListener = \"addEventListener\";\n    _removeEventListener = \"removeEventListener\";\n  } else {\n    _addEventListener = \"attachEvent\";\n    _removeEventListener = \"detachEvent\";\n    prefix = \"on\";\n  }\n\n  function getSupport() {\n    if (!support) {\n      support = \"onwheel\" in document.createElement(\"div\") ? \"wheel\" : document.onmousewheel !== void 0 ? \"mousewheel\" : \"DOMMouseScroll\";\n    }\n\n    return support;\n  }\n\n  function createCallback(element, callback) {\n    var fn = function (originalEvent) {\n      !originalEvent && (originalEvent = window.event);\n      var event = {\n        originalEvent,\n        target: originalEvent.target || originalEvent.srcElement,\n        type: \"wheel\",\n        deltaMode: originalEvent.type == \"MozMousePixelScroll\" ? 0 : 1,\n        deltaX: 0,\n        delatZ: 0,\n        preventDefault: function () {\n          originalEvent.preventDefault ? originalEvent.preventDefault() : originalEvent.returnValue = false;\n        }\n      };\n\n      if (getSupport() == \"mousewheel\") {\n        event.deltaY = -1 / 40 * originalEvent.wheelDelta;\n        originalEvent.wheelDeltaX && (event.deltaX = -1 / 40 * originalEvent.wheelDeltaX);\n      } else {\n        event.deltaY = originalEvent.detail;\n      }\n\n      return callback(event);\n    };\n\n    fns.push({\n      element,\n      fn\n    });\n    return fn;\n  }\n\n  function getCallback(element) {\n    for (var i = 0; i < fns.length; i++) {\n      if (fns[i].element === element) {\n        return fns[i].fn;\n      }\n    }\n\n    return function () {};\n  }\n\n  function removeCallback(element) {\n    for (var i = 0; i < fns.length; i++) {\n      if (fns[i].element === element) {\n        return fns.splice(i, 1);\n      }\n    }\n  }\n\n  function _addWheelListener(elem, eventName, callback, isPassiveListener) {\n    var cb;\n\n    if (getSupport() === \"wheel\") {\n      cb = callback;\n    } else {\n      cb = createCallback(elem, callback);\n    }\n\n    elem[_addEventListener](prefix + eventName, cb, isPassiveListener ? passiveTrueOption : passiveFalseOption);\n  }\n\n  function _removeWheelListener(elem, eventName, callback, isPassiveListener) {\n    var cb;\n\n    if (getSupport() === \"wheel\") {\n      cb = callback;\n    } else {\n      cb = getCallback(elem);\n    }\n\n    elem[_removeEventListener](prefix + eventName, cb, isPassiveListener ? passiveTrueOption : passiveFalseOption);\n\n    removeCallback(elem);\n  }\n\n  function addWheelListener(elem, callback, isPassiveListener) {\n    _addWheelListener(elem, getSupport(), callback, isPassiveListener);\n\n    if (getSupport() == \"DOMMouseScroll\") {\n      _addWheelListener(elem, \"MozMousePixelScroll\", callback, isPassiveListener);\n    }\n  }\n\n  function removeWheelListener(elem, callback, isPassiveListener) {\n    _removeWheelListener(elem, getSupport(), callback, isPassiveListener);\n\n    if (getSupport() == \"DOMMouseScroll\") {\n      _removeWheelListener(elem, \"MozMousePixelScroll\", callback, isPassiveListener);\n    }\n  }\n\n  return {\n    on: addWheelListener,\n    off: removeWheelListener\n  };\n}();\n\nvar Utils$2 = utilities,\n    _browser = \"unknown\";\n\nif (typeof document != \"undefined\" && !!document.documentMode) {\n  _browser = \"ie\";\n}\n\nvar svgUtilities = {\n  svgNS: \"http://www.w3.org/2000/svg\",\n  xmlNS: \"http://www.w3.org/XML/1998/namespace\",\n  xmlnsNS: \"http://www.w3.org/2000/xmlns/\",\n  xlinkNS: \"http://www.w3.org/1999/xlink\",\n  evNS: \"http://www.w3.org/2001/xml-events\",\n  getBoundingClientRectNormalized: function (svg) {\n    if (svg.clientWidth && svg.clientHeight) {\n      return {\n        width: svg.clientWidth,\n        height: svg.clientHeight\n      };\n    } else if (!!svg.getBoundingClientRect()) {\n      return svg.getBoundingClientRect();\n    } else {\n      throw new Error(\"Cannot get BoundingClientRect for SVG.\");\n    }\n  },\n  getOrCreateViewport: function (svg, selector) {\n    var viewport = null;\n\n    if (Utils$2.isElement(selector)) {\n      viewport = selector;\n    } else {\n      viewport = svg.querySelector(selector);\n    }\n\n    if (!viewport) {\n      var childNodes = Array.prototype.slice.call(svg.childNodes || svg.children).filter(function (el) {\n        return el.nodeName !== \"defs\" && el.nodeName !== \"#text\";\n      });\n\n      if (childNodes.length === 1 && childNodes[0].nodeName === \"g\" && childNodes[0].getAttribute(\"transform\") === null) {\n        viewport = childNodes[0];\n      }\n    }\n\n    if (!viewport) {\n      var viewportId = \"viewport-\" + new Date().toISOString().replace(/\\D/g, \"\");\n      viewport = document.createElementNS(this.svgNS, \"g\");\n      viewport.setAttribute(\"id\", viewportId);\n      var svgChildren = svg.childNodes || svg.children;\n\n      if (!!svgChildren && svgChildren.length > 0) {\n        for (var i = svgChildren.length; i > 0; i--) {\n          if (svgChildren[svgChildren.length - i].nodeName !== \"defs\") {\n            viewport.appendChild(svgChildren[svgChildren.length - i]);\n          }\n        }\n      }\n\n      svg.appendChild(viewport);\n    }\n\n    var classNames = [];\n\n    if (viewport.getAttribute(\"class\")) {\n      classNames = viewport.getAttribute(\"class\").split(\" \");\n    }\n\n    if (!~classNames.indexOf(\"svg-pan-zoom_viewport\")) {\n      classNames.push(\"svg-pan-zoom_viewport\");\n      viewport.setAttribute(\"class\", classNames.join(\" \"));\n    }\n\n    return viewport;\n  },\n  setupSvgAttributes: function (svg) {\n    svg.setAttribute(\"xmlns\", this.svgNS);\n    svg.setAttributeNS(this.xmlnsNS, \"xmlns:xlink\", this.xlinkNS);\n    svg.setAttributeNS(this.xmlnsNS, \"xmlns:ev\", this.evNS);\n\n    if (svg.parentNode !== null) {\n      var style = svg.getAttribute(\"style\") || \"\";\n\n      if (style.toLowerCase().indexOf(\"overflow\") === -1) {\n        svg.setAttribute(\"style\", \"overflow: hidden; \" + style);\n      }\n    }\n  },\n  internetExplorerRedisplayInterval: 300,\n  refreshDefsGlobal: Utils$2.throttle(function () {\n    var allDefs = document.querySelectorAll(\"defs\");\n    var allDefsCount = allDefs.length;\n\n    for (var i = 0; i < allDefsCount; i++) {\n      var thisDefs = allDefs[i];\n      thisDefs.parentNode.insertBefore(thisDefs, thisDefs);\n    }\n  }, commonjsGlobal ? commonjsGlobal.internetExplorerRedisplayInterval : null),\n  setCTM: function (element, matrix, defs) {\n    var that = this,\n        s = \"matrix(\" + matrix.a + \",\" + matrix.b + \",\" + matrix.c + \",\" + matrix.d + \",\" + matrix.e + \",\" + matrix.f + \")\";\n    element.setAttributeNS(null, \"transform\", s);\n\n    if (\"transform\" in element.style) {\n      element.style.transform = s;\n    } else if (\"-ms-transform\" in element.style) {\n      element.style[\"-ms-transform\"] = s;\n    } else if (\"-webkit-transform\" in element.style) {\n      element.style[\"-webkit-transform\"] = s;\n    }\n\n    if (_browser === \"ie\" && !!defs) {\n      defs.parentNode.insertBefore(defs, defs);\n      window.setTimeout(function () {\n        that.refreshDefsGlobal();\n      }, that.internetExplorerRedisplayInterval);\n    }\n  },\n  getEventPoint: function (evt, svg) {\n    var point = svg.createSVGPoint();\n    Utils$2.mouseAndTouchNormalize(evt, svg);\n    point.x = evt.clientX;\n    point.y = evt.clientY;\n    return point;\n  },\n  getTouchPoint: function (evt, svg, touch) {\n    var point = svg.createSVGPoint();\n    Utils$2.touchNormalize(evt, svg, touch);\n    point.x = evt.clientX;\n    point.y = evt.clientY;\n    return point;\n  },\n  getSvgCenterPoint: function (svg, width, height) {\n    return this.createSVGPoint(svg, width / 2, height / 2);\n  },\n  createSVGPoint: function (svg, x, y) {\n    var point = svg.createSVGPoint();\n    point.x = x;\n    point.y = y;\n    return point;\n  }\n};\nvar SvgUtils$2 = svgUtilities;\nvar controlIcons = {\n  enable: function (instance) {\n    var defs = instance.svg.querySelector(\"defs\");\n\n    if (!defs) {\n      defs = document.createElementNS(SvgUtils$2.svgNS, \"defs\");\n      instance.svg.appendChild(defs);\n    }\n\n    var styleEl = defs.querySelector(\"style#svg-pan-zoom-controls-styles\");\n\n    if (!styleEl) {\n      var style = document.createElementNS(SvgUtils$2.svgNS, \"style\");\n      style.setAttribute(\"id\", \"svg-pan-zoom-controls-styles\");\n      style.setAttribute(\"type\", \"text/css\");\n      style.textContent = \".svg-pan-zoom-control { cursor: pointer; fill: black; fill-opacity: 0.333; } .svg-pan-zoom-control:hover { fill-opacity: 0.8; } .svg-pan-zoom-control-background { fill: white; fill-opacity: 0.5; } .svg-pan-zoom-control-background { fill-opacity: 0.8; }\";\n      defs.appendChild(style);\n    }\n\n    var zoomGroup = document.createElementNS(SvgUtils$2.svgNS, \"g\");\n    zoomGroup.setAttribute(\"id\", \"svg-pan-zoom-controls\");\n    zoomGroup.setAttribute(\"transform\", \"translate(\" + (instance.width - 70) + \" \" + (instance.height - 76) + \") scale(0.75)\");\n    zoomGroup.setAttribute(\"class\", \"svg-pan-zoom-control\");\n    zoomGroup.appendChild(this._createZoomIn(instance));\n    zoomGroup.appendChild(this._createZoomReset(instance));\n    zoomGroup.appendChild(this._createZoomOut(instance));\n    instance.svg.appendChild(zoomGroup);\n    instance.controlIcons = zoomGroup;\n  },\n  _createZoomIn: function (instance) {\n    var zoomIn = document.createElementNS(SvgUtils$2.svgNS, \"g\");\n    zoomIn.setAttribute(\"id\", \"svg-pan-zoom-zoom-in\");\n    zoomIn.setAttribute(\"transform\", \"translate(30.5 5) scale(0.015)\");\n    zoomIn.setAttribute(\"class\", \"svg-pan-zoom-control\");\n    zoomIn.addEventListener(\"click\", function () {\n      instance.getPublicInstance().zoomIn();\n    }, false);\n    zoomIn.addEventListener(\"touchstart\", function () {\n      instance.getPublicInstance().zoomIn();\n    }, false);\n    var zoomInBackground = document.createElementNS(SvgUtils$2.svgNS, \"rect\");\n    zoomInBackground.setAttribute(\"x\", \"0\");\n    zoomInBackground.setAttribute(\"y\", \"0\");\n    zoomInBackground.setAttribute(\"width\", \"1500\");\n    zoomInBackground.setAttribute(\"height\", \"1400\");\n    zoomInBackground.setAttribute(\"class\", \"svg-pan-zoom-control-background\");\n    zoomIn.appendChild(zoomInBackground);\n    var zoomInShape = document.createElementNS(SvgUtils$2.svgNS, \"path\");\n    zoomInShape.setAttribute(\"d\", \"M1280 576v128q0 26 -19 45t-45 19h-320v320q0 26 -19 45t-45 19h-128q-26 0 -45 -19t-19 -45v-320h-320q-26 0 -45 -19t-19 -45v-128q0 -26 19 -45t45 -19h320v-320q0 -26 19 -45t45 -19h128q26 0 45 19t19 45v320h320q26 0 45 19t19 45zM1536 1120v-960 q0 -119 -84.5 -203.5t-203.5 -84.5h-960q-119 0 -203.5 84.5t-84.5 203.5v960q0 119 84.5 203.5t203.5 84.5h960q119 0 203.5 -84.5t84.5 -203.5z\");\n    zoomInShape.setAttribute(\"class\", \"svg-pan-zoom-control-element\");\n    zoomIn.appendChild(zoomInShape);\n    return zoomIn;\n  },\n  _createZoomReset: function (instance) {\n    var resetPanZoomControl = document.createElementNS(SvgUtils$2.svgNS, \"g\");\n    resetPanZoomControl.setAttribute(\"id\", \"svg-pan-zoom-reset-pan-zoom\");\n    resetPanZoomControl.setAttribute(\"transform\", \"translate(5 35) scale(0.4)\");\n    resetPanZoomControl.setAttribute(\"class\", \"svg-pan-zoom-control\");\n    resetPanZoomControl.addEventListener(\"click\", function () {\n      instance.getPublicInstance().reset();\n    }, false);\n    resetPanZoomControl.addEventListener(\"touchstart\", function () {\n      instance.getPublicInstance().reset();\n    }, false);\n    var resetPanZoomControlBackground = document.createElementNS(SvgUtils$2.svgNS, \"rect\");\n    resetPanZoomControlBackground.setAttribute(\"x\", \"2\");\n    resetPanZoomControlBackground.setAttribute(\"y\", \"2\");\n    resetPanZoomControlBackground.setAttribute(\"width\", \"182\");\n    resetPanZoomControlBackground.setAttribute(\"height\", \"58\");\n    resetPanZoomControlBackground.setAttribute(\"class\", \"svg-pan-zoom-control-background\");\n    resetPanZoomControl.appendChild(resetPanZoomControlBackground);\n    var resetPanZoomControlShape1 = document.createElementNS(SvgUtils$2.svgNS, \"path\");\n    resetPanZoomControlShape1.setAttribute(\"d\", \"M33.051,20.632c-0.742-0.406-1.854-0.609-3.338-0.609h-7.969v9.281h7.769c1.543,0,2.701-0.188,3.473-0.562c1.365-0.656,2.048-1.953,2.048-3.891C35.032,22.757,34.372,21.351,33.051,20.632z\");\n    resetPanZoomControlShape1.setAttribute(\"class\", \"svg-pan-zoom-control-element\");\n    resetPanZoomControl.appendChild(resetPanZoomControlShape1);\n    var resetPanZoomControlShape2 = document.createElementNS(SvgUtils$2.svgNS, \"path\");\n    resetPanZoomControlShape2.setAttribute(\"d\", \"M170.231,0.5H15.847C7.102,0.5,0.5,5.708,0.5,11.84v38.861C0.5,56.833,7.102,61.5,15.847,61.5h154.384c8.745,0,15.269-4.667,15.269-10.798V11.84C185.5,5.708,178.976,0.5,170.231,0.5z M42.837,48.569h-7.969c-0.219-0.766-0.375-1.383-0.469-1.852c-0.188-0.969-0.289-1.961-0.305-2.977l-0.047-3.211c-0.03-2.203-0.41-3.672-1.142-4.406c-0.732-0.734-2.103-1.102-4.113-1.102h-7.05v13.547h-7.055V14.022h16.524c2.361,0.047,4.178,0.344,5.45,0.891c1.272,0.547,2.351,1.352,3.234,2.414c0.731,0.875,1.31,1.844,1.737,2.906s0.64,2.273,0.64,3.633c0,1.641-0.414,3.254-1.242,4.84s-2.195,2.707-4.102,3.363c1.594,0.641,2.723,1.551,3.387,2.73s0.996,2.98,0.996,5.402v2.32c0,1.578,0.063,2.648,0.19,3.211c0.19,0.891,0.635,1.547,1.333,1.969V48.569z M75.579,48.569h-26.18V14.022h25.336v6.117H56.454v7.336h16.781v6H56.454v8.883h19.125V48.569z M104.497,46.331c-2.44,2.086-5.887,3.129-10.34,3.129c-4.548,0-8.125-1.027-10.731-3.082s-3.909-4.879-3.909-8.473h6.891c0.224,1.578,0.662,2.758,1.316,3.539c1.196,1.422,3.246,2.133,6.15,2.133c1.739,0,3.151-0.188,4.236-0.562c2.058-0.719,3.087-2.055,3.087-4.008c0-1.141-0.504-2.023-1.512-2.648c-1.008-0.609-2.607-1.148-4.796-1.617l-3.74-0.82c-3.676-0.812-6.201-1.695-7.576-2.648c-2.328-1.594-3.492-4.086-3.492-7.477c0-3.094,1.139-5.664,3.417-7.711s5.623-3.07,10.036-3.07c3.685,0,6.829,0.965,9.431,2.895c2.602,1.93,3.966,4.73,4.093,8.402h-6.938c-0.128-2.078-1.057-3.555-2.787-4.43c-1.154-0.578-2.587-0.867-4.301-0.867c-1.907,0-3.428,0.375-4.565,1.125c-1.138,0.75-1.706,1.797-1.706,3.141c0,1.234,0.561,2.156,1.682,2.766c0.721,0.406,2.25,0.883,4.589,1.43l6.063,1.43c2.657,0.625,4.648,1.461,5.975,2.508c2.059,1.625,3.089,3.977,3.089,7.055C108.157,41.624,106.937,44.245,104.497,46.331z M139.61,48.569h-26.18V14.022h25.336v6.117h-18.281v7.336h16.781v6h-16.781v8.883h19.125V48.569z M170.337,20.14h-10.336v28.43h-7.266V20.14h-10.383v-6.117h27.984V20.14z\");\n    resetPanZoomControlShape2.setAttribute(\"class\", \"svg-pan-zoom-control-element\");\n    resetPanZoomControl.appendChild(resetPanZoomControlShape2);\n    return resetPanZoomControl;\n  },\n  _createZoomOut: function (instance) {\n    var zoomOut = document.createElementNS(SvgUtils$2.svgNS, \"g\");\n    zoomOut.setAttribute(\"id\", \"svg-pan-zoom-zoom-out\");\n    zoomOut.setAttribute(\"transform\", \"translate(30.5 70) scale(0.015)\");\n    zoomOut.setAttribute(\"class\", \"svg-pan-zoom-control\");\n    zoomOut.addEventListener(\"click\", function () {\n      instance.getPublicInstance().zoomOut();\n    }, false);\n    zoomOut.addEventListener(\"touchstart\", function () {\n      instance.getPublicInstance().zoomOut();\n    }, false);\n    var zoomOutBackground = document.createElementNS(SvgUtils$2.svgNS, \"rect\");\n    zoomOutBackground.setAttribute(\"x\", \"0\");\n    zoomOutBackground.setAttribute(\"y\", \"0\");\n    zoomOutBackground.setAttribute(\"width\", \"1500\");\n    zoomOutBackground.setAttribute(\"height\", \"1400\");\n    zoomOutBackground.setAttribute(\"class\", \"svg-pan-zoom-control-background\");\n    zoomOut.appendChild(zoomOutBackground);\n    var zoomOutShape = document.createElementNS(SvgUtils$2.svgNS, \"path\");\n    zoomOutShape.setAttribute(\"d\", \"M1280 576v128q0 26 -19 45t-45 19h-896q-26 0 -45 -19t-19 -45v-128q0 -26 19 -45t45 -19h896q26 0 45 19t19 45zM1536 1120v-960q0 -119 -84.5 -203.5t-203.5 -84.5h-960q-119 0 -203.5 84.5t-84.5 203.5v960q0 119 84.5 203.5t203.5 84.5h960q119 0 203.5 -84.5 t84.5 -203.5z\");\n    zoomOutShape.setAttribute(\"class\", \"svg-pan-zoom-control-element\");\n    zoomOut.appendChild(zoomOutShape);\n    return zoomOut;\n  },\n  disable: function (instance) {\n    if (instance.controlIcons) {\n      instance.controlIcons.parentNode.removeChild(instance.controlIcons);\n      instance.controlIcons = null;\n    }\n  }\n};\nvar SvgUtils$1 = svgUtilities,\n    Utils$1 = utilities;\n\nvar ShadowViewport$1 = function (viewport, options) {\n  this.init(viewport, options);\n};\n\nShadowViewport$1.prototype.init = function (viewport, options) {\n  this.viewport = viewport;\n  this.options = options;\n  this.originalState = {\n    zoom: 1,\n    x: 0,\n    y: 0\n  };\n  this.activeState = {\n    zoom: 1,\n    x: 0,\n    y: 0\n  };\n  this.updateCTMCached = Utils$1.proxy(this.updateCTM, this);\n  this.requestAnimationFrame = Utils$1.createRequestAnimationFrame(this.options.refreshRate);\n  this.viewBox = {\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0\n  };\n  this.cacheViewBox();\n  var newCTM = this.processCTM();\n  this.setCTM(newCTM);\n  this.updateCTM();\n};\n\nShadowViewport$1.prototype.cacheViewBox = function () {\n  var svgViewBox = this.options.svg.getAttribute(\"viewBox\");\n\n  if (svgViewBox) {\n    var viewBoxValues = svgViewBox.split(/[\\s\\,]/).filter(function (v) {\n      return v;\n    }).map(parseFloat);\n    this.viewBox.x = viewBoxValues[0];\n    this.viewBox.y = viewBoxValues[1];\n    this.viewBox.width = viewBoxValues[2];\n    this.viewBox.height = viewBoxValues[3];\n    var zoom = Math.min(this.options.width / this.viewBox.width, this.options.height / this.viewBox.height);\n    this.activeState.zoom = zoom;\n    this.activeState.x = (this.options.width - this.viewBox.width * zoom) / 2;\n    this.activeState.y = (this.options.height - this.viewBox.height * zoom) / 2;\n    this.updateCTMOnNextFrame();\n    this.options.svg.removeAttribute(\"viewBox\");\n  } else {\n    this.simpleViewBoxCache();\n  }\n};\n\nShadowViewport$1.prototype.simpleViewBoxCache = function () {\n  var bBox = this.viewport.getBBox();\n  this.viewBox.x = bBox.x;\n  this.viewBox.y = bBox.y;\n  this.viewBox.width = bBox.width;\n  this.viewBox.height = bBox.height;\n};\n\nShadowViewport$1.prototype.getViewBox = function () {\n  return Utils$1.extend({}, this.viewBox);\n};\n\nShadowViewport$1.prototype.processCTM = function () {\n  var newCTM = this.getCTM();\n\n  if (this.options.fit || this.options.contain) {\n    var newScale;\n\n    if (this.options.fit) {\n      newScale = Math.min(this.options.width / this.viewBox.width, this.options.height / this.viewBox.height);\n    } else {\n      newScale = Math.max(this.options.width / this.viewBox.width, this.options.height / this.viewBox.height);\n    }\n\n    newCTM.a = newScale;\n    newCTM.d = newScale;\n    newCTM.e = -this.viewBox.x * newScale;\n    newCTM.f = -this.viewBox.y * newScale;\n  }\n\n  if (this.options.center) {\n    var offsetX = (this.options.width - (this.viewBox.width + this.viewBox.x * 2) * newCTM.a) * 0.5,\n        offsetY = (this.options.height - (this.viewBox.height + this.viewBox.y * 2) * newCTM.a) * 0.5;\n    newCTM.e = offsetX;\n    newCTM.f = offsetY;\n  }\n\n  this.originalState.zoom = newCTM.a;\n  this.originalState.x = newCTM.e;\n  this.originalState.y = newCTM.f;\n  return newCTM;\n};\n\nShadowViewport$1.prototype.getOriginalState = function () {\n  return Utils$1.extend({}, this.originalState);\n};\n\nShadowViewport$1.prototype.getState = function () {\n  return Utils$1.extend({}, this.activeState);\n};\n\nShadowViewport$1.prototype.getZoom = function () {\n  return this.activeState.zoom;\n};\n\nShadowViewport$1.prototype.getRelativeZoom = function () {\n  return this.activeState.zoom / this.originalState.zoom;\n};\n\nShadowViewport$1.prototype.computeRelativeZoom = function (scale) {\n  return scale / this.originalState.zoom;\n};\n\nShadowViewport$1.prototype.getPan = function () {\n  return {\n    x: this.activeState.x,\n    y: this.activeState.y\n  };\n};\n\nShadowViewport$1.prototype.getCTM = function () {\n  var safeCTM = this.options.svg.createSVGMatrix();\n  safeCTM.a = this.activeState.zoom;\n  safeCTM.b = 0;\n  safeCTM.c = 0;\n  safeCTM.d = this.activeState.zoom;\n  safeCTM.e = this.activeState.x;\n  safeCTM.f = this.activeState.y;\n  return safeCTM;\n};\n\nShadowViewport$1.prototype.setCTM = function (newCTM) {\n  var willZoom = this.isZoomDifferent(newCTM),\n      willPan = this.isPanDifferent(newCTM);\n\n  if (willZoom || willPan) {\n    if (willZoom) {\n      if (this.options.beforeZoom(this.getRelativeZoom(), this.computeRelativeZoom(newCTM.a)) === false) {\n        newCTM.a = newCTM.d = this.activeState.zoom;\n        willZoom = false;\n      } else {\n        this.updateCache(newCTM);\n        this.options.onZoom(this.getRelativeZoom());\n      }\n    }\n\n    if (willPan) {\n      var preventPan = this.options.beforePan(this.getPan(), {\n        x: newCTM.e,\n        y: newCTM.f\n      }),\n          preventPanX = false,\n          preventPanY = false;\n\n      if (preventPan === false) {\n        newCTM.e = this.getPan().x;\n        newCTM.f = this.getPan().y;\n        preventPanX = preventPanY = true;\n      } else if (Utils$1.isObject(preventPan)) {\n        if (preventPan.x === false) {\n          newCTM.e = this.getPan().x;\n          preventPanX = true;\n        } else if (Utils$1.isNumber(preventPan.x)) {\n          newCTM.e = preventPan.x;\n        }\n\n        if (preventPan.y === false) {\n          newCTM.f = this.getPan().y;\n          preventPanY = true;\n        } else if (Utils$1.isNumber(preventPan.y)) {\n          newCTM.f = preventPan.y;\n        }\n      }\n\n      if (preventPanX && preventPanY || !this.isPanDifferent(newCTM)) {\n        willPan = false;\n      } else {\n        this.updateCache(newCTM);\n        this.options.onPan(this.getPan());\n      }\n    }\n\n    if (willZoom || willPan) {\n      this.updateCTMOnNextFrame();\n    }\n  }\n};\n\nShadowViewport$1.prototype.isZoomDifferent = function (newCTM) {\n  return this.activeState.zoom !== newCTM.a;\n};\n\nShadowViewport$1.prototype.isPanDifferent = function (newCTM) {\n  return this.activeState.x !== newCTM.e || this.activeState.y !== newCTM.f;\n};\n\nShadowViewport$1.prototype.updateCache = function (newCTM) {\n  this.activeState.zoom = newCTM.a;\n  this.activeState.x = newCTM.e;\n  this.activeState.y = newCTM.f;\n};\n\nShadowViewport$1.prototype.pendingUpdate = false;\n\nShadowViewport$1.prototype.updateCTMOnNextFrame = function () {\n  if (!this.pendingUpdate) {\n    this.pendingUpdate = true;\n    this.requestAnimationFrame.call(window, this.updateCTMCached);\n  }\n};\n\nShadowViewport$1.prototype.updateCTM = function () {\n  var ctm = this.getCTM();\n  SvgUtils$1.setCTM(this.viewport, ctm, this.defs);\n  this.pendingUpdate = false;\n\n  if (this.options.onUpdatedCTM) {\n    this.options.onUpdatedCTM(ctm);\n  }\n};\n\nvar shadowViewport = function (viewport, options) {\n  return new ShadowViewport$1(viewport, options);\n};\n\nvar Wheel = uniwheel,\n    ControlIcons = controlIcons,\n    Utils = utilities,\n    SvgUtils = svgUtilities,\n    ShadowViewport = shadowViewport;\n\nvar SvgPanZoom = function (svg, options) {\n  this.init(svg, options);\n};\n\nvar optionsDefaults = {\n  viewportSelector: \".svg-pan-zoom_viewport\",\n  panEnabled: true,\n  controlIconsEnabled: false,\n  zoomEnabled: true,\n  dblClickZoomEnabled: true,\n  mouseWheelZoomEnabled: true,\n  preventMouseEventsDefault: true,\n  zoomScaleSensitivity: 0.1,\n  minZoom: 0.5,\n  maxZoom: 10,\n  fit: true,\n  contain: false,\n  center: true,\n  refreshRate: \"auto\",\n  beforeZoom: null,\n  onZoom: null,\n  beforePan: null,\n  onPan: null,\n  customEventsHandler: null,\n  eventsListenerElement: null,\n  onUpdatedCTM: null\n};\nvar passiveListenerTrueOption = {\n  passive: true\n};\nvar passiveListenerFalseOption = {\n  passive: false\n};\n\nSvgPanZoom.prototype.init = function (svg, options) {\n  var that = this;\n  this.svg = svg;\n  this.defs = svg.querySelector(\"defs\");\n  SvgUtils.setupSvgAttributes(this.svg);\n  this.options = Utils.extend(Utils.extend({}, optionsDefaults), options);\n  this.state = \"none\";\n  var boundingClientRectNormalized = SvgUtils.getBoundingClientRectNormalized(svg);\n  this.width = boundingClientRectNormalized.width;\n  this.height = boundingClientRectNormalized.height;\n  this.viewport = ShadowViewport(SvgUtils.getOrCreateViewport(this.svg, this.options.viewportSelector), {\n    svg: this.svg,\n    width: this.width,\n    height: this.height,\n    fit: this.options.fit,\n    contain: this.options.contain,\n    center: this.options.center,\n    refreshRate: this.options.refreshRate,\n    beforeZoom: function (oldScale, newScale) {\n      if (that.viewport && that.options.beforeZoom) {\n        return that.options.beforeZoom(oldScale, newScale);\n      }\n    },\n    onZoom: function (scale) {\n      if (that.viewport && that.options.onZoom) {\n        return that.options.onZoom(scale);\n      }\n    },\n    beforePan: function (oldPoint, newPoint) {\n      if (that.viewport && that.options.beforePan) {\n        return that.options.beforePan(oldPoint, newPoint);\n      }\n    },\n    onPan: function (point) {\n      if (that.viewport && that.options.onPan) {\n        return that.options.onPan(point);\n      }\n    },\n    onUpdatedCTM: function (ctm) {\n      if (that.viewport && that.options.onUpdatedCTM) {\n        return that.options.onUpdatedCTM(ctm);\n      }\n    }\n  });\n  var publicInstance = this.getPublicInstance();\n  publicInstance.setBeforeZoom(this.options.beforeZoom);\n  publicInstance.setOnZoom(this.options.onZoom);\n  publicInstance.setBeforePan(this.options.beforePan);\n  publicInstance.setOnPan(this.options.onPan);\n  publicInstance.setOnUpdatedCTM(this.options.onUpdatedCTM);\n\n  if (this.options.controlIconsEnabled) {\n    ControlIcons.enable(this);\n  }\n\n  this.lastMouseWheelEventTime = Date.now();\n  this.setupHandlers();\n};\n\nSvgPanZoom.prototype.setupHandlers = function () {\n  var that = this,\n      prevEvt = null;\n  this.eventListeners = {\n    pointerdown: function (evt) {\n      if (evt.pointerType === \"touch\") return;\n      var result = that.handleMouseDown(evt, prevEvt);\n      prevEvt = evt;\n      return result;\n    },\n    touchstart: function (evt) {\n      var result = that.handleTouchStart(evt, prevEvt);\n      prevEvt = evt;\n      return result;\n    },\n    pointerup: function (evt) {\n      if (evt.pointerType === \"touch\") return;\n      return that.handleMouseUp(evt);\n    },\n    touchend: function (evt) {\n      return that.handleTouchEnd(evt);\n    },\n    pointermove: function (evt) {\n      if (evt.pointerType === \"touch\") return;\n      return that.handleMouseMove(evt);\n    },\n    touchmove: function (evt) {\n      return that.handleTouchMove(evt);\n    },\n    pointerleave: function (evt) {\n      if (evt.pointerType === \"touch\") return;\n      return that.handleMouseUp(evt);\n    },\n    pointercancel: function (evt) {\n      if (evt.pointerType === \"touch\") return;\n      return that.handleMouseUp(evt);\n    },\n    touchleave: function (evt) {\n      return that.handleTouchEnd(evt);\n    },\n    touchcancel: function (evt) {\n      return that.handleTouchEnd(evt);\n    }\n  };\n\n  if (this.options.customEventsHandler != null) {\n    this.options.customEventsHandler.init({\n      svgElement: this.svg,\n      eventsListenerElement: this.options.eventsListenerElement,\n      instance: this.getPublicInstance()\n    });\n    var haltEventListeners = this.options.customEventsHandler.haltEventListeners;\n\n    if (haltEventListeners && haltEventListeners.length) {\n      for (var i = haltEventListeners.length - 1; i >= 0; i--) {\n        if (this.eventListeners.hasOwnProperty(haltEventListeners[i])) {\n          delete this.eventListeners[haltEventListeners[i]];\n        }\n      }\n    }\n  }\n\n  for (var event in this.eventListeners) {\n    (this.options.eventsListenerElement || this.svg).addEventListener(event, this.eventListeners[event], !this.options.preventMouseEventsDefault ? passiveListenerTrueOption : passiveListenerFalseOption);\n  }\n\n  if (this.options.mouseWheelZoomEnabled) {\n    this.options.mouseWheelZoomEnabled = false;\n    this.enableMouseWheelZoom();\n  }\n};\n\nSvgPanZoom.prototype.enableMouseWheelZoom = function () {\n  if (!this.options.mouseWheelZoomEnabled) {\n    var that = this;\n\n    this.wheelListener = function (evt) {\n      return that.handleMouseWheel(evt);\n    };\n\n    var isPassiveListener = !this.options.preventMouseEventsDefault;\n    Wheel.on(this.options.eventsListenerElement || this.svg, this.wheelListener, isPassiveListener);\n    this.options.mouseWheelZoomEnabled = true;\n  }\n};\n\nSvgPanZoom.prototype.disableMouseWheelZoom = function () {\n  if (this.options.mouseWheelZoomEnabled) {\n    var isPassiveListener = !this.options.preventMouseEventsDefault;\n    Wheel.off(this.options.eventsListenerElement || this.svg, this.wheelListener, isPassiveListener);\n    this.options.mouseWheelZoomEnabled = false;\n  }\n};\n\nSvgPanZoom.prototype.handleMouseWheel = function (evt) {\n  if (!this.options.zoomEnabled || this.state !== \"none\") {\n    return;\n  }\n\n  if (this.options.preventMouseEventsDefault) {\n    if (evt.preventDefault) {\n      evt.preventDefault();\n    } else {\n      evt.returnValue = false;\n    }\n  }\n\n  var delta = evt.deltaY || 1,\n      timeDelta = Date.now() - this.lastMouseWheelEventTime,\n      divider = 3 + Math.max(0, 30 - timeDelta);\n  this.lastMouseWheelEventTime = Date.now();\n\n  if (\"deltaMode\" in evt && evt.deltaMode === 0 && evt.wheelDelta) {\n    delta = evt.deltaY === 0 ? 0 : Math.abs(evt.wheelDelta) / evt.deltaY;\n  }\n\n  delta = -0.3 < delta && delta < 0.3 ? delta : (delta > 0 ? 1 : -1) * Math.log(Math.abs(delta) + 10) / divider;\n  var inversedScreenCTM = this.svg.getScreenCTM().inverse(),\n      relativeMousePoint = SvgUtils.getEventPoint(evt, this.svg).matrixTransform(inversedScreenCTM),\n      zoom = Math.pow(1 + this.options.zoomScaleSensitivity, -1 * delta);\n  this.zoomAtPoint(zoom, relativeMousePoint);\n};\n\nSvgPanZoom.prototype.zoomAtPoint = function (zoomScale, point, zoomAbsolute) {\n  var originalState = this.viewport.getOriginalState();\n\n  if (!zoomAbsolute) {\n    if (this.getZoom() * zoomScale < this.options.minZoom * originalState.zoom) {\n      zoomScale = this.options.minZoom * originalState.zoom / this.getZoom();\n    } else if (this.getZoom() * zoomScale > this.options.maxZoom * originalState.zoom) {\n      zoomScale = this.options.maxZoom * originalState.zoom / this.getZoom();\n    }\n  } else {\n    zoomScale = Math.max(this.options.minZoom * originalState.zoom, Math.min(this.options.maxZoom * originalState.zoom, zoomScale));\n    zoomScale = zoomScale / this.getZoom();\n  }\n\n  var oldCTM = this.viewport.getCTM(),\n      relativePoint = point.matrixTransform(oldCTM.inverse()),\n      modifier = this.svg.createSVGMatrix().translate(relativePoint.x, relativePoint.y).scale(zoomScale).translate(-relativePoint.x, -relativePoint.y),\n      newCTM = oldCTM.multiply(modifier);\n\n  if (newCTM.a !== oldCTM.a) {\n    this.viewport.setCTM(newCTM);\n  }\n};\n\nSvgPanZoom.prototype.zoom = function (scale, absolute) {\n  this.zoomAtPoint(scale, SvgUtils.getSvgCenterPoint(this.svg, this.width, this.height), absolute);\n};\n\nSvgPanZoom.prototype.publicZoom = function (scale, absolute) {\n  if (absolute) {\n    scale = this.computeFromRelativeZoom(scale);\n  }\n\n  this.zoom(scale, absolute);\n};\n\nSvgPanZoom.prototype.publicZoomAtPoint = function (scale, point, absolute) {\n  if (absolute) {\n    scale = this.computeFromRelativeZoom(scale);\n  }\n\n  if (Utils.getType(point) !== \"SVGPoint\") {\n    if (\"x\" in point && \"y\" in point) {\n      point = SvgUtils.createSVGPoint(this.svg, point.x, point.y);\n    } else {\n      throw new Error(\"Given point is invalid\");\n    }\n  }\n\n  this.zoomAtPoint(scale, point, absolute);\n};\n\nSvgPanZoom.prototype.getZoom = function () {\n  return this.viewport.getZoom();\n};\n\nSvgPanZoom.prototype.getRelativeZoom = function () {\n  return this.viewport.getRelativeZoom();\n};\n\nSvgPanZoom.prototype.computeFromRelativeZoom = function (zoom) {\n  return zoom * this.viewport.getOriginalState().zoom;\n};\n\nSvgPanZoom.prototype.resetZoom = function () {\n  var originalState = this.viewport.getOriginalState();\n  this.zoom(originalState.zoom, true);\n};\n\nSvgPanZoom.prototype.resetPan = function () {\n  this.pan(this.viewport.getOriginalState());\n};\n\nSvgPanZoom.prototype.reset = function () {\n  this.resetZoom();\n  this.resetPan();\n};\n\nSvgPanZoom.prototype.handleDblClick = function (evt) {\n  if (this.options.preventMouseEventsDefault) {\n    if (evt.preventDefault) {\n      evt.preventDefault();\n    } else {\n      evt.returnValue = false;\n    }\n  }\n\n  if (this.options.controlIconsEnabled) {\n    var targetClass = evt.target.getAttribute(\"class\") || \"\";\n\n    if (targetClass.indexOf(\"svg-pan-zoom-control\") > -1) {\n      return false;\n    }\n  }\n\n  var zoomFactor;\n\n  if (evt.shiftKey) {\n    zoomFactor = 1 / ((1 + this.options.zoomScaleSensitivity) * 2);\n  } else {\n    zoomFactor = (1 + this.options.zoomScaleSensitivity) * 2;\n  }\n\n  var point = SvgUtils.getEventPoint(evt, this.svg).matrixTransform(this.svg.getScreenCTM().inverse());\n  this.zoomAtPoint(zoomFactor, point);\n};\n\nSvgPanZoom.prototype.handleMouseDown = function (evt, prevEvt) {\n  if (this.options.preventMouseEventsDefault) {\n    if (evt.preventDefault) {\n      evt.preventDefault();\n    } else {\n      evt.returnValue = false;\n    }\n  }\n\n  Utils.mouseAndTouchNormalize(evt, this.svg);\n\n  if (this.options.dblClickZoomEnabled && Utils.isDblClick(evt, prevEvt)) {\n    this.handleDblClick(evt);\n  } else {\n    this.state = \"pan\";\n    this.firstEventCTM = this.viewport.getCTM();\n    this.stateOrigin = SvgUtils.getEventPoint(evt, this.svg).matrixTransform(this.firstEventCTM.inverse());\n  }\n};\n\nSvgPanZoom.prototype.handleMouseMove = function (evt) {\n  if (this.options.preventMouseEventsDefault) {\n    if (evt.preventDefault) {\n      evt.preventDefault();\n    } else {\n      evt.returnValue = false;\n    }\n  }\n\n  if (this.state === \"pan\" && this.options.panEnabled) {\n    var point = SvgUtils.getEventPoint(evt, this.svg).matrixTransform(this.firstEventCTM.inverse()),\n        viewportCTM = this.firstEventCTM.translate(point.x - this.stateOrigin.x, point.y - this.stateOrigin.y);\n    this.viewport.setCTM(viewportCTM);\n  }\n};\n\nSvgPanZoom.prototype.handleMouseUp = function (evt) {\n  if (this.options.preventMouseEventsDefault) {\n    if (evt.preventDefault) {\n      evt.preventDefault();\n    } else {\n      evt.returnValue = false;\n    }\n  }\n\n  if (this.state === \"pan\") {\n    this.state = \"none\";\n  }\n};\n\nSvgPanZoom.prototype.handleTouchStart = function (evt, prevEvt) {\n  if (evt.touches.length == 1) {\n    this.handleMouseDown(evt, prevEvt);\n  } else {\n    if (this.options.preventMouseEventsDefault) {\n      if (evt.preventDefault) {\n        evt.preventDefault();\n      } else {\n        evt.returnValue = false;\n      }\n    }\n\n    this.firstEventCTM = this.viewport.getCTM();\n    var touch1 = SvgUtils.getTouchPoint(evt, this.svg, 0);\n    var touch2 = SvgUtils.getTouchPoint(evt, this.svg, 1);\n    this.firstDistance = Utils.calculateDistance(touch1, touch2);\n    touch1.x = (touch1.x + touch2.x) / 2;\n    touch1.y = (touch1.y + touch2.y) / 2;\n    this.stateOrigin = touch1.matrixTransform(this.firstEventCTM.inverse());\n    this.firstZoomLevel = this.getZoom();\n  }\n};\n\nSvgPanZoom.prototype.handleTouchMove = function (evt) {\n  if (evt.touches.length == 1) {\n    this.handleMouseMove(evt);\n  } else {\n    if (this.options.preventMouseEventsDefault) {\n      if (evt.preventDefault) {\n        evt.preventDefault();\n      } else {\n        evt.returnValue = false;\n      }\n    }\n\n    if (!this.options.panEnabled && !this.options.zoomEnabled) {\n      return;\n    }\n\n    var touch1 = SvgUtils.getTouchPoint(evt, this.svg, 0);\n    var touch2 = SvgUtils.getTouchPoint(evt, this.svg, 1);\n    var center = this.svg.createSVGPoint();\n    center.x = (touch1.x + touch2.x) / 2;\n    center.y = (touch1.y + touch2.y) / 2;\n\n    if (this.state === \"pan\" && this.options.panEnabled) {\n      var point = center.matrixTransform(this.firstEventCTM.inverse());\n      var viewportCTM = this.firstEventCTM.translate(point.x - this.stateOrigin.x, point.y - this.stateOrigin.y);\n      this.viewport.setCTM(viewportCTM);\n    }\n\n    if (this.options.zoomEnabled) {\n      var distance2 = Utils.calculateDistance(touch1, touch2);\n      var scale = distance2 / this.firstDistance;\n      var inversedScreenCTM = this.svg.getScreenCTM().inverse();\n      var relativeTouchPoint = center.matrixTransform(inversedScreenCTM);\n      this.zoomAtPoint(this.firstZoomLevel * scale, relativeTouchPoint, true);\n    }\n  }\n};\n\nSvgPanZoom.prototype.handleTouchEnd = function (evt) {\n  if (evt.touches.length == 0) {\n    this.handleMouseUp(evt);\n  } else {\n    if (this.options.preventMouseEventsDefault) {\n      if (evt.preventDefault) {\n        evt.preventDefault();\n      } else {\n        evt.returnValue = false;\n      }\n    }\n\n    this.firstEventCTM = this.viewport.getCTM();\n\n    if (evt.touches.length == 1) {\n      this.stateOrigin = SvgUtils.getEventPoint(evt, this.svg).matrixTransform(this.firstEventCTM.inverse());\n    } else {\n      var touch1 = SvgUtils.getTouchPoint(evt, this.svg, 0);\n      var touch2 = SvgUtils.getTouchPoint(evt, this.svg, 1);\n      this.firstDistance = Utils.calculateDistance(touch1, touch2);\n      touch1.x = (touch1.x + touch2.x) / 2;\n      touch1.y = (touch1.y + touch2.y) / 2;\n      this.stateOrigin = touch1.matrixTransform(this.firstEventCTM.inverse());\n    }\n  }\n};\n\nSvgPanZoom.prototype.fit = function () {\n  var viewBox = this.viewport.getViewBox(),\n      newScale = Math.min(this.width / viewBox.width, this.height / viewBox.height);\n  this.zoom(newScale, true);\n};\n\nSvgPanZoom.prototype.contain = function () {\n  var viewBox = this.viewport.getViewBox(),\n      newScale = Math.max(this.width / viewBox.width, this.height / viewBox.height);\n  this.zoom(newScale, true);\n};\n\nSvgPanZoom.prototype.center = function () {\n  var viewBox = this.viewport.getViewBox(),\n      offsetX = (this.width - (viewBox.width + viewBox.x * 2) * this.getZoom()) * 0.5,\n      offsetY = (this.height - (viewBox.height + viewBox.y * 2) * this.getZoom()) * 0.5;\n  this.getPublicInstance().pan({\n    x: offsetX,\n    y: offsetY\n  });\n};\n\nSvgPanZoom.prototype.updateBBox = function () {\n  this.viewport.simpleViewBoxCache();\n};\n\nSvgPanZoom.prototype.pan = function (point) {\n  var viewportCTM = this.viewport.getCTM();\n  viewportCTM.e = point.x;\n  viewportCTM.f = point.y;\n  this.viewport.setCTM(viewportCTM);\n};\n\nSvgPanZoom.prototype.panBy = function (point) {\n  var viewportCTM = this.viewport.getCTM();\n  viewportCTM.e += point.x;\n  viewportCTM.f += point.y;\n  this.viewport.setCTM(viewportCTM);\n};\n\nSvgPanZoom.prototype.getPan = function () {\n  var state = this.viewport.getState();\n  return {\n    x: state.x,\n    y: state.y\n  };\n};\n\nSvgPanZoom.prototype.resize = function () {\n  var boundingClientRectNormalized = SvgUtils.getBoundingClientRectNormalized(this.svg);\n  this.width = boundingClientRectNormalized.width;\n  this.height = boundingClientRectNormalized.height;\n  var viewport = this.viewport;\n  viewport.options.width = this.width;\n  viewport.options.height = this.height;\n  viewport.processCTM();\n\n  if (this.options.controlIconsEnabled) {\n    this.getPublicInstance().disableControlIcons();\n    this.getPublicInstance().enableControlIcons();\n  }\n};\n\nSvgPanZoom.prototype.destroy = function () {\n  var that = this;\n  this.beforeZoom = null;\n  this.onZoom = null;\n  this.beforePan = null;\n  this.onPan = null;\n  this.onUpdatedCTM = null;\n\n  if (this.options.customEventsHandler != null) {\n    this.options.customEventsHandler.destroy({\n      svgElement: this.svg,\n      eventsListenerElement: this.options.eventsListenerElement,\n      instance: this.getPublicInstance()\n    });\n  }\n\n  for (var event in this.eventListeners) {\n    (this.options.eventsListenerElement || this.svg).removeEventListener(event, this.eventListeners[event], !this.options.preventMouseEventsDefault ? passiveListenerTrueOption : passiveListenerFalseOption);\n  }\n\n  this.disableMouseWheelZoom();\n  this.getPublicInstance().disableControlIcons();\n  instancesStore = instancesStore.filter(function (instance) {\n    return instance.svg !== that.svg;\n  });\n  delete this.options;\n  delete this.viewport;\n  delete this.publicInstance;\n  delete this.pi;\n\n  this.getPublicInstance = function () {\n    return null;\n  };\n};\n\nSvgPanZoom.prototype.getPublicInstance = function () {\n  var that = this;\n\n  if (!this.publicInstance) {\n    this.publicInstance = this.pi = {\n      enablePan: function () {\n        that.options.panEnabled = true;\n        return that.pi;\n      },\n      disablePan: function () {\n        that.options.panEnabled = false;\n        return that.pi;\n      },\n      isPanEnabled: function () {\n        return !!that.options.panEnabled;\n      },\n      pan: function (point) {\n        that.pan(point);\n        return that.pi;\n      },\n      panBy: function (point) {\n        that.panBy(point);\n        return that.pi;\n      },\n      getPan: function () {\n        return that.getPan();\n      },\n      setBeforePan: function (fn) {\n        that.options.beforePan = fn === null ? null : Utils.proxy(fn, that.publicInstance);\n        return that.pi;\n      },\n      setOnPan: function (fn) {\n        that.options.onPan = fn === null ? null : Utils.proxy(fn, that.publicInstance);\n        return that.pi;\n      },\n      enableZoom: function () {\n        that.options.zoomEnabled = true;\n        return that.pi;\n      },\n      disableZoom: function () {\n        that.options.zoomEnabled = false;\n        return that.pi;\n      },\n      isZoomEnabled: function () {\n        return !!that.options.zoomEnabled;\n      },\n      enableControlIcons: function () {\n        if (!that.options.controlIconsEnabled) {\n          that.options.controlIconsEnabled = true;\n          ControlIcons.enable(that);\n        }\n\n        return that.pi;\n      },\n      disableControlIcons: function () {\n        if (that.options.controlIconsEnabled) {\n          that.options.controlIconsEnabled = false;\n          ControlIcons.disable(that);\n        }\n\n        return that.pi;\n      },\n      isControlIconsEnabled: function () {\n        return !!that.options.controlIconsEnabled;\n      },\n      enableDblClickZoom: function () {\n        that.options.dblClickZoomEnabled = true;\n        return that.pi;\n      },\n      disableDblClickZoom: function () {\n        that.options.dblClickZoomEnabled = false;\n        return that.pi;\n      },\n      isDblClickZoomEnabled: function () {\n        return !!that.options.dblClickZoomEnabled;\n      },\n      enableMouseWheelZoom: function () {\n        that.enableMouseWheelZoom();\n        return that.pi;\n      },\n      disableMouseWheelZoom: function () {\n        that.disableMouseWheelZoom();\n        return that.pi;\n      },\n      isMouseWheelZoomEnabled: function () {\n        return !!that.options.mouseWheelZoomEnabled;\n      },\n      setZoomScaleSensitivity: function (scale) {\n        that.options.zoomScaleSensitivity = scale;\n        return that.pi;\n      },\n      setMinZoom: function (zoom) {\n        that.options.minZoom = zoom;\n        return that.pi;\n      },\n      setMaxZoom: function (zoom) {\n        that.options.maxZoom = zoom;\n        return that.pi;\n      },\n      setBeforeZoom: function (fn) {\n        that.options.beforeZoom = fn === null ? null : Utils.proxy(fn, that.publicInstance);\n        return that.pi;\n      },\n      setOnZoom: function (fn) {\n        that.options.onZoom = fn === null ? null : Utils.proxy(fn, that.publicInstance);\n        return that.pi;\n      },\n      zoom: function (scale) {\n        that.publicZoom(scale, true);\n        return that.pi;\n      },\n      zoomBy: function (scale) {\n        that.publicZoom(scale, false);\n        return that.pi;\n      },\n      zoomAtPoint: function (scale, point) {\n        that.publicZoomAtPoint(scale, point, true);\n        return that.pi;\n      },\n      zoomAtPointBy: function (scale, point) {\n        that.publicZoomAtPoint(scale, point, false);\n        return that.pi;\n      },\n      zoomIn: function () {\n        this.zoomBy(1 + that.options.zoomScaleSensitivity);\n        return that.pi;\n      },\n      zoomOut: function () {\n        this.zoomBy(1 / (1 + that.options.zoomScaleSensitivity));\n        return that.pi;\n      },\n      getZoom: function () {\n        return that.getRelativeZoom();\n      },\n      setOnUpdatedCTM: function (fn) {\n        that.options.onUpdatedCTM = fn === null ? null : Utils.proxy(fn, that.publicInstance);\n        return that.pi;\n      },\n      resetZoom: function () {\n        that.resetZoom();\n        return that.pi;\n      },\n      resetPan: function () {\n        that.resetPan();\n        return that.pi;\n      },\n      reset: function () {\n        that.reset();\n        return that.pi;\n      },\n      fit: function () {\n        that.fit();\n        return that.pi;\n      },\n      contain: function () {\n        that.contain();\n        return that.pi;\n      },\n      center: function () {\n        that.center();\n        return that.pi;\n      },\n      updateBBox: function () {\n        that.updateBBox();\n        return that.pi;\n      },\n      resize: function () {\n        that.resize();\n        return that.pi;\n      },\n      getSizes: function () {\n        return {\n          width: that.width,\n          height: that.height,\n          realZoom: that.getZoom(),\n          viewBox: that.viewport.getViewBox()\n        };\n      },\n      destroy: function () {\n        that.destroy();\n        return that.pi;\n      }\n    };\n  }\n\n  return this.publicInstance;\n};\n\nvar instancesStore = [];\n\nvar svgPanZoom = function (elementOrSelector, options) {\n  var svg = Utils.getSvg(elementOrSelector);\n\n  if (svg === null) {\n    return null;\n  } else {\n    for (var i = instancesStore.length - 1; i >= 0; i--) {\n      if (instancesStore[i].svg === svg) {\n        return instancesStore[i].instance.getPublicInstance();\n      }\n    }\n\n    instancesStore.push({\n      svg,\n      instance: new SvgPanZoom(svg, options)\n    });\n    return instancesStore[instancesStore.length - 1].instance.getPublicInstance();\n  }\n};\n\nvar svgPanZoom_1 = svgPanZoom;\nconst methods = {\n  fitToContents() {\n    this.fit().center().zoomOut().zoomOut();\n    return this;\n  },\n\n  getViewArea() {\n    const sizes = this.getSizes();\n    const pan = this.getPan();\n    const scale = sizes.realZoom;\n    pan.x /= scale;\n    pan.y /= scale;\n    const viewport = {\n      width: sizes.width / scale,\n      height: sizes.height / scale\n    };\n    return {\n      box: {\n        top: -pan.y,\n        bottom: viewport.height - pan.y,\n        left: -pan.x,\n        right: viewport.width - pan.x\n      },\n      center: {\n        x: viewport.width / 2 - pan.x,\n        y: viewport.height / 2 - pan.y\n      }\n    };\n  },\n\n  getViewBox() {\n    return this.getViewArea().box;\n  },\n\n  setViewBox(box) {\n    const width = box.right - box.left;\n    const height = box.bottom - box.top;\n    const {\n      width: sizeWidth,\n      height: sizeHeight\n    } = this.getSizes();\n    const ratio = width / height;\n    const currentRatio = sizeWidth / sizeHeight;\n    const newWidth = ratio < currentRatio ? height * currentRatio : width;\n    const newHeight = ratio > currentRatio ? width / currentRatio : height;\n    const absoluteZoom = Math.min(sizeWidth / newWidth, sizeHeight / newHeight);\n    const realZoom = this.getRealZoom();\n    const relativeZoom = this.getZoom();\n    const originalZoom = realZoom / relativeZoom;\n    this.zoom(absoluteZoom / originalZoom);\n    const center = {\n      x: (box.left + width / 2) * absoluteZoom,\n      y: (box.top + height / 2) * absoluteZoom\n    };\n    this.pan({\n      x: -center.x + newWidth / 2 * absoluteZoom,\n      y: -center.y + newHeight / 2 * absoluteZoom\n    });\n  },\n\n  getRealZoom() {\n    return this.getSizes().realZoom;\n  },\n\n  applyAbsoluteZoomLevel(zoomLevel, minZoomLevel, maxZoomLevel) {\n    const min = Math.max(1e-4, minZoomLevel);\n    const max = Math.max(min, maxZoomLevel);\n    const zoom = Math.max(Math.min(max, zoomLevel), min);\n    const realZoom = this.getRealZoom();\n    const relativeZoom = this.getZoom();\n    const originalZoom = realZoom / relativeZoom;\n    this.setMinZoom(min / originalZoom).setMaxZoom(max / originalZoom).zoom(zoom / originalZoom);\n  },\n\n  isPanEnabled() {\n    return this._isPanEnabled;\n  },\n\n  enablePan() {\n    this._isPanEnabled = true;\n\n    this._internalEnablePan();\n\n    return this;\n  },\n\n  disablePan() {\n    this._isPanEnabled = false;\n\n    this._internalDisablePan();\n\n    return this;\n  },\n\n  isZoomEnabled() {\n    return this._isZoomEnabled;\n  },\n\n  enableZoom() {\n    this._isZoomEnabled = true;\n\n    this._internalEnableZoom();\n\n    return this;\n  },\n\n  disableZoom() {\n    this._isZoomEnabled = false;\n\n    this._internalDisableZoom();\n\n    return this;\n  },\n\n  setPanEnabled(enabled) {\n    if (enabled) {\n      this.enablePan();\n    } else {\n      this.disablePan();\n    }\n\n    return this;\n  },\n\n  setZoomEnabled(enabled) {\n    if (enabled) {\n      this.enableZoom();\n      this.enableDblClickZoom();\n    } else {\n      this.disableZoom();\n      this.disableDblClickZoom();\n    }\n\n    return this;\n  }\n\n};\n\nfunction constructor(svgPanZoom2, options) {\n  var _a, _b;\n\n  const instance = svgPanZoom2;\n  instance._isPanEnabled = (_a = options.panEnabled) != null ? _a : true;\n  instance._isZoomEnabled = (_b = options == null ? void 0 : options.zoomEnabled) != null ? _b : true;\n  instance._internalIsPanEnabled = instance.isPanEnabled;\n  instance._internalEnablePan = instance.enablePan;\n  instance._internalDisablePan = instance.disablePan;\n  instance._internalIsZoomEnabled = instance.isZoomEnabled;\n  instance._internalEnableZoom = instance.enableZoom;\n  instance._internalDisableZoom = instance.disableZoom;\n  Object.assign(svgPanZoom2, methods);\n  return instance;\n}\n\nfunction createSvgPanZoomEx(svg, options) {\n  var _a, _b, _c, _d, _e, _f;\n\n  const userInit = (_b = (_a = options.customEventsHandler) == null ? void 0 : _a.init) != null ? _b : _ => {};\n  const userDestroy = (_d = (_c = options.customEventsHandler) == null ? void 0 : _c.destroy) != null ? _d : _ => {};\n  const haltEventListeners = (_f = (_e = options.customEventsHandler) == null ? void 0 : _e.haltEventListeners) != null ? _f : [];\n\n  if (options.mouseWheelZoomEnabled === void 0) {\n    options.mouseWheelZoomEnabled = options.zoomEnabled;\n  }\n\n  options.customEventsHandler = {\n    init: o => {\n      constructor(o.instance, options);\n      userInit(o);\n    },\n    destroy: o => userDestroy(o),\n    haltEventListeners\n  };\n  return svgPanZoom_1(svg, options);\n}\n\nfunction useSvgPanZoom(svg, options) {\n  const instance = ref();\n  let state = 0;\n  const mountedCallbacks = [];\n  const unmountedCallbacks = [];\n\n  const instanceMounted = () => {\n    state = 1;\n    mountedCallbacks.forEach(c => c());\n    mountedCallbacks.length = 0;\n  };\n\n  const instanceUnmounted = () => {\n    state = 2;\n    unmountedCallbacks.forEach(c => c());\n    unmountedCallbacks.length = 0;\n  };\n\n  onMounted(() => {\n    var _a, _b, _c, _d, _e, _f;\n\n    const element = nonNull(svg.value, \"<svg>\");\n    const userInit = (_b = (_a = options.customEventsHandler) == null ? void 0 : _a.init) != null ? _b : _ => {};\n    const userDestroy = (_d = (_c = options.customEventsHandler) == null ? void 0 : _c.destroy) != null ? _d : _ => {};\n    const haltEventListeners = (_f = (_e = options.customEventsHandler) == null ? void 0 : _e.haltEventListeners) != null ? _f : [];\n    options.customEventsHandler = {\n      init: o => {\n        instance.value = o.instance;\n        userInit(o);\n        instanceMounted();\n      },\n      destroy: o => {\n        instanceUnmounted();\n        userDestroy(o);\n      },\n      haltEventListeners\n    };\n\n    const initialize = () => {\n      const rect = element.getBoundingClientRect();\n\n      if (rect.width !== 0 && rect.height !== 0) {\n        createSvgPanZoomEx(element, options);\n      } else {\n        setTimeout(initialize, 200);\n      }\n    };\n\n    initialize();\n  });\n  onUnmounted(() => {\n    var _a;\n\n    (_a = instance.value) == null ? void 0 : _a.destroy();\n    instance.value = void 0;\n  });\n\n  const onSvgPanZoomMounted = callback => {\n    if (state === 0) {\n      mountedCallbacks.push(callback);\n    } else if (state === 1) {\n      callback();\n    }\n  };\n\n  const onSvgPanZoomUnmounted = callback => {\n    if (state === 0 || state === 1) {\n      unmountedCallbacks.push(callback);\n    } else {\n      callback();\n    }\n  };\n\n  return {\n    svgPanZoom: instance,\n    onSvgPanZoomMounted,\n    onSvgPanZoomUnmounted\n  };\n}\n\nconst zoomLevelKey = Symbol(\"zoomLevel\");\n\nfunction provideZoomLevel(zoomLevel, viewStyle) {\n  const scale = computed(() => {\n    return viewStyle.scalingObjects ? 1 : 1 / zoomLevel.value;\n  });\n  provide(zoomLevelKey, {\n    zoomLevel,\n    scale\n  });\n  return {\n    scale\n  };\n}\n\nfunction useZoomLevel() {\n  return nonNull(inject(zoomLevelKey), \"zoomLevel\");\n}\n\nfunction isPromise(obj) {\n  return obj instanceof Promise || obj && typeof obj.then === \"function\";\n}\n\nfunction useTransitionWhile() {\n  let timerId = null;\n  const transitionOption = ref({\n    enabled: false,\n    duration: 300,\n    timingFunction: \"linear\"\n  });\n\n  function transitionWhile(func, duration = 300, timingFunction = \"linear\") {\n    if (timerId) {\n      clearTimeout(timerId);\n      timerId = null;\n    }\n\n    transitionOption.value = {\n      enabled: true,\n      duration,\n      timingFunction\n    };\n    nextTick(() => __async(this, null, function* () {\n      const promise = func();\n\n      if (isPromise(promise)) {\n        yield promise;\n      }\n\n      if (timerId) {\n        clearTimeout(timerId);\n      }\n\n      timerId = window == null ? void 0 : window.setTimeout(() => {\n        transitionOption.value.enabled = false;\n        timerId = null;\n      }, duration);\n    }));\n  }\n\n  return {\n    transitionWhile,\n    transitionOption\n  };\n}\n\nfunction useTranslatePathsToObject(input) {\n  const objects = ref({});\n  const isInCompatibilityModeForPath = ref(false);\n  let nextId2 = 1;\n  const idStore = /* @__PURE__ */new Map();\n  watchEffect(() => {\n    if (input.value instanceof Array) {\n      const containKeys = /* @__PURE__ */new Set([]);\n      objects.value = Object.fromEntries(input.value.map(path => {\n        let id = path.id;\n\n        if (!id) {\n          if (!isInCompatibilityModeForPath.value) {\n            isInCompatibilityModeForPath.value = true;\n            console.warn(\"[v-network-graph] Please specify the `id` field for the `Path` object. Currently, this works for compatibility, but in the future, the id field will be required.\");\n          }\n\n          id = idStore.get(path);\n\n          if (!id) {\n            id = \"path-\" + nextId2++;\n            idStore.set(path, id);\n          }\n        }\n\n        containKeys.add(id);\n        return [id, path];\n      }));\n\n      if (isInCompatibilityModeForPath.value) {\n        for (const [path, id] of Array.from(idStore.entries())) {\n          if (!containKeys.has(id)) {\n            idStore.delete(path);\n          }\n        }\n      }\n    } else {\n      objects.value = input.value;\n    }\n  });\n  return {\n    objects,\n    isInCompatibilityModeForPath\n  };\n}\n\nfunction bindProp(props, name, emit, filter) {\n  if (filter) {\n    const prop2 = ref(filter(props[name]));\n\n    const update = filtered => {\n      if (!isEqual(filtered, prop2.value)) {\n        prop2.value = filtered;\n      }\n\n      if (!isEqual(filtered, props[name])) {\n        emit(`update:${name}`, filtered);\n      }\n    };\n\n    watch(() => filter(prop2.value), update);\n    watch(() => props[name], v => update(filter(v)));\n\n    if (prop2.value !== props[name]) {\n      emit(`update:${name}`, prop2.value);\n    }\n\n    return prop2;\n  }\n\n  const prop = ref(props[name]);\n  watch(() => props[name], v => {\n    if (!isEqual(v, prop.value)) {\n      prop.value = v;\n    }\n  });\n  watch(prop, v => {\n    if (!isEqual(v, props[name])) {\n      emit(`update:${name}`, v);\n    }\n  });\n  return prop;\n}\n\nfunction bindPropKeySet(props, name, sourceObject, emit) {\n  const bound = reactive( /* @__PURE__ */new Set());\n  watch(() => props[name], () => {\n    const prop = props[name];\n    const filtered = prop.filter(n => n in sourceObject.value);\n\n    if (!isEqual(filtered, Array.from(bound))) {\n      bound.clear();\n      filtered.forEach(bound.add, bound);\n    }\n  }, {\n    deep: true,\n    immediate: true\n  });\n  watch(bound, () => {\n    const array = Array.from(bound);\n\n    if (!isEqual(props[name], array)) {\n      emit(`update:${name}`, array);\n    }\n  });\n  return Reactive(bound);\n}\n\nconst _hoisted_1$f = [\"cx\", \"cy\", \"r\", \"fill\", \"stroke\", \"stroke-width\", \"stroke-dasharray\"];\nconst _hoisted_2$3 = [\"x\", \"y\", \"width\", \"height\", \"rx\", \"ry\", \"fill\", \"stroke\", \"stroke-width\", \"stroke-dasharray\"];\n\nconst _sfc_main$n = /* @__PURE__ */defineComponent({\n  props: {\n    baseX: {\n      type: Number,\n      default: 0\n    },\n    baseY: {\n      type: Number,\n      default: 0\n    },\n    config: {\n      type: Object,\n      required: true\n    }\n  },\n\n  setup(__props, {\n    expose\n  }) {\n    const props = __props;\n    const {\n      scale\n    } = useZoomLevel();\n    const x = ref(props.baseX);\n    const y = ref(props.baseY);\n    const strokeWidth = ref(0);\n    const strokeColor = ref(\"#000000\");\n    const strokeDasharray = ref(void 0);\n    const radius = ref(0);\n    const width = ref(0);\n    const height = ref(0);\n    const borderRadius = ref(0);\n    watchEffect(() => {\n      var _a;\n\n      const s = scale.value;\n      strokeWidth.value = props.config.strokeWidth * s;\n      strokeColor.value = (_a = props.config.strokeColor) != null ? _a : \"none\";\n      strokeDasharray.value = applyScaleToDasharray(props.config.strokeDasharray, s);\n\n      if (props.config.type === \"circle\") {\n        x.value = props.baseX;\n        y.value = props.baseY;\n        radius.value = props.config.radius * s;\n      } else {\n        width.value = props.config.width * s;\n        height.value = props.config.height * s;\n        borderRadius.value = props.config.borderRadius * s;\n        x.value = props.baseX - width.value / 2;\n        y.value = props.baseY - height.value / 2;\n      }\n    });\n    expose({\n      x,\n      y,\n      strokeWidth,\n      strokeColor,\n      strokeDasharray,\n      radius,\n      width,\n      height,\n      borderRadius\n    });\n    return (_ctx, _cache) => {\n      return __props.config.type === \"circle\" ? (openBlock(), createElementBlock(\"circle\", {\n        key: 0,\n        class: \"v-shape-circle\",\n        cx: x.value,\n        cy: y.value,\n        r: radius.value,\n        fill: __props.config.color,\n        stroke: strokeColor.value,\n        \"stroke-width\": strokeWidth.value,\n        \"stroke-dasharray\": strokeDasharray.value\n      }, null, 8, _hoisted_1$f)) : (openBlock(), createElementBlock(\"rect\", {\n        key: 1,\n        class: \"v-shape-rect\",\n        x: x.value,\n        y: y.value,\n        width: width.value,\n        height: height.value,\n        rx: borderRadius.value,\n        ry: borderRadius.value,\n        fill: __props.config.color,\n        stroke: strokeColor.value,\n        \"stroke-width\": strokeWidth.value,\n        \"stroke-dasharray\": strokeDasharray.value\n      }, null, 8, _hoisted_2$3));\n    };\n  }\n\n});\n\nconst _hoisted_1$e = [\"rx\", \"ry\", \"fill\", \"transform\"];\nconst _hoisted_2$2 = [\"x\", \"y\", \"dominant-baseline\", \"font-family\", \"font-size\", \"fill\"];\nconst _hoisted_3$2 = [\"x\", \"dy\", \"dominant-baseline\"];\n\nconst _sfc_main$m = /* @__PURE__ */defineComponent({\n  props: {\n    text: {\n      type: String,\n      required: true\n    },\n    x: {\n      type: Number,\n      required: true\n    },\n    y: {\n      type: Number,\n      required: true\n    },\n    dominantBaseline: {\n      type: String,\n      required: false,\n      default: \"central\"\n    },\n    config: {\n      type: Object,\n      required: true\n    }\n  },\n\n  setup(__props, {\n    expose\n  }) {\n    const props = __props;\n\n    function updateBackgroundPosition(element2, pos2, transform2) {\n      var _a;\n\n      const bbox = element2.getBBox();\n      pos2.x = bbox.x;\n      pos2.y = bbox.y;\n      pos2.width = bbox.width;\n      pos2.height = bbox.height;\n      transform2.value = (_a = element2.getAttribute(\"transform\")) != null ? _a : void 0;\n    }\n\n    function enableMutationObserver(element2, pos2, transform2) {\n      const observer2 = new MutationObserver(() => {\n        updateBackgroundPosition(element2, pos2, transform2);\n      });\n      observer2.observe(element2, {\n        attributes: true,\n        attributeFilter: [\"x\", \"y\", \"transform\", \"font-size\"]\n      });\n      updateBackgroundPosition(element2, pos2, transform2);\n      return observer2;\n    }\n\n    const attrs = useAttrs();\n    const {\n      scale\n    } = useZoomLevel();\n    const texts = computed(() => {\n      var _a, _b;\n\n      return (_b = (_a = props.text) == null ? void 0 : _a.toString().split(/\\r?\\n/)) != null ? _b : \"\";\n    });\n    const fontSize = computed(() => {\n      var _a;\n\n      return (_a = attrs[\"font-size\"]) != null ? _a : props.config.fontSize * scale.value;\n    });\n    const lineHeight = computed(() => fontSize.value * props.config.lineHeight);\n    const topDeltaY = computed(() => {\n      const dominantBaseline = props.dominantBaseline;\n\n      if (dominantBaseline === \"hanging\") {\n        return 0;\n      } else if (dominantBaseline === \"central\") {\n        return -(lineHeight.value * (texts.value.length - 1)) / 2;\n      } else {\n        return -lineHeight.value * (texts.value.length - 1);\n      }\n    });\n    const element = ref();\n    const transform = ref(\"\");\n    const pos = reactive({\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0\n    });\n    const backgroundRectPos = computed(() => {\n      var _a, _b;\n\n      const config = props.config.background;\n      if (!config) return pos;\n      let paddingVertical, paddingHorizontal;\n\n      if (config.padding instanceof Object) {\n        paddingVertical = config.padding.vertical;\n        paddingHorizontal = config.padding.horizontal;\n      } else {\n        paddingVertical = (_a = config.padding) != null ? _a : 0;\n        paddingHorizontal = (_b = config.padding) != null ? _b : 0;\n      }\n\n      const lineMargin = lineHeight.value - fontSize.value;\n      return {\n        x: pos.x - paddingHorizontal * scale.value,\n        y: pos.y - paddingVertical * scale.value - lineMargin / 2,\n        width: pos.width + paddingHorizontal * 2 * scale.value,\n        height: pos.height + paddingVertical * 2 * scale.value + lineMargin\n      };\n    });\n    let observer;\n\n    const updateObserver = () => {\n      if (props.config.background && props.config.background.visible) {\n        if (!observer && element.value) {\n          observer = enableMutationObserver(element.value, pos, transform);\n        }\n      } else {\n        observer == null ? void 0 : observer.disconnect();\n        observer = void 0;\n      }\n    };\n\n    onMounted(() => updateObserver());\n    watch(() => props.config.background && props.config.background.visible, (v, prev) => {\n      if (v == prev) return;\n      updateObserver();\n    });\n    onUnmounted(() => {\n      observer == null ? void 0 : observer.disconnect();\n      observer = void 0;\n    });\n    expose({\n      fontSize,\n      element,\n      transform,\n      backgroundRectPos,\n      scale\n    });\n    return (_ctx, _cache) => {\n      var _a, _b, _c, _d, _e, _f;\n\n      return openBlock(), createElementBlock(Fragment, null, [__props.config.background && __props.config.background.visible ? (openBlock(), createElementBlock(\"rect\", mergeProps({\n        key: 0,\n        class: \"v-text-background\"\n      }, unref(backgroundRectPos), {\n        rx: ((_b = (_a = __props.config.background) == null ? void 0 : _a.borderRadius) != null ? _b : 0) * unref(scale),\n        ry: ((_d = (_c = __props.config.background) == null ? void 0 : _c.borderRadius) != null ? _d : 0) * unref(scale),\n        fill: (_f = (_e = __props.config.background) == null ? void 0 : _e.color) != null ? _f : \"#ffffff\",\n        transform: transform.value\n      }), null, 16, _hoisted_1$e)) : createCommentVNode(\"\", true), createElementVNode(\"text\", mergeProps({\n        ref_key: \"element\",\n        ref: element,\n        class: \"v-text\"\n      }, _ctx.$attrs, {\n        x: __props.x,\n        y: __props.y,\n        \"dominant-baseline\": __props.dominantBaseline,\n        \"font-family\": _ctx.$attrs[\"font-family\"] ? `${_ctx.$attrs[\"font-family\"]}` : __props.config.fontFamily,\n        \"font-size\": unref(fontSize),\n        fill: _ctx.$attrs.fill ? `${_ctx.$attrs.fill}` : __props.config.color\n      }), [unref(texts).length <= 1 ? (openBlock(), createElementBlock(Fragment, {\n        key: 0\n      }, [createTextVNode(toDisplayString(__props.text), 1)], 64)) : (openBlock(true), createElementBlock(Fragment, {\n        key: 1\n      }, renderList(unref(texts), (t, i) => {\n        return openBlock(), createElementBlock(\"tspan\", {\n          key: i,\n          x: __props.x,\n          dy: i == 0 ? unref(topDeltaY) : unref(lineHeight),\n          \"dominant-baseline\": __props.dominantBaseline\n        }, toDisplayString(t), 9, _hoisted_3$2);\n      }), 128))], 16, _hoisted_2$2)], 64);\n    };\n  }\n\n});\n\nvar VNode_vue_vue_type_style_index_0_scoped_true_lang = \"\";\n\nvar _export_sfc = (sfc, props) => {\n  const target = sfc.__vccOpts || sfc;\n\n  for (const [key, val] of props) {\n    target[key] = val;\n  }\n\n  return target;\n};\n\nconst _hoisted_1$d = [\"transform\"];\n\nconst _sfc_main$l = /* @__PURE__ */defineComponent({\n  props: {\n    id: {\n      type: String,\n      required: true\n    },\n    state: {\n      type: Object,\n      required: true\n    },\n    pos: {\n      type: Object,\n      required: false,\n      default: void 0\n    }\n  },\n\n  setup(__props, {\n    expose\n  }) {\n    const props = __props;\n    const x = computed(() => {\n      var _a;\n\n      return ((_a = props.pos) == null ? void 0 : _a.x) || 0;\n    });\n    const y = computed(() => {\n      var _a;\n\n      return ((_a = props.pos) == null ? void 0 : _a.y) || 0;\n    });\n    const config = useNodeConfig();\n    const {\n      scale\n    } = useZoomLevel();\n    const {\n      handleNodePointerDownEvent,\n      handleNodePointerOverEvent,\n      handleNodePointerOutEvent,\n      handleNodeClickEvent,\n      handleNodeDoubleClickEvent,\n      handleNodeContextMenu\n    } = useMouseOperation();\n    const labelVisibility = computed(() => {\n      var _a;\n\n      if (props.state.label.visible) {\n        return (_a = props.state.labelText) != null ? _a : false;\n      }\n\n      return false;\n    });\n    const labelMargin = computed(() => {\n      if (props.state.label.direction === NodeLabelDirection.CENTER) {\n        return 0;\n      } else {\n        return props.state.label.margin * scale.value;\n      }\n    });\n    const labelShiftV = ref(0);\n    const labelShiftH = ref(0);\n    const labelDiagonalShiftV = ref(0);\n    const labelDiagonalShiftH = ref(0);\n    watchEffect(() => {\n      const s = scale.value;\n      const shape = props.state.shape;\n\n      if (shape.type == \"circle\") {\n        const radius = shape.radius * s;\n        const m = radius + labelMargin.value;\n        const diagonalMargin = Math.sqrt(__pow(m, 2) / 2);\n        labelShiftV.value = radius + labelMargin.value;\n        labelShiftH.value = radius + labelMargin.value;\n        labelDiagonalShiftV.value = diagonalMargin;\n        labelDiagonalShiftH.value = diagonalMargin;\n      } else {\n        const borderRadius = shape.borderRadius * s;\n        const width = shape.width * s;\n        const height = shape.height * s;\n        const m = borderRadius + labelMargin.value;\n        const diagonalMargin = Math.sqrt(__pow(m, 2) / 2);\n        labelShiftV.value = height / 2 + labelMargin.value;\n        labelShiftH.value = width / 2 + labelMargin.value;\n        labelDiagonalShiftV.value = height / 2 - borderRadius + diagonalMargin;\n        labelDiagonalShiftH.value = width / 2 - borderRadius + diagonalMargin;\n      }\n    });\n    const textAnchor = computed(() => {\n      switch (props.state.label.direction) {\n        case NodeLabelDirection.CENTER:\n        case NodeLabelDirection.NORTH:\n        case NodeLabelDirection.SOUTH:\n          return \"middle\";\n\n        case NodeLabelDirection.EAST:\n        case NodeLabelDirection.NORTH_EAST:\n        case NodeLabelDirection.SOUTH_EAST:\n          return \"start\";\n\n        case NodeLabelDirection.WEST:\n        case NodeLabelDirection.NORTH_WEST:\n        case NodeLabelDirection.SOUTH_WEST:\n        default:\n          return \"end\";\n      }\n    });\n    const dominantBaseline = computed(() => {\n      switch (props.state.label.direction) {\n        case NodeLabelDirection.NORTH:\n        case NodeLabelDirection.NORTH_EAST:\n        case NodeLabelDirection.NORTH_WEST:\n          return \"text-top\";\n\n        case NodeLabelDirection.SOUTH:\n        case NodeLabelDirection.SOUTH_EAST:\n        case NodeLabelDirection.SOUTH_WEST:\n          return \"hanging\";\n\n        case NodeLabelDirection.CENTER:\n        case NodeLabelDirection.EAST:\n        case NodeLabelDirection.WEST:\n        default:\n          return \"central\";\n      }\n    });\n    const labelX = computed(() => {\n      switch (props.state.label.direction) {\n        case NodeLabelDirection.CENTER:\n        case NodeLabelDirection.NORTH:\n        case NodeLabelDirection.SOUTH:\n          return 0;\n\n        case NodeLabelDirection.EAST:\n          return labelShiftH.value;\n\n        case NodeLabelDirection.WEST:\n          return -labelShiftH.value;\n\n        case NodeLabelDirection.NORTH_EAST:\n        case NodeLabelDirection.SOUTH_EAST:\n          return labelDiagonalShiftH.value;\n\n        case NodeLabelDirection.NORTH_WEST:\n        case NodeLabelDirection.SOUTH_WEST:\n        default:\n          return -labelDiagonalShiftH.value;\n      }\n    });\n    const labelY = computed(() => {\n      switch (props.state.label.direction) {\n        case NodeLabelDirection.NORTH:\n          return -labelShiftV.value;\n\n        case NodeLabelDirection.SOUTH:\n          return labelShiftV.value;\n\n        case NodeLabelDirection.CENTER:\n        case NodeLabelDirection.EAST:\n        case NodeLabelDirection.WEST:\n          return 0;\n\n        case NodeLabelDirection.NORTH_EAST:\n        case NodeLabelDirection.NORTH_WEST:\n          return -labelDiagonalShiftV.value;\n\n        case NodeLabelDirection.SOUTH_EAST:\n        case NodeLabelDirection.SOUTH_WEST:\n        default:\n          return labelDiagonalShiftV.value;\n      }\n    });\n    expose({\n      x,\n      y,\n      config,\n      labelVisibility,\n      handleNodePointerDownEvent,\n      handleNodePointerOverEvent,\n      handleNodePointerOutEvent,\n      handleNodeClickEvent,\n      handleNodeDoubleClickEvent,\n      handleNodeContextMenu,\n      textAnchor,\n      dominantBaseline,\n      labelX,\n      labelY,\n      scale\n    });\n    return (_ctx, _cache) => {\n      return openBlock(), createElementBlock(\"g\", {\n        class: normalizeClass({\n          \"v-node\": true,\n          hover: __props.state.hovered,\n          selected: __props.state.selected\n        }),\n        transform: `translate(${unref(x)} ${unref(y)})`,\n        onPointerdown: _cache[0] || (_cache[0] = withModifiers($event => unref(handleNodePointerDownEvent)(__props.id, $event), [\"stop\"])),\n        onPointerenterPassive: _cache[1] || (_cache[1] = $event => unref(handleNodePointerOverEvent)(__props.id, $event)),\n        onPointerleavePassive: _cache[2] || (_cache[2] = $event => unref(handleNodePointerOutEvent)(__props.id, $event)),\n        onClick: _cache[3] || (_cache[3] = withModifiers($event => unref(handleNodeClickEvent)(__props.id, $event), [\"stop\"])),\n        onDblclick: _cache[4] || (_cache[4] = withModifiers($event => unref(handleNodeDoubleClickEvent)(__props.id, $event), [\"stop\"])),\n        onContextmenu: _cache[5] || (_cache[5] = $event => unref(handleNodeContextMenu)(__props.id, $event))\n      }, [renderSlot(_ctx.$slots, \"override-node\", {\n        nodeId: __props.id,\n        scale: unref(scale),\n        config: __props.state.shape,\n        class: normalizeClass({\n          draggable: __props.state.draggable,\n          selectable: __props.state.selectable\n        })\n      }, () => [createVNode(_sfc_main$n, {\n        config: __props.state.shape,\n        class: normalizeClass({\n          draggable: __props.state.draggable,\n          selectable: __props.state.selectable\n        })\n      }, null, 8, [\"config\", \"class\"])], true), unref(labelVisibility) ? renderSlot(_ctx.$slots, \"override-node-label\", {\n        key: 0,\n        nodeId: __props.id,\n        scale: unref(scale),\n        text: __props.state.labelText,\n        x: unref(labelX),\n        y: unref(labelY),\n        config: __props.state.label,\n        shape: __props.state.shape,\n        textAnchor: unref(textAnchor),\n        dominantBaseline: unref(dominantBaseline)\n      }, () => [createVNode(_sfc_main$m, {\n        text: __props.state.labelText,\n        x: unref(labelX),\n        y: unref(labelY),\n        config: __props.state.label,\n        \"text-anchor\": unref(textAnchor),\n        \"dominant-baseline\": unref(dominantBaseline)\n      }, null, 8, [\"text\", \"x\", \"y\", \"config\", \"text-anchor\", \"dominant-baseline\"])], true) : createCommentVNode(\"\", true)], 42, _hoisted_1$d);\n    };\n  }\n\n});\n\nvar VNode = /* @__PURE__ */_export_sfc(_sfc_main$l, [[\"__scopeId\", \"data-v-13e63a9b\"]]);\n\nvar VNodeFocusRing_vue_vue_type_style_index_0_scoped_true_lang = \"\";\n\nconst _sfc_main$k = /* @__PURE__ */defineComponent({\n  props: {\n    id: {\n      type: String,\n      required: true\n    },\n    state: {\n      type: Object,\n      required: true\n    },\n    pos: {\n      type: Object,\n      required: false,\n      default: void 0\n    }\n  },\n\n  setup(__props, {\n    expose\n  }) {\n    const props = __props;\n    const x = computed(() => {\n      var _a;\n\n      return ((_a = props.pos) == null ? void 0 : _a.x) || 0;\n    });\n    const y = computed(() => {\n      var _a;\n\n      return ((_a = props.pos) == null ? void 0 : _a.y) || 0;\n    });\n    const config = useNodeConfig();\n    const shapeConfig = reactive({});\n    watchEffect(() => {\n      var _a, _b, _c;\n\n      const shapeStyle = props.state.shape;\n\n      if (shapeStyle.type === \"circle\") {\n        const shape = {\n          type: \"circle\",\n          radius: shapeStyle.radius + ((_a = shapeStyle.strokeWidth) != null ? _a : 0) / 2 + config.focusring.padding + config.focusring.width / 2,\n          color: \"none\",\n          strokeWidth: config.focusring.width,\n          strokeColor: config.focusring.color,\n          strokeDasharray: config.focusring.dasharray\n        };\n        Object.assign(shapeConfig, shape);\n      } else {\n        const shape = {\n          type: \"rect\",\n          width: shapeStyle.width + ((_b = shapeStyle.strokeWidth) != null ? _b : 0) + config.focusring.padding * 2 + config.focusring.width,\n          height: shapeStyle.height + ((_c = shapeStyle.strokeWidth) != null ? _c : 0) + config.focusring.padding * 2 + config.focusring.width,\n          borderRadius: shapeStyle.borderRadius > 0 ? shapeStyle.borderRadius + config.focusring.padding : 0,\n          color: \"none\",\n          strokeWidth: config.focusring.width,\n          strokeColor: config.focusring.color,\n          strokeDasharray: config.focusring.dasharray\n        };\n        Object.assign(shapeConfig, shape);\n      }\n    });\n    expose({\n      x,\n      y,\n      shapeConfig\n    });\n    return (_ctx, _cache) => {\n      return openBlock(), createBlock(_sfc_main$n, {\n        class: \"v-node-focus-ring\",\n        \"base-x\": unref(x),\n        \"base-y\": unref(y),\n        config: unref(shapeConfig)\n      }, null, 8, [\"base-x\", \"base-y\", \"config\"]);\n    };\n  }\n\n});\n\nvar VNodeFocusRing = /* @__PURE__ */_export_sfc(_sfc_main$k, [[\"__scopeId\", \"data-v-dbfca3b6\"]]);\n\nvar VLine_vue_vue_type_style_index_0_scoped_true_lang = \"\";\nconst _hoisted_1$c = [\"d\", \"stroke\", \"stroke-width\", \"stroke-dasharray\", \"stroke-linecap\"];\n\nconst _sfc_main$j = /* @__PURE__ */defineComponent({\n  props: {\n    p1: {\n      type: Object,\n      required: true\n    },\n    p2: {\n      type: Object,\n      required: true\n    },\n    config: {\n      type: Object,\n      required: true\n    }\n  },\n\n  setup(__props, {\n    expose\n  }) {\n    const props = __props;\n    const {\n      scale\n    } = useZoomLevel();\n    const strokeWidth = computed(() => {\n      return props.config.width * scale.value;\n    });\n    const strokeDasharray = computed(() => {\n      return applyScaleToDasharray(props.config.dasharray, scale.value);\n    });\n    const animationSpeed = computed(() => {\n      const speed = props.config.animate ? getDasharrayUnit(props.config.dasharray) * props.config.animationSpeed * scale.value : false;\n      return speed ? `--animation-speed:${speed}` : void 0;\n    });\n    expose({\n      strokeWidth,\n      strokeDasharray,\n      animationSpeed\n    });\n    return (_ctx, _cache) => {\n      return openBlock(), createElementBlock(\"path\", {\n        class: normalizeClass({\n          \"v-line\": true,\n          animate: __props.config.animate\n        }),\n        d: `M ${__props.p1.x} ${__props.p1.y} L ${__props.p2.x} ${__props.p2.y}`,\n        stroke: __props.config.color,\n        \"stroke-width\": unref(strokeWidth),\n        \"stroke-dasharray\": unref(strokeDasharray),\n        \"stroke-linecap\": __props.config.linecap,\n        style: normalizeStyle(unref(animationSpeed))\n      }, null, 14, _hoisted_1$c);\n    };\n  }\n\n});\n\nvar VLine = /* @__PURE__ */_export_sfc(_sfc_main$j, [[\"__scopeId\", \"data-v-80a2ecac\"]]);\n\nvar VEdgeCurved_vue_vue_type_style_index_0_scoped_true_lang = \"\";\nconst _hoisted_1$b = [\"d\", \"stroke\", \"stroke-width\", \"stroke-dasharray\", \"stroke-linecap\", \"marker-start\", \"marker-end\"];\n\nconst _sfc_main$i = /* @__PURE__ */defineComponent({\n  props: {\n    state: {\n      type: Object,\n      required: true\n    },\n    config: {\n      type: Object,\n      required: true\n    },\n    markerStart: {\n      type: String,\n      required: false,\n      default: void 0\n    },\n    markerEnd: {\n      type: String,\n      required: false,\n      default: void 0\n    }\n  },\n\n  setup(__props, {\n    expose\n  }) {\n    const props = __props;\n    const {\n      scale\n    } = useZoomLevel();\n    const pathD = computed(() => {\n      var _a, _b;\n\n      const p = props.state.position;\n      const points = [...((_b = (_a = props.state.curve) == null ? void 0 : _a.control) != null ? _b : []), {\n        x: p.p2.x,\n        y: p.p2.y\n      }];\n      const d = [];\n      d.push(`M ${p.p1.x} ${p.p1.y}`);\n      chunk(points, 2).forEach(([p1, p2]) => d.push(`Q ${p1.x} ${p1.y} ${p2.x} ${p2.y}`));\n      return d.join(\" \");\n    });\n    const strokeWidth = computed(() => {\n      return props.config.width * scale.value;\n    });\n    const strokeDasharray = computed(() => {\n      return applyScaleToDasharray(props.config.dasharray, scale.value);\n    });\n    const animationSpeed = computed(() => {\n      const speed = props.config.animate ? getDasharrayUnit(props.config.dasharray) * props.config.animationSpeed * scale.value : false;\n      return speed ? `--animation-speed:${speed}` : void 0;\n    });\n    expose({\n      strokeWidth,\n      strokeDasharray,\n      animationSpeed\n    });\n    return (_ctx, _cache) => {\n      return openBlock(), createElementBlock(\"path\", {\n        class: normalizeClass({\n          \"v-line\": true,\n          animate: __props.config.animate\n        }),\n        d: unref(pathD),\n        fill: \"none\",\n        stroke: __props.config.color,\n        \"stroke-width\": unref(strokeWidth),\n        \"stroke-dasharray\": unref(strokeDasharray),\n        \"stroke-linecap\": __props.config.linecap,\n        style: normalizeStyle(unref(animationSpeed)),\n        \"marker-start\": __props.markerStart,\n        \"marker-end\": __props.markerEnd\n      }, null, 14, _hoisted_1$b);\n    };\n  }\n\n});\n\nvar VEdgeCurved = /* @__PURE__ */_export_sfc(_sfc_main$i, [[\"__scopeId\", \"data-v-1a7165f7\"]]);\n\nvar VEdge_vue_vue_type_style_index_0_scoped_true_lang = \"\";\n\nconst _sfc_main$h = /* @__PURE__ */defineComponent({\n  props: {\n    id: {\n      type: String,\n      required: true\n    },\n    state: {\n      type: Object,\n      required: true\n    },\n    sourcePos: {\n      type: Object,\n      required: false,\n      default: void 0\n    },\n    targetPos: {\n      type: Object,\n      required: false,\n      default: void 0\n    }\n  },\n\n  setup(__props, {\n    expose\n  }) {\n    const config = useEdgeConfig();\n    expose({\n      config\n    });\n    return (_ctx, _cache) => {\n      return unref(config).type == \"straight\" || !__props.state.curve ? (openBlock(), createBlock(VLine, mergeProps({\n        key: 0,\n        \"data-edge-id\": __props.id\n      }, __props.state.position, {\n        class: {\n          selectable: __props.state.selectable,\n          hover: __props.state.hovered,\n          selected: __props.state.selected\n        },\n        config: __props.state.line.stroke,\n        \"marker-start\": __props.state.sourceMarkerId ? `url('#${__props.state.sourceMarkerId}')` : void 0,\n        \"marker-end\": __props.state.targetMarkerId ? `url('#${__props.state.targetMarkerId}')` : void 0\n      }), null, 16, [\"data-edge-id\", \"class\", \"config\", \"marker-start\", \"marker-end\"])) : (openBlock(), createBlock(VEdgeCurved, {\n        key: 1,\n        \"data-edge-id\": __props.id,\n        class: normalizeClass({\n          selectable: __props.state.selectable,\n          hover: __props.state.hovered,\n          selected: __props.state.selected\n        }),\n        state: __props.state,\n        config: __props.state.line.stroke,\n        \"marker-start\": __props.state.sourceMarkerId ? `url('#${__props.state.sourceMarkerId}')` : void 0,\n        \"marker-end\": __props.state.targetMarkerId ? `url('#${__props.state.targetMarkerId}')` : void 0\n      }, null, 8, [\"data-edge-id\", \"class\", \"state\", \"config\", \"marker-start\", \"marker-end\"]));\n    };\n  }\n\n});\n\nvar VEdge = /* @__PURE__ */_export_sfc(_sfc_main$h, [[\"__scopeId\", \"data-v-8d79e384\"]]);\n\nvar VEdgeSummarized_vue_vue_type_style_index_0_scoped_true_lang = \"\";\n\nconst _sfc_main$g = /* @__PURE__ */defineComponent({\n  props: {\n    edges: {\n      type: Object,\n      required: true\n    },\n    layouts: {\n      type: Object,\n      required: true\n    }\n  },\n\n  setup(__props, {\n    expose\n  }) {\n    const props = __props;\n    const config = useEdgeConfig();\n    const {\n      handleEdgesPointerDownEvent,\n      handleEdgesPointerOverEvent,\n      handleEdgesPointerOutEvent,\n      handleEdgesClickEvent,\n      handleEdgesDoubleClickEvent,\n      handleEdgesContextMenu\n    } = useMouseOperation();\n    const {\n      edgeStates\n    } = useStates();\n    const pos = ref({\n      p1: {\n        x: 0,\n        y: 0\n      },\n      p2: {\n        x: 0,\n        y: 0\n      }\n    });\n    const centerPos = ref({\n      x: 0,\n      y: 0\n    });\n    watchEffect(() => {\n      const edgeId = Object.keys(props.edges).find(edgeId2 => edgeId2 in edgeStates);\n\n      if (edgeId) {\n        pos.value = edgeStates[edgeId].position;\n        centerPos.value = {\n          x: (pos.value.p1.x + pos.value.p2.x) / 2,\n          y: (pos.value.p1.y + pos.value.p2.y) / 2\n        };\n      }\n    });\n    const edgeIds = computed(() => Object.keys(props.edges));\n    const labelConfig = computed(() => Config.values(config.summarized.label, props.edges));\n    const shapeConfig = computed(() => Config.values(config.summarized.shape, props.edges));\n    const strokeConfig = computed(() => Config.values(config.summarized.stroke, props.edges));\n    const hovered = computed(() => edgeIds.value.some(edge => edgeStates[edge].hovered));\n    const selectable = computed(() => edgeIds.value.some(edge => edgeStates[edge].selectable));\n    const selected = computed(() => edgeIds.value.some(edge => edgeStates[edge].selected));\n    expose({\n      config,\n      pos,\n      centerPos,\n      handleEdgesPointerDownEvent,\n      handleEdgesPointerOverEvent,\n      handleEdgesPointerOutEvent,\n      handleEdgesClickEvent,\n      handleEdgesDoubleClickEvent,\n      handleEdgesContextMenu,\n      hovered,\n      selectable,\n      selected\n    });\n    return (_ctx, _cache) => {\n      return openBlock(), createElementBlock(\"g\", {\n        class: normalizeClass({\n          \"v-line-summarized\": true,\n          hovered: unref(hovered),\n          selectable: unref(selectable),\n          selected: unref(selected)\n        }),\n        onPointerdown: _cache[0] || (_cache[0] = withModifiers($event => unref(handleEdgesPointerDownEvent)(unref(edgeIds), $event), [\"stop\"])),\n        onPointerenterPassive: _cache[1] || (_cache[1] = $event => unref(handleEdgesPointerOverEvent)(unref(edgeIds), $event)),\n        onPointerleavePassive: _cache[2] || (_cache[2] = $event => unref(handleEdgesPointerOutEvent)(unref(edgeIds), $event)),\n        onClick: _cache[3] || (_cache[3] = withModifiers($event => unref(handleEdgesClickEvent)(unref(edgeIds), $event), [\"stop\"])),\n        onDblclick: _cache[4] || (_cache[4] = withModifiers($event => unref(handleEdgesDoubleClickEvent)(unref(edgeIds), $event), [\"stop\"])),\n        onContextmenu: _cache[5] || (_cache[5] = $event => unref(handleEdgesContextMenu)(unref(edgeIds), $event))\n      }, [createVNode(VLine, mergeProps(pos.value, {\n        config: unref(strokeConfig),\n        \"data-edge-id\": unref(edgeIds)[0]\n      }), null, 16, [\"config\", \"data-edge-id\"]), createVNode(_sfc_main$n, {\n        \"base-x\": centerPos.value.x,\n        \"base-y\": centerPos.value.y,\n        config: unref(shapeConfig)\n      }, null, 8, [\"base-x\", \"base-y\", \"config\"]), createVNode(_sfc_main$m, {\n        text: Object.keys(__props.edges).length.toString(),\n        x: centerPos.value.x,\n        y: centerPos.value.y,\n        config: unref(labelConfig),\n        \"text-anchor\": \"middle\",\n        \"dominant-baseline\": \"central\"\n      }, null, 8, [\"text\", \"x\", \"y\", \"config\"])], 34);\n    };\n  }\n\n});\n\nvar VEdgeSummarized = /* @__PURE__ */_export_sfc(_sfc_main$g, [[\"__scopeId\", \"data-v-274f28a7\"]]);\n\nconst _hoisted_1$a = {\n  class: \"v-edge-overlay\"\n};\n\nconst _sfc_main$f = /* @__PURE__ */defineComponent({\n  props: {\n    edgeId: {\n      type: String,\n      required: false,\n      default: void 0\n    },\n    edge: {\n      type: Object,\n      required: false,\n      default: void 0\n    },\n    edges: {\n      type: Object,\n      required: false,\n      default: () => {}\n    },\n    state: {\n      type: Object,\n      required: true\n    },\n    isSummarized: {\n      type: Boolean,\n      required: true\n    }\n  },\n\n  setup(__props) {\n    const props = __props;\n    const {\n      svg\n    } = useContainers();\n    const {\n      scale\n    } = useZoomLevel();\n    const edgeConfig = useEdgeConfig();\n\n    function getStrokeConfig() {\n      if (props.isSummarized) {\n        return Config.values(edgeConfig.summarized.stroke, props.edges);\n      } else {\n        return props.state.line.stroke;\n      }\n    }\n\n    function toEdgePosition(line) {\n      return {\n        source: line.p1,\n        target: line.p2\n      };\n    }\n\n    function calculateCenterPoint(state) {\n      if (state.curve) {\n        return state.curve.center;\n      } else {\n        const p1 = state.origin.p1;\n        const p2 = state.origin.p2;\n        return {\n          x: (p1.x + p2.x) / 2,\n          y: (p1.y + p2.y) / 2\n        };\n      }\n    }\n\n    function getPathTotalLength() {\n      var _a;\n\n      if (!svg.value) return 0;\n      const edgeId = (_a = props.edgeId) != null ? _a : Object.keys(props.edges)[0];\n      const path = svg.value.querySelector(`path[data-edge-id=\"${edgeId}\"]`);\n      if (!path) return 0;\n      return path.getTotalLength();\n    }\n\n    function calculatePointAtLength(distance2) {\n      var _a;\n\n      if (!svg.value || !isFinite(distance2)) return props.state.position.p1;\n      props.state;\n      const edgeId = (_a = props.edgeId) != null ? _a : Object.keys(props.edges)[0];\n      const path = svg.value.querySelector(`path[data-edge-id=\"${edgeId}\"]`);\n      if (!path) return props.state.position.p1;\n      const p = path.getPointAtLength(distance2);\n      return {\n        x: p.x,\n        y: p.y\n      };\n    }\n\n    return (_ctx, _cache) => {\n      return openBlock(), createElementBlock(\"g\", _hoisted_1$a, [__props.isSummarized ? renderSlot(_ctx.$slots, \"default\", {\n        key: 0,\n        edges: __props.edges,\n        isSummarized: __props.isSummarized,\n        stroke: getStrokeConfig(),\n        position: toEdgePosition(__props.state.origin),\n        center: calculateCenterPoint(__props.state),\n        hovered: __props.state.hovered,\n        selected: __props.state.selected,\n        scale: unref(scale),\n        length: getPathTotalLength(),\n        pointAtLength: calculatePointAtLength\n      }) : renderSlot(_ctx.$slots, \"default\", {\n        key: 1,\n        edgeId: __props.edgeId,\n        edge: __props.edge,\n        edges: {\n          [__props.edgeId]: __props.edge\n        },\n        isSummarized: __props.isSummarized,\n        stroke: getStrokeConfig(),\n        position: toEdgePosition(__props.state.origin),\n        center: calculateCenterPoint(__props.state),\n        hovered: __props.state.hovered,\n        selected: __props.state.selected,\n        scale: unref(scale),\n        length: getPathTotalLength(),\n        pointAtLength: calculatePointAtLength\n      })]);\n    };\n  }\n\n});\n\nconst _sfc_main$e = /* @__PURE__ */defineComponent({\n  props: {\n    hasEdgeOverlaySlot: {\n      type: Boolean,\n      required: true\n    }\n  },\n\n  setup(__props, {\n    expose\n  }) {\n    const {\n      edgeStates,\n      edgeZOrderedList,\n      edgeGroupStates,\n      layouts\n    } = useStates();\n    expose({\n      edgeStates,\n      edgeZOrderedList,\n      edgeGroupStates,\n      layouts\n    });\n    return (_ctx, _cache) => {\n      return openBlock(true), createElementBlock(Fragment, null, renderList(unref(edgeZOrderedList), entry => {\n        return openBlock(), createElementBlock(Fragment, null, [unref(isSummarizedEdges)(entry) ? (openBlock(), createElementBlock(Fragment, {\n          key: 0\n        }, [(openBlock(), createBlock(VEdgeSummarized, {\n          key: entry.key,\n          edges: entry.group.edges,\n          layouts: unref(layouts).nodes\n        }, null, 8, [\"edges\", \"layouts\"])), __props.hasEdgeOverlaySlot ? (openBlock(), createBlock(_sfc_main$f, {\n          key: entry.key,\n          edges: entry.group.edges,\n          state: unref(edgeStates)[Object.keys(entry.group.edges)[0]],\n          \"is-summarized\": true\n        }, {\n          default: withCtx(slotProps => [renderSlot(_ctx.$slots, \"default\", normalizeProps(guardReactiveProps(slotProps)))]),\n          _: 2\n        }, 1032, [\"edges\", \"state\"])) : createCommentVNode(\"\", true)], 64)) : (openBlock(), createElementBlock(Fragment, {\n          key: 1\n        }, [(openBlock(), createBlock(VEdge, {\n          key: entry.key,\n          id: entry.key,\n          state: unref(edgeStates)[entry.key],\n          \"source-pos\": unref(layouts).nodes[entry.edge.source],\n          \"target-pos\": unref(layouts).nodes[entry.edge.target]\n        }, null, 8, [\"id\", \"state\", \"source-pos\", \"target-pos\"])), __props.hasEdgeOverlaySlot ? (openBlock(), createBlock(_sfc_main$f, {\n          key: entry.key,\n          \"edge-id\": entry.key,\n          edge: entry.edge,\n          state: unref(edgeStates)[entry.key],\n          \"is-summarized\": false\n        }, {\n          default: withCtx(slotProps => [renderSlot(_ctx.$slots, \"default\", normalizeProps(guardReactiveProps(slotProps)))]),\n          _: 2\n        }, 1032, [\"edge-id\", \"edge\", \"state\"])) : createCommentVNode(\"\", true)], 64))], 64);\n      }), 256);\n    };\n  }\n\n});\n\nvar VEdgeBackground_vue_vue_type_style_index_0_scoped_true_lang = \"\";\nconst _hoisted_1$9 = [\"d\", \"stroke-width\"];\n\nconst _sfc_main$d = /* @__PURE__ */defineComponent({\n  props: {\n    id: {\n      type: String,\n      required: true\n    },\n    state: {\n      type: Object,\n      required: true\n    },\n    sourcePos: {\n      type: Object,\n      required: false,\n      default: void 0\n    },\n    targetPos: {\n      type: Object,\n      required: false,\n      default: void 0\n    }\n  },\n\n  setup(__props, {\n    expose\n  }) {\n    const props = __props;\n    const {\n      scale\n    } = useZoomLevel();\n    const config = useEdgeConfig();\n    const {\n      handleEdgePointerDownEvent,\n      handleEdgePointerOverEvent,\n      handleEdgePointerOutEvent,\n      handleEdgeClickEvent,\n      handleEdgeDoubleClickEvent,\n      handleEdgeContextMenu\n    } = useMouseOperation();\n    const pathD = computed(() => {\n      const p = props.state.position;\n\n      if (config.type === \"straight\" || !props.state.curve) {\n        return `M ${p.p1.x} ${p.p1.y} L ${p.p2.x} ${p.p2.y}`;\n      } else {\n        const points = [...props.state.curve.control, {\n          x: p.p2.x,\n          y: p.p2.y\n        }];\n        const d = [];\n        d.push(`M ${p.p1.x} ${p.p1.y}`);\n        chunk(points, 2).forEach(([p1, p2]) => d.push(`Q ${p1.x} ${p1.y} ${p2.x} ${p2.y}`));\n        return d.join(\" \");\n      }\n    });\n    const strokeWidth = computed(() => (props.state.line.stroke.width + 10) * scale.value);\n    expose({\n      config,\n      handleEdgePointerDownEvent,\n      handleEdgePointerOverEvent,\n      handleEdgePointerOutEvent,\n      handleEdgeClickEvent,\n      handleEdgeDoubleClickEvent,\n      handleEdgeContextMenu\n    });\n    return (_ctx, _cache) => {\n      return openBlock(), createElementBlock(\"path\", {\n        class: normalizeClass({\n          \"v-line-background\": true,\n          selectable: __props.state.selectable\n        }),\n        d: unref(pathD),\n        stroke: \"transparent\",\n        \"stroke-width\": unref(strokeWidth),\n        fill: \"none\",\n        onPointerdown: _cache[0] || (_cache[0] = withModifiers($event => unref(handleEdgePointerDownEvent)(__props.id, $event), [\"stop\"])),\n        onPointerenterPassive: _cache[1] || (_cache[1] = $event => unref(handleEdgePointerOverEvent)(__props.id, $event)),\n        onPointerleavePassive: _cache[2] || (_cache[2] = $event => unref(handleEdgePointerOutEvent)(__props.id, $event)),\n        onClick: _cache[3] || (_cache[3] = withModifiers($event => unref(handleEdgeClickEvent)(__props.id, $event), [\"stop\"])),\n        onDblclick: _cache[4] || (_cache[4] = withModifiers($event => unref(handleEdgeDoubleClickEvent)(__props.id, $event), [\"stop\"])),\n        onContextmenu: _cache[5] || (_cache[5] = $event => unref(handleEdgeContextMenu)(__props.id, $event))\n      }, null, 42, _hoisted_1$9);\n    };\n  }\n\n});\n\nvar VEdgeBackground = /* @__PURE__ */_export_sfc(_sfc_main$d, [[\"__scopeId\", \"data-v-8dc141be\"]]);\n\nconst _sfc_main$c = /* @__PURE__ */defineComponent({\n  setup(__props, {\n    expose\n  }) {\n    const {\n      edgeStates,\n      edgeGroupStates,\n      layouts\n    } = useStates();\n    expose({\n      edgeStates,\n      edgeGroupStates,\n      layouts\n    });\n    return (_ctx, _cache) => {\n      return openBlock(true), createElementBlock(Fragment, null, renderList(unref(edgeGroupStates).edgeGroups, ({\n        summarize,\n        edges\n      }) => {\n        return openBlock(), createElementBlock(Fragment, null, [!summarize ? (openBlock(true), createElementBlock(Fragment, {\n          key: 0\n        }, renderList(edges, (edge, id) => {\n          return openBlock(), createBlock(VEdgeBackground, {\n            key: id,\n            id,\n            state: unref(edgeStates)[id],\n            \"source-pos\": unref(layouts).nodes[edge.source],\n            \"target-pos\": unref(layouts).nodes[edge.target]\n          }, null, 8, [\"id\", \"state\", \"source-pos\", \"target-pos\"]);\n        }), 128)) : createCommentVNode(\"\", true)], 64);\n      }), 256);\n    };\n  }\n\n});\n\nvar VEdgeLabels_vue_vue_type_style_index_0_scoped_true_lang = \"\";\nconst _hoisted_1$8 = {\n  class: \"v-edge-labels\"\n};\n\nconst _sfc_main$b = /* @__PURE__ */defineComponent({\n  setup(__props, {\n    expose\n  }) {\n    const edgeConfig = useEdgeConfig();\n    const {\n      nodeStates,\n      edgeStates,\n      edgeGroupStates,\n      summarizedEdgeStates,\n      layouts\n    } = useStates();\n    const {\n      scale\n    } = useZoomLevel();\n    const individualEdgeGroups = computed(() => Object.fromEntries(Object.entries(edgeGroupStates.edgeGroups).filter(([_, group]) => !group.summarize && Object.keys(group.edges).length > 0)));\n    const edgeGroups = computed(() => {\n      const individual = {};\n      const summarized = {};\n      Object.entries(edgeGroupStates.edgeGroups).forEach(([id, group]) => {\n        if (Object.keys(group.edges).length > 0) {\n          if (group.summarize) {\n            summarized[id] = group;\n          } else {\n            individual[id] = group;\n          }\n        }\n      });\n      return {\n        individual,\n        summarized\n      };\n    });\n    const nodeShape = computed(() => node => {\n      var _a;\n\n      return {\n        pos: (_a = layouts.nodes[node]) != null ? _a : {\n          x: 0,\n          y: 0\n        },\n        shape: nodeStates[node].shape\n      };\n    });\n    const labelAreaPosition = computed(() => (edgeId, edgeStyle) => {\n      return calculateEdgeLabelArea(edgeStates[edgeId].labelPosition, edgeStyle, edgeConfig.label.margin, edgeConfig.label.padding, scale.value);\n    });\n    const groupLabelAreaPosition = computed(() => (id, group) => {\n      var _a, _b;\n\n      const edgeId = Object.keys(group.edges)[0];\n      return calculateEdgeLabelArea(edgeStates[edgeId].labelPosition, (_b = (_a = summarizedEdgeStates[id]) == null ? void 0 : _a.stroke) != null ? _b : edgeStates[edgeId].line.stroke, edgeConfig.label.margin, edgeConfig.label.padding, scale.value);\n    });\n    const representativeEdgeState = computed(() => group => {\n      return edgeStates[Object.keys(group.edges)[0]];\n    });\n    expose({\n      individualEdgeGroups,\n      edgeGroups,\n      nodeShape,\n      labelAreaPosition,\n      groupLabelAreaPosition,\n      representativeEdgeState,\n      edgeStates,\n      edgeConfig,\n      scale\n    });\n    return (_ctx, _cache) => {\n      return openBlock(), createElementBlock(\"g\", _hoisted_1$8, [(openBlock(true), createElementBlock(Fragment, null, renderList(unref(edgeGroups).individual, (group, id) => {\n        return openBlock(), createElementBlock(Fragment, {\n          key: id\n        }, [(openBlock(true), createElementBlock(Fragment, null, renderList(group.edges, (edge, edgeId) => {\n          return renderSlot(_ctx.$slots, \"edge-label\", {\n            key: edgeId,\n            edgeId,\n            edge,\n            config: unref(edgeConfig).label,\n            area: unref(labelAreaPosition)(edgeId, unref(edgeStates)[edgeId].line.stroke),\n            hovered: unref(edgeStates)[edgeId].hovered,\n            selected: unref(edgeStates)[edgeId].selected,\n            scale: unref(scale)\n          }, void 0, true);\n        }), 128))], 64);\n      }), 128)), (openBlock(true), createElementBlock(Fragment, null, renderList(unref(edgeGroups).summarized, (group, id) => {\n        return renderSlot(_ctx.$slots, \"edges-label\", {\n          key: id,\n          edges: group.edges,\n          config: unref(edgeConfig).label,\n          area: unref(groupLabelAreaPosition)(id, group),\n          hovered: unref(representativeEdgeState)(group).hovered,\n          selected: unref(representativeEdgeState)(group).selected,\n          scale: unref(scale)\n        }, void 0, true);\n      }), 128))]);\n    };\n  }\n\n});\n\nvar VEdgeLabels = /* @__PURE__ */_export_sfc(_sfc_main$b, [[\"__scopeId\", \"data-v-d149fb06\"]]);\n\nconst _sfc_main$a = /* @__PURE__ */defineComponent({\n  setup(__props, {\n    expose\n  }) {\n    const {\n      viewport\n    } = useContainers();\n    const background = ref();\n\n    const updateAttributes = (attrs, bgLayer, vpLayer) => {\n      attrs.forEach(attr => {\n        var _a;\n\n        return bgLayer.setAttribute(attr, (_a = vpLayer.getAttribute(attr)) != null ? _a : \"\");\n      });\n    };\n\n    const observer = new MutationObserver(records => {\n      if (!background.value) return;\n      const attrs = records.map(r => {\n        var _a;\n\n        return (_a = r.attributeName) != null ? _a : \"\";\n      }).filter(Boolean);\n      updateAttributes(attrs, background.value, viewport.value);\n    });\n    onMounted(() => {\n      const attrs = [\"transform\", \"style\"];\n      observer.observe(viewport.value, {\n        attributes: true,\n        attributeFilter: attrs\n      });\n      if (!background.value) return;\n      updateAttributes(attrs, background.value, viewport.value);\n    });\n    onUnmounted(() => {\n      observer.disconnect();\n    });\n    expose({\n      background\n    });\n    return (_ctx, _cache) => {\n      return openBlock(), createElementBlock(\"g\", {\n        ref_key: \"background\",\n        ref: background,\n        class: \"v-background-viewport\"\n      }, [renderSlot(_ctx.$slots, \"default\")], 512);\n    };\n  }\n\n});\n\nvar VBackgroundGrid_vue_vue_type_style_index_0_lang = \"\";\nconst _hoisted_1$7 = {\n  class: \"v-background-grid\",\n  \"shape-rendering\": \"crispEdges\"\n};\nconst _hoisted_2$1 = [\"d\"];\nconst _hoisted_3$1 = [\"d\"];\nconst _hoisted_4$1 = [\"d\"];\nconst _hoisted_5 = [\"d\"];\n\nconst _sfc_main$9 = /* @__PURE__ */defineComponent({\n  setup(__props, {\n    expose\n  }) {\n    const {\n      container,\n      svgPanZoom: svgPanZoom2\n    } = useContainers();\n    const {\n      zoomLevel\n    } = useZoomLevel();\n    const emitter = useEventEmitter();\n    const config = useViewConfig();\n    const basePoint = ref({\n      x: 0,\n      y: 0\n    });\n    const viewport = ref({\n      width: 500,\n      height: 500\n    });\n    onMounted(() => {\n      var _a;\n\n      const pan = (_a = svgPanZoom2.value) == null ? void 0 : _a.getPan();\n\n      if (pan) {\n        basePoint.value = {\n          x: -pan.x,\n          y: -pan.y\n        };\n      }\n\n      const rect = container.value.getBoundingClientRect();\n      viewport.value = {\n        width: rect.width,\n        height: rect.height\n      };\n    });\n    emitter.on(\"view:resize\", rect => {\n      viewport.value = {\n        width: rect.width,\n        height: rect.height\n      };\n    });\n    emitter.on(\"view:pan\", pan => {\n      basePoint.value = {\n        x: -pan.x,\n        y: -pan.y\n      };\n    });\n    emitter.on(\"view:zoom\", () => {\n      var _a;\n\n      const pan = (_a = svgPanZoom2.value) == null ? void 0 : _a.getPan();\n\n      if (pan) {\n        basePoint.value = {\n          x: -pan.x,\n          y: -pan.y\n        };\n      }\n    });\n    const thickVerticals = ref([]);\n    const thickHorizontals = ref([]);\n    const normalVerticals = ref([]);\n    const normalHorizontals = ref([]);\n    watchEffect(() => {\n      const thickH = [];\n      const thickV = [];\n      const normalH = [];\n      const normalV = [];\n      const s = 1 / zoomLevel.value;\n      const gi = config.grid.interval;\n      const x = basePoint.value.x * s;\n      const y = basePoint.value.y * s;\n      const width = Math.floor(viewport.value.width / gi + 1) * gi;\n      const height = Math.floor(viewport.value.height / gi + 1) * gi;\n      const maxWidth = (basePoint.value.x + width) * s;\n      const maxHeight = (basePoint.value.y + height) * s;\n      const inc = config.grid.thickIncrements;\n      const normalDasharray = config.grid.line.dasharray;\n      const thickDasharray = config.grid.thick.dasharray;\n      let thickAttrs = {\n        stroke: config.grid.thick.color,\n        \"stroke-width\": config.grid.thick.width,\n        \"stroke-dasharray\": thickDasharray,\n        \"stroke-dashoffset\": thickDasharray ? x / s : void 0\n      };\n      let normalAttrs = {\n        stroke: config.grid.line.color,\n        \"stroke-width\": config.grid.line.width,\n        \"stroke-dasharray\": normalDasharray,\n        \"stroke-dashoffset\": normalDasharray ? x / s : void 0\n      };\n      const w = (basePoint.value.x + width) * s;\n\n      for (let i = y; i <= maxHeight; i += gi) {\n        const index = Math.floor(i / gi);\n\n        if (inc && index % inc === 0) {\n          thickH.push([index, index * gi, x, w, thickAttrs]);\n        } else {\n          normalH.push([index, index * gi, x, w, normalAttrs]);\n        }\n      }\n\n      thickAttrs = __spreadValues({}, thickAttrs);\n      thickAttrs[\"stroke-dashoffset\"] = thickDasharray ? y / s : void 0;\n      normalAttrs = __spreadValues({}, normalAttrs);\n      normalAttrs[\"stroke-dashoffset\"] = normalDasharray ? y / s : void 0;\n      const h = (basePoint.value.y + height) * s;\n\n      for (let i = x; i <= maxWidth; i += gi) {\n        const index = Math.floor(i / gi);\n\n        if (inc && index % inc === 0) {\n          thickV.push([index, index * gi, y, h, thickAttrs]);\n        } else {\n          normalV.push([index, index * gi, y, h, normalAttrs]);\n        }\n      }\n\n      thickHorizontals.value = thickH;\n      thickVerticals.value = thickV;\n      normalHorizontals.value = normalH;\n      normalVerticals.value = normalV;\n    });\n    expose({\n      thickVerticals,\n      thickHorizontals,\n      normalVerticals,\n      normalHorizontals\n    });\n    return (_ctx, _cache) => {\n      return openBlock(), createElementBlock(\"g\", _hoisted_1$7, [(openBlock(true), createElementBlock(Fragment, null, renderList(normalHorizontals.value, ([i, v, x, w, attrs]) => {\n        return openBlock(), createElementBlock(\"path\", mergeProps({\n          key: `nv${i}`,\n          d: `M ${x} ${v} L ${w} ${v}`\n        }, attrs, {\n          style: {\n            \"vector-effect\": \"non-scaling-stroke\"\n          }\n        }), null, 16, _hoisted_2$1);\n      }), 128)), (openBlock(true), createElementBlock(Fragment, null, renderList(normalVerticals.value, ([i, v, y, h, attrs]) => {\n        return openBlock(), createElementBlock(\"path\", mergeProps({\n          key: `nh${i}`,\n          d: `M ${v} ${y} L ${v} ${h}`\n        }, attrs, {\n          style: {\n            \"vector-effect\": \"non-scaling-stroke\"\n          }\n        }), null, 16, _hoisted_3$1);\n      }), 128)), (openBlock(true), createElementBlock(Fragment, null, renderList(thickHorizontals.value, ([i, v, x, w, attrs]) => {\n        return openBlock(), createElementBlock(\"path\", mergeProps({\n          key: `tv${i}`,\n          d: `M ${x} ${v} L ${w} ${v}`\n        }, attrs, {\n          style: {\n            \"vector-effect\": \"non-scaling-stroke\"\n          }\n        }), null, 16, _hoisted_4$1);\n      }), 128)), (openBlock(true), createElementBlock(Fragment, null, renderList(thickVerticals.value, ([i, v, y, h, attrs]) => {\n        return openBlock(), createElementBlock(\"path\", mergeProps({\n          key: `th${i}`,\n          d: `M ${v} ${y} L ${v} ${h}`\n        }, attrs, {\n          style: {\n            \"vector-effect\": \"non-scaling-stroke\"\n          }\n        }), null, 16, _hoisted_5);\n      }), 128))]);\n    };\n  }\n\n});\n\nfunction findFirstNonNull(...values) {\n  return values.find(v => !!v);\n}\n\nconst EPSILON = Number.EPSILON * 100;\n\nfunction calculatePathPoints(path, nodeStates, nodeLayouts, edgeStates, scale, curveInNode, pathEndType, margin) {\n  var _a;\n\n  const edges = path.edges;\n\n  const directions = _detectDirectionsOfPathEdges(edges);\n\n  const edgePos = edges.map((edge, i) => _getEdgeLine(edge, directions[i], edgeStates[edge.edgeId]));\n  const points = [];\n  let isMarginOverRunStart = false;\n  let isMarginOverRunEnd = false;\n  {\n    const firstEdge = edgePos[0];\n    let nodeRadius = _getNodeRadius(nodeStates[firstEdge.source].shape) * scale;\n    const lineMargin = margin + (pathEndType === \"edgeOfNode\" ? nodeRadius : 0);\n    const nextPoint = lineMargin <= 0 ? firstEdge.line.source : _calculateEdgeOfNode(firstEdge, lineMargin, nodeLayouts, true);\n    points.push(nextPoint);\n    nodeRadius = _getNodeRadius(nodeStates[firstEdge.target].shape) * scale;\n\n    if (margin > 0) {\n      const distance2 = V.distance(firstEdge.line.source, firstEdge.line.target);\n\n      if (distance2 <= lineMargin + nodeRadius) {\n        isMarginOverRunStart = true;\n      }\n    }\n  }\n  const length2 = edges.length;\n\n  for (let i = 1; i < length2; i++) {\n    const prev = edgePos[i - 1];\n    const next = edgePos[i];\n    const nodeId = next.source;\n    const nodePos = Vector2D.fromObject((_a = nodeLayouts[nodeId]) != null ? _a : {\n      x: 0,\n      y: 0\n    });\n\n    const crossPoint = _getIntersectionOfLines(prev, next, nodePos);\n\n    const nodeRadius = _getNodeRadius(nodeStates[nodeId].shape) * scale;\n    const nodeCoreRadius = Math.max(nodeRadius * (2 / 3), nodeRadius - 4 * scale);\n\n    const prevCoreIp = _getIntersectionOfLineAndNode(prev, nodePos, nodeCoreRadius, true);\n\n    const nextCoreIp = _getIntersectionOfLineAndNode(next, nodePos, nodeCoreRadius, false);\n\n    const prevNodeIp = _getIntersectionOfLineAndNode(prev, nodePos, nodeRadius, true);\n\n    const nextNodeIp = _getIntersectionOfLineAndNode(next, nodePos, nodeRadius, false);\n\n    let pos;\n\n    if (crossPoint) {\n      const d = V.distance(crossPoint, nodePos);\n\n      if (d < nodeCoreRadius) {\n        pos = [findFirstNonNull(prevCoreIp, prevNodeIp, prev.line.target), crossPoint, findFirstNonNull(nextCoreIp, nextNodeIp, next.line.source)];\n      } else if (d <= nodeRadius) {\n        let p1, p2;\n\n        if (prevNodeIp && prevCoreIp) {\n          p1 = V.distance(crossPoint, prevCoreIp) < V.distance(crossPoint, prevNodeIp) ? prevCoreIp : prevNodeIp;\n        } else {\n          p1 = prevNodeIp || prev.line.target;\n        }\n\n        if (nextNodeIp && nextCoreIp) {\n          p2 = V.distance(crossPoint, nextCoreIp) < V.distance(crossPoint, nextNodeIp) ? nextCoreIp : nextNodeIp;\n        } else {\n          p2 = nextNodeIp || next.line.source;\n        }\n\n        pos = [p1, crossPoint, p2];\n      } else {\n        if (prevCoreIp && nextCoreIp) {\n          pos = [prevCoreIp, nodePos, nextCoreIp];\n        } else if (prevNodeIp && nextNodeIp) {\n          pos = [prevNodeIp, nodePos, nextNodeIp];\n        } else {\n          pos = [findFirstNonNull(prevCoreIp, prevNodeIp, prev.line.target), nodePos, findFirstNonNull(nextCoreIp, nextNodeIp, next.line.source)];\n        }\n      }\n    } else {\n      if (prevCoreIp && nextCoreIp) {\n        pos = [prevCoreIp, nodePos, nextCoreIp];\n      } else if (prevNodeIp && nextNodeIp) {\n        pos = [prevNodeIp, nodePos, nextNodeIp];\n      } else {\n        pos = [prev.line.target, nodePos, next.line.source];\n      }\n    }\n\n    if (prev.curve) {\n      const lastPoints = points[points.length - 1];\n\n      if (lastPoints) {\n        const lastPoint = lastPoints instanceof Array ? lastPoints[lastPoints.length - 1] : lastPoints;\n        let nextPoint;\n\n        if (pos instanceof Array) {\n          nextPoint = curveInNode ? pos[0] : pos[1];\n        } else {\n          nextPoint = pos;\n        }\n\n        const control = calculateBezierCurveControlPoint(lastPoint, prev.curve.circle.center, nextPoint, prev.curve.theta);\n\n        if (pos instanceof Array && curveInNode) {\n          points.push([...control, ...pos]);\n        } else {\n          points.push([...control, nextPoint]);\n        }\n      }\n    } else {\n      if (curveInNode || !(pos instanceof Array)) {\n        points.push(pos);\n      } else {\n        if (next.curve) {\n          points.push(pos[1]);\n        } else {\n          points.push(pos[0], pos[2]);\n        }\n      }\n    }\n  }\n\n  {\n    const lastEdge = edgePos[edgePos.length - 1];\n    let nodeRadius = _getNodeRadius(nodeStates[lastEdge.target].shape) * scale;\n    const lineMargin = margin + (pathEndType === \"edgeOfNode\" ? nodeRadius : 0);\n    const nextPoint = lineMargin <= 0 ? lastEdge.line.target : _calculateEdgeOfNode(lastEdge, lineMargin, nodeLayouts, false);\n    nodeRadius = _getNodeRadius(nodeStates[lastEdge.source].shape) * scale;\n    const curve = lastEdge.curve;\n\n    if (curve) {\n      const pos = points[points.length - 1];\n      const lastPoint = pos instanceof Array ? pos[pos.length - 1] : pos;\n      const control = calculateBezierCurveControlPoint(lastPoint, curve.circle.center, nextPoint, curve.theta);\n      points.push([...control, nextPoint]);\n    } else {\n      points.push(nextPoint);\n    }\n\n    if (margin > 0) {\n      const distance2 = V.distance(lastEdge.line.source, lastEdge.line.target);\n\n      if (distance2 <= lineMargin + nodeRadius) {\n        isMarginOverRunEnd = true;\n      }\n    }\n  }\n\n  if (isMarginOverRunStart) {\n    points.shift();\n\n    if (points[0] instanceof Array) {\n      points.unshift(points[0][0]);\n    }\n  }\n\n  if (isMarginOverRunEnd) {\n    points.pop();\n  }\n\n  return points;\n}\n\nfunction _detectDirectionsOfPathEdges(edges) {\n  const length2 = edges.length;\n\n  if (length2 <= 1) {\n    return [true];\n  }\n\n  const directions = [];\n  let lastNode = null;\n\n  for (let i = 0; i < length2; i++) {\n    const source = edges[i].edge.source;\n    const target = edges[i].edge.target;\n    let isForward;\n\n    if (i === 0) {\n      if (length2 > 2) {\n        const edge0 = [source, target].sort();\n        const edge1 = [edges[1].edge.source, edges[1].edge.target].sort();\n\n        if (edge0[0] === edge1[0] && edge0[1] === edge1[1]) {\n          const next = [edges[2].edge.source, edges[2].edge.target];\n\n          if (next.includes(edges[1].edge.target)) {\n            isForward = target === edges[1].edge.source;\n          } else {\n            isForward = target === edges[1].edge.target;\n          }\n        } else {\n          isForward = [edges[1].edge.source, edges[1].edge.target].includes(target);\n        }\n      } else {\n        isForward = [edges[1].edge.source, edges[1].edge.target].includes(target);\n      }\n    } else {\n      isForward = lastNode === source;\n    }\n\n    directions.push(isForward);\n    lastNode = isForward ? target : source;\n  }\n\n  return directions;\n}\n\nfunction _calculateEdgeOfNode(edge, nodeRadius, nodeLayouts, direction) {\n  const nodeId = direction ? edge.source : edge.target;\n  const curve = edge.curve;\n\n  if (curve) {\n    let moveRad = nodeRadius / curve.circle.radius;\n\n    if (curve.theta > 0) {\n      moveRad *= -1;\n    }\n\n    if (!direction) {\n      moveRad *= -1;\n    }\n\n    return Vector2D.fromObject(moveOnCircumference(direction ? edge.line.source : edge.line.target, curve.circle.center, moveRad));\n  } else {\n    let source, target;\n\n    if (direction) {\n      source = edge.line.target;\n      target = edge.line.source;\n    } else {\n      source = edge.line.source;\n      target = edge.line.target;\n    }\n\n    const p = getIntersectionOfLineTargetAndCircle(source, target, Vector2D.fromObject(nodeLayouts[nodeId]), nodeRadius);\n    return p === null ? source : p;\n  }\n}\n\nfunction _getIntersectionOfLines(prev, next, nodePos) {\n  let crossPoint = null;\n\n  if (prev.curve) {\n    if (next.curve) {\n      if (prev.line.target.isEqualTo(next.line.source)) {\n        return prev.line.target.clone();\n      }\n\n      crossPoint = getIntersectionOfCircles(prev.curve.circle.center, prev.curve.circle.radius, next.curve.circle.center, next.curve.circle.radius, prev.curve.center);\n    } else {\n      crossPoint = getIntersectionOfLineTargetAndCircle2(next.line.target, next.line.source, prev.curve.circle.center, prev.curve.circle.radius, nodePos);\n    }\n  } else {\n    if (next.curve) {\n      crossPoint = getIntersectionOfLineTargetAndCircle(prev.line.source, prev.line.target, next.curve.circle.center, next.curve.circle.radius);\n    } else {\n      const prevSlope = _getSlope(prev.line);\n\n      const nextSlope = _getSlope(next.line);\n\n      const isParallel = !isFinite(prevSlope) && !isFinite(nextSlope) || Math.abs(prevSlope - nextSlope) < EPSILON;\n\n      if (isParallel) {\n        crossPoint = null;\n      } else {\n        crossPoint = getIntersectionPointOfLines(prev.line, next.line);\n      }\n    }\n  }\n\n  return crossPoint;\n}\n\nfunction _getIntersectionOfLineAndNode(edge, nodeCenter, nodeRadius, targetSide) {\n  if (edge.curve) {\n    return getIntersectionOfCircles(nodeCenter, nodeRadius, edge.curve.circle.center, edge.curve.circle.radius, Vector2D.fromObject(edge.curve.center));\n  } else {\n    return getIntersectionOfLineTargetAndCircle(targetSide ? edge.line.source : edge.line.target, targetSide ? edge.line.target : edge.line.source, nodeCenter, nodeRadius);\n  }\n}\n\nfunction _getEdgeLine(edge, direction, state) {\n  let position = state.origin;\n  let source = edge.edge.source;\n  let target = edge.edge.target;\n  let curve = state.curve;\n\n  if (!direction) {\n    position = inverseLine(position);\n    source = edge.edge.target;\n    target = edge.edge.source;\n\n    if (curve) {\n      curve = __spreadProps(__spreadValues({}, curve), {\n        theta: -curve.theta\n      });\n    }\n  }\n\n  const line = VectorLine.fromLinePosition(position);\n  const result = {\n    edgeId: edge.edgeId,\n    source,\n    target,\n    line,\n    curve\n  };\n  return result;\n}\n\nfunction _getNodeRadius(shape) {\n  if (shape.type == \"circle\") {\n    return shape.radius;\n  } else {\n    return Math.min(shape.width, shape.height) / 2;\n  }\n}\n\nfunction _getSlope(pos) {\n  return (pos.target.y - pos.source.y) / (pos.target.x - pos.source.x);\n}\n\nvar VPathLine_vue_vue_type_style_index_0_scoped_true_lang = \"\";\nconst _hoisted_1$6 = [\"d\", \"stroke\", \"stroke-width\", \"stroke-dasharray\", \"stroke-linecap\", \"stroke-linejoin\"];\n\nconst _sfc_main$8 = /* @__PURE__ */defineComponent({\n  props: {\n    points: {\n      type: Array,\n      required: true\n    },\n    path: {\n      type: Object,\n      required: true\n    }\n  },\n\n  setup(__props, {\n    expose\n  }) {\n    const props = __props;\n    const {\n      scale\n    } = useZoomLevel();\n    const pathConfig = usePathConfig();\n    const d = computed(() => {\n      let move = true;\n      return props.points.map(p => {\n        if (p === null) {\n          move = true;\n        } else if (p instanceof Array) {\n          p = [...p];\n          const list = [];\n\n          if (p.length % 2 === 1) {\n            const x = p[0];\n            p = p.slice(1);\n            list.push(`L ${x.x} ${x.y}`);\n          }\n\n          chunk(p, 2).map(([p1, p2]) => list.push(`Q ${p1.x} ${p1.y} ${p2.x} ${p2.y}`));\n          return list.join(\" \");\n        } else {\n          const m = move;\n          move = false;\n          return `${m ? \"M \" : \"L \"}${p.x} ${p.y}`;\n        }\n      }).join(\" \");\n    });\n    const config = computed(() => {\n      const state = props.path;\n\n      if (state.selected) {\n        return Config.values(pathConfig.selected, state.path);\n      } else if (state.hovered && pathConfig.hover) {\n        return Config.values(pathConfig.hover, state.path);\n      } else {\n        return Config.values(pathConfig.normal, state.path);\n      }\n    });\n    const strokeDasharray = computed(() => {\n      return applyScaleToDasharray(config.value.dasharray, scale.value);\n    });\n    const animationSpeed = computed(() => {\n      const speed = config.value.animate ? getDasharrayUnit(config.value.dasharray) * config.value.animationSpeed * scale.value : false;\n      return speed ? `--animation-speed:${speed}` : void 0;\n    });\n    expose({\n      d,\n      scale,\n      config,\n      strokeDasharray,\n      animationSpeed\n    });\n    return (_ctx, _cache) => {\n      return openBlock(), createElementBlock(\"path\", {\n        class: normalizeClass({\n          \"v-path-line\": true,\n          animate: unref(config).animate\n        }),\n        d: unref(d),\n        fill: \"none\",\n        stroke: unref(config).color,\n        \"stroke-width\": unref(config).width * unref(scale),\n        \"stroke-dasharray\": unref(strokeDasharray),\n        \"stroke-linecap\": unref(config).linecap,\n        \"stroke-linejoin\": unref(config).linejoin,\n        style: normalizeStyle(unref(animationSpeed))\n      }, null, 14, _hoisted_1$6);\n    };\n  }\n\n});\n\nvar VPathLine = /* @__PURE__ */_export_sfc(_sfc_main$8, [[\"__scopeId\", \"data-v-e0c8fe90\"]]);\n\nvar VPaths_vue_vue_type_style_index_0_scoped_true_lang = \"\";\n\nconst _sfc_main$7 = /* @__PURE__ */defineComponent({\n  setup(__props, {\n    expose\n  }) {\n    const {\n      pathZOrderedList,\n      nodeStates,\n      edgeStates,\n      layouts\n    } = useStates();\n    const {\n      scale\n    } = useZoomLevel();\n    const pathConfig = usePathConfig();\n    const {\n      handlePathPointerDownEvent,\n      handlePathPointerOverEvent,\n      handlePathPointerOutEvent,\n      handlePathClickEvent,\n      handlePathDoubleClickEvent,\n      handlePathContextMenu\n    } = useMouseOperation();\n    const calcPathPoints = computed(() => path => {\n      if (path.edges.length === 0) return [];\n      const margin = Config.value(pathConfig.margin, path.path) * scale.value;\n      return calculatePathPoints(path, nodeStates, layouts.nodes, edgeStates, scale.value, pathConfig.curveInNode, pathConfig.end, margin);\n    });\n    expose({\n      pathConfig,\n      pathZOrderedList,\n      calcPathPoints,\n      handlePathPointerDownEvent,\n      handlePathPointerOverEvent,\n      handlePathPointerOutEvent,\n      handlePathClickEvent,\n      handlePathDoubleClickEvent,\n      handlePathContextMenu\n    });\n    return (_ctx, _cache) => {\n      return openBlock(), createBlock(TransitionGroup, {\n        name: unref(pathConfig).transition,\n        css: !!unref(pathConfig).transition,\n        tag: \"g\",\n        class: \"v-paths\"\n      }, {\n        default: withCtx(() => [(openBlock(true), createElementBlock(Fragment, null, renderList(unref(pathZOrderedList), path => {\n          return openBlock(), createBlock(VPathLine, {\n            key: path.id,\n            points: unref(calcPathPoints)(path),\n            class: normalizeClass({\n              clickable: path.clickable,\n              hoverable: path.hoverable\n            }),\n            path,\n            onPointerdown: $event => unref(handlePathPointerDownEvent)(path.id, $event),\n            onPointerenterPassive: $event => unref(handlePathPointerOverEvent)(path.id, $event),\n            onPointerleavePassive: $event => unref(handlePathPointerOutEvent)(path.id, $event),\n            onClick: withModifiers($event => unref(handlePathClickEvent)(path.id, $event), [\"stop\"]),\n            onDblclick: withModifiers($event => unref(handlePathDoubleClickEvent)(path.id, $event), [\"stop\"]),\n            onContextmenu: $event => unref(handlePathContextMenu)(path.id, $event)\n          }, null, 8, [\"points\", \"class\", \"path\", \"onPointerdown\", \"onPointerenterPassive\", \"onPointerleavePassive\", \"onClick\", \"onDblclick\", \"onContextmenu\"]);\n        }), 128))]),\n        _: 1\n      }, 8, [\"name\", \"css\"]);\n    };\n  }\n\n});\n\nvar VPaths = /* @__PURE__ */_export_sfc(_sfc_main$7, [[\"__scopeId\", \"data-v-5ef199da\"]]);\n\nconst _hoisted_1$5 = [\"points\", \"fill\"];\n\nconst _sfc_main$6 = /* @__PURE__ */defineComponent({\n  props: {\n    width: {\n      type: Number,\n      required: true\n    },\n    height: {\n      type: Number,\n      required: true\n    },\n    refX: {\n      type: Number,\n      required: true\n    },\n    color: {\n      type: String,\n      required: true\n    },\n    isSource: {\n      type: Boolean,\n      required: true\n    },\n    units: {\n      type: String,\n      required: true\n    }\n  },\n\n  setup(__props) {\n    const props = __props;\n    const arrowPoints = computed(() => {\n      const w = props.width;\n      const h = props.height;\n\n      if (props.isSource) {\n        return `${w} ${h}, 0 ${h / 2}, ${w} 0`;\n      } else {\n        return `0 0, ${w} ${h / 2}, 0 ${h}`;\n      }\n    });\n    return (_ctx, _cache) => {\n      return openBlock(), createElementBlock(\"polygon\", {\n        points: unref(arrowPoints),\n        fill: __props.color\n      }, null, 8, _hoisted_1$5);\n    };\n  }\n\n});\n\nconst _hoisted_1$4 = [\"points\", \"stroke-width\", \"stroke\"];\n\nconst _sfc_main$5 = /* @__PURE__ */defineComponent({\n  props: {\n    width: {\n      type: Number,\n      required: true\n    },\n    height: {\n      type: Number,\n      required: true\n    },\n    refX: {\n      type: Number,\n      required: true\n    },\n    color: {\n      type: String,\n      required: true\n    },\n    isSource: {\n      type: Boolean,\n      required: true\n    },\n    units: {\n      type: String,\n      required: true\n    }\n  },\n\n  setup(__props) {\n    const props = __props;\n    const angleStroke = computed(() => {\n      return props.units === \"strokeWidth\" ? 1 : Math.min(props.width, props.height) / 5;\n    });\n    const anglePoints = computed(() => {\n      const m = angleStroke.value / 2;\n      const w = props.width;\n      const h = props.height;\n\n      if (props.isSource) {\n        return `${w - m} ${h - m}, ${m} ${h / 2}, ${w - m} ${m}`;\n      } else {\n        return `${m} ${m}, ${w - m} ${h / 2}, ${m} ${h - m}`;\n      }\n    });\n    return (_ctx, _cache) => {\n      return openBlock(), createElementBlock(\"polyline\", {\n        points: unref(anglePoints),\n        fill: \"none\",\n        \"stroke-width\": unref(angleStroke),\n        stroke: __props.color,\n        \"stroke-linecap\": \"round\",\n        \"stroke-linejoin\": \"round\"\n      }, null, 8, _hoisted_1$4);\n    };\n  }\n\n});\n\nconst _hoisted_1$3 = [\"fill\", \"cx\", \"cy\", \"rx\", \"ry\"];\n\nconst _sfc_main$4 = /* @__PURE__ */defineComponent({\n  props: {\n    width: {\n      type: Number,\n      required: true\n    },\n    height: {\n      type: Number,\n      required: true\n    },\n    refX: {\n      type: Number,\n      required: true\n    },\n    color: {\n      type: String,\n      required: true\n    },\n    isSource: {\n      type: Boolean,\n      required: true\n    },\n    units: {\n      type: String,\n      required: true\n    }\n  },\n\n  setup(__props) {\n    return (_ctx, _cache) => {\n      return openBlock(), createElementBlock(\"ellipse\", {\n        fill: __props.color,\n        cx: __props.width / 2,\n        cy: __props.height / 2,\n        rx: __props.width / 2,\n        ry: __props.height / 2\n      }, null, 8, _hoisted_1$3);\n    };\n  }\n\n});\n\nconst _hoisted_1$2 = [\"id\", \"markerWidth\", \"markerHeight\", \"refX\", \"refY\", \"markerUnits\"];\n\nconst _sfc_main$3 = /* @__PURE__ */defineComponent({\n  props: {\n    id: {\n      type: String,\n      required: true\n    },\n    marker: {\n      type: Object,\n      required: true\n    },\n    scale: {\n      type: Number,\n      required: true\n    }\n  },\n\n  setup(__props) {\n    const props = __props;\n    const types = {\n      arrow: _sfc_main$6,\n      angle: _sfc_main$5,\n      circle: _sfc_main$4\n    };\n    const width = computed(() => props.marker.width * (props.marker.units === \"strokeWidth\" ? 1 : props.scale));\n    const height = computed(() => props.marker.height * (props.marker.units === \"strokeWidth\" ? 1 : props.scale));\n    const refX = computed(() => {\n      const margin = props.marker.margin * (props.marker.units === \"strokeWidth\" ? 1 : props.scale);\n      return props.marker.isSource ? width.value + margin : -margin;\n    });\n    return (_ctx, _cache) => {\n      return __props.marker.type !== \"none\" && __props.marker.type !== \"custom\" ? (openBlock(), createElementBlock(\"marker\", {\n        key: 0,\n        id: __props.id,\n        markerWidth: unref(width),\n        markerHeight: unref(height),\n        refX: unref(refX),\n        refY: unref(height) / 2,\n        orient: \"auto\",\n        markerUnits: __props.marker.units,\n        class: \"v-marker\"\n      }, [(openBlock(), createBlock(resolveDynamicComponent(types[__props.marker.type]), {\n        width: unref(width),\n        height: unref(height),\n        refX: unref(refX),\n        color: __props.marker.color,\n        \"is-source\": __props.marker.isSource,\n        units: __props.marker.units\n      }, null, 8, [\"width\", \"height\", \"refX\", \"color\", \"is-source\", \"units\"]))], 8, _hoisted_1$2)) : createCommentVNode(\"\", true);\n    };\n  }\n\n});\n\nvar VSelectionBox_vue_vue_type_style_index_0_scoped_true_lang = \"\";\nconst _hoisted_1$1 = [\"x\", \"y\", \"width\", \"height\", \"fill\", \"stroke\", \"stroke-width\", \"stroke-dasharray\"];\n\nconst _sfc_main$2 = /* @__PURE__ */defineComponent({\n  props: {\n    box: {\n      type: Object,\n      required: true\n    },\n    config: {\n      type: Object,\n      required: true\n    }\n  },\n\n  setup(__props) {\n    return (_ctx, _cache) => {\n      return openBlock(), createElementBlock(\"rect\", {\n        class: \"selection-box\",\n        x: Math.round(__props.box.pos.x),\n        y: Math.round(__props.box.pos.y),\n        width: Math.ceil(__props.box.size.width),\n        height: Math.ceil(__props.box.size.height),\n        fill: __props.config.color,\n        stroke: __props.config.strokeColor,\n        \"stroke-width\": __props.config.strokeWidth,\n        \"stroke-dasharray\": __props.config.strokeDasharray\n      }, null, 8, _hoisted_1$1);\n    };\n  }\n\n});\n\nvar VSelectionBox = /* @__PURE__ */_export_sfc(_sfc_main$2, [[\"__scopeId\", \"data-v-7cc205b5\"]]);\n\nvar VNetworkGraph_vue_vue_type_style_index_0_scoped_true_lang = \"\";\nconst SYSTEM_SLOTS = [\"override-node\", \"override-node-label\", \"edge-overlay\", \"edge-label\", \"edges-label\"];\n\nconst _sfc_main$1 = defineComponent({\n  components: {\n    VNode,\n    VNodeFocusRing,\n    VEdgeGroups: _sfc_main$e,\n    VEdgeBackgrounds: _sfc_main$c,\n    VEdgeLabels,\n    VBackgroundViewport: _sfc_main$a,\n    VBackgroundGrid: _sfc_main$9,\n    VPaths,\n    VMarkerHead: _sfc_main$3,\n    VSelectionBox\n  },\n  props: {\n    nodes: {\n      type: Object,\n      default: () => ({})\n    },\n    edges: {\n      type: Object,\n      default: () => ({})\n    },\n    paths: {\n      type: [Object, Array],\n      default: () => ({})\n    },\n    layouts: {\n      type: Object,\n      default: () => ({})\n    },\n    zoomLevel: {\n      type: Number,\n      default: 1\n    },\n    selectedNodes: {\n      type: Array,\n      default: () => []\n    },\n    selectedEdges: {\n      type: Array,\n      default: () => []\n    },\n    selectedPaths: {\n      type: Array,\n      default: () => []\n    },\n    configs: {\n      type: Object,\n      default: () => ({})\n    },\n    layers: {\n      type: Object,\n      default: () => ({})\n    },\n    eventHandlers: {\n      type: Object,\n      default: () => ({})\n    }\n  },\n  emits: [\"update:zoomLevel\", \"update:selectedNodes\", \"update:selectedEdges\", \"update:selectedPaths\", \"update:layouts\"],\n\n  setup(props, {\n    emit,\n    slots\n  }) {\n    const nodesRef = toRef(props, \"nodes\");\n    const edgesRef = toRef(props, \"edges\");\n    const {\n      objects: pathsRef,\n      isInCompatibilityModeForPath\n    } = useTranslatePathsToObject(toRef(props, \"paths\"));\n    const emitter = provideEventEmitter();\n    Object.entries(props.eventHandlers).forEach(([type, event]) => {\n      emitter.on(type, event);\n    });\n    const configs = provideConfigs(toRef(props, \"configs\"));\n    const layerDefs = computed(() => {\n      const definedSlots = new Set(Object.keys(slots));\n      SYSTEM_SLOTS.forEach(s => definedSlots.delete(s));\n      const layers = Object.fromEntries(LayerPositions.map(n => [n, []]));\n      Object.assign(layers, Object.entries(props.layers).reduce((accum, [name, type]) => {\n        definedSlots.delete(name);\n\n        if (type in accum) {\n          accum[type].push(name);\n        } else {\n          accum[type] = [name];\n        }\n\n        return accum;\n      }, {}));\n      layers[\"root\"].push(...definedSlots);\n      return layers;\n    });\n    const isShowGrid = computed(() => configs.view.grid.visible);\n    const isShowBackgroundViewport = computed(() => {\n      const layers = layerDefs.value;\n      return isShowGrid.value || layers[\"background\"].length > 0 || layers[\"grid\"].length > 0;\n    });\n    const hasOverrideNodeSlot = computed(() => \"override-node\" in slots);\n    const hasOverrideNodeLabelSlot = computed(() => \"override-node-label\" in slots);\n    const hasEdgeOverlaySlot = computed(() => \"edge-overlay\" in slots);\n    const hasEdgeLabelSlot = computed(() => \"edge-label\" in slots);\n    const hasEdgesLabelSlot = computed(() => \"edges-label\" in slots);\n    const container = ref();\n    const svg = ref();\n    const viewport = ref();\n    const state = ref(0);\n    const show = computed(() => state.value !== 0);\n    const zoomLevel = bindProp(props, \"zoomLevel\", emit, v => {\n      v = Math.max(v, configs.view.minZoomLevel);\n      v = Math.min(v, configs.view.maxZoomLevel);\n      return v;\n    });\n    const {\n      svgPanZoom: svgPanZoom2,\n      onSvgPanZoomMounted,\n      onSvgPanZoomUnmounted\n    } = useSvgPanZoom(svg, {\n      viewportSelector: \".v-viewport\",\n      minZoom: configs.view.minZoomLevel,\n      maxZoom: configs.view.maxZoomLevel,\n      dblClickZoomEnabled: isDoubleClickZoomEnabled(configs.view),\n      mouseWheelZoomEnabled: isMouseWheelZoomEnabled(configs.view),\n      fit: true,\n      center: true,\n      zoomEnabled: configs.view.zoomEnabled,\n      preventMouseEventsDefault: false,\n      onZoom: _ => {\n        var _a, _b;\n\n        if (state.value === 2) return;\n        const z = (_b = (_a = svgPanZoom2.value) == null ? void 0 : _a.getRealZoom()) != null ? _b : 1;\n\n        if (Math.abs(zoomLevel.value - z) >= 1e-6) {\n          zoomLevel.value = z;\n          emitter.emit(\"view:zoom\", z);\n        }\n      },\n      panEnabled: configs.view.panEnabled,\n      onPan: p => {\n        if (state.value === 2) return;\n        emitter.emit(\"view:pan\", p);\n      }\n    });\n    provideContainers({\n      container,\n      svg,\n      viewport,\n      svgPanZoom: svgPanZoom2\n    });\n    const rectSize = {\n      width: 0,\n      height: 0\n    };\n    const resizeObserver = globalThis.ResizeObserver ? new ResizeObserver(() => {\n      var _a, _b, _c;\n\n      (_a = svgPanZoom2.value) == null ? void 0 : _a.resize();\n      if (!configs.view.autoPanOnResize) return;\n      const r = (_b = container.value) == null ? void 0 : _b.getBoundingClientRect();\n\n      if (r) {\n        const x = -(rectSize.width - r.width) / 2;\n        const y = -(rectSize.height - r.height) / 2;\n        (_c = svgPanZoom2.value) == null ? void 0 : _c.panBy({\n          x,\n          y\n        });\n        const {\n          width,\n          height\n        } = r;\n\n        if (rectSize.width !== width || rectSize.height !== height) {\n          Object.assign(rectSize, {\n            width,\n            height\n          });\n          emitter.emit(\"view:resize\", {\n            x: r.x,\n            y: r.y,\n            width,\n            height\n          });\n        }\n      }\n    }) : void 0;\n    onSvgPanZoomMounted(() => {\n      var _a, _b, _c;\n\n      const c = nonNull(container.value, \"svg-pan-zoom container\");\n      resizeObserver == null ? void 0 : resizeObserver.observe(c);\n      (_b = (_a = configs.view).onSvgPanZoomInitialized) == null ? void 0 : _b.call(_a, nonNull(svgPanZoom2.value, \"svg-pan-zoom instance\"));\n      const r = c.getBoundingClientRect();\n      const {\n        width,\n        height\n      } = r;\n      Object.assign(rectSize, {\n        width,\n        height\n      });\n      (_c = viewport.value) == null ? void 0 : _c.addEventListener(\"touchstart\", stopEventPropagation, {\n        passive: false\n      });\n    });\n    onSvgPanZoomUnmounted(() => {\n      var _a;\n\n      resizeObserver == null ? void 0 : resizeObserver.disconnect();\n      (_a = viewport.value) == null ? void 0 : _a.removeEventListener(\"touchstart\", stopEventPropagation);\n    });\n\n    const applyAbsoluteZoomLevel = absoluteZoomLevel => {\n      var _a;\n\n      (_a = svgPanZoom2.value) == null ? void 0 : _a.applyAbsoluteZoomLevel(absoluteZoomLevel, configs.view.minZoomLevel, configs.view.maxZoomLevel);\n    };\n\n    watch(() => configs.view.panEnabled, v => {\n      var _a;\n\n      (_a = svgPanZoom2.value) == null ? void 0 : _a.setPanEnabled(v);\n    });\n    watch(() => [configs.view.zoomEnabled, isDoubleClickZoomEnabled(configs.view), isMouseWheelZoomEnabled(configs.view)], v => {\n      applyZoomEnabled(svgPanZoom2.value, configs.view.zoomEnabled, configs.view.doubleClickZoomEnabled, configs.view.mouseWheelZoomEnabled);\n    });\n    watch(zoomLevel, v => applyAbsoluteZoomLevel(v));\n    watch(() => [configs.view.minZoomLevel, configs.view.maxZoomLevel], _ => {\n      applyAbsoluteZoomLevel(zoomLevel.value);\n    });\n    const {\n      scale\n    } = provideZoomLevel(zoomLevel, configs.view);\n    onSvgPanZoomMounted(() => {\n      const initialZoomLevel = props.zoomLevel;\n      applyAbsoluteZoomLevel(initialZoomLevel);\n    });\n\n    const updateBorderBox = callback => {\n      var _a;\n\n      if (Object.keys(props.nodes).length > 0) {\n        (_a = svgPanZoom2.value) == null ? void 0 : _a.updateBBox();\n        nextTick(callback);\n      } else {\n        callback();\n      }\n    };\n\n    const fitToContents = () => {\n      updateBorderBox(() => {\n        if (svgPanZoom2.value) {\n          svgPanZoom2.value.fitToContents();\n          emitter.emit(\"view:fit\", void 0);\n        }\n      });\n    };\n\n    const panToCenter = () => {\n      updateBorderBox(() => {\n        var _a;\n\n        (_a = svgPanZoom2.value) == null ? void 0 : _a.center();\n      });\n    };\n\n    const getViewBox = () => {\n      var _a, _b;\n\n      return (_b = (_a = svgPanZoom2.value) == null ? void 0 : _a.getViewBox()) != null ? _b : {\n        top: 0,\n        bottom: 0,\n        left: 0,\n        right: 0\n      };\n    };\n\n    const setViewBox = box => {\n      var _a;\n\n      return (_a = svgPanZoom2.value) == null ? void 0 : _a.setViewBox(box);\n    };\n\n    const currentSelectedNodes = bindPropKeySet(props, \"selectedNodes\", nodesRef, emit);\n    watch(currentSelectedNodes, nodes => emitter.emit(\"node:select\", Array.from(nodes)));\n    const currentSelectedEdges = bindPropKeySet(props, \"selectedEdges\", edgesRef, emit);\n    watch(currentSelectedEdges, edges => emitter.emit(\"edge:select\", Array.from(edges)));\n    const currentSelectedPaths = bindPropKeySet(props, \"selectedPaths\", pathsRef, emit);\n    watch(currentSelectedPaths, paths => emitter.emit(\"path:select\", Array.from(paths)));\n    const hoveredNodes = Reactive( /* @__PURE__ */new Set());\n    const hoveredEdges = Reactive( /* @__PURE__ */new Set());\n    const hoveredPaths = Reactive( /* @__PURE__ */new Set());\n    const currentLayouts = Reactive({\n      nodes: {}\n    });\n    watch(() => props.layouts, () => Object.assign(currentLayouts, props.layouts), {\n      deep: true,\n      immediate: true\n    });\n    watch(currentLayouts, () => emit(\"update:layouts\", currentLayouts), {\n      deep: true\n    });\n    const visibleNodeFocusRing = computed(() => {\n      return configs.node.focusring.visible;\n    });\n    const markerState = makeMarkerState();\n    const dragging = ref(false);\n    emitter.on(\"node:dragstart\", _ => dragging.value = true);\n    emitter.on(\"node:dragend\", _ => dragging.value = false);\n    emitter.on(\"view:mode\", mode => {\n      var _a, _b, _c, _d;\n\n      if (configs.view.panEnabled) {\n        if (mode === \"default\") {\n          (_a = svgPanZoom2.value) == null ? void 0 : _a.enablePan();\n        } else {\n          (_b = svgPanZoom2.value) == null ? void 0 : _b.disablePan();\n        }\n      }\n\n      if (configs.view.zoomEnabled) {\n        if (mode === \"default\") {\n          (_c = svgPanZoom2.value) == null ? void 0 : _c.enableZoom();\n        } else {\n          (_d = svgPanZoom2.value) == null ? void 0 : _d.disableZoom();\n        }\n      }\n    });\n    const touches = computed(() => {\n      return configs.view.panEnabled || configs.view.zoomEnabled || configs.node.draggable;\n    });\n    const {\n      nodeStates,\n      nodeZOrderedList,\n      edgeStates,\n      pathStates\n    } = provideStates(makeStateInput(nodesRef, currentSelectedNodes, hoveredNodes), makeStateInput(edgesRef, currentSelectedEdges, hoveredEdges), makeStateInput(pathsRef, currentSelectedPaths, hoveredPaths), readonly(configs), currentLayouts, markerState, scale);\n    const isSvgWheelZoomEnabled = computed(() => isMouseWheelZoomEnabled(configs.view));\n    const {\n      isBoxSelectionMode,\n      selectionBox,\n      startBoxSelection,\n      stopBoxSelection\n    } = provideMouseOperation(svg, readonly(currentLayouts), readonly(zoomLevel), nodeStates, edgeStates, pathStates, currentSelectedNodes, currentSelectedEdges, currentSelectedPaths, hoveredNodes, hoveredEdges, hoveredPaths, isInCompatibilityModeForPath, isSvgWheelZoomEnabled, configs, emitter);\n    const visiblePaths = computed(() => configs.path.visible);\n\n    const activateParams = () => ({\n      layouts: Reactive(currentLayouts.nodes),\n      nodePositions: toRef(currentLayouts, \"nodes\"),\n      nodes: nodesRef,\n      edges: edgesRef,\n      configs: readonly(configs),\n      scale: readonly(scale),\n      emitter,\n      svgPanZoom: nonNull(svgPanZoom2.value)\n    });\n\n    watch(() => configs.view.layoutHandler, (newHandler, oldHandler) => {\n      oldHandler.deactivate();\n      newHandler.activate(activateParams());\n    });\n    const {\n      transitionWhile,\n      transitionOption\n    } = useTransitionWhile();\n    const transitionStyles = computed(() => {\n      const o = transitionOption.value;\n      return o.enabled ? {\n        \"--transition-duration\": o.duration + \"ms\",\n        \"--transition-function\": o.timingFunction\n      } : {};\n    });\n    onSvgPanZoomMounted(() => {\n      updateBorderBox(() => {\n        const svg2 = nonNull(svgPanZoom2.value, \"svg-pan-zoom\");\n        configs.view.layoutHandler.activate(activateParams());\n        nextTick(() => {\n          const autoPanAndZoom = configs.view.autoPanAndZoomOnLoad;\n\n          if (configs.view.fit || autoPanAndZoom !== false) {\n            const nodesEmpty = Object.keys(props.nodes).length == 0;\n\n            if (nodesEmpty || autoPanAndZoom === \"center-zero\") {\n              const sizes = svg2.getSizes();\n              svg2.pan({\n                x: sizes.width / 2,\n                y: sizes.height / 2\n              });\n            } else if (autoPanAndZoom === \"fit-content\" || configs.view.fit) {\n              fitToContents();\n            } else if (autoPanAndZoom === \"center-content\") {\n              panToCenter();\n            }\n          }\n\n          emitter.emit(\"view:load\");\n          state.value = 1;\n        });\n      });\n    });\n    onSvgPanZoomUnmounted(() => {\n      state.value = 2;\n      emitter.emit(\"view:unload\");\n      configs.view.layoutHandler.deactivate();\n    });\n    return {\n      container,\n      svg,\n      viewport,\n      show,\n      svgPanZoom: svgPanZoom2,\n      allConfigs: configs,\n      layerDefs,\n      isShowGrid,\n      isShowBackgroundViewport,\n      hasOverrideNodeSlot,\n      hasOverrideNodeLabelSlot,\n      hasEdgeOverlaySlot,\n      hasEdgeLabelSlot,\n      hasEdgesLabelSlot,\n      scale,\n      nodeStates,\n      nodeZOrderedList,\n      currentSelectedNodes,\n      markers: markerState.markers,\n      dragging,\n      touches,\n      currentLayouts,\n      visibleNodeFocusRing,\n      visiblePaths,\n      transitionOption,\n      transitionStyles,\n      isBoxSelectionMode,\n      selectionBox,\n      fitToContents,\n      panToCenter,\n      getViewBox,\n      setViewBox,\n      transitionWhile,\n      startBoxSelection,\n      stopBoxSelection\n    };\n  },\n\n  methods: {\n    zoomIn() {\n      var _a;\n\n      (_a = this.svgPanZoom) == null ? void 0 : _a.zoomIn();\n    },\n\n    zoomOut() {\n      var _a;\n\n      (_a = this.svgPanZoom) == null ? void 0 : _a.zoomOut();\n    },\n\n    panTo(point) {\n      var _a;\n\n      (_a = this.svgPanZoom) == null ? void 0 : _a.pan(point);\n    },\n\n    panBy(point) {\n      var _a;\n\n      (_a = this.svgPanZoom) == null ? void 0 : _a.panBy(point);\n    },\n\n    getPan() {\n      return nonNull(this.svgPanZoom).getPan();\n    },\n\n    getSizes() {\n      const sizes = nonNull(this.svgPanZoom).getSizes();\n      return {\n        width: sizes.width,\n        height: sizes.height,\n        viewBox: sizes.viewBox\n      };\n    },\n\n    translateFromDomToSvgCoordinates(coordinates) {\n      return translateFromDomToSvgCoordinates(nonNull(this.svg, \"svg\"), nonNull(this.viewport, \"viewport\"), coordinates);\n    },\n\n    translateFromSvgToDomCoordinates(coordinates) {\n      return translateFromSvgToDomCoordinates(nonNull(this.svg, \"svg\"), nonNull(this.viewport, \"viewport\"), coordinates);\n    },\n\n    getAsSvg() {\n      const element = nonNull(this.svg, \"svg\");\n      const viewport = nonNull(this.viewport, \"svg viewport\");\n      const target = element.cloneNode(true);\n      const box = viewport.getBBox();\n      const z = 1 / this.scale;\n      const svg = {\n        x: Math.floor((box.x - 10) * z),\n        y: Math.floor((box.y - 10) * z),\n        width: Math.ceil((box.width + 20) * z),\n        height: Math.ceil((box.height + 20) * z)\n      };\n      target.setAttribute(\"width\", svg.width.toString());\n      target.setAttribute(\"height\", svg.height.toString());\n      const v = target.querySelector(\".v-viewport\");\n      v.setAttribute(\"transform\", `translate(${-svg.x} ${-svg.y}), scale(${z})`);\n      v.removeAttribute(\"style\");\n      target.setAttribute(\"viewBox\", `0 0 ${svg.width} ${svg.height}`);\n      let data = target.outerHTML;\n      data = data.replaceAll(/ data-v-[0-9a-z]+=\"\"/g, \"\");\n      data = data.replaceAll(/<!--[\\s\\S]*?-->/gm, \"\");\n      return data;\n    }\n\n  }\n});\n\nfunction applyZoomEnabled(svgPanZoom2, enable, enableDblClick, enableMouseWheel) {\n  svgPanZoom2.setZoomEnabled(enable);\n\n  if (enable && enableDblClick) {\n    svgPanZoom2.enableDblClickZoom();\n  } else {\n    svgPanZoom2.disableDblClickZoom();\n  }\n\n  if (enable && enableMouseWheel) {\n    svgPanZoom2.enableMouseWheelZoom();\n  } else {\n    svgPanZoom2.disableMouseWheelZoom();\n  }\n}\n\nfunction isDoubleClickZoomEnabled(view) {\n  return view.zoomEnabled && view.doubleClickZoomEnabled;\n}\n\nfunction isMouseWheelZoomEnabled(view) {\n  return view.zoomEnabled && view.mouseWheelZoomEnabled;\n}\n\nfunction stopEventPropagation(event) {\n  event.stopPropagation();\n}\n\nconst _hoisted_1 = {\n  ref: \"container\",\n  class: \"v-network-graph\"\n};\nconst _hoisted_2 = {\n  key: 0\n};\nconst _hoisted_3 = {\n  class: \"v-layer-edges\"\n};\nconst _hoisted_4 = {\n  key: 1,\n  class: \"v-layer-nodes-selections\"\n};\n\nfunction _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {\n  const _component_v_marker_head = resolveComponent(\"v-marker-head\");\n\n  const _component_v_background_grid = resolveComponent(\"v-background-grid\");\n\n  const _component_v_background_viewport = resolveComponent(\"v-background-viewport\");\n\n  const _component_v_edge_backgrounds = resolveComponent(\"v-edge-backgrounds\");\n\n  const _component_v_edge_groups = resolveComponent(\"v-edge-groups\");\n\n  const _component_v_edge_labels = resolveComponent(\"v-edge-labels\");\n\n  const _component_v_node_focus_ring = resolveComponent(\"v-node-focus-ring\");\n\n  const _component_v_node = resolveComponent(\"v-node\");\n\n  const _component_v_paths = resolveComponent(\"v-paths\");\n\n  const _component_v_selection_box = resolveComponent(\"v-selection-box\");\n\n  return openBlock(), createElementBlock(\"div\", _hoisted_1, [(openBlock(), createElementBlock(\"svg\", {\n    ref: \"svg\",\n    class: normalizeClass([\"v-canvas\", {\n      show: _ctx.show,\n      dragging: _ctx.dragging,\n      touches: _ctx.touches,\n      \"box-selection-mode\": _ctx.isBoxSelectionMode\n    }]),\n    width: \"500\",\n    height: \"500\",\n    viewBox: \"0 0 500 500\"\n  }, [(openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.layerDefs[\"root\"], layerName => {\n    return renderSlot(_ctx.$slots, layerName, {\n      key: layerName,\n      scale: _ctx.scale\n    }, void 0, true);\n  }), 128)), Object.keys(_ctx.markers).length > 0 ? (openBlock(), createElementBlock(\"defs\", _hoisted_2, [(openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.markers, (marker, id) => {\n    return openBlock(), createBlock(_component_v_marker_head, {\n      id,\n      key: id,\n      marker,\n      scale: _ctx.scale\n    }, null, 8, [\"id\", \"marker\", \"scale\"]);\n  }), 128))])) : createCommentVNode(\"\", true), _ctx.isShowBackgroundViewport ? (openBlock(), createBlock(_component_v_background_viewport, {\n    key: 1\n  }, {\n    default: withCtx(() => [(openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.layerDefs[\"background\"], layerName => {\n      return openBlock(), createElementBlock(\"g\", {\n        key: layerName,\n        class: \"v-layer\"\n      }, [renderSlot(_ctx.$slots, layerName, {\n        scale: _ctx.scale\n      }, void 0, true)]);\n    }), 128)), _ctx.isShowGrid ? (openBlock(), createBlock(_component_v_background_grid, {\n      key: 0\n    })) : createCommentVNode(\"\", true), (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.layerDefs[\"grid\"], layerName => {\n      return openBlock(), createElementBlock(\"g\", {\n        key: layerName,\n        class: \"v-layer\"\n      }, [renderSlot(_ctx.$slots, layerName, {\n        scale: _ctx.scale\n      }, void 0, true)]);\n    }), 128))]),\n    _: 3\n  })) : createCommentVNode(\"\", true), createElementVNode(\"g\", {\n    ref: \"viewport\",\n    class: normalizeClass([\"v-viewport\", {\n      \"v-transition\": _ctx.transitionOption.enabled\n    }]),\n    style: normalizeStyle(_ctx.transitionStyles)\n  }, [(openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.layerDefs[\"base\"], layerName => {\n    return openBlock(), createElementBlock(\"g\", {\n      key: layerName,\n      class: \"v-layer\"\n    }, [renderSlot(_ctx.$slots, layerName, {\n      scale: _ctx.scale\n    }, void 0, true)]);\n  }), 128)), createElementVNode(\"g\", _hoisted_3, [createVNode(_component_v_edge_backgrounds), createVNode(_component_v_edge_groups, {\n    hasEdgeOverlaySlot: _ctx.hasEdgeOverlaySlot\n  }, {\n    default: withCtx(slotProps => [renderSlot(_ctx.$slots, \"edge-overlay\", normalizeProps(guardReactiveProps(slotProps)), void 0, true)]),\n    _: 3\n  }, 8, [\"hasEdgeOverlaySlot\"])]), (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.layerDefs[\"edges\"], layerName => {\n    return openBlock(), createElementBlock(\"g\", {\n      key: layerName,\n      class: \"v-layer\"\n    }, [renderSlot(_ctx.$slots, layerName, {\n      scale: _ctx.scale\n    }, void 0, true)]);\n  }), 128)), _ctx.hasEdgeLabelSlot || _ctx.hasEdgesLabelSlot ? (openBlock(), createBlock(_component_v_edge_labels, {\n    key: 0\n  }, createSlots({\n    _: 2\n  }, [_ctx.hasEdgeLabelSlot ? {\n    name: \"edge-label\",\n    fn: withCtx(slotProps => [renderSlot(_ctx.$slots, \"edge-label\", normalizeProps(guardReactiveProps(slotProps)), void 0, true)])\n  } : void 0, _ctx.hasEdgesLabelSlot ? {\n    name: \"edges-label\",\n    fn: withCtx(slotProps => [renderSlot(_ctx.$slots, \"edges-label\", normalizeProps(guardReactiveProps(slotProps)), void 0, true)])\n  } : void 0]), 1024)) : createCommentVNode(\"\", true), _ctx.visibleNodeFocusRing ? (openBlock(), createElementBlock(\"g\", _hoisted_4, [(openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.currentSelectedNodes, nodeId => {\n    return openBlock(), createBlock(_component_v_node_focus_ring, {\n      id: nodeId,\n      key: nodeId,\n      state: _ctx.nodeStates[nodeId],\n      pos: _ctx.currentLayouts.nodes[nodeId]\n    }, null, 8, [\"id\", \"state\", \"pos\"]);\n  }), 128))])) : createCommentVNode(\"\", true), (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.layerDefs[\"focusring\"], layerName => {\n    return openBlock(), createElementBlock(\"g\", {\n      key: layerName,\n      class: \"v-layer\"\n    }, [renderSlot(_ctx.$slots, layerName, {\n      scale: _ctx.scale\n    }, void 0, true)]);\n  }), 128)), createVNode(TransitionGroup, {\n    name: _ctx.allConfigs.node.transition,\n    css: !!_ctx.allConfigs.node.transition,\n    tag: \"g\",\n    class: \"v-layer-nodes\"\n  }, {\n    default: withCtx(() => [(openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.nodeZOrderedList, state => {\n      return openBlock(), createBlock(_component_v_node, {\n        id: state.id,\n        key: state.id,\n        state,\n        pos: _ctx.currentLayouts.nodes[state.id]\n      }, createSlots({\n        _: 2\n      }, [_ctx.hasOverrideNodeSlot ? {\n        name: \"override-node\",\n        fn: withCtx(slotProps => [renderSlot(_ctx.$slots, \"override-node\", normalizeProps(guardReactiveProps(slotProps)), void 0, true)])\n      } : void 0, _ctx.hasOverrideNodeLabelSlot ? {\n        name: \"override-node-label\",\n        fn: withCtx(slotProps => [renderSlot(_ctx.$slots, \"override-node-label\", normalizeProps(guardReactiveProps(slotProps)), void 0, true)])\n      } : void 0]), 1032, [\"id\", \"state\", \"pos\"]);\n    }), 128))]),\n    _: 3\n  }, 8, [\"name\", \"css\"]), (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.layerDefs[\"nodes\"], layerName => {\n    return openBlock(), createElementBlock(\"g\", {\n      key: layerName,\n      class: \"v-layer\"\n    }, [renderSlot(_ctx.$slots, layerName, {\n      scale: _ctx.scale\n    }, void 0, true)]);\n  }), 128)), _ctx.visiblePaths ? (openBlock(), createBlock(_component_v_paths, {\n    key: 2\n  })) : createCommentVNode(\"\", true), (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.layerDefs[\"paths\"], layerName => {\n    return openBlock(), createElementBlock(\"g\", {\n      key: layerName,\n      class: \"v-layer\"\n    }, [renderSlot(_ctx.$slots, layerName, {\n      scale: _ctx.scale\n    }, void 0, true)]);\n  }), 128))], 6), _ctx.selectionBox ? (openBlock(), createBlock(_component_v_selection_box, {\n    key: 2,\n    box: _ctx.selectionBox,\n    config: _ctx.allConfigs.view.selection.box\n  }, null, 8, [\"box\", \"config\"])) : createCommentVNode(\"\", true)], 2))], 512);\n}\n\nvar VNetworkGraph = /* @__PURE__ */_export_sfc(_sfc_main$1, [[\"render\", _sfc_render], [\"__scopeId\", \"data-v-191ef492\"]]);\n\nconst _sfc_main = /* @__PURE__ */defineComponent({\n  props: {\n    area: {\n      type: Object,\n      required: true\n    },\n    config: {\n      type: Object,\n      required: true\n    },\n    text: {\n      type: String,\n      required: false,\n      default: \"\"\n    },\n    align: {\n      type: String,\n      required: false,\n      default: \"center\"\n    },\n    verticalAlign: {\n      type: String,\n      required: false,\n      default: \"center\"\n    },\n    edge: {\n      type: Object,\n      required: false,\n      default: void 0\n    },\n    hovered: {\n      type: Boolean,\n      required: false,\n      default: false\n    },\n    selected: {\n      type: Boolean,\n      required: false,\n      default: false\n    },\n    scale: {\n      type: Number,\n      required: false,\n      default: void 0\n    }\n  },\n\n  setup(__props, {\n    expose\n  }) {\n    const props = __props;\n    const x = ref(0);\n    const y = ref(0);\n    const textAnchor = ref(\"middle\");\n    const dominantBaseline = ref(\"central\");\n    const angle2 = ref(0);\n    watchEffect(() => {\n      const s = props.area.source;\n      const t = props.area.target;\n\n      if (props.align === \"source\") {\n        if (s.above.x == t.above.x) {\n          textAnchor.value = s.above.y > t.above.y ? \"start\" : \"end\";\n        } else {\n          textAnchor.value = s.above.x < t.above.x ? \"start\" : \"end\";\n        }\n\n        if (props.verticalAlign === \"above\") {\n          x.value = s.above.x;\n          y.value = s.above.y;\n          dominantBaseline.value = \"text-top\";\n        } else if (props.verticalAlign === \"below\") {\n          x.value = s.below.x;\n          y.value = s.below.y;\n          dominantBaseline.value = \"hanging\";\n        } else {\n          x.value = (s.above.x + s.below.x) / 2;\n          y.value = (s.above.y + s.below.y) / 2;\n          dominantBaseline.value = \"central\";\n        }\n      } else if (props.align === \"target\") {\n        if (s.above.x == t.above.x) {\n          textAnchor.value = s.above.y < t.above.y ? \"start\" : \"end\";\n        } else {\n          textAnchor.value = s.above.x > t.above.x ? \"start\" : \"end\";\n        }\n\n        if (props.verticalAlign === \"above\") {\n          x.value = t.above.x;\n          y.value = t.above.y;\n          dominantBaseline.value = \"text-top\";\n        } else if (props.verticalAlign === \"below\") {\n          x.value = t.below.x;\n          y.value = t.below.y;\n          dominantBaseline.value = \"hanging\";\n        } else {\n          x.value = (t.above.x + t.below.x) / 2;\n          y.value = (t.above.y + t.below.y) / 2;\n          dominantBaseline.value = \"central\";\n        }\n      } else {\n        textAnchor.value = \"middle\";\n\n        if (props.verticalAlign === \"above\") {\n          x.value = (s.above.x + t.above.x) / 2;\n          y.value = (s.above.y + t.above.y) / 2;\n          dominantBaseline.value = \"text-top\";\n        } else if (props.verticalAlign === \"below\") {\n          x.value = (s.below.x + t.below.x) / 2;\n          y.value = (s.below.y + t.below.y) / 2;\n          dominantBaseline.value = \"hanging\";\n        } else {\n          x.value = (s.above.x + t.below.x) / 2;\n          y.value = (s.above.y + t.below.y) / 2;\n          dominantBaseline.value = \"central\";\n        }\n      }\n\n      let degree = VectorLine.fromPositions(s.above, t.above).v.angleDegree();\n\n      if (degree < -90 || degree >= 90) {\n        degree = degree + 180;\n\n        if (degree > 180) {\n          degree -= 360;\n        }\n      }\n\n      angle2.value = degree;\n    });\n    const updatedConfig = computed(() => {\n      if (dominantBaseline.value === \"central\" && !props.config.background) {\n        return __spreadProps(__spreadValues({}, props.config), {\n          background: {\n            visible: true,\n            color: \"#ffffff\",\n            padding: {\n              vertical: 1,\n              horizontal: 4\n            },\n            borderRadius: 2\n          }\n        });\n      } else {\n        return props.config;\n      }\n    });\n    expose({\n      x,\n      y,\n      textAnchor,\n      dominantBaseline,\n      angle: angle2,\n      updatedConfig\n    });\n    return (_ctx, _cache) => {\n      return openBlock(), createBlock(_sfc_main$m, {\n        class: \"v-edge-label\",\n        text: __props.text,\n        x: x.value,\n        y: y.value,\n        config: unref(updatedConfig),\n        \"text-anchor\": textAnchor.value,\n        \"dominant-baseline\": dominantBaseline.value,\n        transform: `rotate(${angle2.value} ${x.value} ${y.value})`\n      }, null, 8, [\"text\", \"x\", \"y\", \"config\", \"text-anchor\", \"dominant-baseline\", \"transform\"]);\n    };\n  }\n\n});\n\nvar components = /* @__PURE__ */Object.freeze({\n  __proto__: null,\n  [Symbol.toStringTag]: \"Module\",\n  VNetworkGraph,\n  VShape: _sfc_main$n,\n  VEdgeLabel: _sfc_main,\n  VLabelText: _sfc_main$m\n});\nconst DEFAULT_GRID = 10;\n\nclass GridLayout extends SimpleLayout {\n  constructor(options = {}) {\n    super();\n    this.options = options;\n  }\n\n  setNodePosition(nodeLayout, pos) {\n    const grid = this.options.grid || DEFAULT_GRID;\n    nodeLayout.value.x = Math.floor(pos.x / grid) * grid;\n    nodeLayout.value.y = Math.floor(pos.y / grid) * grid;\n  }\n\n}\n\nconst install = function (app) {\n  Object.entries(components).forEach(([componentName, component]) => {\n    app.component(componentName, component);\n  });\n};\n\nexport { Config, GridLayout, LayerPositions, NodeLabelDirection, SimpleLayout, _sfc_main as VEdgeLabel, _sfc_main$m as VLabelText, VNetworkGraph, _sfc_main$n as VShape, Vector2D, configsWithType, install as default, defineConfigs, getFullConfigs, useStates, withSelf };","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MA+DaA,iBAA2C,CACtD,OADsD,EAEtD,OAFsD,EAGtD,WAHsD,EAItD,OAJsD,EAKtD,MALsD,EAMtD,MANsD,EAOtD,YAPsD,EAQtD,MARsD;;kBCpCbC,OAAuB;MAC5DC,WAAWD,KAAX,GAAmB;WACdA;EAAA,OACF;WACEE,SAASF,KAAT;EAAc;AAEzB;;iBAM2BG,KAAgBC,OAAO,aAAgB;MAC5DD,QAAQ,MAAR,IAAqBA,QAAQ,MAAM;UAC/B,IAAIE,KAAJ,CAAU,GAAGD,cAAb;EAA2B;;SAE5BD;AACT;;AC1BA,MAAMG,gBAAgBC,OAAO,YAAP,CAAtB;;2BAEkCC,YAA8B;UACtDF,eAAeE;AACzB;;yBAEmD;QAC3CA,aAAaC,QAAQC,OAAOJ,aAAP,CAAR,EAA+B,YAA/B;SACZ;IACLK,WAAWH,WAAWG,SADjB;IAELC,KAAKJ,WAAWI,GAFX;IAGLC,UAAUL,WAAWK,QAHhB;IAILC,YAAYN,WAAWM;EAJlB;AAMT;;MCrBaC,OAAO;EACX,aAAYf,KAAZ,EAAwCgB,MAAxC,EAAsD;WACpDhB,iBAAiBiB,QAAjB,GAA4BjB,MAAMgB,MAAN,CAA5B,GAA4ChB;EAAA;;EAG9C,cAAaA,KAAb,EAA0CgB,MAA1C,EAAwD;QACzDE,OAAOC,MAAP,CAAcnB,KAAd,EAAqBoB,MAArB,CAA4BC,KAAKA,aAAaJ,QAA9C,EAAwDK,MAAxD,KAAmE,GAAG;aACjEtB;IAAA;;WAEFkB,OAAOK,WAAP,CACLL,OAAOM,OAAP,CAAexB,KAAf,EAAsByB,GAAtB,CAA0B,CAAC,CAACC,CAAD,EAAIL,CAAJ,CAAD,KAAY,CAACK,CAAD,EAAIL,aAAaJ,QAAb,GAAwBI,EAAEL,MAAF,CAAxB,GAAoCK,CAAxC,CAAtC,CADK;EAEP;;AAXgB;;IAiIRM,4DAAL;kCACI;iCACD;sCACK;gCACN;sCACM;iCACL;sCACK;gCACN;sCACM;;AATH;;kBAiJgDC,UAA6B;QACjFC,QAAO;SACNX,OAAOY,MAAP,CAAcD,KAAd,EAAoBD,SAASC,KAAT,CAApB;AACT;;yBAQEE,SAAsC;SAC/BA;AACT;;uBAQEA,SAAsC;SAC/BA;AACT;;qBCjT4BC,MAAYC,OAAmBC,OAAqB;QACxEC,QAAQpB,OAAOI,MAAP,CAAcc,MAAMG,MAApB,EAA4BJ,IAA5B;;MACVG,MAAME,IAAN,IAAc,UAAU;WACnB;MACLC,OAAOH,MAAMI,MAAN,GAAe,CAAf,GAAmBL,KADrB;MAELM,QAAQL,MAAMI,MAAN,GAAe,CAAf,GAAmBL;IAFtB;SAIF;WACE;MACLI,OAAOH,MAAMG,KAAN,GAAcJ,KADhB;MAELM,QAAQL,MAAMK,MAAN,GAAeN;IAFlB;;AAKX;;2BAGEO,SACAC,UACAC,eACAC,gBACS;QAEHC,YAAYC,KAAKC,GAAL,CAASN,QAAQO,CAAR,GAAYL,cAAcK,CAAnC;QACZC,aAAaJ,YAAYH,SAASJ,KAAT,GAAiB,CAAjB,GAAqBM,eAAeN,KAAf,GAAuB;QAGrEY,YAAYJ,KAAKC,GAAL,CAASN,QAAQU,CAAR,GAAYR,cAAcQ,CAAnC;QACZC,aAAaF,YAAYR,SAASF,MAAT,GAAkB,CAAlB,GAAsBI,eAAeJ,MAAf,GAAwB;SACtES,cAAcG;AACvB;;+BAEsCC,WAAwCnB,OAAe;MACvFoB,SAA0B;;MAC1BpB,UAAU,CAAV,IAAemB,cAAc,MAA7B,IAA0CA,cAAc,QAAQ;aACzDA,gCAAa;EAAA,WACb,OAAOA,SAAP,KAAqB,QADR,EACkB;aAC/BA,UACNE,KADM,CACA,KADA,EAEN9B,GAFM,CAEFJ,KAAKmC,SAASnC,CAAT,IAAca,KAFjB,EAGNd,MAHM,CAGCC,KAAK,CAACoC,MAAMpC,CAAN,CAHP,EAINqC,IAJM,CAID,GAJC;EAIE,CANW,MAOjB;aACIL,YAAYnB;EAAA;;SAEhBoB,UAAUA,WAAW,GAArB,GAA2BA,MAA3B,GAAoC;AAC7C;;0BAEiCD,WAAwC;MACnEC,SAA0B;;MAC1BD,cAAc,MAAd,IAA2BA,cAAc,QAAQ;aAC1C;EAAA,WACA,OAAOA,SAAP,KAAqB,QADrB,EAC+B;UAClCM,QAAQN,UACXE,KADW,CACL,KADK,EAEX9B,GAFW,CAEPJ,KAAKmC,SAASnC,CAAT,CAFE,EAGXD,MAHW,CAGJC,KAAK,CAACoC,MAAMpC,CAAN,CAHF;;QAIVsC,MAAMrC,MAAN,GAAe,CAAf,KAAqB,GAAG;eAEjBqC,MAAMC,MAAN,CAAa,CAACC,CAAD,EAAIC,CAAJ,KAAUD,IAAIC,CAA3B,EAA8B,CAA9B;IAA+B,OACnC;eAEIH,MAAMC,MAAN,CAAa,CAACC,CAAD,EAAIC,CAAJ,KAAUD,IAAIC,CAA3B,EAA8B,CAA9B,IAAmC;IAAA;GAXrC,MAaJ;aACIT,YAAY;EAAA;;SAEhBC;AACT;;ACrEA,IAAIS,aAAa,OAAOC,MAAP,IAAiB,QAAjB,IAA6BA,MAA7B,IAAuCA,OAAO9C,MAAP,KAAkBA,MAAzD,IAAmE8C,MAApF;AAEA,mBAAeD,UAAf;ACAA,IAAIE,WAAW,OAAOC,IAAP,IAAe,QAAf,IAA2BA,IAA3B,IAAmCA,KAAKhD,MAAL,KAAgBA,MAAnD,IAA6DgD,IAA5E;AAGA,IAAIC,OAAOJ,gBAAcE,QAAdF,IAA0B9C,SAAS,aAAT,GAArC;AAEA,aAAekD,IAAf;ACPA,IAAIC,eAAe,IAAnB;;AAUA,yBAAyBC,MAAzB,EAAiC;EAC/B,IAAIC,QAAQD,OAAO/C,MAAnB;;EAEA,OAAOgD,WAAWF,aAAaG,IAAb,CAAkBF,OAAOG,MAAP,CAAcF,KAAd,CAAlB,CAAlB,EAA2D;;EAC3D,OAAOA,KAAP;AACF;;ACbA,IAAIG,cAAc,MAAlB;;AASA,kBAAkBJ,MAAlB,EAA0B;EACxB,OAAOA,SACHA,OAAOK,KAAP,CAAa,CAAb,EAAgBC,gBAAgBN,MAAhB,IAA0B,CAA1C,EAA6CO,OAA7C,CAAqDH,WAArD,EAAkE,EAAlE,CADG,GAEHJ,MAFJ;AAGF;;ACSA,kBAAkBrE,KAAlB,EAAyB;EACvB,IAAIqC,OAAO,OAAOrC,KAAlB;EACA,OAAOA,SAAS,IAAT,KAAkBqC,QAAQ,QAAR,IAAoBA,QAAQ,UAA9C,CAAP;AACF;;ACzBA,IAAI9B,WAAS4D,OAAK5D,MAAlB;AAEA,eAAeA,QAAf;ACFA,IAAIsE,gBAAc3D,OAAO4D,SAAzB;AAGA,IAAIC,mBAAiBF,cAAYE,cAAjC;AAOA,IAAIC,yBAAuBH,cAAYI,QAAvC;AAGA,IAAIC,mBAAiB3E,WAASA,SAAO4E,WAAhB5E,GAA8B,MAAnD;;AASA,mBAAmBP,KAAnB,EAA0B;EACxB,IAAIoF,QAAQL,iBAAeM,IAAfN,CAAoB/E,KAApB+E,EAA2BG,gBAA3BH,CAAZ;EAAA,IACIO,MAAMtF,MAAMkF,gBAAN,CADV;;EAGA,IAAI;IACFlF,MAAMkF,gBAAN,IAAwB,MAAxB;IACA,IAAIK,WAAW,IAAf;EAAe,CAFjB,CAEiB,OACRC,CADQ,EACf;;EAEF,IAAIlC,SAAS0B,uBAAqBK,IAArBL,CAA0BhF,KAA1BgF,CAAb;;EACA,IAAIO,QAAJ,EAAc;IACZ,IAAIH,KAAJ,EAAW;MACTpF,MAAMkF,gBAAN,IAAwBI,GAAxB;IAAwB,CAD1B,MAEO;MACL,OAAOtF,MAAMkF,gBAAN,CAAP;IAAaA;;;EAGjB,OAAO5B,MAAP;AACF;;AC1CA,IAAIuB,gBAAc3D,OAAO4D,SAAzB;AAOA,IAAIE,uBAAuBH,cAAYI,QAAvC;;AASA,wBAAwBjF,KAAxB,EAA+B;EAC7B,OAAOgF,qBAAqBK,IAArB,CAA0BrF,KAA1B,CAAP;AACF;;ACdA,IAAIyF,UAAU,eAAd;AAAA,IACIC,eAAe,oBADnB;AAIA,IAAIR,iBAAiB3E,WAASA,SAAO4E,WAAhB5E,GAA8B,MAAnD;;AASA,oBAAoBP,KAApB,EAA2B;EACzB,IAAIA,SAAS,IAAb,EAAmB;IACjB,OAAOA,UAAU,MAAV,GAAsB0F,YAAtB,GAAqCD,OAA5C;EAA4C;;EAE9C,OAAQP,kBAAkBA,kBAAkBhE,OAAOlB,KAAP,CAApC,GACJ2F,UAAU3F,KAAV,CADI,GAEJ4F,eAAe5F,KAAf,CAFJ;AAGF;;ACDA,sBAAsBA,KAAtB,EAA6B;EAC3B,OAAOA,SAAS,IAAT,IAAiB,OAAOA,KAAP,IAAgB,QAAxC;AACF;;ACtBA,IAAI6F,cAAY,iBAAhB;;AAmBA,kBAAkB7F,KAAlB,EAAyB;EACvB,OAAO,OAAOA,KAAP,IAAgB,QAAhB,IACJ8F,aAAa9F,KAAb,KAAuB+F,WAAW/F,KAAX,KAAqB6F,WAD/C;AAEF;;ACrBA,IAAIG,MAAM,IAAI,CAAd;AAGA,IAAIC,aAAa,oBAAjB;AAGA,IAAIC,aAAa,YAAjB;AAGA,IAAIC,YAAY,aAAhB;AAGA,IAAIC,eAAe5C,QAAnB;;AAyBA,kBAAkBxD,KAAlB,EAAyB;EACvB,IAAI,OAAOA,KAAP,IAAgB,QAApB,EAA8B;IAC5B,OAAOA,KAAP;EAAO;;EAET,IAAIqG,SAASrG,KAAT,CAAJ,EAAqB;IACnB,OAAOgG,GAAP;EAAO;;EAET,IAAIM,SAAStG,KAAT,CAAJ,EAAqB;IACnB,IAAIuG,QAAQ,OAAOvG,MAAMwG,OAAb,IAAwB,UAAxB,GAAqCxG,MAAMwG,OAAN,EAArC,GAAuDxG,KAAnE;IACAA,QAAQsG,SAASC,KAAT,IAAmBA,QAAQ,EAA3B,GAAiCA,KAAzC;EAAyC;;EAE3C,IAAI,OAAOvG,KAAP,IAAgB,QAApB,EAA8B;IAC5B,OAAOA,UAAU,CAAV,GAAcA,KAAd,GAAsB,CAACA,KAA9B;EAA8B;;EAEhCA,QAAQyG,SAASzG,KAAT,CAAR;EACA,IAAI0G,WAAWR,WAAW3B,IAAX,CAAgBvE,KAAhB,CAAf;EACA,OAAQ0G,YAAYP,UAAU5B,IAAV,CAAevE,KAAf,CAAZ,GACJoG,aAAapG,MAAM0E,KAAN,CAAY,CAAZ,CAAb,EAA6BgC,WAAW,CAAX,GAAe,CAA5C,CADI,GAEHT,WAAW1B,IAAX,CAAgBvE,KAAhB,IAAyBgG,GAAzB,GAA+B,CAAChG,KAFrC;AAGF;;AC1DA,IAAI2G,aAAW,IAAI,CAAnB;AAAA,IACIC,cAAc,qBADlB;;AA0BA,kBAAkB5G,KAAlB,EAAyB;EACvB,IAAI,CAACA,KAAL,EAAY;IACV,OAAOA,UAAU,CAAV,GAAcA,KAAd,GAAsB,CAA7B;EAA6B;;EAE/BA,QAAQ6G,SAAS7G,KAAT,CAAR;;EACA,IAAIA,UAAU2G,UAAV,IAAsB3G,UAAU,CAAC2G,UAArC,EAA+C;IAC7C,IAAIG,OAAQ9G,QAAQ,CAAR,GAAY,EAAZ,GAAiB,CAA7B;IACA,OAAO8G,OAAOF,WAAd;EAAc;;EAEhB,OAAO5G,UAAUA,KAAV,GAAkBA,KAAlB,GAA0B,CAAjC;AACF;;ACXA,mBAAmBA,KAAnB,EAA0B;EACxB,IAAIsD,SAASyD,SAAS/G,KAAT,CAAb;EAAA,IACIgH,YAAY1D,SAAS,CADzB;EAGA,OAAOA,WAAWA,MAAX,GAAqB0D,YAAY1D,SAAS0D,SAArB,GAAiC1D,MAAtD,GAAgE,CAAvE;AACF;;ACxBA,kBAAkBK,KAAlB,EAAyBsD,QAAzB,EAAmC;EACjC,IAAI3C,QAAQ,EAAZ;EAAA,IACI4C,UAASvD,SAAS,IAAT,GAAgB,CAAhB,GAAoBA,MAAMrC,MADvC;EAAA,IAEIgC,SAAS6D,MAAMD,OAAN,CAFb;;EAIA,OAAO,EAAE5C,KAAF,GAAU4C,OAAjB,EAAyB;IACvB5D,OAAOgB,KAAP,IAAgB2C,SAAStD,MAAMW,KAAN,CAAT,EAAuBA,KAAvB,EAA8BX,KAA9B,CAAhB;EAAmD;;EAErD,OAAOL,MAAP;AACF;;ACKA,IAAI8D,UAAUD,MAAMC,OAApB;AAEA,gBAAeA,OAAf;ACnBA,IAAIT,WAAW,IAAI,CAAnB;AAGA,IAAIU,gBAAc9G,WAASA,SAAOuE,SAAhBvE,GAA4B,MAA9C;AAAA,IACI+G,iBAAiBD,gBAAcA,cAAYpC,QAA1BoC,GAAqC,MAD1D;;AAWA,sBAAsBrH,KAAtB,EAA6B;EAE3B,IAAI,OAAOA,KAAP,IAAgB,QAApB,EAA8B;IAC5B,OAAOA,KAAP;EAAO;;EAET,IAAIoH,UAAQpH,KAARoH,CAAJ,EAAoB;IAElB,OAAOG,SAASvH,KAAT,EAAgBwH,YAAhB,IAAgC,EAAvC;EAAuC;;EAEzC,IAAInB,SAASrG,KAAT,CAAJ,EAAqB;IACnB,OAAOsH,iBAAiBA,eAAejC,IAAf,CAAoBrF,KAApB,CAAjB,GAA8C,EAArD;EAAqD;;EAEvD,IAAIsD,SAAUtD,QAAQ,EAAtB;EACA,OAAQsD,UAAU,GAAV,IAAkB,IAAItD,KAAJ,IAAc,CAAC2G,QAAjC,GAA6C,IAA7C,GAAoDrD,MAA5D;AACF;;ACXA,kBAAkBtD,KAAlB,EAAyB;EACvB,OAAOA,SAAS,IAAT,GAAgB,EAAhB,GAAqBwH,aAAaxH,KAAb,CAA5B;AACF;;ACnBA,IAAIyH,iBAAiBtD,OAAKuD,QAA1B;AAAA,IACIC,cAAY7E,KAAK8E,GADrB;;AAUA,qBAAqBC,UAArB,EAAiC;EAC/B,IAAIC,OAAOhF,KAAK+E,UAAL,CAAX;EACA,OAAO,UAASE,MAAT,EAAiBC,SAAjB,EAA4B;IACjCD,SAASlB,SAASkB,MAAT,CAAT;IACAC,YAAYA,aAAa,IAAb,GAAoB,CAApB,GAAwBL,YAAUM,UAAUD,SAAV,CAAVL,EAAgC,GAAhCA,CAApC;;IACA,IAAIK,aAAaP,eAAeM,MAAf,CAAjB,EAAyC;MAGvC,IAAIG,OAAQ,UAASH,MAAT,IAAmB,GAAnB,EAAwBxE,KAAxB,CAA8B,GAA9B,CAAZ;MAAA,IACIvD,QAAQ8H,KAAKI,KAAK,CAAL,IAAU,GAAV,IAAiB,CAACA,KAAK,CAAL,CAAD,GAAWF,SAA5B,CAAL,CADZ;MAGAE,OAAQ,UAASlI,KAAT,IAAkB,GAAlB,EAAuBuD,KAAvB,CAA6B,GAA7B,CAAR;MACA,OAAO,EAAE2E,KAAK,CAAL,IAAU,GAAV,IAAiB,CAACA,KAAK,CAAL,CAAD,GAAWF,SAA5B,CAAF,CAAP;IAAqC;;IAEvC,OAAOF,KAAKC,MAAL,CAAP;EAAkB,CAZpB;AAcF;;ACTA,IAAII,QAAQC,YAAY,OAAZ,CAAZ;AAEA,cAAeD,KAAf;ACnBA,MAAME,2BAA2B,EAAjC;;MAEaC,aAAsC;EAGjDC,SAASC,UAAT,EAAqD;UAC7C;MAAEC,aAAF;MAAiBC,KAAjB;MAAwB3G,OAAxB;MAAiC4G,OAAjC;MAA0CzG,KAA1C;MAAiDpB;IAAjD,IAAgE0H;;UAChEI,SAAwBC,aAAa;iBAC9B,CAACC,EAAD,EAAKC,GAAL,KAAa7H,OAAOM,OAAP,CAAeqH,SAAf,GAA2B;cAC3CG,SAAS,KAAKC,uBAAL,CAA6BR,aAA7B,EAA4CK,EAA5C;aACVI,gBAAgBF,QAAQD;MAAG;;;UAI9BI,sBAAuBC,OAAD,IAAuB;YAE3CC,WAAWD,QAAQhI,MAAR,CAAe0C,KAAK,OAAO2E,cAAczI,KAArB,CAApB;YACXsJ,OAAOC,YAAWC,WAAX;YACP3F,IAAI3B,MAAMlC;;iBACLyJ,UAAUJ,UAAU;cACvBrH,OAAO0G,MAAM1I,KAAN,CAAYyJ,MAAZ;cACP/G,WAAWgH,YAAY1H,IAAZ,EAAkBD,QAAQC,IAA1B,EAAgC6B,CAAhC;;cACX8F,YAAYC,mBAAKN,KAAKO,MAAV;;iBACT;cACHC,YAAY;;qBACL,CAAChB,EAAD,EAAKC,GAAL,KAAa7H,OAAOM,OAAP,CAAeiH,cAAczI,KAA7B,GAAqC;gBACvDyJ,WAAWX;kBACTiB,aAAarB,MAAM1I,KAAN,CAAY8I,EAAZ;gBACf,CAACiB;kBACCnH,iBAAiB8G,YAAYK,UAAZ,EAAwBhI,QAAQC,IAAhC,EAAsC6B,CAAtC;wBACXmG,kBAAkBL,SAAlB,EAA6BjH,QAA7B,EAAuCqG,GAAvC,EAA4CnG,cAA5C;;gBACRkH,WAAW;;;;;cAIbA,WAAW;sBAGH9G,KAAKN,SAASJ,KAAT,GAAiB+F,2BAA2BxE;;gBACvD8F,UAAU3G,CAAV,GAAcN,SAASJ,KAAT,GAAiB,CAA/B,GAAmCgH,KAAKW,GAAL,CAASC,OAAO;wBAC3ClH,IAAIsG,KAAKO,MAAL,CAAY7G;wBAChBG,KAAKT,SAASF,MAAT,GAAkB6F,2BAA2BxE;YAAA;iBAEzD;;;;;cAIHmF,SAAS,KAAKC,uBAAL,CAA6BR,aAA7B,EAA4CgB,MAA5C;aACVP,gBAAgBF,QAAQW;MAAS;;;wBAItBzI,OAAOiJ,IAAP,CAAYzB,MAAM1I,KAAlB;UACdoK,gBAAgBC,MAAM,MAAMnJ,OAAOiJ,IAAP,CAAYzB,MAAM1I,KAAlB,CAAZ,EAAsCmJ,mBAAtC;YAEdmB,GAAG,kBAAkB1B;YACrB0B,GAAG,oBAAoB1B;YACvB0B,GAAG,gBAAgB1B;;SAEtB2B,eAAe,MAAM;;cAEhBC,IAAI,kBAAkB5B;cACtB4B,IAAI,oBAAoB5B;cACxB4B,IAAI,gBAAgB5B;IAAM;;;EAItC6B,aAAmB;QACb,KAAKF,cAAc;WAChBA;;;;EAICrB,gBAAgBwB,UAAhB,EAA2C3B,GAA3C,EAA0D;eACvD/I,MAAMgD,IAAImF,QAAMY,IAAI/F,CAAVmF,EAAa,CAAbA;eACVnI,MAAMmD,IAAIgF,QAAMY,IAAI5F,CAAVgF,EAAa,CAAbA;EAAc;;EAG7Bc,wBAAwBR,aAAxB,EAA2DzG,IAA3D,EAAyE;UACzEgH,SAAS2B,MAAMlC,cAAczI,KAApB,EAA2BgC,IAA3B;;QACX,CAACgH,OAAOhJ,OAAO;aACVA,QAAQ;QAAEgD,GAAG,CAAL;QAAQG,GAAG;MAAX;;;WAEV6F;EAAA;;AAjFwC;;ACDnD,0BAA0B;EACxB,KAAK4B,QAAL,GAAgB,EAAhB;EACA,KAAKC,IAAL,GAAY,CAAZ;AACF;;ACsBA,YAAY7K,KAAZ,EAAmBuG,KAAnB,EAA0B;EACxB,OAAOvG,UAAUuG,KAAV,IAAoBvG,UAAUA,KAAV,IAAmBuG,UAAUA,KAAxD;AACF;;ACxBA,sBAAsB5C,KAAtB,EAA6BmH,GAA7B,EAAkC;EAChC,IAAI5D,UAASvD,MAAMrC,MAAnB;;EACA,OAAO4F,SAAP,EAAiB;IACf,IAAI6D,GAAGpH,MAAMuD,OAAN,EAAc,CAAd,CAAH,EAAqB4D,GAArB,CAAJ,EAA+B;MAC7B,OAAO5D,OAAP;IAAO;;;EAGX,OAAO,EAAP;AACF;;ACfA,IAAI8D,aAAa7D,MAAMrC,SAAvB;AAGA,IAAImG,SAASD,WAAWC,MAAxB;;AAWA,yBAAyBH,GAAzB,EAA8B;EAC5B,IAAII,OAAO,KAAKN,QAAhB;EAAA,IACItG,QAAQ6G,aAAaD,IAAb,EAAmBJ,GAAnB,CADZ;;EAGA,IAAIxG,QAAQ,CAAZ,EAAe;IACb,OAAO,KAAP;EAAO;;EAET,IAAI8G,YAAYF,KAAK5J,MAAL,GAAc,CAA9B;;EACA,IAAIgD,SAAS8G,SAAb,EAAwB;IACtBF,KAAKG,GAAL;GADF,MAEO;IACLJ,OAAO5F,IAAP,CAAY6F,IAAZ,EAAkB5G,KAAlB,EAAyB,CAAzB;EAA0B;;EAE5B,EAAE,KAAKuG,IAAP;EACA,OAAO,IAAP;AACF;;ACrBA,sBAAsBC,GAAtB,EAA2B;EACzB,IAAII,OAAO,KAAKN,QAAhB;EAAA,IACItG,QAAQ6G,aAAaD,IAAb,EAAmBJ,GAAnB,CADZ;EAGA,OAAOxG,QAAQ,CAAR,GAAY,MAAZ,GAAwB4G,KAAK5G,KAAL,EAAY,CAAZ,CAA/B;AACF;;ACLA,sBAAsBwG,GAAtB,EAA2B;EACzB,OAAOK,aAAa,KAAKP,QAAlB,EAA4BE,GAA5B,IAAmC,EAA1C;AACF;;ACDA,sBAAsBA,GAAtB,EAA2B9K,KAA3B,EAAkC;EAChC,IAAIkL,OAAO,KAAKN,QAAhB;EAAA,IACItG,QAAQ6G,aAAaD,IAAb,EAAmBJ,GAAnB,CADZ;;EAGA,IAAIxG,QAAQ,CAAZ,EAAe;IACb,EAAE,KAAKuG,IAAP;IACAK,KAAKI,IAAL,CAAU,CAACR,GAAD,EAAM9K,KAAN,CAAV;EAAsB,CAFxB,MAGO;IACLkL,KAAK5G,KAAL,EAAY,CAAZ,IAAiBtE,KAAjB;EAAiB;;EAEnB,OAAO,IAAP;AACF;;ACVA,mBAAmBwB,OAAnB,EAA4B;EAC1B,IAAI8C,QAAQ,EAAZ;EAAA,IACI4C,UAAS1F,WAAW,IAAX,GAAkB,CAAlB,GAAsBA,QAAQF,MAD3C;EAGA,KAAKiK,KAAL;;EACA,OAAO,EAAEjH,KAAF,GAAU4C,OAAjB,EAAyB;IACvB,IAAIsE,QAAQhK,QAAQ8C,KAAR,CAAZ;IACA,KAAKmH,GAAL,CAASD,MAAM,CAAN,CAAT,EAAmBA,MAAM,CAAN,CAAnB;EAA2B;AAE/B;;AAGAE,UAAU5G,SAAV,CAAoByG,KAApB,GAA4BI,cAA5B;AACAD,UAAU5G,SAAV,CAAoB,QAApB,IAAgC8G,eAAhC;AACAF,UAAU5G,SAAV,CAAoB+G,GAApB,GAA0BC,YAA1B;AACAJ,UAAU5G,SAAV,CAAoBiH,GAApB,GAA0BC,YAA1B;AACAN,UAAU5G,SAAV,CAAoB2G,GAApB,GAA0BQ,YAA1B;;ACpBA,sBAAsB;EACpB,KAAKrB,QAAL,GAAgB,IAAIc,SAAJ,EAAhB;EACA,KAAKb,IAAL,GAAY,CAAZ;AACF;;ACHA,qBAAqBC,GAArB,EAA0B;EACxB,IAAII,OAAO,KAAKN,QAAhB;EAAA,IACItH,SAAS4H,KAAK,QAAL,EAAeJ,GAAf,CADb;EAGA,KAAKD,IAAL,GAAYK,KAAKL,IAAjB;EACA,OAAOvH,MAAP;AACF;;ACNA,kBAAkBwH,GAAlB,EAAuB;EACrB,OAAO,KAAKF,QAAL,CAAciB,GAAd,CAAkBf,GAAlB,CAAP;AACF;;ACFA,kBAAkBA,GAAlB,EAAuB;EACrB,OAAO,KAAKF,QAAL,CAAcmB,GAAd,CAAkBjB,GAAlB,CAAP;AACF;;ACPA,IAAIoB,WAAW,wBAAf;AAAA,IACIC,YAAU,mBADd;AAAA,IAEIC,SAAS,4BAFb;AAAA,IAGIC,WAAW,gBAHf;;AAsBA,oBAAoBrM,KAApB,EAA2B;EACzB,IAAI,CAACsG,SAAStG,KAAT,CAAL,EAAsB;IACpB,OAAO,KAAP;EAAO;;EAIT,IAAIsF,MAAMS,WAAW/F,KAAX,CAAV;EACA,OAAOsF,OAAO6G,SAAP,IAAkB7G,OAAO8G,MAAzB,IAAmC9G,OAAO4G,QAA1C,IAAsD5G,OAAO+G,QAApE;AACF;;AC/BA,IAAIC,aAAanI,OAAK,oBAALA,CAAjB;AAEA,mBAAemI,UAAf;;ACFA,IAAIC,aAAc,YAAW;EAC3B,IAAIC,MAAM,SAASC,IAAT,CAAcH,gBAAcA,aAAWnC,IAAzBmC,IAAiCA,aAAWnC,IAAXmC,CAAgBI,QAAjDJ,IAA6D,EAA3E,CAAV;EACA,OAAOE,MAAO,mBAAmBA,GAA1B,GAAiC,EAAxC;AACF,CAHkB,EAAlB;;AAYA,kBAAkB1E,IAAlB,EAAwB;EACtB,OAAO,CAAC,CAACyE,UAAF,IAAiBA,cAAczE,IAAtC;AACF;;AChBA,IAAI6E,cAAY1L,SAAS6D,SAAzB;AAGA,IAAI8H,iBAAeD,YAAU1H,QAA7B;;AASA,kBAAkB6C,IAAlB,EAAwB;EACtB,IAAIA,QAAQ,IAAZ,EAAkB;IAChB,IAAI;MACF,OAAO8E,eAAavH,IAAbuH,CAAkB9E,IAAlB8E,CAAP;IAA6B,CAD/B,CAC+B,OACtBpH,CADsB,EAC7B;;IACF,IAAI;MACF,OAAQsC,OAAO,EAAf;IAAe,CADjB,CACiB,OACRtC,CADQ,EACf;;;EAEJ,OAAO,EAAP;AACF;;ACdA,IAAIqH,eAAe,qBAAnB;AAGA,IAAIC,eAAe,6BAAnB;AAGA,IAAIH,cAAY1L,SAAS6D,SAAzB;AAAA,IACID,gBAAc3D,OAAO4D,SADzB;AAIA,IAAI8H,iBAAeD,YAAU1H,QAA7B;AAGA,IAAIF,mBAAiBF,cAAYE,cAAjC;AAGA,IAAIgI,aAAaC,OAAO,MACtBJ,eAAavH,IAAbuH,CAAkB7H,gBAAlB6H,EAAkChI,OAAlCgI,CAA0CC,YAA1CD,EAAwD,MAAxDA,EACChI,OADDgI,CACS,wDADTA,EACmE,OADnEA,CADsB,GAEwD,GAF/D,CAAjB;;AAaA,sBAAsB5M,KAAtB,EAA6B;EAC3B,IAAI,CAACsG,SAAStG,KAAT,CAAD,IAAoBiN,SAASjN,KAAT,CAAxB,EAAyC;IACvC,OAAO,KAAP;EAAO;;EAET,IAAIkN,UAAUC,WAAWnN,KAAX,IAAoB+M,UAApB,GAAiCD,YAA/C;EACA,OAAOI,QAAQ3I,IAAR,CAAa6I,SAASpN,KAAT,CAAb,CAAP;AACF;;ACpCA,kBAAkBqN,MAAlB,EAA0BvC,GAA1B,EAA+B;EAC7B,OAAOuC,UAAU,IAAV,GAAiB,MAAjB,GAA6BA,OAAOvC,GAAP,CAApC;AACF;;ACCA,mBAAmBuC,MAAnB,EAA2BvC,GAA3B,EAAgC;EAC9B,IAAI9K,QAAQsN,SAASD,MAAT,EAAiBvC,GAAjB,CAAZ;EACA,OAAOyC,aAAavN,KAAb,IAAsBA,KAAtB,GAA8B,MAArC;AACF;;ACVA,IAAIwN,QAAMC,UAAUtJ,MAAV,EAAgB,KAAhB,CAAV;AAEA,YAAeqJ,KAAf;ACHA,IAAIE,eAAeD,UAAUvM,MAAV,EAAkB,QAAlB,CAAnB;AAEA,qBAAewM,YAAf;;ACIA,qBAAqB;EACnB,KAAK9C,QAAL,GAAgB8C,iBAAeA,eAAa,IAAbA,CAAfA,GAAoC,EAApD;EACA,KAAK7C,IAAL,GAAY,CAAZ;AACF;;ACFA,oBAAoBC,GAApB,EAAyB;EACvB,IAAIxH,SAAS,KAAKyI,GAAL,CAASjB,GAAT,KAAiB,OAAO,KAAKF,QAAL,CAAcE,GAAd,CAArC;EACA,KAAKD,IAAL,IAAavH,SAAS,CAAT,GAAa,CAA1B;EACA,OAAOA,MAAP;AACF;;ACXA,IAAIqK,mBAAiB,2BAArB;AAGA,IAAI9I,gBAAc3D,OAAO4D,SAAzB;AAGA,IAAIC,mBAAiBF,cAAYE,cAAjC;;AAWA,iBAAiB+F,GAAjB,EAAsB;EACpB,IAAII,OAAO,KAAKN,QAAhB;;EACA,IAAI8C,cAAJ,EAAkB;IAChB,IAAIpK,SAAS4H,KAAKJ,GAAL,CAAb;IACA,OAAOxH,WAAWqK,gBAAX,GAA4B,MAA5B,GAAwCrK,MAA/C;EAA+C;;EAEjD,OAAOyB,iBAAeM,IAAfN,CAAoBmG,IAApBnG,EAA0B+F,GAA1B/F,IAAiCmG,KAAKJ,GAAL,CAAjC/F,GAA6C,MAApD;AACF;;ACxBA,IAAIF,gBAAc3D,OAAO4D,SAAzB;AAGA,IAAIC,mBAAiBF,cAAYE,cAAjC;;AAWA,iBAAiB+F,GAAjB,EAAsB;EACpB,IAAII,OAAO,KAAKN,QAAhB;EACA,OAAO8C,iBAAgBxC,KAAKJ,GAAL,MAAc,MAA9B4C,GAA2C3I,iBAAeM,IAAfN,CAAoBmG,IAApBnG,EAA0B+F,GAA1B/F,CAAlD;AACF;;ACjBA,IAAI4I,mBAAiB,2BAArB;;AAYA,iBAAiB7C,GAAjB,EAAsB9K,KAAtB,EAA6B;EAC3B,IAAIkL,OAAO,KAAKN,QAAhB;EACA,KAAKC,IAAL,IAAa,KAAKkB,GAAL,CAASjB,GAAT,IAAgB,CAAhB,GAAoB,CAAjC;EACAI,KAAKJ,GAAL,IAAa4C,kBAAgB1N,UAAU,MAA1B0N,GAAuCC,gBAAvCD,GAAwD1N,KAArE;EACA,OAAO,IAAP;AACF;;ACPA,cAAcwB,OAAd,EAAuB;EACrB,IAAI8C,QAAQ,EAAZ;EAAA,IACI4C,UAAS1F,WAAW,IAAX,GAAkB,CAAlB,GAAsBA,QAAQF,MAD3C;EAGA,KAAKiK,KAAL;;EACA,OAAO,EAAEjH,KAAF,GAAU4C,OAAjB,EAAyB;IACvB,IAAIsE,QAAQhK,QAAQ8C,KAAR,CAAZ;IACA,KAAKmH,GAAL,CAASD,MAAM,CAAN,CAAT,EAAmBA,MAAM,CAAN,CAAnB;EAA2B;AAE/B;;AAGAoC,KAAK9I,SAAL,CAAeyG,KAAf,GAAuBsC,SAAvB;AACAD,KAAK9I,SAAL,CAAe,QAAf,IAA2BgJ,UAA3B;AACAF,KAAK9I,SAAL,CAAe+G,GAAf,GAAqBkC,OAArB;AACAH,KAAK9I,SAAL,CAAeiH,GAAf,GAAqBiC,OAArB;AACAJ,KAAK9I,SAAL,CAAe2G,GAAf,GAAqBwC,OAArB;;AClBA,yBAAyB;EACvB,KAAKpD,IAAL,GAAY,CAAZ;EACA,KAAKD,QAAL,GAAgB;IACd,QAAQ,IAAIgD,IAAJ,EADM;IAEd,OAAO,KAAKJ,SAAO9B,SAAZ,GAFO;IAGd,UAAU,IAAIkC,IAAJ;EAHI,CAAhB;AAKF;;ACXA,mBAAmB5N,KAAnB,EAA0B;EACxB,IAAIqC,OAAO,OAAOrC,KAAlB;EACA,OAAQqC,QAAQ,QAAR,IAAoBA,QAAQ,QAA5B,IAAwCA,QAAQ,QAAhD,IAA4DA,QAAQ,SAApE,GACHrC,UAAU,WADP,GAEHA,UAAU,IAFf;AAGF;;ACFA,oBAAoByB,GAApB,EAAyBqJ,GAAzB,EAA8B;EAC5B,IAAII,OAAOzJ,IAAImJ,QAAf;EACA,OAAOsD,UAAUpD,GAAV,IACHI,KAAK,OAAOJ,GAAP,IAAc,QAAd,GAAyB,QAAzB,GAAoC,MAAzC,CADG,GAEHI,KAAKzJ,GAFT;AAGF;;ACJA,wBAAwBqJ,GAAxB,EAA6B;EAC3B,IAAIxH,SAAS6K,WAAW,IAAX,EAAiBrD,GAAjB,EAAsB,QAAtB,EAAgCA,GAAhC,CAAb;EACA,KAAKD,IAAL,IAAavH,SAAS,CAAT,GAAa,CAA1B;EACA,OAAOA,MAAP;AACF;;ACJA,qBAAqBwH,GAArB,EAA0B;EACxB,OAAOqD,WAAW,IAAX,EAAiBrD,GAAjB,EAAsBe,GAAtB,CAA0Bf,GAA1B,CAAP;AACF;;ACFA,qBAAqBA,GAArB,EAA0B;EACxB,OAAOqD,WAAW,IAAX,EAAiBrD,GAAjB,EAAsBiB,GAAtB,CAA0BjB,GAA1B,CAAP;AACF;;ACDA,qBAAqBA,GAArB,EAA0B9K,KAA1B,EAAiC;EAC/B,IAAIkL,OAAOiD,WAAW,IAAX,EAAiBrD,GAAjB,CAAX;EAAA,IACID,OAAOK,KAAKL,IADhB;EAGAK,KAAKO,GAAL,CAASX,GAAT,EAAc9K,KAAd;EACA,KAAK6K,IAAL,IAAaK,KAAKL,IAAL,IAAaA,IAAb,GAAoB,CAApB,GAAwB,CAArC;EACA,OAAO,IAAP;AACF;;ACNA,kBAAkBrJ,OAAlB,EAA2B;EACzB,IAAI8C,QAAQ,EAAZ;EAAA,IACI4C,UAAS1F,WAAW,IAAX,GAAkB,CAAlB,GAAsBA,QAAQF,MAD3C;EAGA,KAAKiK,KAAL;;EACA,OAAO,EAAEjH,KAAF,GAAU4C,OAAjB,EAAyB;IACvB,IAAIsE,QAAQhK,QAAQ8C,KAAR,CAAZ;IACA,KAAKmH,GAAL,CAASD,MAAM,CAAN,CAAT,EAAmBA,MAAM,CAAN,CAAnB;EAA2B;AAE/B;;AAGA4C,SAAStJ,SAAT,CAAmByG,KAAnB,GAA2B8C,aAA3B;AACAD,SAAStJ,SAAT,CAAmB,QAAnB,IAA+BwJ,cAA/B;AACAF,SAAStJ,SAAT,CAAmB+G,GAAnB,GAAyB0C,WAAzB;AACAH,SAAStJ,SAAT,CAAmBiH,GAAnB,GAAyByC,WAAzB;AACAJ,SAAStJ,SAAT,CAAmB2G,GAAnB,GAAyBgD,WAAzB;ACxBA,IAAIC,mBAAmB,GAAvB;;AAYA,kBAAkB5D,GAAlB,EAAuB9K,KAAvB,EAA8B;EAC5B,IAAIkL,OAAO,KAAKN,QAAhB;;EACA,IAAIM,gBAAgBQ,SAApB,EAA+B;IAC7B,IAAIiD,QAAQzD,KAAKN,QAAjB;;IACA,IAAI,CAAC4C,KAAD,IAASmB,MAAMrN,MAAN,GAAeoN,mBAAmB,CAA/C,EAAmD;MACjDC,MAAMrD,IAAN,CAAW,CAACR,GAAD,EAAM9K,KAAN,CAAX;MACA,KAAK6K,IAAL,GAAY,EAAEK,KAAKL,IAAnB;MACA,OAAO,IAAP;IAAO;;IAETK,OAAO,KAAKN,QAAL,GAAgB,IAAIwD,QAAJ,CAAaO,KAAb,CAAvB;EAAyC;;EAE3CzD,KAAKO,GAAL,CAASX,GAAT,EAAc9K,KAAd;EACA,KAAK6K,IAAL,GAAYK,KAAKL,IAAjB;EACA,OAAO,IAAP;AACF;;ACjBA,eAAerJ,OAAf,EAAwB;EACtB,IAAI0J,OAAO,KAAKN,QAAL,GAAgB,IAAIc,SAAJ,CAAclK,OAAd,CAA3B;EACA,KAAKqJ,IAAL,GAAYK,KAAKL,IAAjB;AACF;;AAGA+D,MAAM9J,SAAN,CAAgByG,KAAhB,GAAwBsD,UAAxB;AACAD,MAAM9J,SAAN,CAAgB,QAAhB,IAA4BgK,WAA5B;AACAF,MAAM9J,SAAN,CAAgB+G,GAAhB,GAAsBkD,QAAtB;AACAH,MAAM9J,SAAN,CAAgBiH,GAAhB,GAAsBiD,QAAtB;AACAJ,MAAM9J,SAAN,CAAgB2G,GAAhB,GAAsBwD,QAAtB;;ACtBA,IAAIC,iBAAkB,YAAW;EAC/B,IAAI;IACF,IAAIpH,OAAO2F,UAAUvM,MAAV,EAAkB,gBAAlB,CAAX;IACA4G,KAAK,EAAL,EAAS,EAAT,EAAa,EAAb;IACA,OAAOA,IAAP;EAAO,CAHT,CAGS,OACAtC,CADA,EACP;AACJ,CANsB,EAAtB;;AAQA,uBAAe0J,cAAf;;ACCA,yBAAyB7B,MAAzB,EAAiCvC,GAAjC,EAAsC9K,KAAtC,EAA6C;EAC3C,IAAI8K,OAAO,WAAP,IAAsBoE,gBAA1B,EAA0C;IACxCA,iBAAe7B,MAAf6B,EAAuBpE,GAAvBoE,EAA4B;MAC1B,gBAAgB,IADU;MAE1B,cAAc,IAFY;MAG1B,SAASlP,KAHiB;MAI1B,YAAY;IAJc,CAA5BkP;EAKC,CANH,MAOO;IACL7B,OAAOvC,GAAP,IAAc9K,KAAd;EAAc;AAElB;;ACVA,0BAA0BqN,MAA1B,EAAkCvC,GAAlC,EAAuC9K,KAAvC,EAA8C;EAC5C,IAAKA,UAAU,MAAV,IAAuB,CAAC+K,GAAGsC,OAAOvC,GAAP,CAAH,EAAgB9K,KAAhB,CAAxB,IACAA,UAAU,MAAV,IAAuB,EAAE8K,OAAOuC,MAAT,CAD5B,EAC+C;IAC7C8B,gBAAgB9B,MAAhB,EAAwBvC,GAAxB,EAA6B9K,KAA7B;EAAkC;AAEtC;;ACVA,uBAAuBoP,SAAvB,EAAkC;EAChC,OAAO,UAAS/B,MAAT,EAAiBpG,QAAjB,EAA2BoI,QAA3B,EAAqC;IAC1C,IAAI/K,QAAQ,EAAZ;IAAA,IACIgL,WAAWpO,OAAOmM,MAAP,CADf;IAAA,IAEIkC,QAAQF,SAAShC,MAAT,CAFZ;IAAA,IAGInG,UAASqI,MAAMjO,MAHnB;;IAKA,OAAO4F,SAAP,EAAiB;MACf,IAAI4D,MAAMyE,MAAMH,YAAYlI,OAAZ,GAAqB,EAAE5C,KAA7B,CAAV;;MACA,IAAI2C,SAASqI,SAASxE,GAAT,CAAT,EAAwBA,GAAxB,EAA6BwE,QAA7B,MAA2C,KAA/C,EAAsD;QACpD;MAAA;;;IAGJ,OAAOjC,MAAP;EAAO,CAZT;AAcF;;ACTA,IAAImC,UAAUC,eAAd;AAEA,gBAAeD,OAAf;ACZA,IAAIE,gBAAc,OAAOC,OAAP,IAAkB,QAAlB,IAA8BA,OAA9B,IAAyC,CAACA,QAAQC,QAAlD,IAA8DD,OAAhF;AAGA,IAAIE,eAAaH,iBAAe,OAAOI,MAAP,IAAiB,QAAhCJ,IAA4CI,MAA5CJ,IAAsD,CAACI,OAAOF,QAA9DF,IAA0EI,MAA3F;AAGA,IAAIC,kBAAgBF,gBAAcA,aAAWF,OAAXE,KAAuBH,aAAzD;AAGA,IAAIM,WAASD,kBAAgB5L,OAAK6L,MAArBD,GAA8B,MAA3C;AAAA,IACIE,cAAcD,WAASA,SAAOC,WAAhBD,GAA8B,MADhD;;AAWA,qBAAqBE,MAArB,EAA6BC,MAA7B,EAAqC;EACnC,IAAIA,MAAJ,EAAY;IACV,OAAOD,OAAOxL,KAAP,EAAP;;;EAEF,IAAIwC,UAASgJ,OAAO5O,MAApB;EAAA,IACIgC,SAAS2M,cAAcA,YAAY/I,OAAZ,CAAd,GAAoC,IAAIgJ,OAAOE,WAAX,CAAuBlJ,OAAvB,CADjD;EAGAgJ,OAAOG,IAAP,CAAY/M,MAAZ;EACA,OAAOA,MAAP;AACF;;AC7BA,IAAIgN,cAAanM,OAAKoM,UAAtB;AAEA,mBAAeD,WAAf;;ACIA,0BAA0BE,WAA1B,EAAuC;EACrC,IAAIlN,SAAS,IAAIkN,YAAYJ,WAAhB,CAA4BI,YAAYC,UAAxC,CAAb;EACA,IAAIF,YAAJ,CAAejN,MAAf,EAAuBmI,GAAvB,CAA2B,IAAI8E,YAAJ,CAAeC,WAAf,CAA3B;EACA,OAAOlN,MAAP;AACF;;ACHA,yBAAyBoN,UAAzB,EAAqCP,MAArC,EAA6C;EAC3C,IAAID,SAASC,SAASQ,iBAAiBD,WAAWR,MAA5B,CAAT,GAA+CQ,WAAWR,MAAvE;EACA,OAAO,IAAIQ,WAAWN,WAAf,CAA2BF,MAA3B,EAAmCQ,WAAWE,UAA9C,EAA0DF,WAAWpP,MAArE,CAAP;AACF;;ACLA,mBAAmBuP,MAAnB,EAA2BlN,KAA3B,EAAkC;EAChC,IAAIW,QAAQ,EAAZ;EAAA,IACI4C,UAAS2J,OAAOvP,MADpB;EAGAqC,UAAUA,QAAQwD,MAAMD,OAAN,CAAlB;;EACA,OAAO,EAAE5C,KAAF,GAAU4C,OAAjB,EAAyB;IACvBvD,MAAMW,KAAN,IAAeuM,OAAOvM,KAAP,CAAf;EAAsB;;EAExB,OAAOX,KAAP;AACF;;ACdA,IAAImN,eAAe5P,OAAO6P,MAA1B;;AAUA,IAAIC,aAAc,YAAW;EAC3B,kBAAkB;;EAClB,OAAO,UAASC,KAAT,EAAgB;IACrB,IAAI,CAAC3K,SAAS2K,KAAT,CAAL,EAAsB;MACpB,OAAO,EAAP;;;IAEF,IAAIH,YAAJ,EAAkB;MAChB,OAAOA,aAAaG,KAAb,CAAP;IAAyB;;IAE3B5D,OAAOvI,SAAP,GAAmBmM,KAAnB;IACA,IAAI3N,SAAS,IAAI+J,MAAJ,EAAb;IACAA,OAAOvI,SAAP,GAAmB,MAAnB;IACA,OAAOxB,MAAP;EAAO,CAVT;AAYF,CAdkB,EAAlB;;AAgBA,mBAAe0N,UAAf;;ACrBA,iBAAiBlJ,IAAjB,EAAuBoJ,SAAvB,EAAkC;EAChC,OAAO,UAASC,GAAT,EAAc;IACnB,OAAOrJ,KAAKoJ,UAAUC,GAAV,CAAL,CAAP;EAA0B,CAD5B;AAGF;;ACTA,IAAIC,eAAeC,QAAQnQ,OAAOoQ,cAAf,EAA+BpQ,MAA/B,CAAnB;AAEA,qBAAekQ,YAAf;ACJA,IAAIvM,gBAAc3D,OAAO4D,SAAzB;;AASA,qBAAqB9E,KAArB,EAA4B;EAC1B,IAAIuR,OAAOvR,SAASA,MAAMoQ,WAA1B;EAAA,IACIa,QAAS,OAAOM,IAAP,IAAe,UAAf,IAA6BA,KAAKzM,SAAlC,IAAgDD,aAD7D;EAGA,OAAO7E,UAAUiR,KAAjB;AACF;;ACJA,yBAAyB5D,MAAzB,EAAiC;EAC/B,OAAQ,OAAOA,OAAO+C,WAAd,IAA6B,UAA7B,IAA2C,CAACoB,YAAYnE,MAAZ,CAA5C,GACJ2D,aAAWI,eAAa/D,MAAb+D,CAAXJ,CADI,GAEJ,EAFJ;AAGF;;ACXA,IAAIS,YAAU,oBAAd;;AASA,yBAAyBzR,KAAzB,EAAgC;EAC9B,OAAO8F,aAAa9F,KAAb,KAAuB+F,WAAW/F,KAAX,KAAqByR,SAAnD;AACF;;ACXA,IAAI5M,gBAAc3D,OAAO4D,SAAzB;AAGA,IAAIC,mBAAiBF,cAAYE,cAAjC;AAGA,IAAI2M,yBAAuB7M,cAAY6M,oBAAvC;AAoBA,IAAIC,cAAcC,gBAAgB,YAAW;EAAE,OAAOC,SAAP;CAAb,EAAhB,IAAsDD,eAAtD,GAAwE,UAAS5R,KAAT,EAAgB;EACxG,OAAO8F,aAAa9F,KAAb,KAAuB+E,iBAAeM,IAAfN,CAAoB/E,KAApB+E,EAA2B,QAA3BA,CAAvB,IACL,CAAC2M,uBAAqBrM,IAArBqM,CAA0B1R,KAA1B0R,EAAiC,QAAjCA,CADH;AAEF,CAHA;AAKA,oBAAeC,WAAf;AClCA,IAAIG,qBAAmB,gBAAvB;;AA4BA,kBAAkB9R,KAAlB,EAAyB;EACvB,OAAO,OAAOA,KAAP,IAAgB,QAAhB,IACLA,QAAQ,EADH,IACSA,QAAQ,CAAR,IAAa,CADtB,IAC2BA,SAAS8R,kBAD3C;AAEF;;ACJA,qBAAqB9R,KAArB,EAA4B;EAC1B,OAAOA,SAAS,IAAT,IAAiB+R,SAAS/R,MAAMsB,MAAf,CAAjB,IAA2C,CAAC6L,WAAWnN,KAAX,CAAnD;AACF;;ACFA,2BAA2BA,KAA3B,EAAkC;EAChC,OAAO8F,aAAa9F,KAAb,KAAuBgS,YAAYhS,KAAZ,CAA9B;AACF;;ACjBA,qBAAqB;EACnB,OAAO,KAAP;AACF;;ACXA,IAAI0P,gBAAc,OAAOC,OAAP,IAAkB,QAAlB,IAA8BA,OAA9B,IAAyC,CAACA,QAAQC,QAAlD,IAA8DD,OAAhF;AAGA,IAAIE,eAAaH,iBAAe,OAAOI,MAAP,IAAiB,QAAhCJ,IAA4CI,MAA5CJ,IAAsD,CAACI,OAAOF,QAA9DF,IAA0EI,MAA3F;AAGA,IAAIC,kBAAgBF,gBAAcA,aAAWF,OAAXE,KAAuBH,aAAzD;AAGA,IAAIM,WAASD,kBAAgB5L,OAAK6L,MAArBD,GAA8B,MAA3C;AAGA,IAAIkC,iBAAiBjC,WAASA,SAAOkC,QAAhBlC,GAA2B,MAAhD;AAmBA,IAAIkC,WAAWD,kBAAkBE,SAAjC;AAEA,iBAAeD,QAAf;AChCA,IAAIE,cAAY,iBAAhB;AAGA,IAAIzF,YAAY1L,SAAS6D,SAAzB;AAAA,IACID,gBAAc3D,OAAO4D,SADzB;AAIA,IAAI8H,eAAeD,UAAU1H,QAA7B;AAGA,IAAIF,mBAAiBF,cAAYE,cAAjC;AAGA,IAAIsN,mBAAmBzF,aAAavH,IAAb,CAAkBnE,MAAlB,CAAvB;;AA8BA,uBAAuBlB,KAAvB,EAA8B;EAC5B,IAAI,CAAC8F,aAAa9F,KAAb,CAAD,IAAwB+F,WAAW/F,KAAX,KAAqBoS,WAAjD,EAA4D;IAC1D,OAAO,KAAP;EAAO;;EAET,IAAInB,QAAQG,eAAapR,KAAboR,CAAZ;;EACA,IAAIH,UAAU,IAAd,EAAoB;IAClB,OAAO,IAAP;EAAO;;EAET,IAAIM,OAAOxM,iBAAeM,IAAfN,CAAoBkM,KAApBlM,EAA2B,aAA3BA,KAA6CkM,MAAMb,WAA9D;EACA,OAAO,OAAOmB,IAAP,IAAe,UAAf,IAA6BA,gBAAgBA,IAA7C,IACL3E,aAAavH,IAAb,CAAkBkM,IAAlB,KAA2Bc,gBAD7B;AAEF;;ACtDA,IAAIZ,YAAU,oBAAd;AAAA,IACIa,aAAW,gBADf;AAAA,IAEIC,YAAU,kBAFd;AAAA,IAGIC,YAAU,eAHd;AAAA,IAIIC,aAAW,gBAJf;AAAA,IAKItG,UAAU,mBALd;AAAA,IAMIuG,WAAS,cANb;AAAA,IAOIC,cAAY,iBAPhB;AAAA,IAQIP,cAAY,iBARhB;AAAA,IASIQ,cAAY,iBAThB;AAAA,IAUIC,WAAS,cAVb;AAAA,IAWIC,cAAY,iBAXhB;AAAA,IAYIC,eAAa,kBAZjB;AAcA,IAAIC,mBAAiB,sBAArB;AAAA,IACIC,gBAAc,mBADlB;AAAA,IAEIC,aAAa,uBAFjB;AAAA,IAGIC,aAAa,uBAHjB;AAAA,IAIIC,UAAU,oBAJd;AAAA,IAKIC,WAAW,qBALf;AAAA,IAMIC,WAAW,qBANf;AAAA,IAOIC,WAAW,qBAPf;AAAA,IAQIC,kBAAkB,4BARtB;AAAA,IASIC,YAAY,sBAThB;AAAA,IAUIC,YAAY,sBAVhB;AAaA,IAAIC,iBAAiB,EAArB;AACAA,eAAeT,UAAf,IAA6BS,eAAeR,UAAf,IAC7BQ,eAAeP,OAAf,IAA0BO,eAAeN,QAAf,IAC1BM,eAAeL,QAAf,IAA2BK,eAAeJ,QAAf,IAC3BI,eAAeH,eAAf,IAAkCG,eAAeF,SAAf,IAClCE,eAAeD,SAAf,IAA4B,IAJ5B;AAKAC,eAAelC,SAAf,IAA0BkC,eAAerB,UAAf,IAC1BqB,eAAeX,gBAAf,IAAiCW,eAAepB,SAAf,IACjCoB,eAAeV,aAAf,IAA8BU,eAAenB,SAAf,IAC9BmB,eAAelB,UAAf,IAA2BkB,eAAexH,OAAf,IAC3BwH,eAAejB,QAAf,IAAyBiB,eAAehB,WAAf,IACzBgB,eAAevB,WAAf,IAA4BuB,eAAef,WAAf,IAC5Be,eAAed,QAAf,IAAyBc,eAAeb,WAAf,IACzBa,eAAeZ,YAAf,IAA6B,KAP7B;;AAgBA,0BAA0B/S,KAA1B,EAAiC;EAC/B,OAAO8F,aAAa9F,KAAb,KACL+R,SAAS/R,MAAMsB,MAAf,CADK,IACqB,CAAC,CAACqS,eAAe5N,WAAW/F,KAAX,CAAf,CAD9B;AAEF;;AClDA,mBAAmB8H,IAAnB,EAAyB;EACvB,OAAO,UAAS9H,KAAT,EAAgB;IACrB,OAAO8H,KAAK9H,KAAL,CAAP;EAAiB,CADnB;AAGF;;ACRA,IAAI0P,cAAc,OAAOC,OAAP,IAAkB,QAAlB,IAA8BA,OAA9B,IAAyC,CAACA,QAAQC,QAAlD,IAA8DD,OAAhF;AAGA,IAAIE,aAAaH,eAAe,OAAOI,MAAP,IAAiB,QAAhC,IAA4CA,MAA5C,IAAsD,CAACA,OAAOF,QAA9D,IAA0EE,MAA3F;AAGA,IAAIC,gBAAgBF,cAAcA,WAAWF,OAAX,KAAuBD,WAAzD;AAGA,IAAIkE,cAAc7D,iBAAiBhM,aAAW8P,OAA9C;;AAGA,IAAIC,WAAY,YAAW;EACzB,IAAI;IAEF,IAAIC,QAAQlE,cAAcA,WAAWmE,OAAzB,IAAoCnE,WAAWmE,OAAX,CAAmB,MAAnB,EAA2BD,KAA3E;;IAEA,IAAIA,KAAJ,EAAW;MACT,OAAOA,KAAP;IAAO;;IAIT,OAAOH,eAAeA,YAAYK,OAA3B,IAAsCL,YAAYK,OAAZ,CAAoB,MAApB,CAA7C;EAAuE,CATzE,CASyE,OAChEzO,CADgE,EACvE;AACJ,CAZgB,EAAhB;;AAcA,iBAAesO,QAAf;ACxBA,IAAII,mBAAmBJ,cAAYA,WAASK,YAA5C;AAmBA,IAAIA,eAAeD,mBAAmBE,UAAUF,gBAAV,CAAnB,GAAiDG,gBAApE;AAEA,qBAAeF,YAAf;;AClBA,iBAAiB9G,MAAjB,EAAyBvC,GAAzB,EAA8B;EAC5B,IAAIA,QAAQ,aAAR,IAAyB,OAAOuC,OAAOvC,GAAP,CAAP,KAAuB,UAApD,EAAgE;IAC9D;EAAA;;EAGF,IAAIA,OAAO,WAAX,EAAwB;IACtB;EAAA;;EAGF,OAAOuC,OAAOvC,GAAP,CAAP;AACF;;ACdA,IAAIjG,gBAAc3D,OAAO4D,SAAzB;AAGA,IAAIC,mBAAiBF,cAAYE,cAAjC;;AAYA,qBAAqBsI,MAArB,EAA6BvC,GAA7B,EAAkC9K,KAAlC,EAAyC;EACvC,IAAIsU,WAAWjH,OAAOvC,GAAP,CAAf;;EACA,IAAI,EAAE/F,iBAAeM,IAAfN,CAAoBsI,MAApBtI,EAA4B+F,GAA5B/F,KAAoCgG,GAAGuJ,QAAH,EAAatU,KAAb,CAAtC,KACCA,UAAU,MAAV,IAAuB,EAAE8K,OAAOuC,MAAT,CAD5B,EAC+C;IAC7C8B,gBAAgB9B,MAAhB,EAAwBvC,GAAxB,EAA6B9K,KAA7B;EAAkC;AAEtC;;ACZA,oBAAoB6Q,MAApB,EAA4BtB,KAA5B,EAAmClC,MAAnC,EAA2CkH,UAA3C,EAAuD;EACrD,IAAIC,QAAQ,CAACnH,MAAb;EACAA,WAAWA,SAAS,EAApB;EAEA,IAAI/I,QAAQ,EAAZ;EAAA,IACI4C,UAASqI,MAAMjO,MADnB;;EAGA,OAAO,EAAEgD,KAAF,GAAU4C,OAAjB,EAAyB;IACvB,IAAI4D,MAAMyE,MAAMjL,KAAN,CAAV;IAEA,IAAImQ,WAAWF,aACXA,WAAWlH,OAAOvC,GAAP,CAAX,EAAwB+F,OAAO/F,GAAP,CAAxB,EAAqCA,GAArC,EAA0CuC,MAA1C,EAAkDwD,MAAlD,CADW,GAEX,MAFJ;;IAIA,IAAI4D,aAAa,MAAjB,EAA4B;MAC1BA,WAAW5D,OAAO/F,GAAP,CAAX;IAAkB;;IAEpB,IAAI0J,KAAJ,EAAW;MACTrF,gBAAgB9B,MAAhB,EAAwBvC,GAAxB,EAA6B2J,QAA7B;IAAqC,CADvC,MAEO;MACLC,YAAYrH,MAAZ,EAAoBvC,GAApB,EAAyB2J,QAAzB;IAAiC;;;EAGrC,OAAOpH,MAAP;AACF;;AC5BA,mBAAmBvJ,CAAnB,EAAsBmD,QAAtB,EAAgC;EAC9B,IAAI3C,QAAQ,EAAZ;EAAA,IACIhB,SAAS6D,MAAMrD,CAAN,CADb;;EAGA,OAAO,EAAEQ,KAAF,GAAUR,CAAjB,EAAoB;IAClBR,OAAOgB,KAAP,IAAgB2C,SAAS3C,KAAT,CAAhB;EAA8B;;EAEhC,OAAOhB,MAAP;AACF;;AChBA,IAAIwO,mBAAmB,gBAAvB;AAGA,IAAI6C,WAAW,kBAAf;;AAUA,iBAAiB3U,KAAjB,EAAwBkH,OAAxB,EAAgC;EAC9B,IAAI7E,OAAO,OAAOrC,KAAlB;EACAkH,UAASA,WAAU,IAAV,GAAiB4K,gBAAjB,GAAoC5K,OAA7C;EAEA,OAAO,CAAC,CAACA,OAAF,KACJ7E,QAAQ,QAAR,IACEA,QAAQ,QAAR,IAAoBsS,SAASpQ,IAAT,CAAcvE,KAAd,CAFlB,KAGAA,QAAQ,EAAR,IAAcA,QAAQ,CAAR,IAAa,CAA3B,IAAgCA,QAAQkH,OAH/C;AAIF;;ACdA,IAAIrC,gBAAc3D,OAAO4D,SAAzB;AAGA,IAAIC,mBAAiBF,cAAYE,cAAjC;;AAUA,uBAAuB/E,KAAvB,EAA8B4U,SAA9B,EAAyC;EACvC,IAAIC,QAAQzN,UAAQpH,KAARoH,CAAZ;EAAA,IACI0N,QAAQ,CAACD,KAAD,IAAUlD,cAAY3R,KAAZ2R,CADtB;EAAA,IAEIoD,SAAS,CAACF,KAAD,IAAU,CAACC,KAAX,IAAoB5C,WAASlS,KAATkS,CAFjC;EAAA,IAGI8C,SAAS,CAACH,KAAD,IAAU,CAACC,KAAX,IAAoB,CAACC,MAArB,IAA+BZ,eAAanU,KAAbmU,CAH5C;EAAA,IAIIc,cAAcJ,SAASC,KAAT,IAAkBC,MAAlB,IAA4BC,MAJ9C;EAAA,IAKI1R,SAAS2R,cAAcC,UAAUlV,MAAMsB,MAAhB,EAAwB6T,MAAxB,CAAd,GAAgD,EAL7D;EAAA,IAMIjO,UAAS5D,OAAOhC,MANpB;;EAQA,SAASwJ,GAAT,IAAgB9K,KAAhB,EAAuB;IACrB,IAAK,cAAa+E,iBAAeM,IAAfN,CAAoB/E,KAApB+E,EAA2B+F,GAA3B/F,CAAb,KACD,EAAEkQ,gBAECnK,OAAO,QAAP,IAECiK,WAAWjK,OAAO,QAAP,IAAmBA,OAAO,QAArC,CAFD,IAICkK,WAAWlK,OAAO,QAAP,IAAmBA,OAAO,YAA1B,IAA0CA,OAAO,YAA5D,CAJD,IAMAsK,QAAQtK,GAAR,EAAa5D,OAAb,CARD,CAAF,CADJ,EAUQ;MACN5D,OAAOgI,IAAP,CAAYR,GAAZ;IAAe;;;EAGnB,OAAOxH,MAAP;AACF;;ACrCA,sBAAsB+J,MAAtB,EAA8B;EAC5B,IAAI/J,SAAS,EAAb;;EACA,IAAI+J,UAAU,IAAd,EAAoB;IAClB,SAASvC,GAAT,IAAgB5J,OAAOmM,MAAP,CAAhB,EAAgC;MAC9B/J,OAAOgI,IAAP,CAAYR,GAAZ;IAAe;;;EAGnB,OAAOxH,MAAP;AACF;;ACZA,IAAIuB,gBAAc3D,OAAO4D,SAAzB;AAGA,IAAIC,mBAAiBF,cAAYE,cAAjC;;AASA,oBAAoBsI,MAApB,EAA4B;EAC1B,IAAI,CAAC/G,SAAS+G,MAAT,CAAL,EAAuB;IACrB,OAAOgI,aAAahI,MAAb,CAAP;EAA0B;;EAE5B,IAAIiI,UAAU9D,YAAYnE,MAAZ,CAAd;EAAA,IACI/J,SAAS,EADb;;EAGA,SAASwH,GAAT,IAAgBuC,MAAhB,EAAwB;IACtB,IAAI,EAAEvC,OAAO,aAAP,KAAyBwK,WAAW,CAACvQ,iBAAeM,IAAfN,CAAoBsI,MAApBtI,EAA4B+F,GAA5B/F,CAArC,CAAF,CAAJ,EAA+E;MAC7EzB,OAAOgI,IAAP,CAAYR,GAAZ;IAAe;;;EAGnB,OAAOxH,MAAP;AACF;;ACHA,gBAAgB+J,MAAhB,EAAwB;EACtB,OAAO2E,YAAY3E,MAAZ,IAAsBkI,cAAclI,MAAd,EAAsB,IAAtB,CAAtB,GAAoDmI,WAAWnI,MAAX,CAA3D;AACF;;ACFA,uBAAuBrN,KAAvB,EAA8B;EAC5B,OAAOyV,WAAWzV,KAAX,EAAkB0V,OAAO1V,KAAP,CAAlB,CAAP;AACF;;ACEA,uBAAuBqN,MAAvB,EAA+BwD,MAA/B,EAAuC/F,GAAvC,EAA4C6K,QAA5C,EAAsDC,SAAtD,EAAiErB,UAAjE,EAA6EsB,KAA7E,EAAoF;EAClF,IAAIvB,WAAWwB,QAAQzI,MAAR,EAAgBvC,GAAhB,CAAf;EAAA,IACIiL,WAAWD,QAAQjF,MAAR,EAAgB/F,GAAhB,CADf;EAAA,IAEIkL,UAAUH,MAAMhK,GAAN,CAAUkK,QAAV,CAFd;;EAIA,IAAIC,OAAJ,EAAa;IACXC,iBAAiB5I,MAAjB,EAAyBvC,GAAzB,EAA8BkL,OAA9B;IACA;EAAA;;EAEF,IAAIvB,WAAWF,aACXA,WAAWD,QAAX,EAAqByB,QAArB,EAAgCjL,MAAM,EAAtC,EAA2CuC,MAA3C,EAAmDwD,MAAnD,EAA2DgF,KAA3D,CADW,GAEX,MAFJ;EAIA,IAAIK,WAAWzB,aAAa,MAA5B;;EAEA,IAAIyB,QAAJ,EAAc;IACZ,IAAIrB,QAAQzN,UAAQ2O,QAAR3O,CAAZ;IAAA,IACI2N,SAAS,CAACF,KAAD,IAAU3C,WAAS6D,QAAT7D,CADvB;IAAA,IAEIiE,UAAU,CAACtB,KAAD,IAAU,CAACE,MAAX,IAAqBZ,eAAa4B,QAAb5B,CAFnC;IAIAM,WAAWsB,QAAX;;IACA,IAAIlB,SAASE,MAAT,IAAmBoB,OAAvB,EAAgC;MAC9B,IAAI/O,UAAQkN,QAARlN,CAAJ,EAAuB;QACrBqN,WAAWH,QAAX;MAAW,CADb,MACa,IAEJ8B,kBAAkB9B,QAAlB,CAFI,EAEyB;QACpCG,WAAW4B,UAAU/B,QAAV,CAAX;MAA6B,CAHlB,MAGkB,IAEtBS,MAFsB,EAEd;QACfmB,WAAW,KAAX;QACAzB,WAAW6B,YAAYP,QAAZ,EAAsB,IAAtB,CAAX;MAAqC,CAJR,MAIQ,IAE9BI,OAF8B,EAErB;QAChBD,WAAW,KAAX;QACAzB,WAAW8B,gBAAgBR,QAAhB,EAA0B,IAA1B,CAAX;MAAyC,CAJJ,MAMlC;QACHtB,WAAW,EAAX;;KAhBJ,UAmBS+B,cAAcT,QAAd,KAA2BpE,cAAYoE,QAAZpE,GAAuB;MACzD8C,WAAWH,QAAX;;MACA,IAAI3C,cAAY2C,QAAZ3C,CAAJ,EAA2B;QACzB8C,WAAWgC,cAAcnC,QAAd,CAAX;MAAiC,CADnC,MACmC,IAE1B,CAAChO,SAASgO,QAAT,CAAD,IAAuBnH,WAAWmH,QAAX,CAFG,EAEmB;QACpDG,WAAWiC,gBAAgBX,QAAhB,CAAX;MAAmC;WAGlC;MACHG,WAAW,KAAX;IAAW;;;EAGf,IAAIA,QAAJ,EAAc;IAEZL,MAAMpK,GAAN,CAAUsK,QAAV,EAAoBtB,QAApB;IACAmB,UAAUnB,QAAV,EAAoBsB,QAApB,EAA8BJ,QAA9B,EAAwCpB,UAAxC,EAAoDsB,KAApD;IACAA,MAAM,QAAN,EAAgBE,QAAhB;EAAwB;;EAE1BE,iBAAiB5I,MAAjB,EAAyBvC,GAAzB,EAA8B2J,QAA9B;AACF;;ACxEA,mBAAmBpH,MAAnB,EAA2BwD,MAA3B,EAAmC8E,QAAnC,EAA6CpB,UAA7C,EAAyDsB,KAAzD,EAAgE;EAC9D,IAAIxI,WAAWwD,MAAf,EAAuB;IACrB;EAAA;;EAEFrB,UAAQqB,MAARrB,EAAgB,UAASuG,QAAT,EAAmBjL,GAAnB,EAAwB;IACtC+K,UAAUA,QAAQ,IAAIjH,KAAJ,EAAlB;;IACA,IAAItI,SAASyP,QAAT,CAAJ,EAAwB;MACtBY,cAActJ,MAAd,EAAsBwD,MAAtB,EAA8B/F,GAA9B,EAAmC6K,QAAnC,EAA6CiB,SAA7C,EAAwDrC,UAAxD,EAAoEsB,KAApE;IAAyE,CAD3E,MAGK;MACH,IAAIpB,WAAWF,aACXA,WAAWuB,QAAQzI,MAAR,EAAgBvC,GAAhB,CAAX,EAAiCiL,QAAjC,EAA4CjL,MAAM,EAAlD,EAAuDuC,MAAvD,EAA+DwD,MAA/D,EAAuEgF,KAAvE,CADW,GAEX,MAFJ;;MAIA,IAAIpB,aAAa,MAAjB,EAA4B;QAC1BA,WAAWsB,QAAX;MAAW;;MAEbE,iBAAiB5I,MAAjB,EAAyBvC,GAAzB,EAA8B2J,QAA9B;IAAsC;GAb1CjF,EAeGkG,MAfHlG;AAgBF;;ACvBA,kBAAkBxP,KAAlB,EAAyB;EACvB,OAAOA,KAAP;AACF;;ACRA,eAAe8H,IAAf,EAAqB+O,OAArB,EAA8BC,IAA9B,EAAoC;EAClC,QAAQA,KAAKxV,MAAb;IAAa,KACN,CADM;MACH,OAAOwG,KAAKzC,IAAL,CAAUwR,OAAV,CAAP;;IAAwB,KAC3B,CAD2B;MACxB,OAAO/O,KAAKzC,IAAL,CAAUwR,OAAV,EAAmBC,KAAK,CAAL,CAAnB,CAAP;;IAAiC,KACpC,CADoC;MACjC,OAAOhP,KAAKzC,IAAL,CAAUwR,OAAV,EAAmBC,KAAK,CAAL,CAAnB,EAA4BA,KAAK,CAAL,CAA5B,CAAP;;IAA0C,KAC7C,CAD6C;MAC1C,OAAOhP,KAAKzC,IAAL,CAAUwR,OAAV,EAAmBC,KAAK,CAAL,CAAnB,EAA4BA,KAAK,CAAL,CAA5B,EAAqCA,KAAK,CAAL,CAArC,CAAP;EAJV;;EAMA,OAAOhP,KAAKiP,KAAL,CAAWF,OAAX,EAAoBC,IAApB,CAAP;AACF;;ACfA,IAAIE,cAAYlU,KAAKmU,GAArB;;AAWA,kBAAkBnP,IAAlB,EAAwBoP,KAAxB,EAA+BhG,SAA/B,EAA0C;EACxCgG,QAAQF,YAAUE,UAAU,MAAV,GAAuBpP,KAAKxG,MAAL,GAAc,CAArC,GAA0C4V,KAApDF,EAA2D,CAA3DA,CAAR;EACA,OAAO,YAAW;IAChB,IAAIF,OAAOjF,SAAX;IAAA,IACIvN,QAAQ,EADZ;IAAA,IAEI4C,UAAS8P,YAAUF,KAAKxV,MAAL,GAAc4V,KAAxBF,EAA+B,CAA/BA,CAFb;IAAA,IAGIrT,QAAQwD,MAAMD,OAAN,CAHZ;;IAKA,OAAO,EAAE5C,KAAF,GAAU4C,OAAjB,EAAyB;MACvBvD,MAAMW,KAAN,IAAewS,KAAKI,QAAQ5S,KAAb,CAAf;IAA4B;;IAE9BA,QAAQ,EAAR;IACA,IAAI6S,YAAYhQ,MAAM+P,QAAQ,CAAd,CAAhB;;IACA,OAAO,EAAE5S,KAAF,GAAU4S,KAAjB,EAAwB;MACtBC,UAAU7S,KAAV,IAAmBwS,KAAKxS,KAAL,CAAnB;IAAwB;;IAE1B6S,UAAUD,KAAV,IAAmBhG,UAAUvN,KAAV,CAAnB;IACA,OAAOoT,MAAMjP,IAAN,EAAY,IAAZ,EAAkBqP,SAAlB,CAAP;EAAkC,CAfpC;AAiBF;;ACdA,kBAAkBnX,KAAlB,EAAyB;EACvB,OAAO,YAAW;IAChB,OAAOA,KAAP;EAAO,CADT;AAGF;;ACXA,IAAIoX,kBAAkB,CAAClI,gBAAD,GAAkBmI,QAAlB,GAA6B,UAASvP,IAAT,EAAezD,MAAf,EAAuB;EACxE,OAAO6K,iBAAepH,IAAfoH,EAAqB,UAArBA,EAAiC;IACtC,gBAAgB,IADsB;IAEtC,cAAc,KAFwB;IAGtC,SAASoI,SAASjT,MAAT,CAH6B;IAItC,YAAY;EAJ0B,CAAjC6K,CAAP;AAMF,CAPA;AASA,wBAAekI,eAAf;ACpBA,IAAIG,YAAY,GAAhB;AAAA,IACIC,WAAW,EADf;AAIA,IAAIC,YAAYC,KAAKC,GAArB;;AAWA,kBAAkB7P,IAAlB,EAAwB;EACtB,IAAI8P,QAAQ,CAAZ;EAAA,IACIC,aAAa,CADjB;EAGA,OAAO,YAAW;IAChB,IAAIC,QAAQL,WAAZ;IAAA,IACIM,YAAYP,YAAYM,QAAQD,UAApB,CADhB;IAGAA,aAAaC,KAAb;;IACA,IAAIC,YAAY,CAAhB,EAAmB;MACjB,IAAI,EAAEH,KAAF,IAAWL,SAAf,EAA0B;QACxB,OAAO1F,UAAU,CAAV,CAAP;MAAiB;KAFrB,MAIO;MACL+F,QAAQ,CAAR;IAAQ;;IAEV,OAAO9P,KAAKiP,KAAL,CAAW,MAAX,EAAsBlF,SAAtB,CAAP;EAAsC,CAZxC;AAcF;;ACvBA,IAAImG,cAAcC,SAASb,iBAAT,CAAlB;AAEA,oBAAeY,WAAf;;ACDA,kBAAkBlQ,IAAlB,EAAwBoP,KAAxB,EAA+B;EAC7B,OAAOc,cAAYE,SAASpQ,IAAT,EAAeoP,KAAf,EAAsBG,QAAtB,CAAZW,EAA6ClQ,OAAO,EAApDkQ,CAAP;AACF;;ACCA,wBAAwBhY,KAAxB,EAA+BsE,KAA/B,EAAsC+I,MAAtC,EAA8C;EAC5C,IAAI,CAAC/G,SAAS+G,MAAT,CAAL,EAAuB;IACrB,OAAO,KAAP;EAAO;;EAET,IAAIhL,OAAO,OAAOiC,KAAlB;;EACA,IAAIjC,QAAQ,QAAR,GACK2P,YAAY3E,MAAZ,KAAuB+H,QAAQ9Q,KAAR,EAAe+I,OAAO/L,MAAtB,CAD5B,GAEKe,QAAQ,QAAR,IAAoBiC,SAAS+I,MAFtC,EAGM;IACJ,OAAOtC,GAAGsC,OAAO/I,KAAP,CAAH,EAAkBtE,KAAlB,CAAP;EAA8B;;EAEhC,OAAO,KAAP;AACF;;ACjBA,wBAAwBmY,QAAxB,EAAkC;EAChC,OAAOC,SAAS,UAAS/K,MAAT,EAAiBgL,OAAjB,EAA0B;IACxC,IAAI/T,QAAQ,EAAZ;IAAA,IACI4C,UAASmR,QAAQ/W,MADrB;IAAA,IAEIiT,aAAarN,UAAS,CAAT,GAAamR,QAAQnR,UAAS,CAAjB,CAAb,GAAmC,MAFpD;IAAA,IAGIoR,QAAQpR,UAAS,CAAT,GAAamR,QAAQ,CAAR,CAAb,GAA0B,MAHtC;IAKA9D,aAAc4D,SAAS7W,MAAT,GAAkB,CAAlB,IAAuB,OAAOiT,UAAP,IAAqB,UAA5C,IACTrN,WAAUqN,UADD,IAEV,MAFJ;;IAIA,IAAI+D,SAASC,eAAeF,QAAQ,CAAR,CAAf,EAA2BA,QAAQ,CAAR,CAA3B,EAAuCC,KAAvC,CAAb,EAA4D;MAC1D/D,aAAarN,UAAS,CAAT,GAAa,MAAb,GAAyBqN,UAAtC;MACArN,UAAS,CAAT;IAAS;;IAEXmG,SAASnM,OAAOmM,MAAP,CAAT;;IACA,OAAO,EAAE/I,KAAF,GAAU4C,OAAjB,EAAyB;MACvB,IAAI2J,SAASwH,QAAQ/T,KAAR,CAAb;;MACA,IAAIuM,MAAJ,EAAY;QACVsH,SAAS9K,MAAT,EAAiBwD,MAAjB,EAAyBvM,KAAzB,EAAgCiQ,UAAhC;MAA0C;;;IAG9C,OAAOlH,MAAP;EACD,CAtBM,CAAP;AAuBF;;ACAA,IAAImL,QAAQC,eAAe,UAASpL,MAAT,EAAiBwD,MAAjB,EAAyB8E,QAAzB,EAAmC;EAC5DiB,UAAUvJ,MAAV,EAAkBwD,MAAlB,EAA0B8E,QAA1B;AACD,CAFW,CAAZ;AAIA,cAAe6C,KAAf;;6BC5B6C;SACpC;IACLE,MAAM;MACJC,gBAAgB,KADZ;MAEJC,YAAY,IAFR;MAGJC,aAAa,IAHT;MAIJC,cAAc,GAJV;MAKJC,cAAc,EALV;MAMJC,wBAAwB,IANpB;MAOJC,uBAAuB,IAPnB;MAQJC,qBAAqB,KARjB;MASJC,sBAAsB,gBATlB;MAUJC,iBAAiB,IAVb;MAWJC,eAAe,IAAI/Q,YAAJ,EAXX;MAYJgR,yBAAyB,MAZrB;MAaJC,MAAM;QACJC,SAAS,KADL;QAEJC,UAAU,EAFN;QAGJC,iBAAiB,CAHb;QAIJC,MAAM;UACJC,OAAO,SADH;UAEJtX,OAAO,CAFH;UAGJe,WAAW;QAHP,CAJF;QASJwW,OAAO;UACLD,OAAO,SADF;UAELtX,OAAO,CAFF;UAGLe,WAAW;QAHN;MATH,CAbF;MA4BJyW,WAAW;QACT7P,KAAK;UACH2P,OAAO,WADJ;UAEHG,aAAa,CAFV;UAGHC,aAAa,SAHV;UAIHC,iBAAiB;QAJd,CADI;QAOTC,UAAWC,KAAD,IAA0B;gBAC5BC,SAAS,SAAS7V,IAAT,CAAc8V,UAAUC,SAAxB,IAAqCH,MAAMI,OAA3C,GAAqDJ,MAAMK;iBAClEL,MAAM9X,IAAN,KAAe,SAAf,GAA4B+X,MAA5B,GAAqC,CAACA;QAAA;MATvC;IA5BP,CADD;IA0CLpY,MAAMyY,SAAS5Y;MACbO,QAAQ;QACNC,MAAM,QADA;QAENE,QAAQ,EAFF;QAIND,OAAO,EAJD;QAKNE,QAAQ,EALF;QAMNkY,cAAc,CANR;QAQNd,OAAO,SARD;QASNG,aAAa,CATP;QAUNC,aAAa,SAVP;QAWNC,iBAAiB;MAXX,CADK;MAcbU,OAAO;QACLtY,MAAML,QAAQjB,OAAOf,KAAP,CAAa6B,MAAKO,MAAL,CAAYC,IAAzB,EAA+BL,IAA/B,CADT;QAELO,QAAQP;;;+BAAgBhC,MAAM6B,MAAKO,MAAL,CAAYG,QAAQP,UAAI,YAAK,KAAK;QAAA,CAF3D;QAGLM,OAAON;;;+BAAgBhC,MAAM6B,MAAKO,MAAL,CAAYE,OAAON,UAAI,YAAK,KAAK;QAAA,CAHzD;QAILQ,QAAQR;;;+BAAgBhC,MAAM6B,MAAKO,MAAL,CAAYI,QAAQR,UAAI,YAAK,KAAK;QAAA,CAJ3D;QAKL0Y,cAAc1Y;;;UAAQ,oBAAOhC,KAAP,CAAa6B,MAAKO,MAAL,CAAYsY,YAAzB,EAAuC1Y,IAAvC,kBAAgD,CAAhD;QAAgD,CALjE;QAML+X,aAAa/X,QAAQjB,OAAOf,KAAP,CAAa6B,MAAKO,MAAL,CAAY2X,WAAzB,EAAsC/X,IAAtC,CANhB;QAOLgY,aAAahY,QAAQjB,OAAOf,KAAP,CAAa6B,MAAKO,MAAL,CAAY4X,WAAzB,EAAsChY,IAAtC,CAPhB;QAQLiY,iBAAiBjY,QAAQjB,OAAOf,KAAP,CAAa6B,MAAKO,MAAL,CAAY6X,eAAzB,EAA0CjY,IAA1C,CARpB;QASL4X,OAAO;MATF,CAdM;MAyBbgB,UAAU,MAzBG;MA0BbC,WAAW,IA1BE;MA2BbC,YAAY,KA3BC;MA4BbC,OAAO;QACLvB,SAAS,IADJ;QAELwB,YAAY,MAFP;QAGLC,UAAU,EAHL;QAILC,YAAY,GAJP;QAKLtB,OAAO,SALF;QAMLuB,YAAY,MANP;QAgBLC,QAAQ,CAhBH;QAiBLC,WAAW1Z,mBAAmB2Z,KAjBzB;QAkBLC,MAAM;MAlBD,CA5BM;MAgDbC,WAAW;QACThC,SAAS,IADA;QAETlX,OAAO,CAFE;QAGTmZ,SAAS,CAHA;QAIT7B,OAAO;MAJE,CAhDE;MAsDb8B,QAAQ;QACNC,SAAS,KADH;QAENC,QAAQ,CAFF;QAGNC,qBAAqB,IAHf;QAINC,wBAAwB;MAJlB,CAtDK;MA4DbC,YAAY;IA5DC,EAAT,CA1CD;IAwGLC,MAAMvB,SAAS5Y;MACbO,QAAQ;QACNE,OAAO,CADD;QAENsX,OAAO,SAFD;QAGNvW,WAAW,CAHL;QAIN4Y,SAAS,MAJH;QAKNC,SAAS,KALH;QAMNC,gBAAgB;MANV,CADK;MASbxB,OAAO;QACLrY,OAAO0Z,QAAQjb,OAAOf,KAAP,CAAa6B,MAAKO,MAAL,CAAYE,KAAzB,EAAgC0Z,IAAhC,IAAwC,CADlD;QAELpC,OAAO,SAFF;QAGLvW,WAAW2Y,QAAQjb,OAAOf,KAAP,CAAa6B,MAAKO,MAAL,CAAYiB,SAAzB,EAAoC2Y,IAApC,CAHd;QAILC,SAASD,QAAQjb,OAAOf,KAAP,CAAa6B,MAAKO,MAAL,CAAY6Z,OAAzB,EAAkCD,IAAlC,CAJZ;QAKLE,SAASF,QAAQjb,OAAOf,KAAP,CAAa6B,MAAKO,MAAL,CAAY8Z,OAAzB,EAAkCF,IAAlC,CALZ;QAMLG,gBAAgBH,QAAQjb,OAAOf,KAAP,CAAa6B,MAAKO,MAAL,CAAY+Z,cAAzB,EAAyCH,IAAzC;MANnB,CATM;MAiBbpB,UAAU;QACRtY,OAAO0Z,QAAQjb,OAAOf,KAAP,CAAa6B,MAAKO,MAAL,CAAYE,KAAzB,EAAgC0Z,IAAhC,IAAwC,CAD/C;QAERpC,OAAO,SAFC;QAGRvW,WAAW2Y,QAAQ;gBACXI,IAAIrb,OAAOf,KAAP,CAAa6B,MAAKO,MAAL,CAAYE,KAAzB,EAAgC0Z,IAAhC;iBACH,GAAGI,IAAI,OAAOA,IAAI;QAAA,CALnB;QAORH,SAASD,QAAQjb,OAAOf,KAAP,CAAa6B,MAAKO,MAAL,CAAY6Z,OAAzB,EAAkCD,IAAlC,CAPT;QAQRE,SAASF,QAAQjb,OAAOf,KAAP,CAAa6B,MAAKO,MAAL,CAAY8Z,OAAzB,EAAkCF,IAAlC,CART;QASRG,gBAAgBH,QAAQjb,OAAOf,KAAP,CAAa6B,MAAKO,MAAL,CAAY+Z,cAAzB,EAAyCH,IAAzC;MAThB,CAjBG;MA4BblB,YAAY,KA5BC;MA6BbuB,KAAK,CA7BQ;MA8Bbha,MAAM,UA9BO;MA+Bbia,QAAQ;QACNzL,QAAQ;UACNxO,MAAM,MADA;UAENC,OAAO,CAFD;UAGNE,QAAQ,CAHF;UAIN4Y,QAAQ,EAJF;UAKNmB,OAAO,aALD;UAMN3C,OAAO;QAND,CADF;QASN5Y,QAAQ;UACNqB,MAAM,MADA;UAENC,OAAO,CAFD;UAGNE,QAAQ,CAHF;UAIN4Y,QAAQ,EAJF;UAKNmB,OAAO,aALD;UAMN3C,OAAO;QAND;MATF,CA/BK;MAiDbwB,QAAQ,IAjDK;MAkDboB,WAAW,CAACC,MAAD,EAAgB1a,OAAhB,KAAqC;eACvCA,QAAQia,IAAR,CAAa3Z,IAAb,IAAqB,OAArB,GAA+B,KAA/B,GAAuC;MAAA,CAnDnC;MAqDbqa,YAAY;QACV3B,OAAO;UACLE,UAAU,EADL;UAELC,YAAY,CAFP;UAGLtB,OAAO;QAHF,CADG;QAMVzX,OAAO;UACLE,MAAM,MADD;UAGLE,QAAQ,CAHH;UAKLD,OAAO,EALF;UAMLE,QAAQ,EANH;UAOLkY,cAAc,CAPT;UAQLd,OAAO,SARF;UASLG,aAAa,CATR;UAULC,aAAa,SAVR;UAWLC,iBAAiB;QAXZ,CANG;QAmBV0C,QAAQ;UACNra,OAAO,CADD;UAENsX,OAAO,SAFD;UAGNvW,WAAW,MAHL;UAIN4Y,SAAS,MAJH;UAKNC,SAAS,KALH;UAMNC,gBAAgB;QANV;MAnBE,CArDC;MAiFbS,WAAW,OAjFE;MAkFb7B,OAAO;QACLC,YAAY,MADP;QAELC,UAAU,EAFL;QAGLC,YAAY,GAHP;QAILtB,OAAO,SAJF;QAKLuB,YAAY,MALP;QAeLC,QAAQ,CAfH;QAgBLK,SAAS;MAhBJ,CAlFM;MAoGbC,QAAQ;QACNC,SAAS,KADH;QAENC,QAAQ,CAFF;QAGNC,qBAAqB,IAHf;QAINC,wBAAwB;MAJlB;IApGK,EAAT,CAxGD;IAmNLe,MAAMpC,SAAS5Y;MACb2X,SAAS,KADI;MAEbsD,WAAW,KAFE;MAGbC,WAAW,KAHE;MAIbC,aAAa,KAJA;MAKbC,KAAK,cALQ;MAMb7B,QAAQ,CANK;MAQbyB,MAAM3c,SAAS;QACboC,OAAO,CADM;QAEbsX,OAAOsD,KAAK;gBACJC,OAAO,CACX,WADW,EAEX,WAFW,EAGX,WAHW,EAIX,WAJW,EAKX,WALW,EAMX,WANW,EAOX,WAPW,EAQX,WARW,EASX,WATW,EAUX,WAVW,EAWX,WAXW,EAYX,WAZW,EAaX,WAbW,EAcX,WAdW,EAeX,WAfW,EAgBX,WAhBW;gBAkBPC,OAAOF,EAAEG,KAAF,CACV5b,GADU,CACNoC,KACHA,EAAEN,KAAF,CAAQ,EAAR,EAAYK,MAAZ,CAAmB,CAAC0Z,CAAD,EAAIC,CAAJ,KAAU;sBACjB,KAAKD,IAAIC,EAAEC,UAAF,CAAa,CAAb;mBACZF,IAAIA;UAAA,CAFb,EAGG,CAHH,CAFS,EAOV1Z,MAPU,CAOH,CAAC0Z,CAAD,EAAIC,CAAJ,KAAUD,IAAIC,CAPX,EAOc,CAPd;iBAQNJ,KAAKra,KAAKC,GAAL,CAASqa,IAAT,IAAiBD,KAAK7b,MAA3B;QAA2B,CA7BvB;QA+Bb+B,WAAW,MA/BE;QAgCb4Y,SAAS,OAhCI;QAiCbwB,UAAU,OAjCG;QAkCbvB,SAAS,KAlCI;QAmCbC,gBAAgB;MAnCH,CAAT,CARO;MA6Cb/Z,QAAQ;QACNE,OAAOua,QAAQ9b,OAAOf,KAAP,CAAa6B,MAAKgb,IAAL,CAAUva,KAAvB,EAA8Bua,IAA9B,CADT;QAENjD,OAAOiD,QAAQ9b,OAAOf,KAAP,CAAa6B,MAAKgb,IAAL,CAAUjD,KAAvB,EAA8BiD,IAA9B,CAFT;QAGNxZ,WAAWwZ,QAAQ9b,OAAOf,KAAP,CAAa6B,MAAKgb,IAAL,CAAUxZ,SAAvB,EAAkCwZ,IAAlC,CAHb;QAINZ,SAASY,QAAQ9b,OAAOf,KAAP,CAAa6B,MAAKgb,IAAL,CAAUZ,OAAvB,EAAgCY,IAAhC,CAJX;QAKNY,UAAUZ,QAAQ9b,OAAOf,KAAP,CAAa6B,MAAKgb,IAAL,CAAUY,QAAvB,EAAiCZ,IAAjC,CALZ;QAMNX,SAASW,QAAQ9b,OAAOf,KAAP,CAAa6B,MAAKgb,IAAL,CAAUX,OAAvB,EAAgCW,IAAhC,CANX;QAONV,gBAAgBU,QAAQ9b,OAAOf,KAAP,CAAa6B,MAAKgb,IAAL,CAAUV,cAAvB,EAAuCU,IAAvC;MAPlB,CA7CK;MAsDblC,OAAO;QACLrY,OAAOua,QAAQ9b,OAAOf,KAAP,CAAa6B,MAAKO,MAAL,CAAYE,KAAzB,EAAgCua,IAAhC,IAAwC,CADlD;QAELjD,OAAOiD,QAAQ9b,OAAOf,KAAP,CAAa6B,MAAKO,MAAL,CAAYwX,KAAzB,EAAgCiD,IAAhC,CAFV;QAGLxZ,WAAWwZ,QAAQ9b,OAAOf,KAAP,CAAa6B,MAAKO,MAAL,CAAYiB,SAAzB,EAAoCwZ,IAApC,CAHd;QAILZ,SAASY,QAAQ9b,OAAOf,KAAP,CAAa6B,MAAKO,MAAL,CAAY6Z,OAAzB,EAAkCY,IAAlC,CAJZ;QAKLY,UAAUZ,QAAQ9b,OAAOf,KAAP,CAAa6B,MAAKO,MAAL,CAAYqb,QAAzB,EAAmCZ,IAAnC,CALb;QAMLX,SAASW,QAAQ9b,OAAOf,KAAP,CAAa6B,MAAKO,MAAL,CAAY8Z,OAAzB,EAAkCW,IAAlC,CANZ;QAOLV,gBAAgBU,QAAQ9b,OAAOf,KAAP,CAAa6B,MAAKO,MAAL,CAAY+Z,cAAzB,EAAyCU,IAAzC;MAPnB,CAtDM;MA+DbjC,UAAU;QACRtY,OAAOua,QAAQ9b,OAAOf,KAAP,CAAa6B,MAAKO,MAAL,CAAYE,KAAzB,EAAgCua,IAAhC,IAAwC,CAD/C;QAERjD,OAAOiD,QAAQ9b,OAAOf,KAAP,CAAa6B,MAAKO,MAAL,CAAYwX,KAAzB,EAAgCiD,IAAhC,CAFP;QAGRxZ,WAAW,MAHH;QAIR4Y,SAASY,QAAQ9b,OAAOf,KAAP,CAAa6B,MAAKO,MAAL,CAAY6Z,OAAzB,EAAkCY,IAAlC,CAJT;QAKRY,UAAUZ,QAAQ9b,OAAOf,KAAP,CAAa6B,MAAKO,MAAL,CAAYqb,QAAzB,EAAmCZ,IAAnC,CALV;QAMRX,SAASW,QAAQ9b,OAAOf,KAAP,CAAa6B,MAAKO,MAAL,CAAY8Z,OAAzB,EAAkCW,IAAlC,CANT;QAORV,gBAAgBU,QAAQ9b,OAAOf,KAAP,CAAa6B,MAAKO,MAAL,CAAY+Z,cAAzB,EAAyCU,IAAzC;MAPhB,CA/DG;MAwEb/B,YAAY,KAxEC;MAyEbY,QAAQ;QACNC,SAAS,KADH;QAENC,QAAQ,CAFF;QAGNC,qBAAqB,IAHf;QAINC,wBAAwB;MAJlB,CAzEK;MA+EbC,YAAY;IA/EC,EAAT;EAnND;AAqST;;wBAEoG2B,QAAwC;QACpI3b,UAAU4b;;MACZD,QAAQ;YACJ3b,SAAS2b;EAAM;;SAEhB3b;AACT;;AClTA,MAAM6b,eAAerd,OAAO,OAAP,CAArB;;wBAE+BwB,SAA2B;QAClD8b,UAAmB3d,SAASyd,mBAAT;QACnBG,YAAY5c,OAAOiJ,IAAP,CAAY0T,OAAZ;;aACP/S,OAAOgT,WAAW;UACrB,MAAM/b,QAAQ/B,KAAR,CAAc8K,GAAd,GAAoB,MAAM;cAC9B+S,QAAQ/S,GAAR,GAAc/I,QAAQ/B,KAAR,CAAc8K,GAAd,KAAsB;IAAE,GAC3C;MAAEiT,WAAW,IAAb;MAAmBC,MAAM;IAAzB;EAA+B;;UAG5BJ,cAAcC;SACfA;AACT;;AAEA,sBAA+C/S,GAA/C,EAAuD;SAC9CrK,QAAQC,OAAOkd,YAAP,CAAR,EAA8B,WAAW9S,MAAzC,EAAiDA,GAAjD;AACT;;yBAMgC;SACvBmT,aAAa,MAAb;AACT;;yBAEgC;SACvBA,aAAa,MAAb;AACT;;yBAEgC;SACvBA,aAAa,MAAb;AACT;;yBAEgC;SACvBA,aAAa,MAAb;AACT;;AC3CA,IAAIC,SAAS,CAAb;;iBAGgC;SACvBA;AACT;;ACJA,IAAIvQ,iBAAiB,2BAArB;;AAYA,qBAAqB3N,KAArB,EAA4B;EAC1B,KAAK4K,QAAL,CAAca,GAAd,CAAkBzL,KAAlB,EAAyB2N,cAAzB;;EACA,OAAO,IAAP;AACF;;ACPA,qBAAqB3N,KAArB,EAA4B;EAC1B,OAAO,KAAK4K,QAAL,CAAcmB,GAAd,CAAkB/L,KAAlB,CAAP;AACF;;ACCA,kBAAkBmB,MAAlB,EAA0B;EACxB,IAAImD,QAAQ,EAAZ;EAAA,IACI4C,UAAS/F,UAAU,IAAV,GAAiB,CAAjB,GAAqBA,OAAOG,MADzC;EAGA,KAAKsJ,QAAL,GAAgB,IAAIwD,QAAJ,EAAhB;;EACA,OAAO,EAAE9J,KAAF,GAAU4C,OAAjB,EAAyB;IACvB,KAAKiX,GAAL,CAAShd,OAAOmD,KAAP,CAAT;EAAsB;AAE1B;;AAGA8Z,SAAStZ,SAAT,CAAmBqZ,GAAnB,GAAyBC,SAAStZ,SAAT,CAAmBwG,IAAnB,GAA0B+S,WAAnD;AACAD,SAAStZ,SAAT,CAAmBiH,GAAnB,GAAyBuS,WAAzB;;ACdA,mBAAmB3a,KAAnB,EAA0B4a,SAA1B,EAAqC;EACnC,IAAIja,QAAQ,EAAZ;EAAA,IACI4C,UAASvD,SAAS,IAAT,GAAgB,CAAhB,GAAoBA,MAAMrC,MADvC;;EAGA,OAAO,EAAEgD,KAAF,GAAU4C,OAAjB,EAAyB;IACvB,IAAIqX,UAAU5a,MAAMW,KAAN,CAAV,EAAwBA,KAAxB,EAA+BX,KAA/B,CAAJ,EAA2C;MACzC,OAAO,IAAP;IAAO;;;EAGX,OAAO,KAAP;AACF;;ACZA,kBAAkB6a,KAAlB,EAAyB1T,GAAzB,EAA8B;EAC5B,OAAO0T,MAAMzS,GAAN,CAAUjB,GAAV,CAAP;AACF;;ACLA,IAAI2T,yBAAuB,CAA3B;AAAA,IACIC,2BAAyB,CAD7B;;AAgBA,qBAAqB/a,KAArB,EAA4B4C,KAA5B,EAAmCoY,OAAnC,EAA4CpK,UAA5C,EAAwDqK,SAAxD,EAAmE/I,KAAnE,EAA0E;EACxE,IAAIgJ,YAAYF,UAAUF,sBAA1B;EAAA,IACIK,YAAYnb,MAAMrC,MADtB;EAAA,IAEIyd,YAAYxY,MAAMjF,MAFtB;;EAIA,IAAIwd,aAAaC,SAAb,IAA0B,EAAEF,aAAaE,YAAYD,SAA3B,CAA9B,EAAqE;IACnE,OAAO,KAAP;EAAO;;EAGT,IAAIE,aAAanJ,MAAMhK,GAAN,CAAUlI,KAAV,CAAjB;EACA,IAAIsb,aAAapJ,MAAMhK,GAAN,CAAUtF,KAAV,CAAjB;;EACA,IAAIyY,cAAcC,UAAlB,EAA8B;IAC5B,OAAOD,cAAczY,KAAd,IAAuB0Y,cAActb,KAA5C;EAA4C;;EAE9C,IAAIW,QAAQ,EAAZ;EAAA,IACIhB,SAAS,IADb;EAAA,IAEI4b,OAAQP,UAAUD,wBAAV,GAAoC,IAAIN,QAAJ,EAApC,GAAmD,MAF/D;EAIAvI,MAAMpK,GAAN,CAAU9H,KAAV,EAAiB4C,KAAjB;EACAsP,MAAMpK,GAAN,CAAUlF,KAAV,EAAiB5C,KAAjB;;EAGA,OAAO,EAAEW,KAAF,GAAUwa,SAAjB,EAA4B;IAC1B,IAAIK,WAAWxb,MAAMW,KAAN,CAAf;IAAA,IACI8a,WAAW7Y,MAAMjC,KAAN,CADf;;IAGA,IAAIiQ,UAAJ,EAAgB;MACd,IAAI8K,WAAWR,YACXtK,WAAW6K,QAAX,EAAqBD,QAArB,EAA+B7a,KAA/B,EAAsCiC,KAAtC,EAA6C5C,KAA7C,EAAoDkS,KAApD,CADW,GAEXtB,WAAW4K,QAAX,EAAqBC,QAArB,EAA+B9a,KAA/B,EAAsCX,KAAtC,EAA6C4C,KAA7C,EAAoDsP,KAApD,CAFJ;IAE6D;;IAE/D,IAAIwJ,aAAa,MAAjB,EAA4B;MAC1B,IAAIA,QAAJ,EAAc;QACZ;MAAA;;MAEF/b,SAAS,KAAT;MACA;IAAA;;IAGF,IAAI4b,IAAJ,EAAU;MACR,IAAI,CAACI,UAAU/Y,KAAV,EAAiB,UAASgZ,SAAT,EAAmBC,QAAnB,EAA6B;QAC7C,IAAI,CAACC,SAASP,IAAT,EAAeM,QAAf,CAAD,KACCL,aAAaI,SAAb,IAAyBX,UAAUO,QAAV,EAAoBI,SAApB,EAA8BZ,OAA9B,EAAuCpK,UAAvC,EAAmDsB,KAAnD,CAD1B,CAAJ,EAC0F;UACxF,OAAOqJ,KAAK5T,IAAL,CAAUkU,QAAV,CAAP;QAAyB;MAE5B,CALA,CAAL,EAKQ;QACNlc,SAAS,KAAT;QACA;MAAA;KARJ,UAUW,EACL6b,aAAaC,QAAb,IACER,UAAUO,QAAV,EAAoBC,QAApB,EAA8BT,OAA9B,EAAuCpK,UAAvC,EAAmDsB,KAAnD,CAFG,GAGJ;MACLvS,SAAS,KAAT;MACA;IAAA;;;EAGJuS,MAAM,QAAN,EAAgBlS,KAAhB;EACAkS,MAAM,QAAN,EAAgBtP,KAAhB;EACA,OAAOjD,MAAP;AACF;;AC1EA,oBAAoB7B,GAApB,EAAyB;EACvB,IAAI6C,QAAQ,EAAZ;EAAA,IACIhB,SAAS6D,MAAM1F,IAAIoJ,IAAV,CADb;EAGApJ,IAAIie,OAAJ,CAAY,UAAS1f,KAAT,EAAgB8K,GAAhB,EAAqB;IAC/BxH,OAAO,EAAEgB,KAAT,IAAkB,CAACwG,GAAD,EAAM9K,KAAN,CAAlB;EACD,CAFD;EAGA,OAAOsD,MAAP;AACF;;ACRA,oBAAoBmI,GAApB,EAAyB;EACvB,IAAInH,QAAQ,EAAZ;EAAA,IACIhB,SAAS6D,MAAMsE,IAAIZ,IAAV,CADb;EAGAY,IAAIiU,OAAJ,CAAY,UAAS1f,KAAT,EAAgB;IAC1BsD,OAAO,EAAEgB,KAAT,IAAkBtE,KAAlB;EACD,CAFD;EAGA,OAAOsD,MAAP;AACF;;ACPA,IAAImb,yBAAuB,CAA3B;AAAA,IACIC,yBAAyB,CAD7B;AAIA,IAAInM,UAAU,kBAAd;AAAA,IACIC,UAAU,eADd;AAAA,IAEIC,WAAW,gBAFf;AAAA,IAGIC,WAAS,cAHb;AAAA,IAIIC,YAAY,iBAJhB;AAAA,IAKIC,YAAY,iBALhB;AAAA,IAMIC,WAAS,cANb;AAAA,IAOIC,YAAY,iBAPhB;AAAA,IAQIjN,YAAY,iBARhB;AAUA,IAAImN,iBAAiB,sBAArB;AAAA,IACIC,gBAAc,mBADlB;AAIA,IAAI5L,cAAc9G,WAASA,SAAOuE,SAAhBvE,GAA4B,MAA9C;AAAA,IACIof,gBAAgBtY,cAAcA,YAAYb,OAA1B,GAAoC,MADxD;;AAoBA,oBAAoB6G,MAApB,EAA4B9G,KAA5B,EAAmCjB,GAAnC,EAAwCqZ,OAAxC,EAAiDpK,UAAjD,EAA6DqK,SAA7D,EAAwE/I,KAAxE,EAA+E;EAC7E,QAAQvQ,GAAR;IAAQ,KACD2N,aADC;MAEJ,IAAK5F,OAAOoD,UAAP,IAAqBlK,MAAMkK,UAA3B,IACApD,OAAOuD,UAAP,IAAqBrK,MAAMqK,UADhC,EAC6C;QAC3C,OAAO,KAAP;MAAO;;MAETvD,SAASA,OAAO6C,MAAhB;MACA3J,QAAQA,MAAM2J,MAAd;;IAAc,KAEX8C,cAFW;MAGd,IAAK3F,OAAOoD,UAAP,IAAqBlK,MAAMkK,UAA3B,IACD,CAACmO,UAAU,IAAIrO,YAAJ,CAAelD,MAAf,CAAV,EAAkC,IAAIkD,YAAJ,CAAehK,KAAf,CAAlC,CADL,EAC+D;QAC7D,OAAO,KAAP;MAAO;;MAET,OAAO,IAAP;;IAAO,KAEJgM,OAFI;IAEJ,KACAC,OADA;IACA,KACAG,SADA;MAIH,OAAO5H,GAAG,CAACsC,MAAJ,EAAY,CAAC9G,KAAb,CAAP;;IAAyB,KAEtBkM,QAFsB;MAGzB,OAAOpF,OAAOjN,IAAP,IAAemG,MAAMnG,IAArB,IAA6BiN,OAAOuS,OAAP,IAAkBrZ,MAAMqZ,OAA5D;;IAA4D,KAEzDhN,SAFyD;IAEzD,KACAE,SADA;MAKH,OAAOzF,UAAW9G,QAAQ,EAA1B;;IAA0B,KAEvBmM,QAFuB;MAG1B,IAAImN,UAAUC,UAAd;;IAAc,KAEXjN,QAFW;MAGd,IAAIgM,YAAYF,UAAUF,sBAA1B;MACAoB,YAAYA,UAAUE,UAAtB;;MAEA,IAAI1S,OAAOxC,IAAP,IAAetE,MAAMsE,IAArB,IAA6B,CAACgU,SAAlC,EAA6C;QAC3C,OAAO,KAAP;MAAO;;MAGT,IAAI7I,UAAUH,MAAMhK,GAAN,CAAUwB,MAAV,CAAd;;MACA,IAAI2I,OAAJ,EAAa;QACX,OAAOA,WAAWzP,KAAlB;MAAkB;;MAEpBoY,WAAWD,sBAAX;MAGA7I,MAAMpK,GAAN,CAAU4B,MAAV,EAAkB9G,KAAlB;MACA,IAAIjD,SAAS0c,YAAYH,QAAQxS,MAAR,CAAZ,EAA6BwS,QAAQtZ,KAAR,CAA7B,EAA6CoY,OAA7C,EAAsDpK,UAAtD,EAAkEqK,SAAlE,EAA6E/I,KAA7E,CAAb;MACAA,MAAM,QAAN,EAAgBxI,MAAhB;MACA,OAAO/J,MAAP;;IAAO,KAEJuC,SAFI;MAGP,IAAI8Z,aAAJ,EAAmB;QACjB,OAAOA,cAActa,IAAd,CAAmBgI,MAAnB,KAA8BsS,cAActa,IAAd,CAAmBkB,KAAnB,CAArC;MAA6D;;EA1DnE;;EA6DA,OAAO,KAAP;AACF;;ACrGA,mBAAmB5C,KAAnB,EAA0BxC,MAA1B,EAAkC;EAChC,IAAImD,QAAQ,EAAZ;EAAA,IACI4C,UAAS/F,OAAOG,MADpB;EAAA,IAEI2e,SAAStc,MAAMrC,MAFnB;;EAIA,OAAO,EAAEgD,KAAF,GAAU4C,OAAjB,EAAyB;IACvBvD,MAAMsc,SAAS3b,KAAf,IAAwBnD,OAAOmD,KAAP,CAAxB;EAA+B;;EAEjC,OAAOX,KAAP;AACF;;ACHA,wBAAwB0J,MAAxB,EAAgCgC,QAAhC,EAA0C6Q,WAA1C,EAAuD;EACrD,IAAI5c,SAAS+L,SAAShC,MAAT,CAAb;EACA,OAAOjG,UAAQiG,MAARjG,IAAkB9D,MAAlB8D,GAA2B+Y,UAAU7c,MAAV,EAAkB4c,YAAY7S,MAAZ,CAAlB,CAAlC;AACF;;ACRA,qBAAqB1J,KAArB,EAA4B4a,SAA5B,EAAuC;EACrC,IAAIja,QAAQ,EAAZ;EAAA,IACI4C,UAASvD,SAAS,IAAT,GAAgB,CAAhB,GAAoBA,MAAMrC,MADvC;EAAA,IAEI8e,WAAW,CAFf;EAAA,IAGI9c,SAAS,EAHb;;EAKA,OAAO,EAAEgB,KAAF,GAAU4C,OAAjB,EAAyB;IACvB,IAAIlH,QAAQ2D,MAAMW,KAAN,CAAZ;;IACA,IAAIia,UAAUve,KAAV,EAAiBsE,KAAjB,EAAwBX,KAAxB,CAAJ,EAAoC;MAClCL,OAAO8c,UAAP,IAAqBpgB,KAArB;IAAqB;;;EAGzB,OAAOsD,MAAP;AACF;;ACJA,qBAAqB;EACnB,OAAO,EAAP;AACF;;AChBA,IAAIuB,gBAAc3D,OAAO4D,SAAzB;AAGA,IAAI4M,uBAAuB7M,cAAY6M,oBAAvC;AAGA,IAAI2O,mBAAmBnf,OAAOof,qBAA9B;AASA,IAAIC,aAAa,CAACF,gBAAD,GAAoBG,SAApB,GAAgC,UAASnT,MAAT,EAAiB;EAChE,IAAIA,UAAU,IAAd,EAAoB;IAClB,OAAO,EAAP;;;EAEFA,SAASnM,OAAOmM,MAAP,CAAT;EACA,OAAOoT,YAAYJ,iBAAiBhT,MAAjB,CAAZ,EAAsC,UAASqT,MAAT,EAAiB;IAC5D,OAAOhP,qBAAqBrM,IAArB,CAA0BgI,MAA1B,EAAkCqT,MAAlC,CAAP;EACD,CAFM,CAAP;AAGF,CARA;AAUA,mBAAeH,UAAf;AC1BA,IAAII,aAAatP,QAAQnQ,OAAOiJ,IAAf,EAAqBjJ,MAArB,CAAjB;AAEA,mBAAeyf,UAAf;ACDA,IAAI9b,gBAAc3D,OAAO4D,SAAzB;AAGA,IAAIC,mBAAiBF,cAAYE,cAAjC;;AASA,kBAAkBsI,MAAlB,EAA0B;EACxB,IAAI,CAACmE,YAAYnE,MAAZ,CAAL,EAA0B;IACxB,OAAOsT,aAAWtT,MAAXsT,CAAP;EAAwB;;EAE1B,IAAIrd,SAAS,EAAb;;EACA,SAASwH,GAAT,IAAgB5J,OAAOmM,MAAP,CAAhB,EAAgC;IAC9B,IAAItI,iBAAeM,IAAfN,CAAoBsI,MAApBtI,EAA4B+F,GAA5B/F,KAAoC+F,OAAO,aAA/C,EAA8D;MAC5DxH,OAAOgI,IAAP,CAAYR,GAAZ;IAAe;;;EAGnB,OAAOxH,MAAP;AACF;;ACKA,cAAc+J,MAAd,EAAsB;EACpB,OAAO2E,YAAY3E,MAAZ,IAAsBkI,cAAclI,MAAd,CAAtB,GAA8CuT,SAASvT,MAAT,CAArD;AACF;;ACvBA,oBAAoBA,MAApB,EAA4B;EAC1B,OAAOwT,eAAexT,MAAf,EAAuBlD,IAAvB,EAA6BoW,YAA7B,CAAP;AACF;;ACVA,IAAI9B,yBAAuB,CAA3B;AAGA,IAAI5Z,gBAAc3D,OAAO4D,SAAzB;AAGA,IAAIC,mBAAiBF,cAAYE,cAAjC;;AAeA,sBAAsBsI,MAAtB,EAA8B9G,KAA9B,EAAqCoY,OAArC,EAA8CpK,UAA9C,EAA0DqK,SAA1D,EAAqE/I,KAArE,EAA4E;EAC1E,IAAIgJ,YAAYF,UAAUF,sBAA1B;EAAA,IACIqC,WAAWC,WAAW1T,MAAX,CADf;EAAA,IAEI2T,YAAYF,SAASxf,MAFzB;EAAA,IAGI2f,WAAWF,WAAWxa,KAAX,CAHf;EAAA,IAIIwY,YAAYkC,SAAS3f,MAJzB;;EAMA,IAAI0f,aAAajC,SAAb,IAA0B,CAACF,SAA/B,EAA0C;IACxC,OAAO,KAAP;EAAO;;EAET,IAAIva,QAAQ0c,SAAZ;;EACA,OAAO1c,OAAP,EAAgB;IACd,IAAIwG,MAAMgW,SAASxc,KAAT,CAAV;;IACA,IAAI,EAAEua,YAAY/T,OAAOvE,KAAnB,GAA2BxB,iBAAeM,IAAfN,CAAoBwB,KAApBxB,EAA2B+F,GAA3B/F,CAA7B,CAAJ,EAAmE;MACjE,OAAO,KAAP;IAAO;;;EAIX,IAAImc,aAAarL,MAAMhK,GAAN,CAAUwB,MAAV,CAAjB;EACA,IAAI4R,aAAapJ,MAAMhK,GAAN,CAAUtF,KAAV,CAAjB;;EACA,IAAI2a,cAAcjC,UAAlB,EAA8B;IAC5B,OAAOiC,cAAc3a,KAAd,IAAuB0Y,cAAc5R,MAA5C;EAA4C;;EAE9C,IAAI/J,SAAS,IAAb;EACAuS,MAAMpK,GAAN,CAAU4B,MAAV,EAAkB9G,KAAlB;EACAsP,MAAMpK,GAAN,CAAUlF,KAAV,EAAiB8G,MAAjB;EAEA,IAAI8T,WAAWtC,SAAf;;EACA,OAAO,EAAEva,KAAF,GAAU0c,SAAjB,EAA4B;IAC1BlW,MAAMgW,SAASxc,KAAT,CAAN;IACA,IAAIgQ,WAAWjH,OAAOvC,GAAP,CAAf;IAAA,IACIsU,WAAW7Y,MAAMuE,GAAN,CADf;;IAGA,IAAIyJ,UAAJ,EAAgB;MACd,IAAI8K,WAAWR,YACXtK,WAAW6K,QAAX,EAAqB9K,QAArB,EAA+BxJ,GAA/B,EAAoCvE,KAApC,EAA2C8G,MAA3C,EAAmDwI,KAAnD,CADW,GAEXtB,WAAWD,QAAX,EAAqB8K,QAArB,EAA+BtU,GAA/B,EAAoCuC,MAApC,EAA4C9G,KAA5C,EAAmDsP,KAAnD,CAFJ;IAE4D;;IAG9D,IAAI,EAAEwJ,aAAa,MAAb,GACG/K,aAAa8K,QAAb,IAAyBR,UAAUtK,QAAV,EAAoB8K,QAApB,EAA8BT,OAA9B,EAAuCpK,UAAvC,EAAmDsB,KAAnD,CAD5B,GAEEwJ,QAFJ,CAAJ,EAGO;MACL/b,SAAS,KAAT;MACA;IAAA;;IAEF6d,aAAaA,WAAWrW,OAAO,aAA/B;EAA+B;;EAEjC,IAAIxH,UAAU,CAAC6d,QAAf,EAAyB;IACvB,IAAIC,UAAU/T,OAAO+C,WAArB;IAAA,IACIiR,UAAU9a,MAAM6J,WADpB;;IAIA,IAAIgR,WAAWC,OAAX,IACC,iBAAiBhU,MAAjB,IAA2B,iBAAiB9G,KAD7C,IAEA,EAAE,OAAO6a,OAAP,IAAkB,UAAlB,IAAgCA,mBAAmBA,OAAnD,IACA,OAAOC,OAAP,IAAkB,UADlB,IACgCA,mBAAmBA,OADrD,CAFJ,EAGmE;MACjE/d,SAAS,KAAT;IAAS;;;EAGbuS,MAAM,QAAN,EAAgBxI,MAAhB;EACAwI,MAAM,QAAN,EAAgBtP,KAAhB;EACA,OAAOjD,MAAP;AACF;;ACnFA,IAAIge,WAAW7T,UAAUtJ,MAAV,EAAgB,UAAhB,CAAf;AAEA,iBAAemd,QAAf;ACFA,IAAIC,YAAU9T,UAAUtJ,MAAV,EAAgB,SAAhB,CAAd;AAEA,gBAAeod,SAAf;ACFA,IAAIC,QAAM/T,UAAUtJ,MAAV,EAAgB,KAAhB,CAAV;AAEA,YAAeqd,KAAf;ACFA,IAAIC,UAAUhU,UAAUtJ,MAAV,EAAgB,SAAhB,CAAd;AAEA,gBAAesd,OAAf;ACGA,IAAI/O,SAAS,cAAb;AAAA,IACIN,cAAY,iBADhB;AAAA,IAEIsP,aAAa,kBAFjB;AAAA,IAGI7O,SAAS,cAHb;AAAA,IAIIE,aAAa,kBAJjB;AAMA,IAAIE,cAAc,mBAAlB;AAGA,IAAI0O,qBAAqBvU,SAASkU,UAAT,CAAzB;AAAA,IACIM,gBAAgBxU,SAASI,KAAT,CADpB;AAAA,IAEIqU,oBAAoBzU,SAASmU,SAAT,CAFxB;AAAA,IAGIO,gBAAgB1U,SAASoU,KAAT,CAHpB;AAAA,IAIIO,oBAAoB3U,SAASqU,SAAT,CAJxB;AAaA,IAAIO,SAASjc,UAAb;;AAGA,IAAKub,cAAYU,OAAO,IAAIV,UAAJ,CAAa,IAAIW,WAAJ,CAAgB,CAAhB,CAAb,CAAP,KAA4ChP,WAAxDqO,IACA9T,SAAOwU,OAAO,IAAIxU,KAAJ,EAAP,KAAmBkF,MAD1B4O,IAEAC,aAAWS,OAAOT,UAAQW,OAARX,EAAP,KAA6BG,UAFxCJ,IAGAE,SAAOQ,OAAO,IAAIR,KAAJ,EAAP,KAAmB3O,MAH1ByO,IAIAG,aAAWO,OAAO,IAAIP,SAAJ,EAAP,KAAuB1O,UAJvC,EAIoD;EAClDiP,SAAS,UAAShiB,KAAT,EAAgB;IACvB,IAAIsD,SAASyC,WAAW/F,KAAX,CAAb;IAAA,IACIuR,OAAOjO,UAAU8O,WAAV,GAAsBpS,MAAMoQ,WAA5B,GAA0C,MADrD;IAAA,IAEI+R,aAAa5Q,OAAOnE,SAASmE,IAAT,CAAP,GAAwB,EAFzC;;IAIA,IAAI4Q,UAAJ,EAAgB;MACd,QAAQA,UAAR;QAAQ,KACDR,kBADC;UACmB,OAAO1O,WAAP;;QAAO,KAC3B2O,aAD2B;UACZ,OAAOlP,MAAP;;QAAO,KACtBmP,iBADsB;UACH,OAAOH,UAAP;;QAAO,KAC1BI,aAD0B;UACX,OAAOjP,MAAP;;QAAO,KACtBkP,iBADsB;UACH,OAAOhP,UAAP;MAL1B;IAKiC;;IAGnC,OAAOzP,MAAP;EAAO,CAdT;AAgBF;;AAEA,eAAe0e,MAAf;AC/CA,IAAIvD,uBAAuB,CAA3B;AAGA,IAAIhN,UAAU,oBAAd;AAAA,IACIa,WAAW,gBADf;AAAA,IAEIF,YAAY,iBAFhB;AAKA,IAAIvN,cAAc3D,OAAO4D,SAAzB;AAGA,IAAIC,iBAAiBF,YAAYE,cAAjC;;AAgBA,yBAAyBsI,MAAzB,EAAiC9G,KAAjC,EAAwCoY,OAAxC,EAAiDpK,UAAjD,EAA6DqK,SAA7D,EAAwE/I,KAAxE,EAA+E;EAC7E,IAAIuM,WAAWhb,UAAQiG,MAARjG,CAAf;EAAA,IACIib,WAAWjb,UAAQb,KAARa,CADf;EAAA,IAEIkb,SAASF,WAAW9P,QAAX,GAAsB0P,SAAO3U,MAAP2U,CAFnC;EAAA,IAGIO,SAASF,WAAW/P,QAAX,GAAsB0P,SAAOzb,KAAPyb,CAHnC;EAKAM,SAASA,UAAU7Q,OAAV,GAAoBW,SAApB,GAAgCkQ,MAAzC;EACAC,SAASA,UAAU9Q,OAAV,GAAoBW,SAApB,GAAgCmQ,MAAzC;EAEA,IAAIC,WAAWF,UAAUlQ,SAAzB;EAAA,IACIqQ,WAAWF,UAAUnQ,SADzB;EAAA,IAEIsQ,YAAYJ,UAAUC,MAF1B;;EAIA,IAAIG,aAAaxQ,WAAS7E,MAAT6E,CAAjB,EAAmC;IACjC,IAAI,CAACA,WAAS3L,KAAT2L,CAAL,EAAsB;MACpB,OAAO,KAAP;IAAO;;IAETkQ,WAAW,IAAX;IACAI,WAAW,KAAX;EAAW;;EAEb,IAAIE,aAAa,CAACF,QAAlB,EAA4B;IAC1B3M,UAAUA,QAAQ,IAAIjH,KAAJ,EAAlB;IACA,OAAQwT,YAAYjO,eAAa9G,MAAb8G,CAAZ,GACJ6L,YAAY3S,MAAZ,EAAoB9G,KAApB,EAA2BoY,OAA3B,EAAoCpK,UAApC,EAAgDqK,SAAhD,EAA2D/I,KAA3D,CADI,GAEJ8M,WAAWtV,MAAX,EAAmB9G,KAAnB,EAA0B+b,MAA1B,EAAkC3D,OAAlC,EAA2CpK,UAA3C,EAAuDqK,SAAvD,EAAkE/I,KAAlE,CAFJ;EAE2E;;EAE7E,IAAI,EAAE8I,UAAUF,oBAAZ,CAAJ,EAAuC;IACrC,IAAImE,eAAeJ,YAAYzd,eAAeM,IAAf,CAAoBgI,MAApB,EAA4B,aAA5B,CAA/B;IAAA,IACIwV,eAAeJ,YAAY1d,eAAeM,IAAf,CAAoBkB,KAApB,EAA2B,aAA3B,CAD/B;;IAGA,IAAIqc,gBAAgBC,YAApB,EAAkC;MAChC,IAAIC,eAAeF,eAAevV,OAAOrN,KAAP,EAAf,GAAgCqN,MAAnD;MAAA,IACI0V,eAAeF,eAAetc,MAAMvG,KAAN,EAAf,GAA+BuG,KADlD;MAGAsP,UAAUA,QAAQ,IAAIjH,KAAJ,EAAlB;MACA,OAAOgQ,UAAUkE,YAAV,EAAwBC,YAAxB,EAAsCpE,OAAtC,EAA+CpK,UAA/C,EAA2DsB,KAA3D,CAAP;IAAuE;;;EAG3E,IAAI,CAAC6M,SAAL,EAAgB;IACd,OAAO,KAAP;EAAO;;EAET7M,UAAUA,QAAQ,IAAIjH,KAAJ,EAAlB;EACA,OAAOoU,aAAa3V,MAAb,EAAqB9G,KAArB,EAA4BoY,OAA5B,EAAqCpK,UAArC,EAAiDqK,SAAjD,EAA4D/I,KAA5D,CAAP;AACF;;AC/DA,qBAAqB7V,KAArB,EAA4BuG,KAA5B,EAAmCoY,OAAnC,EAA4CpK,UAA5C,EAAwDsB,KAAxD,EAA+D;EAC7D,IAAI7V,UAAUuG,KAAd,EAAqB;IACnB,OAAO,IAAP;EAAO;;EAET,IAAIvG,SAAS,IAAT,IAAiBuG,SAAS,IAA1B,IAAmC,CAACT,aAAa9F,KAAb,CAAD,IAAwB,CAAC8F,aAAaS,KAAb,CAAhE,EAAsF;IACpF,OAAOvG,UAAUA,KAAV,IAAmBuG,UAAUA,KAApC;EAAoC;;EAEtC,OAAO0c,gBAAgBjjB,KAAhB,EAAuBuG,KAAvB,EAA8BoY,OAA9B,EAAuCpK,UAAvC,EAAmD2O,WAAnD,EAAgErN,KAAhE,CAAP;AACF;;ACKA,iBAAiB7V,KAAjB,EAAwBuG,KAAxB,EAA+B;EAC7B,OAAO2c,YAAYljB,KAAZ,EAAmBuG,KAAnB,CAAP;AACF;;mBC1BgD4c,KAAqB;SAC5DjiB,OAAOM,OAAP,CAAe2hB,GAAf;AACT;;0BAEgEniB,QAAWoiB,MAAS;QAC5EC,QAAO,IAAI7B,GAAJ,CAAiBtgB,OAAOiJ,IAAP,CAAYnJ,MAAZ,CAAjB;YACHoiB,MAAM1D,QAAQ,CAAC,CAAC5U,GAAD,EAAM9K,KAAN,CAAD,KAAkB;QACpC,CAACsjB,QAAQtiB,OAAO8J,GAAP,CAAR,EAAqB9K,KAArB,GAA6B;aACzB8K,OAAO9K;IAAA;;UAEXujB,OAAOzY;EACb;QACI4U,QAAQhe,KAAK,OAAOV,OAAOU,CAAP;AAC3B;;6BCIEgH,OACA2U,OACAtb,SAC2B;QAErByhB,QAAQC,SAA0B;IACtCC,kBAAkB,EADoB;IAEtCC,YAAY,EAF0B;IAGtCC,iBAAiB;EAHqB,CAA1B;cAMF,MAAM;UACV;MAAEF,gBAAF;MAAoBC;IAApB,IAAmCE,+BACvC9hB,OADuC,EAEvC2G,MAAM1I,KAFiC,EAGvCqd,MAAMrd,KAHiC;qBAKxBwjB,MAAME,kBAAkBA;qBACxBF,MAAMG,YAAYA;EACpC;cAGW,MAAM;UACVC,kBAAwC;;eACnC,CAAC9a,EAAD,EAAK;MAAEuU,aAAF;MAASyG;IAAT,CAAL,KAA+B5iB,OAAOM,OAAP,CAAegiB,MAAMG,UAArB,GAAkC;UACtEnH,YAAY;;UACZsH,cAAc,GAAG;oBACP;MAAA,WACH/hB,QAAQia,IAAR,CAAaQ,SAAb,YAAkCvb,QAD/B,EACyC;cAC/C4C,IAAI9B,QAAQia,IAAR,CAAaQ,SAAb,CAAuBuH,MAAvB,EAA8BhiB,OAA9B;;YACN8B,MAAM,MAAM;sBACFmgB,sBAAsBtb,MAAM1I,KAA5B,EAAmC+jB,MAAnC,EAA0ChiB,OAA1C,EAAmD+hB,UAAnD;QAA6D,OACpE;sBACOjgB;QAAA;OANF,UAQH9B,QAAQia,IAAR,CAAaQ,WAAW;oBACrBwH,sBAAsBtb,MAAM1I,KAA5B,EAAmC+jB,MAAnC,EAA0ChiB,OAA1C,EAAmD+hB,UAAnD;MAA6D,OACpE;oBACO;MAAA;;YAERH,WAAW7a,IAAI0T,YAAYA;;UAC7BA,WAAW;eACNrS,KAAK4Z,QAAOrE,QAAQuE,OAAOL,gBAAgBK,GAAhB,IAAsB;MAAK;;;qBAGhDT,MAAMI,iBAAiBA;EACzC;SAEMJ;AACT;;sCAaEtG,GACAgH,cACArT,QACA7P,QACAkB,OACA0a,WACc;MACV,CAACM,GAAG;WACC;MAAEiH,IAAI;QAAEnhB,GAAG,CAAL;QAAQG,GAAG;MAAX,CAAN;MAAsBihB,IAAI;QAAEphB,GAAG,CAAL;QAAQG,GAAG;MAAX;IAA1B;;;MAEL+gB,cAAc;WAETG,2BAA2BnH,EAAElB,IAA7B,EAAmCnL,MAAnC,EAA2C7P,MAA3C,EAAmDkB,KAAnD,EAA0D,CAA1D,EAA6D,CAA7D,EAAgE0a,SAAhE;EAAyE,OAC3E;WACEyH,2BACLnH,EAAElB,IADG,EAELnL,MAFK,EAGL7P,MAHK,EAILkB,KAJK,EAKLgb,EAAE4G,UALG,EAML5G,EAAEoH,YANG,EAOL1H,SAPK;EAQP;AAEJ;;AAMA,wCAAwC7a,OAAxC,EAA0D2G,KAA1D,EAAwE2U,KAAxE,EAAsF;QAC9EqG,mBAAoD;QACpDC,aAAwC;QAGxCliB,MAA6B;;aACxB,CAACqH,EAAD,EAAKkT,IAAL,KAAc9a,OAAOM,OAAP,CAAe6b,KAAf,GAAuB;QAC1C,OAAOxM,MAAP,IAAiBnI,KAAjB,IAA0BsT,KAAKhb,MAAL,IAAe0H,KAAzC,GAAiD;;;;UAI/CoC,MAAM,CAACkR,KAAKnL,MAAN,EAAcmL,KAAKhb,MAAnB,EAA2BujB,IAA3B,GAAkC7gB,IAAlC,CAAuC,KAAvC;UACNvC,SAASM,IAAIqJ,GAAJ,KAAY;WACpBhC,MAAMkT;QACTlR,OAAO3J;EAAA;;QAOPqjB,UACJziB,QAAQia,IAAR,CAAaK,GAAb,YAA4Bpb,QAA5B,GACIc,QAAQia,IAAR,CAAaK,GADjB,GAEI,CAACoI,EAAD,EAAYC,EAAZ,KAA4B3iB,QAAQia,IAAR,CAAaK;;aACpC,CAACvR,GAAD,EAAMiZ,MAAN,KAAgB7iB,OAAOM,OAAP,CAAeC,GAAf,GAAqB;UACxCkjB,UAAUzjB,OAAOiJ,IAAP,CAAY4Z,MAAZ,EAAmBziB;QAC/BqjB,WAAW;UAETtI,MAAMmI,QAAQT,MAAR,EAAehiB,OAAf;UACN,CAAC6iB,MAAD,EAAS5I,IAAT,IAAiB9a,OAAOM,OAAP,CAAeuiB,MAAf,EAAsB,CAAtB;;QACnBY,YAAY,GAAG;uBACAC,UAAU;QAAE5I,IAAF;QAAQsI,cAAc,CAAtB;QAAyBR,YAAY;MAArC;iBAChBhZ,OAAO;QAAEuS,aAAF;QAASyG,YAAY,CAArB;QAAwBtH,WAAW;MAAnC;WACb;UACD8H,eAAe;YACbO,iBAAiB3jB,OAAOM,OAAP,CAAeuiB,MAAf,EAAsBtiB,GAAtB,CAA0B,CAAC,CAACqH,EAAD,EAAKgc,KAAL,CAAD,KAAgB;YAC3DxiB,QAAQvB,OAAOf,KAAP,CAAa+B,QAAQia,IAAR,CAAa5Z,MAAb,CAAoBE,KAAjC,EAAwCwiB,KAAxC;;YACRrhB,MAAM,CAACnB,KAAP,GAAe;kBACTyiB,KACN,qEACAjc,IACAxG;kBAEM;QAAA;;eAEHA,QAAQ;MAChB,CAXsB;YAYjB0iB,SAAS9jB,OAAOM,OAAP,CAAeuiB,MAAf,EAAsBtiB,GAAtB,CAA0B,CAAC,CAACwjB,OAAD,EAASH,KAAT,CAAD,EAAiBI,CAAjB,KAAuB;YAC1DA,IAAI,GAAG;0BACOL,eAAeK,IAAI,CAAnB,IAAwB7I,GAAxB,GAA8BwI,eAAeK,CAAf;QAAe;;eAExD,CAACD,OAAD,EAASH,KAAT,EAAeR,YAAf;MACR,CALc;YAMTR,aAAaQ;aACZ5E,QAAQ,CAAC,CAACuF,OAAD,EAASH,KAAT,EAAeK,aAAf,CAAD,KAAkC;yBAC9BF,WAAU;UAAEjJ,WAAF;UAAQsI,2BAAR;UAAsBR;QAAtB;MAC5B;iBACUhZ,OAAO;QAAEuS,aAAF;QAASyG,UAAT;QAAqBtH,WAAW;MAAhC;;;;SAIf;IAAEkH,gBAAF;IAAoBC;EAApB;AACT;;AAEA,+BAA+Bjb,KAA/B,EAA6C2U,KAA7C,EAA2Dtb,OAA3D,EAA6EO,KAA7E,EAA4F;QAEpF8iB,YAAYlkB,OAAOM,OAAP,CAAe6b,KAAf,EAAsB/b;MACpC8jB,cAAc,UAAU;QAQtBC,WAAWviB,KAAK8E,GAAL,CACf,GAAG1G,OAAOC,MAAP,CAAckc,KAAd,EACAiI,OADA,CACQ9f,KAAK,CAACkD,MAAMlD,EAAEqL,MAAR,CAAD,EAAkBnI,MAAMlD,EAAExE,MAAR,CAAlB,CADb,EAEAI,MAFA,CAEOC,KAAKA,CAFZ,EAGAI,GAHA,CAGIO,QAAQ;UACLG,QAAQpB,OAAOI,MAAP,CAAcY,QAAQC,IAAR,CAAaI,MAA3B,EAAmCJ,IAAnC;;QACVG,MAAME,IAAN,KAAe,UAAU;aACpBF,MAAMI,MAAN,GAAe;IAAA,OACjB;aACEO,KAAK8E,GAAL,CAASzF,MAAMG,KAAf,EAAsBH,MAAMK,MAA5B;IAAkC;EAE5C,CAVA,CADY;SAaVF,QAAQ+iB;AACjB;;AAEA,oCACErJ,IADF,EAEEnL,MAFF,EAGE7P,MAHF,EAIEkB,KAJF,EAKE4hB,UALF,EAMEQ,YANF,EAOE1H,SAPF,EAQgB;;;MACV2I,IAAIC,IAAIC,IAAIC;;MACZ1J,KAAKnL,MAAL,GAAcmL,KAAKhb,QAAQ;KAC3BukB,IAAIC,IAAIC,IAAIC,MAAMC,sBAClB,uCAAQ3iB,CAAR,iBAAa,CADK,EAElB,uCAAQG,CAAR,iBAAa,CAFK,EAGlB,uCAAQH,CAAR,iBAAa,CAHK,EAIlB,uCAAQG,CAAR,iBAAa,CAJK,EAKlBjB,KALkB,EAMlB4hB,UANkB,EAOlBQ,YAPkB,EAQlB1H,SARkB;EASpB,OACK;KACH6I,IAAIC,IAAIH,IAAIC,MAAMG,sBAClB,uCAAQ3iB,CAAR,iBAAa,CADK,EAElB,uCAAQG,CAAR,iBAAa,CAFK,EAGlB,uCAAQH,CAAR,iBAAa,CAHK,EAIlB,uCAAQG,CAAR,iBAAa,CAJK,EAKlBjB,KALkB,EAMlB4hB,UANkB,EAOlBQ,YAPkB,EAQlB1H,SARkB;EASpB;;SAEK;IAAEuH,IAAI;MAAEnhB,GAAGuiB,EAAL;MAASpiB,GAAGqiB;IAAZ,CAAN;IAAwBpB,IAAI;MAAEphB,GAAGyiB,EAAL;MAAStiB,GAAGuiB;IAAZ;EAA5B;AACT;;AAEA,+BACEH,EADF,EAEEC,EAFF,EAGEC,EAHF,EAIEC,EAJF,EAKExjB,KALF,EAME4hB,UANF,EAOEQ,YAPF,EAQE1H,SARF,EASoC;QAC5BgJ,KAAKH,KAAKF;QACVM,KAAKH,KAAKF;MAGZM,qBAAqB,CAArB,GAAyBxB,YAAzB,IAAyCpiB;;MAGzC4jB,SAAS,CAAT,IAAclJ,cAAc,SAAS;UACjCmJ,SAASjjB,KAAKkjB,KAAL,CAAWN,KAAKF,EAAhB,EAAoBC,KAAKF,EAAzB;;QACX3I,cAAc,YAAY;YAEtBqJ,gBAAgBnjB,KAAKojB,EAAL,GAAU;;UAC5BH,SAAS,CAACE,aAAV,IAA2BF,UAAUE,eAAe;gBAC9C;MAAA;eAEDrJ,cAAc,cAAc;UAEjCmJ,SAAS,GAAG;gBACN;MAAA;;;;MAKVH,OAAO,GAAG;UACN9e,OAAO+e,KAAK,CAAL,GAAS,EAAT,GAAc;WACpB,CAACN,KAAKO,OAAOhf,IAAb,EAAmB0e,EAAnB,EAAuBC,KAAKK,OAAOhf,IAAnC,EAAyC4e,EAAzC;EAA2C,WACzCG,OAAO,CADkC,EAC/B;UACb/e,OAAO8e,KAAK,CAAL,GAAS,CAAT,GAAa;WACnB,CAACL,EAAD,EAAKC,KAAKM,OAAOhf,IAAjB,EAAuB2e,EAAvB,EAA2BC,KAAKI,OAAOhf,IAAvC;EAA2C,CAHA,MAI7C;UACCqf,QAAQN,KAAKD;UACbQ,YAAY,KAAKD;;QACnBN,KAAK,GAAG;aACH,CAACC;IAAA;;UAEJO,QAAQP,OAAOhjB,KAAKwjB,IAAL,CAAU,IAAIxjB,KAAKyjB,GAAL,CAASH,SAAT,EAAoB,CAApB,CAAd;WACd,CAACb,KAAKc,KAAN,EAAab,KAAKa,QAAQD,SAA1B,EAAqCX,KAAKY,KAA1C,EAAiDX,KAAKW,QAAQD,SAA9D;EAAuE;AAElF;;aC/RoBI,IAAaC,IAAazlB,QAA2B;MACnE,CAACA,QAAQ;aACF;MAAEgC,GAAG,CAAL;MAAQG,GAAG;IAAX;;;SAEJH,IAAIwjB,GAAGxjB,CAAH,GAAOyjB,GAAGzjB;SACdG,IAAIqjB,GAAGrjB,CAAH,GAAOsjB,GAAGtjB;SACdnC;AACT;;kBAIyBwlB,IAAaC,IAAazlB,QAA2B;MACxE,CAACA,QAAQ;aACF;MAAEgC,GAAG,CAAL;MAAQG,GAAG;IAAX;;;SAEJH,IAAIwjB,GAAGxjB,CAAH,GAAOyjB,GAAGzjB;SACdG,IAAIqjB,GAAGrjB,CAAH,GAAOsjB,GAAGtjB;SACdnC;AACT;;kBAIyBwlB,IAAaC,IAAazlB,QAA2B;MACxE,CAACA,QAAQ;aACF;MAAEgC,GAAG,CAAL;MAAQG,GAAG;IAAX;;;SAEJH,IAAIwjB,GAAGxjB,CAAH,GAAOyjB,GAAGzjB;SACdG,IAAIqjB,GAAGrjB,CAAH,GAAOsjB,GAAGtjB;SACdnC;AACT;;wBAI+BK,GAAYqlB,QAAgB1lB,QAA2B;MAChF,CAACA,QAAQ;aACF;MAAEgC,GAAG,CAAL;MAAQG,GAAG;IAAX;;;SAEJH,IAAI3B,EAAE2B,CAAF,GAAM0jB;SACVvjB,IAAI9B,EAAE8B,CAAF,GAAMujB;SACV1lB;AACT;;gBAIuBwlB,IAAaC,IAAazlB,QAA2B;MACtE,CAACA,QAAQ;aACF;MAAEgC,GAAG,CAAL;MAAQG,GAAG;IAAX;;;SAEJH,IAAIwjB,GAAGxjB,CAAH,GAAOyjB,GAAGzjB;SACdG,IAAIqjB,GAAGrjB,CAAH,GAAOsjB,GAAGtjB;SACdnC;AACT;;aAEoBwlB,IAAaC,IAAqB;SAC7CD,GAAGxjB,CAAH,GAAOyjB,GAAGzjB,CAAV,GAAcwjB,GAAGrjB,CAAH,GAAOsjB,GAAGtjB;AACjC;;eAEsBqjB,IAAaC,IAAqB;SAC/CD,GAAGxjB,CAAH,GAAOyjB,GAAGtjB,CAAV,GAAcqjB,GAAGrjB,CAAH,GAAOsjB,GAAGzjB;AACjC;;uBAE8B3B,GAAoB;SACzCA,EAAE2B,CAAF,GAAM3B,EAAE2B,CAAR,GAAY3B,EAAE8B,CAAF,GAAM9B,EAAE8B;AAC7B;;gBAEuB9B,GAAoB;SAClCyB,KAAKwjB,IAAL,CAAUK,cAActlB,CAAd,CAAV;AACT;;yBAEgCmlB,IAAaC,IAAqB;QAC1Db,KAAKY,GAAGxjB,CAAH,GAAOyjB,GAAGzjB;QACf6iB,KAAKW,GAAGrjB,CAAH,GAAOsjB,GAAGtjB;SACdyiB,KAAKA,EAAL,GAAUC,KAAKA;AACxB;;kBAEyBW,IAAaC,IAAqB;SAClD3jB,KAAKwjB,IAAL,CAAUM,gBAAgBJ,EAAhB,EAAoBC,EAApB,CAAV;AACT;;mBAI0BplB,GAAYL,QAA2B;MAC3D,CAACA,QAAQ;aACF;MAAEgC,GAAG,CAAL;MAAQG,GAAG;IAAX;;;QAEL0jB,MAAMvlB,OAAOD,CAAP;;MACRwlB,QAAQ,GAAG;WACN7jB,IAAI;WACJG,IAAI;EAAA,OACN;WACE9B,GAAG;MAAE2B,GAAG6jB,GAAL;MAAU1jB,GAAG0jB;IAAb,GAAoB7lB;EAAM;;SAE/BA;AACT;;gBAIuBK,GAAYylB,QAAe9lB,QAA2B;MACvE,CAACA,QAAQ;aACF;MAAEgC,GAAG,CAAL;MAAQG,GAAG;IAAX;;;QAGL4jB,OAAO1lB,EAAE2B,CAAF,GAAMF,KAAKkkB,GAAL,CAASF,MAAT,CAAN,GAAwBzlB,EAAE8B,CAAF,GAAML,KAAKmkB,GAAL,CAASH,MAAT;QACrCI,OAAO7lB,EAAE2B,CAAF,GAAMF,KAAKmkB,GAAL,CAASH,MAAT,CAAN,GAAwBzlB,EAAE8B,CAAF,GAAML,KAAKkkB,GAAL,CAASF,MAAT;SACpC9jB,IAAI+jB;SACJ5jB,IAAI+jB;SACJlmB;AACT;;AAEA,MAAMmmB,UAAU,MAAMrkB,KAAKojB,EAA3B;;AAEA,iBAAiBkB,GAAjB,EAA8B;SACrBA,MAAMD;AACf;;eAEsB9lB,GAAY;SACzByB,KAAKkjB,KAAL,CAAW3kB,EAAE8B,CAAb,EAAgB9B,EAAE2B,CAAlB;AACT;;qBAE4B3B,GAAY;SAC/BgmB,QAAQC,MAAMjmB,CAAN,CAAR;AACT;;;;;;;;;;;;;;;;;;;;;;MCxHakmB,SAA4B;EAIhC,iBAAU5jB,KAAV,EAA2B;WACzB,IAAI4jB,QAAJ,CAAa5jB,MAAM,CAAN,KAAY,CAAzB,EAA4BA,MAAM,CAAN,KAAY,CAAxC;EAAyC;;EAG3C,kBAAWwf,GAAX,EAAyB;WACvB,IAAIoE,QAAJ,CAAapE,IAAIngB,CAAjB,EAAoBmgB,IAAIhgB,CAAxB;EAAyB;;EAGlCiN,YAAYpN,CAAZ,EAAuBG,CAAvB,EAAkC;SAC3BH,IAAIA;SACJG,IAAIA;EAAA;;EAIXgb,IAAI9c,CAAJ,EAA0B;WACjB8c,IAAI,IAAJ,EAAU9c,CAAV,EAAa,IAAb;EAAiB;;EAG1BmmB,SAASnmB,CAAT,EAA+B;WACtBmmB,SAAS,IAAT,EAAenmB,CAAf,EAAkB,IAAlB;EAAsB;;EAG/BomB,SAASpmB,CAAT,EAA+B;WACtBomB,SAAS,IAAT,EAAepmB,CAAf,EAAkB,IAAlB;EAAsB;;EAG/BqmB,eAAehB,MAAf,EAAyC;WAChCgB,eAAe,IAAf,EAAqBhB,MAArB,EAA6B,IAA7B;EAAiC;;EAG1CiB,OAAOtmB,CAAP,EAA6B;WACpBsmB,OAAO,IAAP,EAAatmB,CAAb,EAAgB,IAAhB;EAAoB;;EAG7BumB,IAAIvmB,CAAJ,EAAwB;WACfumB,IAAI,IAAJ,EAAUvmB,CAAV;EAAW;;EAGpBwmB,MAAMxmB,CAAN,EAA0B;WACjBwmB,MAAM,IAAN,EAAYxmB,CAAZ;EAAa;;EAGtBslB,gBAAwB;WACfA,cAAc,IAAd;EAAkB;;EAG3BrlB,SAAiB;WACRA,OAAO,IAAP;EAAW;;EAGpBslB,gBAAgBvlB,CAAhB,EAAoC;WAC3BulB,gBAAgB,IAAhB,EAAsBvlB,CAAtB;EAAuB;;EAGhCymB,SAASzmB,CAAT,EAA6B;WACpBymB,SAAS,IAAT,EAAezmB,CAAf;EAAgB;;EAGzB0mB,YAAsB;WACbA,UAAU,IAAV,EAAgB,IAAhB;EAAoB;;EAG7BT,QAAgB;WACPA,MAAM,IAAN;EAAU;;EAGnBU,cAAsB;WACbA,YAAY,IAAZ;EAAgB;;EAGzBC,OAAOnB,MAAP,EAAgC;WACvBmB,OAAO,IAAP,EAAanB,MAAb,EAAoB,IAApB;EAAwB;;EAGjCoB,UAAU7mB,CAAV,EAA+B;WACtB,KAAK2B,CAAL,KAAW3B,EAAE2B,CAAb,IAAkB,KAAKG,CAAL,KAAW9B,EAAE8B;EAAA;;EAGxCglB,QAAkB;WACT,IAAIZ,QAAJ,CAAa,KAAKvkB,CAAlB,EAAqB,KAAKG,CAA1B;EAA2B;;EAGpCilB,WAAoB;WACX;MAAEplB,GAAG,KAAKA,CAAV;MAAaG,GAAG,KAAKA;IAArB;;;EAGTklB,UAA4B;WACnB,CAAC,KAAKrlB,CAAN,EAAS,KAAKG,CAAd;EAAe;;AA3Fe;;ACCzC,QAAeyG;EACb2d;AADa,GAEVe,GAFU,CAAf;;MCCaC,WAAW;EAKtBnY,YAAYS,MAAZ,EAA8B7P,MAA9B,EAAgDK,CAAhD,EAA6D;SACtDwP,SAASA;SACT7P,SAASA;SACTK,IAAIA;EAAA;;EAGJ,wBAAiBsY,IAAjB,EAAiD;UAChD9I,SAAS0W,SAASiB,UAAT,CAAoB7O,KAAKwK,EAAzB;UACTnjB,SAASumB,SAASiB,UAAT,CAAoB7O,KAAKyK,EAAzB;WACR,IAAImE,UAAJ,CAAe1X,MAAf,EAAuB7P,MAAvB,EAA+BynB,aAAa5X,MAAb,EAAqB7P,MAArB,CAA/B;EAA2D;;EAG7D,qBAAc0nB,SAAd,EAAmCC,SAAnC,EAAoE;UACnE9X,SAAS0W,SAASiB,UAAT,CAAoBE,SAApB;UACT1nB,SAASumB,SAASiB,UAAT,CAAoBG,SAApB;WACR,IAAIJ,UAAJ,CAAe1X,MAAf,EAAuB7P,MAAvB,EAA+BynB,aAAa5X,MAAb,EAAqB7P,MAArB,CAA/B;EAA2D;;EAG7D,mBAAY6P,MAAZ,EAA8B7P,MAA9B,EAA4D;WAC1D,IAAIunB,UAAJ,CAAe1X,MAAf,EAAuB7P,MAAvB,EAA+BynB,aAAa5X,MAAb,EAAqB7P,MAArB,CAA/B;EAA2D;;AAxB9C;;sBA4BK6P,QAAkB7P,QAA4B;SAClEA,OAAOmnB,KAAP,GAAeX,QAAf,CAAwB3W,MAAxB;AACT;;mCAE0C8I,MAA0C;SAC3E,CAAC4N,SAASiB,UAAT,CAAoB7O,KAAKwK,EAAzB,CAAD,EAA+BoD,SAASiB,UAAT,CAAoB7O,KAAKyK,EAAzB,CAA/B;AACT;;iCAEwCzK,MAA8B;SAC7D,IAAI4N,QAAJ,CAAI,MAAepD,EAAf,CAAkBnhB,CAAlB,GAAsB2W,KAAKyK,EAAL,CAAQphB,CAA9B,IAAmC,CAAvC,EAAuC,MAASmhB,EAAT,CAAYhhB,CAAZ,GAAgBwW,KAAKyK,EAAL,CAAQjhB,CAAxB,IAA6B,CAApE;AACT;;wBAYgCghB,IAAcC,IAA4B;SACjE;IAAED,EAAF;IAAMC;EAAN;AACT;;qBAUEwE,SACAC,cACAC,cACc;QACRnP,OAAO4O,WAAWQ,gBAAX,CAA4BH,OAA5B;SACNI,iBAAiBrP,IAAjB,EAAuBkP,YAAvB,EAAqCC,YAArC;AACT;;AAEA,0BACEnP,IADF,EAEEkP,YAFF,EAGEC,YAHF,EAIgB;QACRG,aAAatP,KAAKtY,CAAL,CAAO8mB,KAAP,GAAeJ,SAAf;QAEbmB,KAAKvP,KAAK9I,MAAL,CAAYsX,KAAZ,GAAoBhK,GAApB,CAAwB8K,WAAWd,KAAX,GAAmBT,cAAnB,CAAkCmB,YAAlC,CAAxB;QAELM,KAAKxP,KAAK3Y,MAAL,CAAYmnB,KAAZ,GAAoBX,QAApB,CAA6ByB,WAAWd,KAAX,GAAmBT,cAAnB,CAAkCoB,YAAlC,CAA7B;MAEP3E,KAAK+E,GAAGd,QAAH;MACLhE,KAAK+E,GAAGf,QAAH;QAEHgB,QAAQX,aAAaS,EAAb,EAAiBC,EAAjB;;MACVxP,KAAKtY,CAAL,CAAOimB,KAAP,KAAiB8B,MAAM9B,KAAN,EAAjB,GAAiC,GAAG;UAEhC+B,KAAK,IAAI9B,QAAJ,CAAI,IAAavkB,CAAb,GAAiBohB,GAAGphB,CAApB,IAAyB,CAA7B,EAA6B,IAAOG,CAAP,GAAWihB,GAAGjhB,CAAd,IAAmB,CAAhD;UACLmmB,KAAKD,GAAGlB,KAAH,GAAWhK,GAAX,CAAe8K,WAAWvB,cAAX,CAA0B,GAA1B,CAAf;SACN2B,GAAGjB,QAAH;SACAkB,GAAGlB,QAAH;;;SAGA;IAAEjE,EAAF;IAAMC;EAAN;AACT;;qBAE4BzK,MAAkC;SACrD;IAAEwK,IAAIxK,KAAKyK,EAAX;IAAeA,IAAIzK,KAAKwK;EAAxB;AACT;;oCAE2CxK,MAAkB;QACrD4P,KAAK5P,KAAKtY,CAAL,CACR8mB,KADQ,GAERJ,SAFQ,GAGRE,MAHQ,CAGDnlB,KAAKojB,EAAL,GAAU,CAHT;SAIJqC,WAAWiB,WAAX,CAAuB7P,KAAK3Y,MAA5B,EAAoC2Y,KAAK3Y,MAAL,CAAYmnB,KAAZ,GAAoBhK,GAApB,CAAwBoL,EAAxB,CAApC;AACT;;yBCxGgCrM,GAAavD,MAA4B;QACjE7V,IAAI6V,KAAKtY,CAAL,CAAO8mB,KAAP,GAAeJ,SAAf;QAGJ0B,KAAK9P,KAAK9I;QACVyM,IAAIgL,EAAEd,QAAF,CAAWtK,CAAX,EAAcuM,EAAd;QAGJC,OAAM5lB,EAAE8jB,GAAF,CAAMtK,CAAN;QAINqM,OAAOF,GAAGtB,KAAH,GAAWhK,GAAX,CAAera,EAAE4jB,cAAF,CAAiBgC,IAAjB,CAAf;SAENC;AACT;;8CAuBE9Y,QACA7P,QACA6I,QACAtH,QACiB;QAEX2E,UAASohB,EAAE3B,aAAF,CAAgB2B,EAAEd,QAAF,CAAWxmB,MAAX,EAAmB6I,MAAnB,CAAhB;QACT+f,WAAW1iB,UAAS3E,SAASA,MAAlB,IAA4BO,KAAKyjB,GAAL,CAAS,CAAT,EAAY,GAAZ;MAEzC,CAACqD,iBAAiB;QAKhBjQ,OAAO4O,WAAWiB,WAAX,CAAuB3Y,MAAvB,EAA+B7P,MAA/B;QACP6oB,IAAIC,gBAAgBjgB,MAAhB,EAAwB8P,IAAxB;QAGJoQ,QAAQzB,EAAEhnB,MAAF,CAASgnB,EAAEd,QAAF,CAAWqC,CAAX,EAAchgB,MAAd,CAAT;MAIVtH,SAASwnB,cAAc;MAKvBxnB,WAAWwnB,cAAcF;QAIvBG,IAAIlnB,KAAKwjB,IAAL,CAAU2D,cAAU,CAAV,IAAcA,aAAS,CAAT,CAAxB;QAMJd,KAAKxP,KAAKtY,CAAL,CAAO0mB,SAAP,GAAmBL,cAAnB,CAAkCsC,CAAlC;SAIJH,EAAErC,QAAF,CAAW2B,EAAX;AACT;;+CAGEtY,QACA7P,QACA6I,QACAtH,QACA2nB,QACiB;QAEXhjB,UAASohB,EAAE3B,aAAF,CAAgB2B,EAAEd,QAAF,CAAWxmB,MAAX,EAAmB6I,MAAnB,CAAhB;QACT+f,WAAW1iB,UAAS3E,SAASA,MAAlB,IAA4BO,KAAKyjB,GAAL,CAAS,CAAT,EAAY,GAAZ;MAEzC,CAACqD,iBAAiB;QAKhBjQ,OAAO4O,WAAWiB,WAAX,CAAuB3Y,MAAvB,EAA+B7P,MAA/B;QACP6oB,IAAIC,gBAAgBjgB,MAAhB,EAAwB8P,IAAxB;QAGJoQ,QAAQzB,EAAEhnB,MAAF,CAASgnB,EAAEd,QAAF,CAAWqC,CAAX,EAAchgB,MAAd,CAAT;MAIVtH,SAASwnB,cAAc;MAKvBxnB,WAAWwnB,cAAcF;QAIvBG,IAAIlnB,KAAKwjB,IAAL,CAAU2D,cAAU,CAAV,IAAcA,aAAS,CAAT,CAAxB;QAMJd,KAAKxP,KAAKtY,CAAL,CAAO0mB,SAAP,GAAmBL,cAAnB,CAAkCsC,CAAlC;QACLG,MAAMN,EAAE1B,KAAF,GAAUhK,GAAV,CAAcgL,EAAd;QACNiB,MAAMP,EAAE1B,KAAF,GAAUX,QAAV,CAAmB2B,EAAnB;QAENkB,KAAKH,OAAOpC,QAAP,CAAgBqC,GAAhB;QACLG,KAAKJ,OAAOpC,QAAP,CAAgBsC,GAAhB;;MAEPtnB,KAAKC,GAAL,CAASsnB,KAAKC,EAAd,IAAoB,GAAG;WAGlBF;EAAA;;SAGFC,KAAKC,EAAL,GAAUH,GAAV,GAAgBC;AACzB;;qCAQ4CG,OAAmBC,OAA6B;QACpFnpB,IAAIinB,EAAEd,QAAF,CAAWgD,MAAM3Z,MAAjB,EAAyB0Z,MAAM1Z,MAA/B;QAEJ2V,KAAK+D,MAAMlpB;QACXolB,KAAK+D,MAAMnpB;QAEXopB,KAAKnC,EAAET,KAAF,CAAQxmB,CAAR,EAAWmlB,EAAX,IAAiB8B,EAAET,KAAF,CAAQrB,EAAR,EAAYC,EAAZ;SAErB+D,MAAM3Z,MAAN,CAAasX,KAAb,GAAqBhK,GAArB,CAAyBsI,GAAG0B,KAAH,GAAWT,cAAX,CAA0B+C,EAA1B,CAAzB;AACT;;kCAGEC,SACAC,SACAC,SACAC,SACAlB,MACiB;QACXN,KAAKqB;QACLpB,KAAKsB;QAGLE,QAAQxB,GAAGnB,KAAH,GAAWX,QAAX,CAAoB6B,EAApB;QAGR/L,IAAIwN,MAAMxpB,MAAN;QAEJypB,OAAOJ,UAAUE;MACnBE,OAAOzN,UAAU;QAGf0N,OAAOloB,KAAKC,GAAL,CAAS4nB,UAAUE,OAAnB;MACTvN,IAAI0N,aAAa;;MAKjB1N,MAAMyN,MAAM;UACRjnB,IAAIgnB,MAAM3C,KAAN,GAAcJ,SAAd;UACJ7K,IAAIwN,QAAQvC,KAAR,GAAgBhK,GAAhB,CAAoBra,EAAE4jB,cAAF,CAAiBiD,OAAjB,CAApB;WACHzN;EAAA;;MAMLI,MAAM0N,MAAM;UACRlnB,IAAIgnB,MAAM3C,KAAN,GAAcJ,SAAd;UACJkD,UAAUN,UAAUE;UAIpB3N,IAAIwN,QAAQvC,KAAR,GAAgBhK,GAAhB,CAAoBra,EAAE4jB,cAAF,CAAiBuD,UAAUN,OAAV,GAAoB,CAACA,OAAtC,CAApB;WACHzN;EAAA;;QAMHK,IAAIoN;QACJO,IAAIL;QAGJ7D,gBAAY,CAAZ,IAAgBiD,SAAK,CAAL,CAAhB,GAAyBA,SAAK,CAAL,CAAzB,KAA8B,IAAU3M,CAAV,GAAcC,CAA5C;QAIA4N,KAAK5N,IAAIyJ;QAGToE,KAAKtoB,KAAKwjB,IAAL,CAAU2D,SAAK,CAAL,IAASA,UAAM,CAAN,CAAnB;QAGLV,KAAKuB,MAAM3C,KAAN,GAAcJ,SAAd;QAGLsD,KAAK,IAAI9D,QAAJ,CAAa,CAACgC,GAAGpmB,CAAjB,EAAoBomB,GAAGvmB,CAAvB;QAKLsoB,MAAM/B,GAAGpB,KAAH,GAAWT,cAAX,CAA0ByD,EAA1B;QACNI,MAAMF,GAAGlD,KAAH,GAAWT,cAAX,CAA0B0D,EAA1B;QAENI,UAAUd,QAAQvC,KAAR,GAAgBhK,GAAhB,CAAoBmN,GAApB,EAAyBnN,GAAzB,CAA6BoN,GAA7B;QACVE,UAAUf,QAAQvC,KAAR,GAAgBhK,GAAhB,CAAoBmN,GAApB,EAAyB9D,QAAzB,CAAkC+D,GAAlC;QAEVlB,KAAKmB,QAAQ1D,QAAR,CAAiB6B,IAAjB;QACLW,KAAKmB,QAAQ3D,QAAR,CAAiB6B,IAAjB;SAEJU,KAAKC,EAAL,GAAUkB,OAAV,GAAoBC;AAC7B;;ACvMA,kDACE/C,SADF,EAEEC,SAFF,EAGE+C,IAHF,EAIExpB,KAJF,EAKE;QACMypB,aAAapD,WAAWqD,aAAX,CAAyBlD,SAAzB,EAAoCC,SAApC;QACbkD,kBAAmBvpB,KAAnB,GAA2BopB,KAAK3R,WAAhC,IAA+C,CAA/C,GAAoD7X;QACpD4pB,mBAAoBtpB,MAApB,GAA6BkpB,KAAK3R,WAAlC,IAAiD,CAAjD,GAAsD7X;QAEtDwY,eACJgR,KAAKhR,YAAL,GAAoB,CAApB,GAAoB,MAAUA,YAAV,GAAyBgR,KAAK3R,WAAL,GAAmB,CAA5C,IAAiD7X,KAArE,GAA6E;QAGzE6pB,wBAAwB1qB,CAAxB,CAA0BimB,KAA1B,KAAoCxkB,KAAKojB,EAAL,GAAU,CAA9C,IAAmDpjB,KAAKojB;QACxD8F,YAAYlpB,KAAKojB,EAAL,GAAU,CAAV,GAAe6F,YAAYjpB,KAAKojB;QAC5C9J,IAAI0P,aAAahpB,KAAKC,GAAL,CAASD,KAAKmpB,GAAL,CAASF,SAAT,CAAT;QACjBlC,IAAIgC,YAAY/oB,KAAKC,GAAL,CAASD,KAAKmpB,GAAL,CAASD,SAAT,CAAT;QAChBE,iBAAiB9P,KAAKyP,YAAYnR;QAClCyR,iBAAiBtC,KAAKiC,aAAapR;;MACrCwR,kBAAkBC,cAAlB,IAAoCzR,iBAAiB,GAAG;QACtDwR,gBAAgB;aACXppB,KAAKwjB,IAAL,CAAU2D,kBAAc,CAAd,IAAkBA,SAAK,CAAL,CAA5B;IAAkC,OACpC;aACEnnB,KAAKwjB,IAAL,CAAU2D,iBAAa,CAAb,IAAiBA,SAAK,CAAL,CAA3B;IAAiC;SAErC;UAECmC,OAAOzD,UAAU3lB,CAAV,GAAc6oB,SAAd,GAA0BnR;UACjC2R,MAAM1D,UAAUxlB,CAAV,GAAc2oB,UAAd,GAA2BpR;UACjCxQ,QAAQye,UAAU3lB,CAAV,GAAc6oB,SAAd,GAA0BnR;UAClC4R,SAAS3D,UAAUxlB,CAAV,GAAc2oB,UAAd,GAA2BpR;UACpC6R,WAAW,CACf,IAAIhF,QAAJ,CAAa6E,IAAb,EAAmBC,GAAnB,CADe,EAEf,IAAI9E,QAAJ,CAAard,KAAb,EAAoBmiB,GAApB,CAFe,EAGf,IAAI9E,QAAJ,CAAard,KAAb,EAAoBoiB,MAApB,CAHe,EAIf,IAAI/E,QAAJ,CAAa6E,IAAb,EAAmBE,MAAnB,CAJe;UAMXhoB,QAAQxB,KAAK0pB,KAAL,CAAK,YAAmBnrB,CAAnB,CAAqB2mB,WAArB,KAAqC,GAArC,IAA4C,GAA5C,GAAmD,EAAxD;UACRyE,wBAAwBF,SAASjoB,KAAT;UACxBooB,QAAQC,qCACZhB,WAAW9a,MADC8b,EAEZC,gBAA2BH,qBAA3BG,EAAkDjB,UAAlDiB,CAFYD,EAGZF,qBAHYE,EAIZjS,YAJYiS;WAMPD,QACHG,aAAuBH,KAAvBG,EAA8BlB,WAAW3qB,MAAzC6rB,EAAiDvrB,MAAjDurB,EADG,GAEHA,aAAuBJ,qBAAvBI,EAA8ClB,WAAW3qB,MAAzD6rB,EAAiEvrB,MAAjEurB,KAA4EnS;EAAA;AAEpF;;gCAaEkO,SACAkE,WACA1R,QACAK,SACAvZ,OACe;QAETyX,OAAO4O,WAAWQ,gBAAX,CAA4BH,OAA5B;QACPK,aAAatP,KAAKtY,CAAL,CAAO8mB,KAAP,GAAeJ,SAAf;QAGbmB,KACJzN,YAAY,CAAZ,GACI9B,KAAK9I,MADT,GAEI8I,KAAK9I,MAAL,CAAYsX,KAAZ,GAAoBhK,GAApB,CAAwB8K,WAAWd,KAAX,GAAmBT,cAAnB,CAAkCjM,UAAUvZ,KAA5C,CAAxB;QAGAinB,KACJ1N,YAAY,CAAZ,GACI9B,KAAK3Y,MADT,GAEI2Y,KAAK3Y,MAAL,CAAYmnB,KAAZ,GAAoBX,QAApB,CAA6ByB,WAAWd,KAAX,GAAmBT,cAAnB,CAAkCjM,UAAUvZ,KAA5C,CAA7B;QAGA6qB,yBAAyBzqB,KAAzB,GAAiC,CAAjC,GAAqC8Y,MAArC,IAA+ClZ;QAC/C8qB,UAAU,IAAIzF,QAAJ,CAAa,CAAC0B,WAAW9lB,CAAzB,EAA4B8lB,WAAWjmB,CAAvC,EAA0C0kB,cAA1C,CAAyDqF,WAAzD;MACZE,cAAc3E,EAAEd,QAAF,CAAW0B,EAAX,EAAe8D,OAAf;MACdE,cAAc5E,EAAEnK,GAAF,CAAM+K,EAAN,EAAU8D,OAAV;MACdG,cAAc7E,EAAEd,QAAF,CAAW2B,EAAX,EAAe6D,OAAf;MACdI,cAAc9E,EAAEnK,GAAF,CAAMgL,EAAN,EAAU6D,OAAV;QAEZlG,SAAQnN,KAAKtY,CAAL,CAAO2mB,WAAP;;MACVlB,SAAQ,GAAR,IAAeA,UAAS,IAAI;KAE5BmG,aAAaC,eAAe,CAACA,WAAD,EAAcD,WAAd;KAC5BE,aAAaC,eAAe,CAACA,WAAD,EAAcD,WAAd;EAAyB;;SAElD;IACLtc,QAAQ;MAAEwc,OAAOJ,WAAT;MAAsBK,OAAOJ;IAA7B,CADH;IAELlsB,QAAQ;MAAEqsB,OAAOF,WAAT;MAAsBG,OAAOF;IAA7B;EAFH;AAIT;;uDAWEG,eACA5qB,eACA6qB,iBACAC,iBACkB;MAEdC;;MACAF,gBAAgBnrB,IAAhB,KAAyB,UAAU;gBACzBmrB,gBAAgBjrB,MAAhB,GAA0BirB,gBAAgBzT,WAAhB,GAA8B;EAAA,OAC/D;gBACO4T,yCACVhrB,aADU,EAEV4qB,aAFU,EAGVC,eAHU,EAIV,CAJU;EAKZ;;MAIEI;;MACAH,gBAAgBprB,IAAhB,KAAyB,UAAU;gBACzBorB,gBAAgBlrB,MAAhB,GAA0BkrB,gBAAgB1T,WAAhB,GAA8B;EAAA,OAC/D;gBACO4T,yCACVJ,aADU,EAEV5qB,aAFU,EAGV8qB,eAHU,EAIV,CAJU;EAKZ;;SAGK,CAACC,SAAD,EAAYE,SAAZ;AACT;;6BASoC7kB,KAAec,QAAkBkc,QAAgB;QAC7E;IAAE/iB,CAAF;IAAKG;EAAL,IAAW4F;QACX6c,KAAK5iB,IAAI6G,OAAO7G;QAChB6iB,KAAK1iB,IAAI0G,OAAO1G;SAEf;IACLH,GAAG4iB,KAAK9iB,KAAKkkB,GAAL,CAASjB,MAAT,CAAL,GAAwBF,KAAK/iB,KAAKmkB,GAAL,CAASlB,MAAT,CAA7B,GAAgDlc,OAAO7G,CADrD;IAELG,GAAGyiB,KAAK9iB,KAAKmkB,GAAL,CAASlB,MAAT,CAAL,GAAwBF,KAAK/iB,KAAKkkB,GAAL,CAASjB,MAAT,CAA7B,GAAgDlc,OAAO1G;EAFrD;AAIT;;4BAOmC0qB,OAAuB;MACpDA,QAAQ,GAAG;WACN,OAAO3H,EAAP,GAAY,CAAZ,GAAgB2H,KAAhB;EAAgB,OAClB;WACE/qB,KAAKojB,EAAL,GAAU,CAAV,GAAc2H;EAAA;AAEzB;;0CAGE1J,IACAta,QACAua,IACA0J,QACY;QACNC,UAAsB;QACtBC,iBAAiBzF,WAAWiB,WAAX,CAAuB3f,MAAvB,EAA+Bsa,EAA/B;QACjB8J,iBAAiB1F,WAAWiB,WAAX,CAAuB3f,MAAvB,EAA+Bua,EAA/B;MAEnByJ,QAAQK,6BAA6BF,cAA7B,EAA6CC,cAA7C;;MACRH,SAASD,KAAT,GAAiB,GAAG;YACdM,mBAAmBN,KAAnB;EAAwB;;QAE5BO,SAAS7G,SAASiB,UAAT,CAAoB6F,oBAAoBlK,EAApB,EAAwBta,MAAxB,EAAgC,CAACgkB,KAAD,GAAS,CAAzC,CAApB;QACTS,aAAa/F,WAAWiB,WAAX,CAAuB3f,MAAvB,EAA+BukB,MAA/B;QACbG,YAAYC,2BAAqCF,UAArCE;QAEZC,SAASP,6BAA6BF,cAA7B,EAA6CM,UAA7C;MACXI,UAAUF,2BAAqCR,cAArCQ;;MACV1rB,KAAKC,GAAL,CAAS0rB,MAAT,IAAmB3rB,KAAKojB,EAAL,GAAU,GAAG;UAC5ByI,KAAKC,4BAAuCF,OAAvCE,EAAgDL,SAAhDK;YACHtjB,KAAKqjB;EAAE,OACV;UAECE,KAAKtH,SAASiB,UAAT,CAAoB6F,oBAAoBD,MAApB,EAA4BvkB,MAA5B,EAAoC4kB,SAAS,CAA7C,CAApB;UACLK,WAAWN,2BACfjG,WAAWiB,WAAX,CAAuB3f,MAAvB,EAA+B0d,SAASiB,UAAT,CAAoBqG,EAApB,CAA/B,CADeL;UAGXO,MAAMH,4BAAuCF,OAAvCE,EAAgDE,QAAhDF;UACNI,MAAMJ,4BAAuCE,QAAvCF,EAAiDL,SAAjDK;YACJtjB,KAAKyjB,KAAKF,IAAIG;EAAG;;UAGnB1jB,KAAK8iB;QAEPa,SAASf,6BAA6BD,cAA7B,EAA6CK,UAA7C;YACLE,2BAAqCP,cAArCO;;MACN1rB,KAAKC,GAAL,CAASksB,MAAT,IAAmBnsB,KAAKojB,EAAL,GAAU,GAAG;UAC5ByI,KAAKC,4BAAuCF,OAAvCE,EAAgDL,SAAhDK;YACHtjB,KAAKqjB;EAAE,OACV;UAECE,KAAKtH,SAASiB,UAAT,CAAoB6F,oBAAoBD,MAApB,EAA4BvkB,MAA5B,EAAoColB,SAAS,CAA7C,CAApB;UACLH,WAAWN,2BACfjG,WAAWiB,WAAX,CAAuB3f,MAAvB,EAA+B0d,SAASiB,UAAT,CAAoBqG,EAApB,CAA/B,CADeL;UAGXO,MAAMH,4BAAuCL,SAAvCK,EAAkDE,QAAlDF;UACNI,MAAMJ,4BAAuCE,QAAvCF,EAAiDF,OAAjDE;YACJtjB,KAAKyjB,KAAKF,IAAIG;EAAG;;SAGpBjB;AACT;;sCAE6CxD,OAAmBC,OAAmB;SAC1E1nB,KAAKkjB,KAAL,CACLuE,MAAMlpB,CAAN,CAAQ8B,CAAR,GAAYqnB,MAAMnpB,CAAN,CAAQ2B,CAApB,GAAwBunB,MAAMlpB,CAAN,CAAQ2B,CAAR,GAAYwnB,MAAMnpB,CAAN,CAAQ8B,CADvC,EAELonB,MAAMlpB,CAAN,CAAQ2B,CAAR,GAAYwnB,MAAMnpB,CAAN,CAAQ2B,CAApB,GAAwBunB,MAAMlpB,CAAN,CAAQ8B,CAAR,GAAYqnB,MAAMnpB,CAAN,CAAQ8B,CAFvC;AAIT;;iDAGEghB,IACAC,IACA8K,IACoB;QACd3J,KAAKpB,GAAGnhB;QACRwiB,KAAKrB,GAAGhhB;QACRsiB,KAAKrB,GAAGphB;QACR0iB,KAAKtB,GAAGjhB;QACRgsB,KAAKD,GAAGlsB;QACRosB,KAAKF,GAAG/rB;QACRksB,MAAM9J,KAAKE;QACX6J,MAAM9J,KAAKE;QACX6J,MAAMJ,KAAK1J;QACX+J,MAAMJ,KAAK1J;QAEX1iB,wBACgByiB,EADhB,IACsB6J,YAAY5J,EAAZ,CADtB,IACyC4J,mBAAmB7J,EAAnB,IAAyB+J,YAAY9J,EAAZ,CAAzB,CADzC,KAC8E,IAC7E2J,GAD6E,GACvEG,GADuE,GACjE,IAAIF,GAAJ,GAAUC,GAFvB;QAGApsB,MACFosB,GADE,IACFF,YAAmB5J,EAAnB,IAAyB6J,YAAY5J,EAAZ,CADvB,IAC0C2J,mBAAmB5J,EAAnB,IAAyB+J,YAAY9J,EAAZ,CAAzB,CAD1C,KAC+E,IAC9E2J,GAD8E,GACxEG,GADwE,GAClE,IAAIF,GAAJ,GAAUC,GAFvB;QAIAhtB,SAASO,KAAKwjB,IAAL,CAAUxjB,KAAKyjB,GAAL,CAAShB,KAAKviB,CAAd,EAAiB,CAAjB,IAAsBF,KAAKyjB,GAAL,CAASf,KAAKriB,CAAd,EAAiB,CAAjB,CAAhC;QACT0G,SAAS,IAAI0d,QAAJ,CAAavkB,CAAb,EAAgBG,CAAhB;SACR,CAAC0G,MAAD,EAAStH,MAAT;AACT;;wBCtT+BsO,QAAwB;MACjD,OAAO4e,IAAP,KAAgB,QAAW;WACtBzf,OAAOoT,IAAP,CAAYvS,MAAZ,EAAoB5L,QAApB,CAA6B,QAA7B,EAAuCyqB,UAAvC,CAAkD,GAAlD,EAAuD,EAAvD;EAAyD,OAC3D;WACED,KAAK5e,MAAL,EAAa6e,UAAb,CAAwB,GAAxB,EAA6B,EAA7B;EAA+B;AAE1C;;2BCS+C;QACvCC,UAAsCzvB,SAAS,EAAT;QACtC0vB,iBAAyC;SACxC;IAAED,OAAF;IAAWC;EAAX;AACT;;mBAE0BC,aAA0B;QAC5C;IAAEF,OAAF;IAAWC;EAAX,IAA8BC;;qBAEjB/kB,KAAawR,QAAoB;;;UAC5CwT,IAAI,qBAAehlB,GAAf,kBAAuB;mBAClBA,OAAOglB,IAAI;;QACtB,CAACA,GAAG;cACEhlB,OAAOwR;IAAA;;;wBAIGxR,KAAa;;;UAC3BglB,IAAI,qBAAehlB,GAAf,kBAAuB;;QAC7BglB,GAAG;UACDA,IAAI,CAAJ,KAAU,GAAG;eACRH,QAAQ7kB,GAAR;eACA8kB,eAAe9kB,GAAf;MAAe,OACjB;uBACUA,OAAOglB,IAAI;MAAA;;;;uBAKXhnB,IAAwB;QACvCA,IAAI;mBACOA;IAAE;;;sBAKjBwT,QACAyT,UACAC,YACAhW,aACAiW,YACA;QACI3T,OAAOja,IAAP,KAAgB,QAAQ;kBACd2tB;aACL;IAAA;;QAGL1T,OAAOja,IAAP,KAAgB,UAAU;kBAChB2tB;aACL1T,OAAO4T;IAAA;;UAGVC,aAAaC,aAAa9T,MAAb,EAAqByT,QAArB,EAA+B/V,WAA/B;UACblR,KAAKunB,SAASF,UAAT,EAAqBF,UAArB;;QACPnnB,OAAOknB,YAAY;aACdlnB;IAAA;;gBAEGknB;cACFlnB,IAAIqnB;WACPrnB;EAAA;;SAGF;IACLwnB,UADK;IAELC;EAFK;AAIT;;AAEA,sBAAsBjU,MAAtB,EAA2CyT,QAA3C,EAA8D/V,WAA9D,EAAmF;;;SAC1EwW,iCACFlU,MADE;IAEL1C,OAAO,aAAOA,KAAP,iBAAgBI,WAFlB;IAGL+V;EAHK;AAKT;;AAEA,kBAAkBD,CAAlB,EAAiCG,UAAjC,EAAqD;QAI7C/E,IAAIuF,eAAeX,EAAElW,KAAjB;QACJ8W,IAAIZ,EAAEC,QAAF,GAAa,GAAb,GAAmB;QACvBY,IAAIb,EAAEvT,KAAF,KAAY,aAAZ,GAA4B,KAA5B,GAAoC;SACvC,UAAU0T,cAAcH,EAAEztB,QAAQytB,EAAExtB,SAASwtB,EAAEttB,UAAUstB,EAAE1U,UAAU8P,KAAKwF,KAAKC;AACxF;;wBC3EEC,SACAlT,QACA9C,UACAiW,SACAC,aACAC,gBACAC,kBAIA;QAEMC,SAAyC/wB,SAAS,EAAT;QAI7C,MAAM,IAAIshB,GAAJ,CAAQtgB,OAAOiJ,IAAP,CAAYymB,QAAQ5wB,KAApB,CAAR,GACN,CAACkxB,KAAD,EAAQC,IAAR,KAAiB;QACX,CAACA,gCAAiB3P,IAAI;;eACf1Y,MAAMooB,OAAO;UAClBC,KAAKplB,GAAL,CAASjD,EAAT;qBAEW8nB,SAASK,QAAQnoB,IAAI,OAAO4U,QAAQoT;IAAW;;eAIrDhoB,MAAMqoB,MAAM;UACjBD,MAAMnlB,GAAN,CAAUjD,EAAV;eAEKya,OAAOza;cACRya,OAAOza;uDACEA,IAAImoB,OAAOnoB,EAAP;aACdmoB,OAAOnoB,EAAP;IAAO;KAGlB;IAAEiV,WAAW;EAAb;QAMA,MAAM,CAAC,GAAGnD,QAAJ,GACN,CAACwW,QAAD,EAAUD,IAAV,KAAmB;UACXE,SAASF,OAAOC,SAAQhwB,MAAR,CAAe0C,KAAK,CAACqtB,KAAKG,QAAL,CAAcxtB,CAAd,CAArB,CAAP,GAAgDstB;UACzDG,UAAUJ,OAAOA,KAAK/vB,MAAL,CAAY0C,KAAK,CAACstB,SAAQE,QAAR,CAAiBxtB,CAAjB,CAAlB,CAAP,GAAgD;WACzD4b,QAAQ5W,MAAM;YACb0a,QAAQyN,OAAOnoB,EAAP;UACV0a,SAAS,CAACA,MAAM5I,gBAAgBA,WAAW;IAChD;YACO8E,QAAQ5W,MAAM;YACd0a,QAAQyN,OAAOnoB,EAAP;UACV0a,SAASA,MAAM5I,gBAAgBA,WAAW;IAC/C;EAAA,GAEH;IAAEmD,WAAW;EAAb;QAKA,MAAM,CAAC,GAAG8S,OAAJ,GACN,CAACnoB,KAAD,EAAQyoB,IAAR,KAAiB;UACTE,SAAS3oB,MAAMtH,MAAN,CAAa0C,KAAK,CAACqtB,KAAKG,QAAL,CAAcxtB,CAAd,CAAnB;UACTytB,UAAUJ,KAAK/vB,MAAL,CAAY0C,KAAK,CAAC4E,MAAM4oB,QAAN,CAAextB,CAAf,CAAlB;WACT4b,QAAQ5W,MAAM;YACb0a,QAAQyN,OAAOnoB,EAAP;UACV0a,SAAS,CAACA,MAAMqN,eAAeA,UAAU;IAC9C;YACOnR,QAAQ5W,MAAM;YACd0a,QAAQyN,OAAOnoB,EAAP;UACV0a,SAASA,MAAMqN,eAAeA,UAAU;IAC7C;EAEL;QAIMW,eAAeC,SAAS,MAAM;UAC5BtU,OAAY6T,mBAAmBA,kBAAnB,GAAyC9vB,OAAOC,MAAP,CAAc8vB,MAAd;;QACvDvT,OAAOhC,MAAP,CAAcC,SAAS;aAClB+V,iBAAiBvU,IAAjB,EAAuBO,OAAOhC,MAA9B,EAAsCmV,OAAtC,EAA+CjW,QAA/C;IAAuD,OACzD;aACEuC;IAAA;EAEV,CAPoB;SASd;IAAE8T,MAAF;IAAUO;EAAV;AACT;;AAEA,wBACEZ,OADF,EAEEK,MAFF,EAGEnoB,EAHF,EAIE8R,QAJF,EAKE8C,MALF,EAMEoT,WANF,EAOE;QACMa,cAAgC;IACpC7oB,EADoC;IAEpC8R,QAFoC;IAGpCiW,SAAS,KAH2B;IAIpC/V,YAAY2W,SAAS,MAAM;UACrB,CAACb,QAAQ5wB,KAAR,CAAc8I,EAAd,UAA0B8oB,MAAMD,YAAY7W,UAAlB;aACxB/Z,OAAOf,KAAP,CAAa0d,OAAO5C,UAApB,EAAgC8V,QAAQ5wB,KAAR,CAAc8I,EAAd,CAAhC;IACR,CAHW,CAJwB;IAQpC8S,QAAQ6V,SAAS,MAAM;UACjB,CAACb,QAAQ5wB,KAAR,CAAc8I,EAAd,UAA0B8oB,MAAMD,YAAY/V,MAAlB;aACxB7a,OAAOf,KAAP,CAAa0d,OAAOhC,MAAP,CAAcE,MAA3B,EAAmCgV,QAAQ5wB,KAAR,CAAc8I,EAAd,CAAnC;IACR,CAHO;EAR4B;SAa/BA,MAAM6oB;cACDf,SAAS9nB,IAAImoB,OAAOnoB,EAAP;AAC3B;;AAEA,0BACEmoB,MADF,EAEEvV,MAFF,EAGEmV,OAHF,EAIEjW,QAJF,EAKE;MACIc,OAAOG,mBAAP,IAA8BH,OAAOI,wBAAwB;WACxDmV,OAAO1M,IAAP,CAAY,CAACjH,CAAD,EAAIC,CAAJ,KAAU;YACrBsU,SAAShB,QAAQ9kB,GAAR,CAAYuR,EAAExU,EAAd;YACTgpB,SAASjB,QAAQ9kB,GAAR,CAAYwR,EAAEzU,EAAd;;UACX+oB,UAAUC,QAAQ;eACbD,SAAS,CAAT,GAAa;MAAA;;YAEhBE,YAAYnX,SAAS7O,GAAT,CAAauR,EAAExU,EAAf;YACZkpB,YAAYpX,SAAS7O,GAAT,CAAawR,EAAEzU,EAAf;;UACdipB,aAAaC,WAAW;eACnBD,YAAY,CAAZ,GAAgB;MAAA;;aAElBzU,EAAE1B,MAAF,GAAW2B,EAAE3B;IACrB,CAZM;EAYN,WACQF,OAAOG,mBADf,EACoC;WAC9BoV,OAAO1M,IAAP,CAAY,CAACjH,CAAD,EAAIC,CAAJ,KAAU;YACrBsU,SAAShB,QAAQ9kB,GAAR,CAAYuR,EAAExU,EAAd;YACTgpB,SAASjB,QAAQ9kB,GAAR,CAAYwR,EAAEzU,EAAd;;UACX+oB,UAAUC,QAAQ;eACbD,SAAS,CAAT,GAAa;MAAA;;aAEfvU,EAAE1B,MAAF,GAAW2B,EAAE3B;IACrB,CAPM;EAON,CATA,MASA,IACQF,OAAOI,sBADf,EACuC;WACjCmV,OAAO1M,IAAP,CAAY,CAACjH,CAAD,EAAIC,CAAJ,KAAU;YACrBwU,YAAYnX,SAAS7O,GAAT,CAAauR,EAAExU,EAAf;YACZkpB,YAAYpX,SAAS7O,GAAT,CAAawR,EAAEzU,EAAf;;UACdipB,aAAaC,WAAW;eACnBD,YAAY,CAAZ,GAAgB;MAAA;;aAElBzU,EAAE1B,MAAF,GAAW2B,EAAE3B;IACrB,CAPM;EAON,CATA,MAUI;WACEqV,OAAO1M,IAAP,CAAY,CAACjH,CAAD,EAAIC,CAAJ,KAAU;aACpBD,EAAE1B,MAAF,GAAW2B,EAAE3B;IACrB,CAFM;EAEN;AAEL;;wBCjIEgV,SACAhW,UACAiW,SACA;SACO;IACLD,OADK;IAELhW,QAFK;IAGLiW;EAHK;AAKT;;AAMA,MAAMoB,YAAY1xB,OAAO,QAAP,CAAlB;AAEA,MAAM2xB,cAA2B;EAC/B7vB,MAAM,MADyB;EAE/BC,OAAO,CAFwB;EAG/BE,QAAQ,CAHuB;EAI/B4Y,QAAQ,CAJuB;EAK/BmB,OAAO,aALwB;EAM/B3C,OAAO;AANwB,CAAjC;;uBAcElR,OACA2U,OACA8U,OACApwB,SACAqwB,SACAC,YACAnwB,OACA;QACMowB,uBAAuDpyB,SAAS,EAAT;QAMvD;IACJ+wB,QAAQsB,UADJ;IAEJf,cAAcgB;EAFV,IAGFC,eACF/pB,MAAMkoB,OADJ,EAEF7uB,QAAQC,IAFN,EAGF0G,MAAMkS,QAHJ,EAIFlS,MAAMmoB,OAJJ,EAKF,CAAC6B,MAAD,EAAQ5pB,EAAR,EAAY6pB,QAAZ,KAAyB;uBACJD,QAAO5pB,IAAI6pB,UAAsC5wB,QAAQC;EAAI,CANhF,EAQF,CAACyH,MAAD,EAASmpB,MAAT,KAAoB;UACZ/pB,YAAYupB,QAAQ1pB;WACnBG,UAAUY,MAAV;EAEX,CAZI;QAsBEwmB,aAAa4C;QAGbC,kBAAkBC,oBAA8BrqB,MAAMkoB,OAApCmC,EAA6C1V,MAAMuT,OAAnDmC,EAA4DhxB,OAA5DgxB;QAGlBC,cAAcC,IAA2B,EAA3B;QAEd;IACJhC,QAAQiC,UADJ;IAEJ1B,cAAc2B;EAFV,IAGFV,eACFpV,MAAMuT,OADJ,EAEF7uB,QAAQia,IAFN,EAGFqB,MAAMzC,QAHJ,EAIFyC,MAAMwT,OAJJ,EAKF,CAAC9M,MAAD,EAAQjb,EAAR,EAAY6pB,QAAZ,KAAyB;uBAErB5O,QACAjb,IACA6pB,UACA5wB,QAAQia,MACRqW,YACAE,YACAO,iBACAV,SACAlwB,OACA+tB;EACF,CAjBA,EAmBF,CAACmD,OAAD,EAAU5P,KAAV,KAAoB;;;gBACZ6P;GApBN,EAsBF,MAAML,YAAYhzB,KAtBhB;cA0BQ,MAAM;gBACJA,QAAQszB,kBAAkBR,gBAAgBnP,UAAlC,EAA8CuP,UAA9C;EACrB;QAGCJ,gBAAgBnP,YAChB4P,KAAKC,2BAA2BlB,oBAA3B,EAAiDQ,eAAjD,EAAkE/wB,OAAlE,GACL;IAAEgc,WAAW;EAAb;QAOI;IACJkT,QAAQwC,UADJ;IAEJjC,cAAckC;EAFV,IAGFjB,eACFN,MAAMvB,OADJ,EAEF7uB,QAAQ8a,IAFN,EAGFsV,MAAMvX,QAHJ,EAIFuX,MAAMtB,OAJJ,EAKF,CAAC8C,MAAD,EAAQ7qB,EAAR,EAAY6pB,QAAZ,KAAyB;UACjBnP,QAAQmP;UAER7V,YAAY2U,SAAS,MAAM;UAC3B,CAACkC,OAAM3zB,KAAN,CAAY8I,EAAZ,UAAwB;aACtB/H,OAAOf,KAAP,CAAa+B,QAAQ8a,IAAR,CAAaC,SAA1B,EAAqC6W,OAAM3zB,KAAN,CAAY8I,EAAZ,CAArC;IACR,CAHiB;UAIZiU,YAAY0U,SAAS,MAAM;UAC3B,CAACkC,OAAM3zB,KAAN,CAAY8I,EAAZ,UAAwB;aACtB/H,OAAOf,KAAP,CAAa+B,QAAQ8a,IAAR,CAAaE,SAA1B,EAAqC4W,OAAM3zB,KAAN,CAAY8I,EAAZ,CAArC;IACR,CAHiB;UAKZ+T,OAAO8W,OAAM3zB,KAAN,CAAY8I,EAAZ;UACPuU,QAAQoU,SAAS,MAAM;YACrB5U,OAAO8W,OAAM3zB,KAAN,CAAY8I,EAAZ;aACN+T,KAAKQ,KAAL,CACJ5b,GADI,CACAmjB;QAAaA,MAAb;QAAqB5I,MAAMqB,MAAMuT,OAAN,CAAc5wB,KAAd,CAAoB4kB,MAApB;MAA3B,EADA,EAEJxjB,MAFI,CAEGoE,KAAKA,EAAEwW,IAFV;IAGR,CALa;EAOlB,CAzBI;QA2BEiV,SAAiB;IACrBsB,UADqB;IAErBW,UAFqB;IAGrBJ,eAHqB;IAIrBR,oBAJqB;IAKrBmB,UALqB;IAMrBrB,OANqB;IAOrBI,gBAPqB;IAQrBW,gBARqB;IASrBO;EATqB;UAWfzB,WAAWhB;SACZA;AACT;;2BAEkC2C,MAAgE;SACzFA,KAAKlX;AACd;;qBAE4B;SACnBjc,QAAQC,OAAOuxB,SAAP,CAAR,EAA2B,QAA3B;AACT;;AAMA,sBAAsBjwB,IAAtB,EAAkC4Y,QAAlC,EAAqDiW,OAArD,EAAuEnT,MAAvE,EAA2F;MACrFmT,WAAWnT,OAAO/C,OAAO;WACpB5Z,OAAOI,MAAP,CAAcuc,OAAO/C,KAArB,EAA4B3Y,IAA5B;EAAgC,OAClC;WACE6xB,mBAAmB7xB,IAAnB,EAAyB4Y,QAAzB,EAAmC8C,MAAnC;EAAyC;AAEpD;;AAEA,4BAA4B1b,IAA5B,EAAwC4Y,QAAxC,EAA2D8C,MAA3D,EAA+E;MAEzE9C,YAAY8C,OAAO9C,UAAU;WACxB7Z,OAAOI,MAAP,CAAcuc,OAAO9C,QAArB,EAA+B5Y,IAA/B;EAAmC,OACrC;WACEjB,OAAOI,MAAP,CAAcuc,OAAOtb,MAArB,EAA6BJ,IAA7B;EAAiC;AAE5C;;AAEA,4BACE0G,KADF,EAEEI,EAFF,EAGE0a,KAHF,EAIE9F,MAJF,EAKE;QACMvb,QAAQsvB,SAAS,MAAM;QACvB,CAAC/oB,MAAM1I,KAAN,CAAY8I,EAAZ,UAAwB8oB,MAAMpO,MAAMrhB,KAAZ;WACtB2xB,aAAaprB,MAAM1I,KAAN,CAAY8I,EAAZ,CAAb,EAA8B0a,MAAM5I,QAApC,EAA8C4I,MAAMqN,OAApD,EAA6DnT,MAA7D;EACR,CAHa;QAKRqW,cAActC,SAAS,MAAM;QAC7B,CAAC/oB,MAAM1I,KAAN,CAAY8I,EAAZ,UAAwB8oB,MAAMpO,MAAMuQ,WAAZ;WACtBF,mBAAmBnrB,MAAM1I,KAAN,CAAY8I,EAAZ,CAAnB,EAAoC0a,MAAM5I,QAA1C,EAAoD8C,MAApD;EACR,CAHmB;QAKd3C,QAAQ0W,SAAS,MAAM;QACvB,CAAC/oB,MAAM1I,KAAN,CAAY8I,EAAZ,UAAwB8oB,MAAMpO,MAAMzI,KAAZ;WACtBha,OAAOI,MAAP,CAAcuc,OAAO3C,KAArB,EAA4BrS,MAAM1I,KAAN,CAAY8I,EAAZ,CAA5B;EACR,CAHa;QAKRkrB,YAAYvC,SAAS,MAAM;;;QAC3B/T,OAAO3C,KAAP,CAAaQ,IAAb,YAA6Bta,UAAU;aAClC2wB,MAAMpO,MAAMzI,KAAZ,EAAmBQ;IAAA,OACrB;UACD,CAAC7S,MAAM1I,KAAN,CAAY8I,EAAZ,UAAwB8oB,MAAMpO,MAAMwQ,SAAZ;aACtB,kBAAMh0B,KAAN,CAAY8I,EAAZ,yBAAkB8oB,MAAMpO,MAAMzI,KAAZ,EAAmBQ,IAArC,kBAA8C;IAAA;EAExD,CAPiB;QASZV,YAAY4W,SAAS,MAAM;QAC3B,CAAC/oB,MAAM1I,KAAN,CAAY8I,EAAZ,UAAwB8oB,MAAMpO,MAAM3I,SAAZ;WACtB9Z,OAAOf,KAAP,CAAa0d,OAAO7C,SAApB,EAA+BnS,MAAM1I,KAAN,CAAY8I,EAAZ,CAA/B;EACR,CAHiB;AAIpB;;AAEA,uBAAuBkT,IAAvB,EAAmCpB,QAAnC,EAAsDiW,OAAtD,EAAwEnT,MAAxE,EAA4F;MACtF9C,UAAU;WACL7Z,OAAOI,MAAP,CAAcuc,OAAO9C,QAArB,EAA+BoB,IAA/B;EAAmC,WACjC6U,WAAWnT,OAAO/C,KADe,EACR;WAC3B5Z,OAAOI,MAAP,CAAcuc,OAAO/C,KAArB,EAA4BqB,IAA5B;EAAgC,CAFG,MAGrC;WACEjb,OAAOI,MAAP,CAAcuc,OAAOtb,MAArB,EAA6B4Z,IAA7B;EAAiC;AAE5C;;AAEA,sBAAsBM,MAAtB,EAAwD;MAClDA,OAAOja,IAAP,KAAgB,QAAQ;WACnB6vB;EAAA,OACF;WACE5V;EAAA;AAEX;;AAEA,4BACEe,KADF,EAEEvU,EAFF,EAGE0a,KAHF,EAIE9F,MAJF,EAKE2U,UALF,EAMEE,UANF,EAOEO,eAPF,EAQEV,OARF,EASElwB,KATF,EAUE+tB,UAVF,EAWE;QACM;IAAEK,UAAF;IAAcC;EAAd,IAA8B0D,UAAU5B,UAAV;SAE7BvwB,OAAO0hB,OAAO;IACnB0Q,QAAQ;MAAE/P,IAAI;QAAEnhB,GAAG,CAAL;QAAQG,GAAG;MAAX,CAAN;MAAsBihB,IAAI;QAAEphB,GAAG,CAAL;QAAQG,GAAG;MAAX;IAA1B,CADW;IAEnBgxB,eAAe;MAAEhQ,IAAI;QAAEnhB,GAAG,CAAL;QAAQG,GAAG;MAAX,CAAN;MAAsBihB,IAAI;QAAEphB,GAAG,CAAL;QAAQG,GAAG;MAAX;IAA1B,CAFI;IAGnBixB,UAAU;MAAEjQ,IAAI;QAAEnhB,GAAG,CAAL;QAAQG,GAAG;MAAX,CAAN;MAAsBihB,IAAI;QAAEphB,GAAG,CAAL;QAAQG,GAAG;MAAX;IAA1B;EAHS;QAMfwW,OAAO8X,SAAyB,MAAM;UACpCzV,OAAOqB,MAAMrd,KAAN,CAAY8I,EAAZ;UACP6T,SAAS0X,cAAcrY,IAAd,EAAoBwH,MAAM5I,QAA1B,EAAoC4I,MAAMqN,OAA1C,EAAmDnT,MAAnD;;QAEXja,MAAM,CAACkZ,OAAOra,KAAd,GAAsB;cAChByiB,KACN,qEACAjc,IACA6T,OAAOra;aAEFA,QAAQ;IAAA;;QAEbqa,OAAO/C,KAAP,KAAiB,MAAjB,IAA8B+C,OAAO/C,KAAP,KAAiB,MAAM;cAC/CmL,KACN,qEACAjc,IACA6T,OAAO/C;aAEFA,QAAQ;IAAA;;QAEb0a,cAAcvzB,OAAOf,KAAP,CAAa0d,OAAOtb,MAAP,CAAcE,KAA3B,EAAkC0Z,IAAlC;;QACdvY,MAAM,CAAC6wB,WAAP,GAAqB;oBACT;IAAA;;UAEVzjB,SAAS0jB,aAAaxzB,OAAOI,MAAP,CAAcuc,OAAOpB,MAAP,CAAczL,MAA5B,EAAoC,CAACmL,IAAD,EAAOW,MAAP,CAApC,CAAb;UACT3b,SAASuzB,aAAaxzB,OAAOI,MAAP,CAAcuc,OAAOpB,MAAP,CAActb,MAA5B,EAAoC,CAACgb,IAAD,EAAOW,MAAP,CAApC,CAAb;WACR;MAAEA,MAAF;MAAU2X,WAAV;MAAuBzjB,MAAvB;MAA+B7P;IAA/B;EACR,CA3BY;QA4BP2Y,OAAOA;QACP6a,kBAA8D7pB,MAClEmoB,gBAAgBpP,gBADkD,EAElE5a,EAFkE;QAI9D2rB,mBAA0C9pB,MAAMmoB,gBAAgBlP,eAAtB,EAAuC9a,EAAvC;QAE1C4rB,iBAAiBC,YAAY,MAAM;;;UACjC3Y,OAAOqB,MAAMrd,KAAN,CAAY8I,EAAZ;QACT,CAACkT;UAECnL,SAASuhB,QAAQ1pB,KAAR,CAAcsT,6BAAMnL,MAApB;UACT7P,SAASoxB,QAAQ1pB,KAAR,CAAcsT,6BAAMhb,MAApB;UAET4zB,cAAc,iBAAW5Y,6BAAMnL,MAAjB,yBAA0BkjB;UACxCc,cAAc,iBAAW7Y,6BAAMhb,MAAjB,yBAA0B+yB;;QAC1C,CAACljB,MAAD,IAAW,CAAC7P,MAAZ,IAAsB,CAAC4zB,WAAvB,IAAsC,CAACC,aAAa;;;;UAKlDC,kBAAkBC,6BACtBP,gBAAgBx0B,KADM+0B,EAEtB,uBAAiB/0B,KAAjB,iBAA0B,KAFJ+0B,EAGtBlkB,MAHsBkkB,EAItB/zB,MAJsB+zB,EAKtB7yB,MAAMlC,KALgB+0B,EAMtBrX,OAAOd,SANemY;UASlB,CAACC,iBAAD,EAAoBC,iBAApB,IACJC,8CAAkDrkB,MAAlDqkB,EAA0Dl0B,MAA1Dk0B,EAAkEN,WAAlEM,EAA+EL,WAA/EK;UAEIrxB,IAAI3B,MAAMlC;UAGVm0B,gBAAgBgB,YACpBL,eADoBK,EAEpBH,oBAAoBnxB,CAFAsxB,EAGpBF,oBAAoBpxB,CAHAsxB;QAOlBtM,eAAe;QACfC,eAAe;UACbsM,IAAIzb,KAAK3Z;;QACXo1B,EAAEvkB,MAAF,CAASxO,IAAT,KAAkB,QAAQ;YACtBia,SAAS8Y,EAAEvkB;qBACFyL,OAAOlB,MAAP,GAAgBkB,OAAOha;;UAClCga,OAAOC,KAAP,KAAiB,eAAe;wBAClB6Y,EAAEd;MAAA;;;QAGlBc,EAAEp0B,MAAF,CAASqB,IAAT,KAAkB,QAAQ;YACtBia,SAAS8Y,EAAEp0B;qBACFsb,OAAOlB,MAAP,GAAgBkB,OAAOha;;UAClCga,OAAOC,KAAP,KAAiB,eAAe;wBAClB6Y,EAAEd;MAAA;;;QAIlB5W,OAAOtC,MAAP,KAAkB,IAAlB,IAA0BsC,OAAOtC,MAAP,KAAkB,QAAW;UACrDga,EAAEvkB,MAAF,CAASxO,IAAT,KAAkB,MAAlB,IAA4B+yB,EAAEp0B,MAAF,CAASqB,IAAT,KAAkB,QAAQ;wBACxC2yB;wBACAC;MAAA;WAEb;sBACWvX,OAAOtC,MAAP,GAAgB4Z;sBAChBtX,OAAOtC,MAAP,GAAgB6Z;IAAA;;UAI5B5yB,OAAOqb,OAAOrb;;QAChBA,SAAS,YAAY;YACjB6xB,SAASY;YACTO,QAAQ;;UACVxM,iBAAiB,CAAjB,IAAsBC,iBAAiB,GAAG;cACtCsL,WAAW5Q,MAAM0Q;MAAA,OAClB;cACCE,WAAWe,YAAsB3R,MAAM0Q,MAA5BiB,EAAoCtM,eAAehlB,CAAnDsxB,EAAsDrM,eAAejlB,CAArEsxB;MAAsE;WAEpF;YAECjB,SAASoB,eAAyBzkB,MAAzBykB,EAAiCt0B,MAAjCs0B;YAETC,QAAQf,gBAAgBx0B,KAAhB,GACVw0B,gBAAgBx0B,KAAhB,CAAsB8jB,UAAtB,GAAmC,CAAnC,GAAuC0Q,gBAAgBx0B,KAAhB,CAAsBskB,YADnD,GAEV;YAEE,CAAC8P,QAAD,EAAWiB,KAAX,IAAoBG,+BACxBhS,MAAM0Q,MADkB,EAExBY,eAFwB,EAGxBS,KAHwB,EAIxB1M,eAAehlB,CAJS,EAKxBilB,eAAejlB,CALS;YAOpBuwB,WAAWA;YACXiB,QAAQA;IAAA;EAEjB,CA5FsB;QA8FjBI,yBAAyBd,YAAY,MAAM;QAC3C,CAACtX,MAAMrd,KAAN,CAAY8I,EAAZ;UACC4sB,iBAAiBpF,WACrB3W,KAAK3Z,KAAL,CAAW6Q,MADU,EAErB,IAFqB,EAGrB2S,MAAMkS,cAHe,EAIrB/b,KAAK3Z,KAAL,CAAW2c,MAAX,CAAkB/C,KAJG,EAKrBqW,UALqB;UAOjB0F,iBAAiBrF,WACrB3W,KAAK3Z,KAAL,CAAWgB,MADU,EAErB,KAFqB,EAGrBwiB,MAAMmS,cAHe,EAIrBhc,KAAK3Z,KAAL,CAAW2c,MAAX,CAAkB/C,KAJG,EAKrBqW,UALqB;EAOxB,CAhB8B;;QAkBzBoD,kBAAkB,MAAM;;;gBAGhB7P,MAAMkS;gBACNlS,MAAMmS;EAAc;AAEpC;;AAEA,2BACEhS,UADF,EAEEuP,UAFF,EAGE;SACOhyB,OAAOM,OAAP,CAAemiB,UAAf,EACJliB,GADI,CACA,CAAC,CAACqJ,GAAD,EAAM8qB,KAAN,CAAD,KAAkB;;;QACjBA,MAAMpZ,WAAW;aACkB;QACnC1T,IAAI,aAAOqB,IAAP,CAAYyrB,MAAMvY,KAAlB,EAAyB,CAAzB,kBAA+BvS,GADA;QAEnC4R,YAAY,IAFuB;QAGnC5R,GAHmC;QAInC8qB,KAJmC;QAKnCha,QAAQ1a,OAAOiJ,IAAP,CAAYyrB,MAAMvY,KAAlB,EACL5b,GADK,CACDqH;;;UAAM,+BAAWA,EAAX,0BAAgB8S,MAAhB,iBAA0B,CAA1B;QAA2B,CADhC,EAELhY,MAFK,CAEE,CAACC,CAAD,EAAIgyB,CAAJ,KAAU/yB,KAAKmU,GAAL,CAASpT,CAAT,EAAYgyB,CAAZ,CAFZ;MAL2B;WAShC;aACE30B,OAAOM,OAAP,CAAeo0B,MAAMvY,KAArB,EAA4B5b,GAA5B,CACL,CAAC,CAACqH,EAAD,EAAKkT,IAAL,CAAD,KAAM;;;;UAEFlT;UACA4T,YAAY;UACZ5R,KAAKhC;UACLkT;UACAJ,QAAQ,wBAAW9S,EAAX,0BAAgB8S,MAAhB,iBAA0B;;MAExC,CATO;IASP;EAEH,CAxBI,EAyBJka,IAzBI;AA0BT;;AAEA,wCACEC,cADF,EAEEjB,eAFF,EAGES,KAHF,EAIE1M,YAJF,EAKEC,YALF,EAM+C;QAIvCoL,SAAS3L,WAAWQ,gBAAX,CAA4BgN,cAA5B;QACTC,UAAUzN,WAAWQ,gBAAX,CAA4B+L,eAA5B;QACVmB,gBAAgBC,wBAAkCpB,eAAlCoB;QAGhB,CAACrsB,MAAD,EAAStH,MAAT,IAAmB4zB,wCACvBjC,OAAOrjB,MADgBslB,EAEvBjC,OAAOlzB,MAFgBm1B,EAGvBF,aAHuBE;MAMrB/B;MACAiB,QAAqC;;MAErCE,UAAU,GAAG;QAEX1M,iBAAiB,CAAjB,IAAsBC,iBAAiB,GAAG;iBACjCiN;IAAA,OACN;iBACMZ,YAAsBY,cAAtBZ,EAAsCtM,YAAtCsM,EAAoDrM,YAApDqM;IAAgE;;WAEtE,CAACf,QAAD,EAAWiB,KAAX;EAAgB;;QAInBe,cAAc7N,WAAWiB,WAAX,CAAuB3f,MAAvB,EAA+BosB,aAA/B;QAGdnI,SAASuI,6BACb9N,WAAWiB,WAAX,CAAuB3f,MAAvB,EAA+BqqB,OAAOrjB,MAAtC,CADawlB,EAEbD,WAFaC;;MAKXxN,iBAAiB,CAAjB,IAAsBC,iBAAiB,GAAG;eACjCiN;EAAA,OACN;QAGDO,gBAAgBzN,eAAetmB;QAC/Bg0B,gBAAgBzN,eAAevmB;;QAG/BurB,SAAS,GAAG;uBACG;uBACA;IAAA;;eAERwH,eACTkB,oBAAwBtC,OAAOrjB,MAA/B2lB,EAAuC3sB,MAAvC2sB,EAA+CF,aAA/CE,CADSlB,EAETkB,oBAAwBtC,OAAOlzB,MAA/Bw1B,EAAuC3sB,MAAvC2sB,EAA+C,CAACD,aAAhDC,CAFSlB;QAOP7G,SAAS4H,6BACX9N,WAAWiB,WAAX,CAAuB3f,MAAvB,EAA+BqqB,OAAOrjB,MAAtC,CADWwlB,EAEX9N,WAAWiB,WAAX,CAAuB3f,MAAvB,EAA+BqqB,OAAOlzB,MAAtC,CAFWq1B;QAITpH,SAASoH,6BACX9N,WAAWqD,aAAX,CAAyB/hB,MAAzB,EAAiCuqB,SAASjQ,EAA1C,CADWkS,EAEX9N,WAAWqD,aAAX,CAAyB/hB,MAAzB,EAAiCuqB,SAAShQ,EAA1C,CAFWiS;;QAITvI,SAASW,MAAT,GAAkB,GAAG;eACdgI,mBAAuBhI,MAAvBgI;;UACL3I,SAASmB,MAAT,GAAkB,GAAG;iBACdwH,mBAAuBxH,MAAvBwH;MAA6B;;;QAGtChI,SAASQ,MAAT,GAAkB,GAAG;YAEjB/D,IAAI+K,cAAc9N,KAAd,GAAsBhK,GAAtB,CAA0B6X,QAAQ30B,CAAR,CAAU0mB,SAAV,GAAsBL,cAAtB,CAAqC,GAArC,CAA1B;iBACC4N,eAAyBW,aAAzBX,EAAwCpK,CAAxCoK;aACJ,CAAClB,QAAD,EAAWiB,KAAX;IAAgB;;;QAKrB,CAAClR,EAAD,EAAKC,EAAL,IAAWsS,0BAAoCtC,QAApCsC;QACX3I,UAAU4I,iCACoBxS,EADpBwS,EACwB9sB,MADxB8sB,EACgCvS,EADhCuS,EACoC7I,MADpC6I,EAEbl1B,GAFak1B,CAETzZ,KAAKA,EAAEkL,QAAF,EAFIuO;UAIR;IACN9sB,QAAQosB,aADF;IAENpI,OAAOC,MAFD;IAGN8I,QAAQ;MAAE/sB,MAAF;MAAUtH;IAAV,CAHF;IAINwrB;EAJM;SAMD,CAACqG,QAAD,EAAWiB,KAAX;AACT;;AAEA,oCACE/C,oBADF,EAEEQ,eAFF,EAGE/wB,OAHF,EAIE;QACM80B,SAAS/D,gBAAgBnP;SACxBniB,QAAQq1B,QACZz1B,OAAO,CAAC,CAAC0H,EAAD,EAAK8sB,KAAL,CAAD,KAAiBA,MAAMpZ,SAAN,IAAmB,QAAQ8V,oBAAR,GAC3C5S,QAAQ,CAAC,CAAC5W,EAAD,EAAK8sB,KAAL,CAAD,KAAiB;UAClBpS,QAAQ;MAAE7G,QAAQ;IAAV;UACRA,SAAS8U,SAAsB,MACnC1wB,OAAOI,MAAP,CAAcY,QAAQia,IAAR,CAAaU,UAAb,CAAwBC,MAAtC,EAA8CiZ,MAAMvY,KAApD,CADa;yBAGMvU,MAAM0a;EAC5B;SACIrZ,KAAKmoB,sBAAsB5S,QAAQ5W,MAAM;;;QAC1C,EAAC,sBAAgB6a,UAAhB,CAA2B7a,EAA3B,yBAAgC0T,SAAjC,GAA4C;aACvC8V,qBAAqBxpB,EAArB;IAAqB;EAE/B;AACH;;MCnnBaguB,QAAQ;EACZ,eAAcr1B,GAAd,EAA8B;WAC5B0F,MAAMic,IAAN,CAAW3hB,IAAIN,MAAJ,EAAX;EAAuB;;AAFb;;ACErB,MAAM41B,iCAAiC,CAAvC;AACA,MAAMC,iCAAiC,CAAvC;MACaC,yBAAyB;;0CAsCW50B,MAAsB;SAC9DA,SAAS,OAAT,GAAmB20B,8BAAnB,GAAoDD;AAC7D;;sBAGEG,aACAC,WACAruB,IACAqR,OACsC;MAElCid,aAAaF,YAAYrrB,GAAZ,CAAgBsrB,SAAhB;;MACbC,YAAY;QACVA,WAAWtuB,EAAX,KAAkBA,IAAI;mBAEX;IAAA;SAEV;UACCuuB,aAAalwB,MAAMic,IAAN,CAAW8T,YAAY11B,OAAZ,EAAX,EAAkC81B,IAAlC,CAAuC,CAAC,CAAC/D,CAAD,EAAI/P,KAAJ,CAAD,KAAgBA,MAAM1a,EAAN,KAAaA,EAApE;;QACfuuB,YAAY;YACR,CAACE,YAAD,EAAe/T,KAAf,IAAwB6T;kBAClB9T,OAAOgU;mBACN/T;IAAA;;;MAIbgU,YAAwBC;GAC3BL,YAAYI,YAAYC,oBAAoBC,kBAAkBN,UAAlB,EAA8Bjd,KAA9B,EAAqCrR,EAArC;cAGjC2C,IAAI0rB,WAAWC;SAEpB,CAAEI,UAAF,EAAcC,gBAAd;AACT;;2BAGEL,YACAjd,OACArR,IACkD;QAC5C6uB,OAAMjgB,KAAKC,GAAL;;MACRyf,cAAcO,OAAMP,WAAWQ,QAAjB,IAA6BX,wBAAwB;eAE1Drf;eACAggB,WAAWD;EAAA,OACjB;iBAEQ;MAAE/f,OAAO,CAAT;MAAYggB,UAAUD,IAAtB;MAA2B7uB;IAA3B;;;QAGT+uB,WAAW;IACfnf,MAAMof,MADS;IAEfC,SAAS5d,MAAM4d,OAFA;IAGfC,SAAS7d,MAAM6d,OAHA;IAIfC,SAAS9d,MAAM8d,OAJA;IAKfC,SAAS/d,MAAM+d,OALA;IAMf1d,SAASL,MAAMK,OANA;IAOf2d,UAAUhe,MAAMge,QAPD;IAQfC,QAAQje,MAAMie,MARC;IASf7d,SAASJ,MAAMI,OATA;IAUf8d,QAAQle,MAAMke,MAVC;IAWfC,SAASne,MAAMme,OAXA;IAYfC,QAAQnB,WAAWxf;EAZJ;MAeb4f;MACAC,mBAA2C;;MAC3Ctd,iBAAiBqe,cAAc;WAC1B12B,OAAO+1B,UAAU;MACtBV,WAAWhd,MAAMgd,SADK;MAEtB70B,OAAO6X,MAAM7X,KAFS;MAGtBE,QAAQ2X,MAAM3X,MAHQ;MAItBi2B,UAAUte,MAAMse,QAJM;MAKtBC,oBAAoBve,MAAMue,kBALJ;MAMtBC,OAAOxe,MAAMwe,KANS;MAOtBC,OAAOze,MAAMye,KAPS;MAQtBC,OAAO1e,MAAM0e,KARS;MAStBC,aAAa3e,MAAM2e,WATG;MAUtBC,WAAW5e,MAAM4e;IAVK;iBAYX,IAAIP,YAAJ,CAAiB,OAAjB,EAA0BX,QAA1B;;QACTT,WAAWxf,KAAX,KAAqB,GAAG;yBACP,IAAI4gB,YAAJ,CAAiB,UAAjB,EAA6BX,QAA7B;IAAqC;SAErD;iBACQ,IAAImB,UAAJ,CAAe,OAAf,EAAwBnB,QAAxB;;QACTT,WAAWxf,KAAX,KAAqB,GAAG;yBACP,IAAIohB,UAAJ,CAAe,UAAf,EAA2BnB,QAA3B;IAAmC;;;SAInD,CAACT,UAAD,EAAaI,UAAb,EAAyBC,gBAAzB;AACT;;yBAEgCxG,QAAiC;QACzD0G,OAAMjgB,KAAKC,GAAL;QACNyL,KAAK6N,OAAOzvB,OAAP,IACRJ,OAAO,CAAC,CAACmyB,CAAD,EAAI/P,KAAJ,CAAD,KAAgBmU,OAAMnU,MAAMoU,QAAZ,GAAuBX,wBAC9Cx1B,IAAI,CAAC,CAAC01B,SAAD,EAAY5D,CAAZ,CAAD,KAAoBtC,OAAO1N,MAAP,CAAc4T,SAAd;AAC7B;;qCCjHE5E,YACAH,SACA6G,OACAC,cACAC,eACAC,WACAzwB,SACA;QACM6a,QAA8B;IAClC6V,6BAAc7rB,GAAd,EADkC;IAElC8rB,QAAQ;MACNC,mBAAmB,EADb;MAENC,mBAAmB;IAFb,CAF0B;IAMlCC,oCAAqBjY,GAArB,EANkC;IAOlCkY,2BAAYlsB,GAAZ;EAPkC;QAU9BmsB,sBAAsB;IAC1BC,aAAaC,0BADa;IAE1BC,WAAWC,wBAFe;IAG1BC,eAAeC;EAHW;;8BAMAC,cAAgC;UACpDC,aAAa3W,MAAM8V,MAAN,CAAaC,iBAAb,KAAmCW,aAAa/C;UAC7DiD,iBAAiBjB,cAAcptB,GAAd,CAAkBmuB,aAAazwB,MAA/B;UAEjB8nB,UAAU,eAAe4F,SAAf,IAA4B3T,MAAM6V,QAAlC;;QACXc,cAAc5I,OAAd,IAA2B4I,cAAc,CAACC,gBAAiB;YAExDzwB,YAAYmtB,QAAQtwB,OAAR,CAAgBgd,MAAM6V,QAAtB,EAAgC/B,IAAhC,CAAqCpa,KAAKic,cAAcptB,GAAd,CAAkBmR,EAAEzT,MAApB,CAA1C;;UACd,CAACE,WAAW;cACR2vB,SAAS;UAAEC,mBAAmB,EAArB;UAAyBC,mBAAmB;QAA5C;;;;qBAGF7vB;YACT2vB,OAAOC,oBAAoBW,aAAa/C;IAAA,OACzC;YACCkD,WAAW7W,MAAM6V,QAAN,CAAextB,GAAf,CAAmB2X,MAAM8V,MAAN,CAAaC,iBAAhC;;UACb,CAACc,UAAU;cACPf,SAAS;UAAEC,mBAAmB,EAArB;UAAyBC,mBAAmB;QAA5C;;;;qBAGFa;IAAA;;QAGbF,cAAcC,gBAAgB;YAG1BE,YAAYxD,QAAQtwB,OAAR,CAAgBgd,MAAM6V,QAAtB,EAAgC53B,GAAhC,CAAoCqC,KAAKA,EAAE2F,MAA3C;YACZ6vB,OAAOE,oBAAoBt4B,OAAOK,WAAP,CAC/B4F,MAAMic,IAAN,CAAW+V,aAAX,EACG/3B,MADH,CACU0C,KAAK,CAACw2B,UAAUhJ,QAAV,CAAmBxtB,CAAnB,CADhB,EAEG1C,MAFH,CAEU0C;;;QAAK,wBAAWA,CAAX,yBAAe+W,SAAf;MAAwB,CAFvC,EAGGpZ,GAHH,CAGOqC,KAAK,CAACA,CAAD,EAAIy2B,oBAAoBnI,QAAQ1pB,KAA5B,EAAmC5E,CAAnC,CAAJ,CAHZ,CAD+B;mBAMpB02B,mBAAmB5wB,mBAAKswB,aAAaO,cAAlB;mBACnBC,mBAAmBH,oBAAoBnI,QAAQ1pB,KAA5B,EAAmCwxB,aAAazwB,MAAhD;IAAsD;;;QAIpF0vB,eAAeve,YAAY;UACzBsf,eAAe1W,MAAM6V,QAAN,CAAextB,GAAf,CAAmB2X,MAAM8V,MAAN,CAAaC,iBAAhC;;QACjBW,cAAc;yBACGA;IAAY;;QAE7Btf,SAAS/P,IAAT,GAAgB,CAAhB,IAAqBouB,MAAM0B,aAAN,CAAoB36B,KAApB,KAA8B,QAAQ;YACvD26B,cAAc36B,QAAQ;IAAA,WACnB4a,SAAS/P,IAAT,KAAkB,CAAlB,IAAuBouB,MAAM0B,aAAN,CAAoB36B,KAApB,KAA8B,MADlC,EAC0C;YAChE26B,cAAc36B,QAAQ;IAAA;EAE/B;QAEKi5B,MAAM0B,eAAeC,QAAQ;QAC7BA,SAAS,QAAQ;oBACLrvB;;EAEjB;;qCAEkC2uB,cAAgC/f,OAAwB;UACnFyL,KAAKsU,aAAaM,gBAAb,CAA8Bx3B,CAA9B,GAAkCmX,MAAM0gB;UAC7ChV,KAAKqU,aAAaM,gBAAb,CAA8Br3B,CAA9B,GAAkCgX,MAAM2gB;UAC7CjyB,YACJ2a,MAAM8V,MAAN,CAAaC,iBAAb,IAAkCW,aAAa/C,SAA/C,GACIvtB;MAAA,CACGswB,aAAazwB,MADhB,GACyBywB,aAAaQ;IADtC,GAEKlX,MAAM8V,MAAN,CAAaE,iBAFlB,CADJ,GAKI;MAAA,CAAGU,aAAazwB,MAAhB,GAAyBywB,aAAaQ;IAAtC;UACA7E,IAAIuD,UAAUp5B;WAEbkB,OAAOK,WAAP,CACLL,OAAOM,OAAP,CAAeqH,SAAf,EAA0BpH,GAA1B,CAA8B,CAAC,CAACO,IAAD,EAAO+G,GAAP,CAAD,KAAiB,CAC7C/G,IAD6C,EAE7C;MACEgB,GAAG+F,IAAI/F,CAAJ,GAAQ4iB,KAAKiQ,CADlB;MAEE1yB,GAAG4F,IAAI5F,CAAJ,GAAQ0iB,KAAKgQ;IAFlB,CAF6C,CAA/C,CADK;EAQP;;gCAG4B7zB,MAAcmY,OAAmB;;;QACzDA,MAAM4gB;;QAKN5gB,MAAMge,QAAN,IAAkB,CAAC,CAAC,WAAD,EAAc,MAAd,EAAsB7G,QAAtB,CAA+B2H,MAAM0B,aAAN,CAAoB36B,KAAnD,GAA2D;;;;UAG5E26B,cAAc36B,QAAQ;UAEtB8a,aAAa,uBAAW9Y,IAAX,yBAAkB8Y,UAAlB,iBAAgC;;QAC/CA,YAAY;YACRkgB,yBACJlE,QAAQtwB,OAAR,CAAgBgd,MAAM6V,QAAtB,EAAgCj4B,MAAhC,CAAuC8b,KAAKic,cAAcptB,GAAd,CAAkBmR,EAAEzT,MAApB,CAA5C,EAAyEnI,MAAzE,GAAkF;;UAChF6Y,MAAMge,QAAN,IAAkB6C,wBAAwB;YAExC7B,cAAcptB,GAAd,CAAkB/J,IAAlB,GAAyB;wBACbuhB,OAAOvhB;QAAI,WAChB,SAAS8Y,UAAT,KAAwB,QAAxB,IAAoCqe,cAActuB,IAAd,IAAsBiQ,UAA1D,CADgB,EACuD;wBAClEqD,IAAInc;QAAI;iBAEf,CAACm3B,cAAcptB,GAAd,CAAkB/J,IAAlB,GAAyB;sBAErBuJ;sBACA4S,IAAInc;MAAI;;;YAGlBi5B,KAAK,cAAc;MAAEj5B,IAAF;MAAQmY;IAAR;EAAe;;sCAGRnY,MAAcmY,OAAmB;QAC/DA,MAAM4gB;YACFE,KAAK,iBAAiB;MAAEj5B,IAAF;MAAQmY;IAAR;EAAe;;sCAGXA,OAAqB;;;UACjD+gB;UAEAhB,eAAe1W,MAAM6V,QAAN,CAAextB,GAAf,CAAmBsO,MAAMgd,SAAzB;;QACjB,CAAC+C,cAAc;;;;iBAGNO,iBAAiB;MAAEz3B,GAAGmX,MAAM0gB,KAAX;MAAkB13B,GAAGgX,MAAM2gB;IAA3B;iBACjBK;UAEPC,YAAYC,iCAAiClhB,MAAM2e,WAAvC;;QACdoB,aAAaiB,WAAb,IAA4BC,WAAW;;;;QAIvC,EAAC,iBAAWlB,aAAazwB,MAAxB,yBAAiCoR,SAAlC,GAA6C;;;;QAI7Cqf,aAAaiB,WAAb,KAA6BC,YAAY,GAAG;YACxCE,iBAAgBC,0BAA0BrB,YAA1B,EAAwC;QAC5D/C,WAAW+C,aAAa/C,SADoC;QAE5D0D,OAAOX,aAAaM,gBAAb,CAA8Bx3B,CAFuB;QAG5D83B,OAAOZ,aAAaM,gBAAb,CAA8Br3B;MAHuB,CAAxC;;cAKd83B,KAAK,kBAAkBK;IAAa;;UAExCE,gBAAgBD,0BAA0BrB,YAA1B,EAAwC/f,KAAxC;;YACd8gB,KAAK,oBAAoBO;EAAa;;wCAGVrhB,OAAqB;UACnD+gB;QAEFhB,eAAe1W,MAAM6V,QAAN,CAAextB,GAAf,CAAmBsO,MAAMgd,SAAzB;;QACf,CAAC+C,cAAc;;;;SAIdA,gBAAgB1W,MAAM6V,QAAN,CAAel4B,MAAf,IAAyB;YACtCa,OAAOk4B,aAAazwB;YAEpB2xB,YAAYC,iCAAiClhB,MAAM2e,WAAvC;YACZ2C,UAAUvB,aAAaiB,WAAb,GAA2BC;;UACvCK,SAAS;cAELD,gBAAgBD,0BAA0BrB,YAA1B,EAAwC;UAC5D/C,WAAW+C,aAAa/C,SADoC;UAE5D0D,OAAOX,aAAaO,cAAb,CAA4Bz3B,CAFyB;UAG5D83B,OAAOZ,aAAaO,cAAb,CAA4Bt3B;QAHyB,CAAxC;;gBAKd83B,KAAK,gBAAgBO;MAAa;;cAEpCP,KAAK,kBAAkB;QAAEj5B,IAAF;QAAQmY;MAAR;IAAe;;UAI1Ckf,SAAS9tB;UACT+tB,SAAS;MAAEC,mBAAmB,EAArB;MAAyBC,mBAAmB;IAA5C;cACLG,qBAAqBja,QAAQ,CAAC,CAACgc,EAAD,EAAKC,OAAL,CAAD,KAAmB;eAC/CC,oBAAoBF,IAAIC;IAClC;UACKE,SAAS77B,QAAQ;EAAA;;oCAGSma,OAAqB;;;UAC/C+gB;UAEAhB,eAAe1W,MAAM6V,QAAN,CAAextB,GAAf,CAAmBsO,MAAMgd,SAAzB;;QACjB,CAAC+C,cAAc;;;;UAIbb,SAAS9V,OAAOpJ,MAAMgd;UAEtBn1B,OAAOk4B,aAAazwB;UAEpB2xB,YAAYC,iCAAiClhB,MAAM2e,WAAvC;UACZ2C,UAAUvB,aAAaiB,WAAb,GAA2BC;;QACvCK,SAAS;UACP,iBAAWvB,aAAazwB,MAAxB,yBAAiCoR,WAAW;cACxC2gB,gBAAgBD,0BAA0BrB,YAA1B,EAAwC/f,KAAxC;;gBACd8gB,KAAK,gBAAgBO;gBACrBP,KAAK,kBAAkB;UAAEj5B,IAAF;UAAQmY;QAAR;MAAe;WAE3C;cACG8gB,KAAK,kBAAkB;QAAEj5B,IAAF;QAAQmY;MAAR;IAAe;;QAG5C,CAACshB,SAAuE;YAEpE,CAACjE,UAAD,EAAaC,gBAAb,IAAiCqE,aACrCtY,MAAMkW,MAD+B,EAErCQ,aAAa/C,SAFwB,EAGrCn1B,IAHqC,EAIrCmY,KAJqC;yBAM1B4hB,mCAAaC,aAAb,CAA2BxE,UAA3B;;UACTC,kBAAkB;2BACPsE,mCAAaC,aAAb,CAA2BvE,gBAA3B;MAA2B;;;QAIxCjU,MAAM6V,QAAN,CAAexuB,IAAf,KAAwB,GAAG;YAEvByuB,SAAS;QAAEC,mBAAmB,EAArB;QAAyBC,mBAAmB;MAA5C;gBACLG,qBAAqBja,QAAQ,CAAC,CAACgc,EAAD,EAAKC,OAAL,CAAD,KAAmB;iBAC/CC,oBAAoBF,IAAIC;MAClC;sBACenY,MAAMkW;YAChBmC,SAAS77B,QAAQ;IAAA,OAClB;yBACck6B;IAAY;;iBAIpB3uB;UACPkuB,gBAAgB/Z,QAAQwZ,aAAa/a,KAAK+a;EAAY;;sCAG1Bl3B,MAAcmY,OAAqB;QACjEA,MAAMke,MAAN,IAAgB,GAAsB;;;;UAGpC6C;;QAEF,CAAC,CAAC,SAAD,EAAY,MAAZ,EAAoB5J,QAApB,CAA6B2H,MAAM4C,QAAN,CAAe77B,KAA5C,GAAoD;;;;QAIrDwjB,MAAM6V,QAAN,CAAexuB,IAAf,IAAuB,GAAG;YAEtBgxB,SAAS77B,QAAQ;gBACb25B,qBAAqBja,QAAQ,CAAC,CAACgc,EAAD,EAAKC,OAAL,CAAD,KAAmB;iBAC/CM,iBAAiBP,IAAIC;MAC/B;IAAA;;UAIGzB,eAAiC;MACrC/C,WAAWhd,MAAMgd,SADoB;MAErC1tB,QAAQzH,IAF6B;MAGrCm5B,aAAa,CAHwB;MAIrCT,kBAAkBH,oBAAoBnI,QAAQ1pB,KAA5B,EAAmC1G,IAAnC,CAJmB;MAKrCw4B,kBAAkB;QAAEx3B,GAAGmX,MAAM0gB,KAAX;QAAkB13B,GAAGgX,MAAM2gB;MAA3B,CALmB;MAMrCL,gBAAgB;QAAEz3B,GAAGmX,MAAM0gB,KAAX;QAAkB13B,GAAGgX,MAAM2gB;MAA3B,CANqB;MAOrCiB,aAAa5hB,MAAM+hB;IAPkB;UASjC7C,SAAS5tB,IAAI0O,MAAMgd,WAAW+C;;QAEhCf,cAAcptB,GAAd,CAAkB/J,IAAlB,GAAyB;UACvBwhB,MAAM8V,MAAN,CAAaC,iBAAb,GAAiC,GAAG;cAEhCD,OAAOC,oBAAoBpf,MAAMgd;;2BACpB+C;MAAY,OAC1B;eAGE1W,MAAM8V,MAAN,CAAaE,iBAAb,CAA+BU,aAAazwB,MAA5C;MAA4C;;;YAI/CwxB,KAAK,oBAAoB;MAAEj5B,IAAF;MAAQmY;IAAR;EAAe;;sCAGdnY,MAAcmY,OAAqB;UAC/Dsf,gBAAgBtb,IAAInc;;QACtBwhB,MAAM6V,QAAN,CAAexuB,IAAf,GAAsB,GAAG;;;;iBAGhBsT,IAAInc;YACTi5B,KAAK,oBAAoB;MAAEj5B,IAAF;MAAQmY;IAAR;EAAe;;qCAGfnY,MAAcmY,OAAqB;UAC9Dsf,gBAAgBlW,OAAOvhB;;QACzBwhB,MAAM6V,QAAN,CAAexuB,IAAf,GAAsB,GAAG;;;;iBAGhB0Y,OAAOvhB;YACZi5B,KAAK,mBAAmB;MAAEj5B,IAAF;MAAQmY;IAAR;EAAe;;iCAGlBnY,MAAcmY,OAAmB;UACxD+gB;YACED,KAAK,oBAAoB;MAAEj5B,IAAF;MAAQmY;IAAR;EAAe;;SAG3C;IACLgiB,0BADK;IAELC,0BAFK;IAGLC,yBAHK;IAILC,oBAJK;IAKLC,0BALK;IAMLC;EANK;AAQT;;AAEA,6BAA6B9zB,KAA7B,EAA6D1G,IAA7D,EAA2E;;;QACnE+G,MAAM,YAAM/G,IAAN,kBAAe;IAAEgB,GAAG,CAAL;IAAQG,GAAG;EAAX;SACpByG,mBAAKb,GAAL;AACT;;qCCjWEmqB,YACA+F,OACAwD,cACAC,eACA/zB,SACA;QACM6a,QAAQ;IACZ6V,6BAAc7rB,GAAd,EADY;IAEZmvB,kBAAkB,CAFN;IAGZjD,2BAAYlsB,GAAZ;EAHY;QAMRovB,sBAAsB;IAC1B9C,WAAW+C,wBADe;IAE1B7C,eAAe8C;EAFW;QAKtBJ,eAAe9hB,YAAY;QAC3BA,SAAS/P,IAAT,GAAgB,CAAhB,IAAqBouB,MAAM0B,aAAN,CAAoB36B,KAApB,KAA8B,QAAQ;YACvD26B,cAAc36B,QAAQ;IAAA,WACnB4a,SAAS/P,IAAT,KAAkB,CAAlB,IAAuBouB,MAAM0B,aAAN,CAAoB36B,KAApB,KAA8B,MADlC,EAC0C;YAChE26B,cAAc36B,QAAQ;IAAA;EAE/B;QAEKi5B,MAAM0B,eAAeC,QAAQ;QAC7BA,SAAS,QAAQ;oBACLrvB;;EAEjB;;sCAEmCyQ,MAAc7B,OAAqB;QACjEA,MAAMke,MAAN,IAAgB,GAAsB;;;;UAGpC6C;;QAEF,CAAC,CAAC,SAAD,EAAY,MAAZ,EAAoB5J,QAApB,CAA6B2H,MAAM4C,QAAN,CAAe77B,KAA5C,GAAoD;;;;QAIrDwjB,MAAM6V,QAAN,CAAexuB,IAAf,IAAuB,GAAG;YAEtBgxB,SAAS77B,QAAQ;gBACb48B,qBAAqBld,QAAQ,CAAC,CAACgc,EAAD,EAAKC,OAAL,CAAD,KAAmB;iBAC/CM,iBAAiBP,IAAIC;MAC/B;YACKgB,mBAAmB;IAAA;;UAGrBA;UAGAzC,eAAiC;MACrC/C,WAAWhd,MAAMgd,SADoB;MAErCruB,IAAIkT,IAFiC;MAGrC+f,aAAa5hB,MAAM+hB;IAHkB;UAKjC7C,SAAS5tB,IAAI0O,MAAMgd,WAAW+C;YAE5Be,KAAK,oBAAoB8B,qBAAqB/gB,IAArB,EAA2B7B,KAA3B;EAAiC;;oCAGlCA,OAAqB;;;UAC/C+gB;UAEAhB,eAAe1W,MAAM6V,QAAN,CAAextB,GAAf,CAAmBsO,MAAMgd,SAAzB;;QACjB,CAAC+C,cAAc;;;;UAIbb,SAAS9V,OAAOpJ,MAAMgd;UAEtBnb,OAAOke,aAAapxB;YAClBmyB,KAAK,kBAAkB8B,qBAAqB/gB,IAArB,EAA2B7B,KAA3B;UAGzB,CAACqd,UAAD,EAAaC,gBAAb,IAAiCqE,aACrCtY,MAAMkW,MAD+B,EAErCQ,aAAa/C,SAFwB,EAGrCnb,gBAAgB7U,KAAhB,GAAwB6U,KAAKtY,IAAL,CAAU,GAAV,CAAxB,GAAyCsY,IAHJ,EAIrC7B,KAJqC;uBAM1B4hB,mCAAaC,aAAb,CAA2BxE,UAA3B;;QACTC,kBAAkB;yBACPsE,mCAAaC,aAAb,CAA2BvE,gBAA3B;IAA2B;;QAGtCjU,MAAM6V,QAAN,CAAexuB,IAAf,KAAwB,GAAG;YAEvB8xB,mBAAmB;gBACfC,qBAAqBld,QAAQ,CAAC,CAACgc,EAAD,EAAKC,OAAL,CAAD,KAAmB;iBAC/CC,oBAAoBF,IAAIC;MAClC;sBACenY,MAAMkW;YAChBmC,SAAS77B,QAAQ;IAAA;;;wCAIWma,OAAqB;UACnD+gB;UAEAhB,eAAe1W,MAAM6V,QAAN,CAAextB,GAAf,CAAmBsO,MAAMgd,SAAzB;;QACjB,CAAC+C,cAAc;;;;eAIR8C,iBAAgBxZ,MAAM6V,QAAN,CAAel4B,MAAf,IAAyB;YAC5C6a,OAAOghB,cAAal0B;cAClBmyB,KAAK,kBAAkB8B,qBAAqB/gB,IAArB,EAA2B7B,KAA3B;IAAiC;;UAI5Dkf,SAAS9tB;UACToxB,mBAAmB;cACfC,qBAAqBld,QAAQ,CAAC,CAACgc,EAAD,EAAKC,OAAL,CAAD,KAAmB;eAC/CC,oBAAoBF,IAAIC;IAClC;YACOV,KAAK,aAAa;EAAS;;gCAGPjf,MAAyB7B,OAAmB;;;QACpEA,MAAM4gB;;QAKN5gB,MAAMge,QAAN,IAAkB,CAAC,CAAC,WAAD,EAAc,MAAd,EAAsB7G,QAAtB,CAA+B2H,MAAM0B,aAAN,CAAoB36B,KAAnD,GAA2D;;;;UAG5E26B,cAAc36B,QAAQ;UAEtBqd,QAAQrB,gBAAgB7U,KAAhB,GAAwB6U,IAAxB,GAA+B,CAACA,IAAD;UAEvCihB,yBACJnG,QAAQtwB,OAAR,CAAgBgd,MAAM6V,QAAtB,EAAgCj4B,MAAhC,CAAuC8b,KAAK;YACpC6G,SAAQ7G,EAAEpU,EAAF,YAAgB3B,KAAhB,GAAwB+V,EAAEpU,EAA1B,GAA+B,CAACoU,EAAEpU,EAAH;aACtCib,OAAMmZ,KAAN,CAAYpY,SAAQ4X,cAAc3wB,GAAd,CAAkB+Y,KAAlB,CAApB;IACR,CAHD,EAGGxjB,MAHH,GAGY;;QAEV0a,gBAAgB7U,OAAO;YAEnBg2B,kBAAkB9f,MAAMia,IAAN,CAAWxS;;;QAAQ,yBAAWA,KAAX,0BAAkBhK,UAAlB;MAA4B,CAA/C;;UACpBqiB,iBAAiB;YACfhjB,MAAMge,QAAN,IAAkB8E,wBAAwB;cACxC5f,MAAM+f,IAAN,CAAWtY,SAAQ4X,cAAc3wB,GAAd,CAAkB+Y,KAAlB,CAAnB,GAA6C;kBACzCpF,QAAQoF,SAAQ4X,cAAcnZ,MAAd,CAAqBuB,KAArB;UAA0B,OAC3C;kBACCpF,QAAQoF,SAAQ;;;oBACdhK,aAAa,kBAAWgK,KAAX,0BAAkBhK;;kBACjC,SAASA,UAAT,KAAwB,QAAxB,IAAoC4hB,cAAc7xB,IAAd,IAAsBiQ,UAA1D,GAAuE;8BAC3DqD,IAAI2G;cAAI;YAEzB;UAAA;eAEE;wBAESvZ;gBACRmU,QAAQoF,SAAQ4X,cAAcve,GAAd,CAAkB2G,KAAlB;QAAuB;;WAG5C;YACChK,aAAa,iBAAWkB,IAAX,yBAAkBlB;;UACjCA,YAAY;YACVX,MAAMge,QAAN,IAAkB8E,wBAAwB;cACxCP,cAAc3wB,GAAd,CAAkBiQ,IAAlB,GAAyB;0BACbuH,OAAOvH;UAAI,WAChB,SAASlB,UAAT,KAAwB,QAAxB,IAAoC4hB,cAAc7xB,IAAd,IAAsBiQ,UAA1D,CADgB,EACuD;0BAClEqD,IAAInC;UAAI;mBAEf,CAAC0gB,cAAc3wB,GAAd,CAAkBiQ,IAAlB,GAAyB;wBAErBzQ;wBACA4S,IAAInC;QAAI;;;;YAIpBif,KAAK,cAAc8B,qBAAqB/gB,IAArB,EAA2B7B,KAA3B;EAAiC;;sCAG1B6B,MAAyB7B,OAAmB;QAC1EA,MAAM4gB;YACFE,KAAK,iBAAiB8B,qBAAqB/gB,IAArB,EAA2B7B,KAA3B;EAAiC;;sCAG7B6B,MAAc7B,OAAqB;iBACxDgE,IAAInC;YACTif,KAAK,oBAAoB8B,qBAAqB/gB,IAArB,EAA2B7B,KAA3B;EAAiC;;qCAGjC6B,MAAc7B,OAAqB;iBACvDoJ,OAAOvH;YACZif,KAAK,mBAAmB8B,qBAAqB/gB,IAArB,EAA2B7B,KAA3B;EAAiC;;iCAGpC6B,MAAc7B,OAAmB;UACxD+gB;YACED,KAAK,oBAAoB8B,qBAAqB/gB,IAArB,EAA2B7B,KAA3B;EAAiC;;uCAG/BkD,OAAiBlD,OAAqB;QACrEA,MAAMke,MAAN,IAAgB,GAAsB;;;;UAGpC6C;;QAEF,CAAC,CAAC,SAAD,EAAY,MAAZ,EAAoB5J,QAApB,CAA6B2H,MAAM4C,QAAN,CAAe77B,KAA5C,GAAoD;;;;QAIrDwjB,MAAM6V,QAAN,CAAexuB,IAAf,IAAuB,GAAG;YAEtBgxB,SAAS77B,QAAQ;gBACb48B,qBAAqBld,QAAQ,CAAC,CAACgc,EAAD,EAAKC,OAAL,CAAD,KAAmB;iBAC/CM,iBAAiBP,IAAIC;MAC/B;YACKgB,mBAAmB;IAAA;;UAGrBA;UAGAzC,eAAiC;MACrC/C,WAAWhd,MAAMgd,SADoB;MAErCruB,IAAIuU,KAFiC;MAGrC0e,aAAa5hB,MAAM+hB;IAHkB;UAKjC7C,SAAS5tB,IAAI0O,MAAMgd,WAAW+C;YAC5Be,KAAK,oBAAoB8B,qBAAqB1f,KAArB,EAA4BlD,KAA5B;EAAkC;;uCAGhCkD,OAAiBlD,OAAqB;UACnEuF,QAAQ1D,QAAQygB,aAAate,GAAb,CAAiBnC,IAAjB;YACdif,KAAK,oBAAoB8B,qBAAqB1f,KAArB,EAA4BlD,KAA5B;EAAkC;;sCAGjCkD,OAAiBlD,OAAqB;UAClEuF,QAAQ1D,QAAQygB,aAAalZ,MAAb,CAAoBvH,IAApB;YACdif,KAAK,mBAAmB8B,qBAAqB1f,KAArB,EAA4BlD,KAA5B;EAAkC;;iCAGrCkD,OAAiBlD,OAAmB;yBAC5CkD,OAAOlD;EAAK;;uCAGEkD,OAAiBlD,OAAmB;+BAC5CkD,OAAOlD;EAAK;;kCAGTkD,OAAiBlD,OAAmB;UAC5D+gB;YACED,KAAK,oBAAoB8B,qBAAqB1f,KAArB,EAA4BlD,KAA5B;EAAkC;;SAG9D;IACLkjB,0BADK;IAELC,0BAFK;IAGLC,yBAHK;IAILC,oBAJK;IAKLC,0BALK;IAMLC,qBANK;IAOLC,2BAPK;IAQLC,2BARK;IASLC,0BATK;IAULC,qBAVK;IAWLC,2BAXK;IAYLC;EAZK;AAcT;;AAEA,8BAA+ChiB,IAA/C,EAAwE7B,KAAxE,EAAgG;MAC1F6B,gBAAgB7U,OAAO;WAClB;MACLkW,OAAOrB,IADF;MAEL7B,KAFK;MAGLuC,YAAY;IAHP;SAKF;WACE;MACLV,IADK;MAELqB,OAAO,CAACrB,IAAD,CAFF;MAGL7B,KAHK;MAILuC,YAAY;IAJP;;AAOX;;2CCjSE/b,WACAs4B,OACAgF,uBACAt1B,SACA;QACM6a,QAAQ;IACZ2X,aAAa,CADD;IAEZ+C,gBAAgB,CAFJ;IAGZ9G,YAAY;EAHA;QAQR+G,2BAA2B;IAC/BvE,aAAawE,+BADkB;IAE/BtE,WAAWuE,6BAFoB;IAG/BrE,eAAeqE;EAHgB;;2CAMQ9K,GAAiB;UAClD4H,cAAc;;QAChB3X,MAAM0a,cAAN,KAAyB,GAAG;gBAEpBC,0BAA0Bze,QAAQ,CAAC,CAACgc,EAAD,EAAKC,OAAL,CAAD,KAAmB;iBACpDM,iBAAiBP,IAAIC,SAAS;UAAE2C,SAAS;QAAX;MACxC;IAAA;;UAEGJ;EAAA;;2CAGiC3K,GAAiB;UAClD4H;EAAA;;yCAG+BhhB,OAAqB;UACpD+jB;;QACF1a,MAAM0a,cAAN,IAAwB,GAAG;YACvBA,iBAAiB;gBAEbC,0BAA0Bze,QAAQ,CAAC,CAACgc,EAAD,EAAKC,OAAL,CAAD,KAAmB;iBACpDC,oBAAoBF,IAAIC;MAClC;YACKP,YAAYC,iCAAiClhB,MAAM2e,WAAvC;;UACdtV,MAAM2X,WAAN,IAAqBC,WAAW;YAE9BjhB,MAAMge,QAAN,IAAkBc,MAAM0B,aAAN,CAAoB36B,KAApB,KAA8B,aAAa;;;;cAG3D26B,cAAc36B,QAAQ;cAGtB,CAACo3B,UAAD,EAAaI,UAAb,EAAyBC,gBAAzB,IAA6CC,kBACjDlU,MAAM4T,UAD2C,EAEjDjd,KAFiD,EAGjD,MAHiD;cAK7Cid,aAAaA;kBACTp3B,MAAOg8B,cAAcxE;;YAC3BC,kBAAkB;oBACVz3B,MAAOg8B,cAAcvE;QAAgB;;;;;qCAMpBtd,OAAmB;QAChDA,MAAM4gB;UAIJG;YACED,KAAK,cAAc;MAAE9gB;IAAF;EAAS;;2CAGGA,OAAmB;QACtDA,MAAM4gB;UACJG;YACED,KAAK,iBAAiB;MAAE9gB;IAAF;EAAS;;2CAGAA,OAAmB;YAClD8gB,KAAK,oBAAoB;MAAE9gB;IAAF;;QAE7BqJ,MAAM0a,cAAN,GAAuB,GAAG;YAEtBA,iBAAiB;gBAEbC,0BAA0Bze,QAAQ,CAAC,CAACgc,EAAD,EAAKC,OAAL,CAAD,KAAmB;;;wBACnD37B,6BAAO47B,mBAAP,CAA2BF,EAA3B,EAA+BC,OAA/B;MACX;IAAA;;;QAIC4C,iBAAkB/4B,CAAD,IAAmB;MACtC+4B;;;YAGM,MAAM;UACRrT,IAAIvqB,UAAUX;QAChB,CAACkrB;MACH+Q,iBAAiB,eAAeuC,iCAAiC;MAAEF,SAAS;IAAX;MACjErC,iBAAiB,SAASwC,2BAA2B;MAAEH,SAAS;IAAX;MACrDrC,iBAAiB,YAAYyC,iCAAiC;MAAEJ,SAAS;IAAX;MAC9DrC,iBAAiB,eAAe0C,iCAAiC;MAAEL,SAAS;IAAX;;QAC/DL,sBAAsBj+B,OAAO;QAC7Bi8B,iBAAiB,SAASsC,gBAAgB;QAAED,SAAS;MAAX;IAAkB;EAEjE;cAEW,MAAM;UACVpT,IAAIvqB,UAAUX;QAChB,CAACkrB;MACH0Q,oBAAoB,eAAe4C;MACnC5C,oBAAoB,SAAS6C;MAC7B7C,oBAAoB,YAAY8C;MAChC9C,oBAAoB,eAAe+C;;QACjCV,sBAAsBj+B,OAAO;QAC7B47B,oBAAoB,SAAS2C;IAAc;EAEhD;QAEKN,uBAAuB,CAACtiB,OAAD,EAAUijB,GAAV,KAAkB;UACvC1T,IAAIvqB,UAAUX;QAChB,CAACkrB,CAAD,IAAMvP,YAAYijB;;QAElBjjB,SAAS;QACTsgB,iBAAiB,SAASsC,gBAAgB;QAAED,SAAS;MAAX;IAAkB,OACzD;QACH1C,oBAAoB,SAAS2C;IAAc;EAEhD;AACH;;qCC/HE9K,YACAwF,OACA4F,cACAC,eACAC,8BACAp2B,SACA;QACM6a,QAAQ;IACZ6V,6BAAc7rB,GAAd,EADY;IAEZmvB,kBAAkB,CAFN;IAGZjD,2BAAYlsB,GAAZ;EAHY;;gCAMiCqP,MAAc1C,OAAwB;;;QAC/E4kB,6BAA6B/+B,OAAO;aAC/B;QAAE6c,MAAO,uBAAWA,IAAX,yBAAkBA,IAAlB,iBAA0BA,IAAnC;QAAiD1C;MAAjD;WACF;aACE;QAAE0C,IAAF;QAAQ1C;MAAR;;;;QAIL6kB,sBAAsB;IAC1BlF,WAAWmF,wBADe;IAE1BjF,eAAekF;EAFW;QAKtBJ,eAAelkB,YAAY;QAC3BA,SAAS/P,IAAT,GAAgB,CAAhB,IAAqBouB,MAAM0B,aAAN,CAAoB36B,KAApB,KAA8B,QAAQ;YACvD26B,cAAc36B,QAAQ;IAAA,WACnB4a,SAAS/P,IAAT,KAAkB,CAAlB,IAAuBouB,MAAM0B,aAAN,CAAoB36B,KAApB,KAA8B,MADlC,EAC0C;YAChE26B,cAAc36B,QAAQ;IAAA;EAE/B;QAEKi5B,MAAM0B,eAAeC,QAAQ;QAC7BA,SAAS,QAAQ;oBACLrvB;;EAEjB;;sCAEmCsR,MAAc1C,OAAqB;;;QACjE,EAAC,iBAAW0C,IAAX,yBAAkBC,SAAnB,GAA8B;;;;QAI9B3C,MAAMke,MAAN,IAAgB,GAAsB;;;;UAGpC6C;;QAEF,CAAC,CAAC,SAAD,EAAY,MAAZ,EAAoB5J,QAApB,CAA6B2H,MAAM4C,QAAN,CAAe77B,KAA5C,GAAoD;;;;QAIrDwjB,MAAM6V,QAAN,CAAexuB,IAAf,IAAuB,GAAG;YAEtBgxB,SAAS77B,QAAQ;gBACbg/B,qBAAqBtf,QAAQ,CAAC,CAACgc,EAAD,EAAKC,OAAL,CAAD,KAAmB;iBAC/CM,iBAAiBP,IAAIC;MAC/B;YACKgB,mBAAmB;IAAA;;UAGrBA;UAGAzC,eAAiC;MACrC/C,WAAWhd,MAAMgd,SADoB;MAErCruB,IAAI+T,IAFiC;MAGrCkf,aAAa5hB,MAAM+hB;IAHkB;UAKjC7C,SAAS5tB,IAAI0O,MAAMgd,WAAW+C;YAE5Be,KAAK,oBAAoBkE,qBAAqBtiB,IAArB,EAA2B1C,KAA3B;EAAiC;;oCAGlCA,OAAqB;;;UAC/C+f,eAAe1W,MAAM6V,QAAN,CAAextB,GAAf,CAAmBsO,MAAMgd,SAAzB;;QACjB,CAAC+C,cAAc;;;;UAIbgB;UAEA7B,SAAS9V,OAAOpJ,MAAMgd;UAEtBta,OAAOqd,aAAapxB;YAClBmyB,KAAK,kBAAkBkE,qBAAqBtiB,IAArB,EAA2B1C,KAA3B;UAGzB,CAACqd,UAAD,EAAaC,gBAAb,IAAiCqE,aACrCtY,MAAMkW,MAD+B,EAErCQ,aAAa/C,SAFwB,EAGrCta,IAHqC,EAIrC1C,KAJqC;uBAM1B4hB,mCAAaC,aAAb,CAA2BxE,UAA3B;;QACTC,kBAAkB;yBACPsE,mCAAaC,aAAb,CAA2BvE,gBAA3B;IAA2B;;QAGtCjU,MAAM6V,QAAN,CAAexuB,IAAf,KAAwB,GAAG;YAEvB8xB,mBAAmB;gBACfqC,qBAAqBtf,QAAQ,CAAC,CAACgc,EAAD,EAAKC,OAAL,CAAD,KAAmB;iBAC/CC,oBAAoBF,IAAIC;MAClC;sBACenY,MAAMkW;YAChBmC,SAAS77B,QAAQ;IAAA;;;wCAIWma,OAAqB;UACnD+f,eAAe1W,MAAM6V,QAAN,CAAextB,GAAf,CAAmBsO,MAAMgd,SAAzB;;QACjB,CAAC+C,cAAc;;;;UAIbgB;;eAEK8B,iBAAgBxZ,MAAM6V,QAAN,CAAel4B,MAAf,IAAyB;YAC5C0b,OAAOmgB,cAAal0B;cAClBmyB,KAAK,kBAAkBkE,qBAAqBtiB,IAArB,EAA2B1C,KAA3B;IAAiC;;UAI5Dkf,SAAS9tB;UACToxB,mBAAmB;cACfqC,qBAAqBtf,QAAQ,CAAC,CAACgc,EAAD,EAAKC,OAAL,CAAD,KAAmB;eAC/CC,oBAAoBF,IAAIC;IAClC;YACOV,KAAK,aAAa;EAAS;;sCAGDpe,MAAc1C,OAAqB;;;QACjE,EAAC,iBAAW0C,IAAX,yBAAkBE,SAAnB,GAA8B;;;;iBAGrBoB,IAAItB;YACToe,KAAK,oBAAoBkE,qBAAqBtiB,IAArB,EAA2B1C,KAA3B;EAAiC;;qCAGjC0C,MAAc1C,OAAqB;;;QAChE,EAAC,iBAAW0C,IAAX,yBAAkBE,SAAnB,GAA8B;;;;iBAGrBwG,OAAO1G;YACZoe,KAAK,mBAAmBkE,qBAAqBtiB,IAArB,EAA2B1C,KAA3B;EAAiC;;gCAGrC0C,MAAc1C,OAAmB;;;QACzDA,MAAM4gB;;QAKN,EAAC,iBAAWle,IAAX,yBAAkBC,SAAnB,GAA8B;;;;QAI9B3C,MAAMge,QAAN,IAAkB,CAAC,CAAC,WAAD,EAAc,MAAd,EAAsB7G,QAAtB,CAA+B2H,MAAM0B,aAAN,CAAoB36B,KAAnD,GAA2D;;;;UAG5E26B,cAAc36B,QAAQ;UAEtB8a,aAAa,uBAAW+B,IAAX,yBAAkB/B,UAAlB,iBAAgC;;QAC/CA,YAAY;YACRskB,yBACJtI,QAAQtwB,OAAR,CAAgBgd,MAAM6V,QAAtB,EAAgCj4B,MAAhC,CAAuC8b,KAAK4hB,cAAc/yB,GAAd,CAAkBmR,EAAEpU,EAApB,CAA5C,EAAqExH,MAArE,GAA8E;;UAC5E6Y,MAAMge,QAAN,IAAkBiH,wBAAwB;YAExCN,cAAc/yB,GAAd,CAAkB8Q,IAAlB,GAAyB;wBACb0G,OAAO1G;QAAI,WAChB,SAAS/B,UAAT,KAAwB,QAAxB,IAAoCgkB,cAAcj0B,IAAd,IAAsBiQ,UAA1D,CADgB,EACuD;wBAClEqD,IAAItB;QAAI;iBAEf,CAACiiB,cAAc/yB,GAAd,CAAkB8Q,IAAlB,GAAyB;sBAErBtR;sBACA4S,IAAItB;MAAI;;;YAGlBoe,KAAK,cAAckE,qBAAqBtiB,IAArB,EAA2B1C,KAA3B;EAAiC;;sCAG1B0C,MAAc1C,OAAmB;;;QAC/DA,MAAM4gB;;QACN,EAAC,iBAAWle,IAAX,yBAAkBC,SAAnB,GAA8B;;;;YAG1Bme,KAAK,iBAAiBkE,qBAAqBtiB,IAArB,EAA2B1C,KAA3B;EAAiC;;iCAGlC0C,MAAc1C,OAAmB;;;QAC1D,EAAC,iBAAW0C,IAAX,yBAAkBC,SAAnB,GAA8B;;;;UAG5Boe;YACED,KAAK,oBAAoBkE,qBAAqBtiB,IAArB,EAA2B1C,KAA3B;EAAiC;;SAG7D;IACLklB,0BADK;IAELC,0BAFK;IAGLC,yBAHK;IAILC,oBAJK;IAKLC,0BALK;IAMLC;EANK;AAQT;;ACxNA,mBAAmB/7B,KAAnB,EAA0BuT,KAA1B,EAAiC+F,GAAjC,EAAsC;EACpC,IAAI3Y,QAAQ,EAAZ;EAAA,IACI4C,UAASvD,MAAMrC,MADnB;;EAGA,IAAI4V,QAAQ,CAAZ,EAAe;IACbA,QAAQ,CAACA,KAAD,GAAShQ,OAAT,GAAkB,CAAlB,GAAuBA,UAASgQ,KAAxC;EAAwC;;EAE1C+F,MAAMA,MAAM/V,OAAN,GAAeA,OAAf,GAAwB+V,GAA9B;;EACA,IAAIA,MAAM,CAAV,EAAa;IACXA,OAAO/V,OAAP;EAAO;;EAETA,UAASgQ,QAAQ+F,GAAR,GAAc,CAAd,GAAoBA,MAAM/F,KAAN,KAAiB,CAA9C;EACAA,WAAW,CAAX;EAEA,IAAI5T,SAAS6D,MAAMD,OAAN,CAAb;;EACA,OAAO,EAAE5C,KAAF,GAAU4C,OAAjB,EAAyB;IACvB5D,OAAOgB,KAAP,IAAgBX,MAAMW,QAAQ4S,KAAd,CAAhB;EAA8B;;EAEhC,OAAO5T,MAAP;AACF;;ACvBA,IAAIq8B,aAAa78B,KAAK88B,IAAtB;AAAA,IACI5oB,cAAYlU,KAAKmU,GADrB;;AAwBA,eAAetT,KAAf,EAAsBkH,IAAtB,EAA4ByN,KAA5B,EAAmC;EACjC,IAAKA,QAAQC,eAAe5U,KAAf,EAAsBkH,IAAtB,EAA4ByN,KAA5B,CAAR,GAA6CzN,SAAS,MAA3D,EAAuE;IACrEA,OAAO,CAAP;EAAO,CADT,MAEO;IACLA,OAAOmM,YAAU/O,UAAU4C,IAAV,CAAVmM,EAA2B,CAA3BA,CAAP;EAAmC;;EAErC,IAAI9P,UAASvD,SAAS,IAAT,GAAgB,CAAhB,GAAoBA,MAAMrC,MAAvC;;EACA,IAAI,CAAC4F,OAAD,IAAW2D,OAAO,CAAtB,EAAyB;IACvB,OAAO,EAAP;;;EAEF,IAAIvG,QAAQ,CAAZ;EAAA,IACI8b,WAAW,CADf;EAAA,IAEI9c,SAAS6D,MAAMw4B,WAAWz4B,UAAS2D,IAApB,CAAN,CAFb;;EAIA,OAAOvG,QAAQ4C,OAAf,EAAuB;IACrB5D,OAAO8c,UAAP,IAAqByf,UAAUl8B,KAAV,EAAiBW,KAAjB,EAAyBA,SAASuG,IAAlC,CAArB;;;EAEF,OAAOvH,MAAP;AACF;;AC7BA,IAAIqU,MAAM,YAAW;EACnB,OAAOxT,OAAKuT,IAALvT,CAAUwT,GAAVxT,EAAP;AACF,CAFA;;AAIA,YAAewT,GAAf;ACjBA,IAAImoB,kBAAkB,qBAAtB;AAGA,IAAI9oB,YAAYlU,KAAKmU,GAArB;AAAA,IACItP,YAAY7E,KAAK8E,GADrB;;AAyDA,kBAAkBE,IAAlB,EAAwBi4B,IAAxB,EAA8BC,OAA9B,EAAuC;EACrC,IAAIC,QAAJ;EAAA,IACIC,QADJ;EAAA,IAEIC,OAFJ;EAAA,IAGI78B,MAHJ;EAAA,IAII88B,OAJJ;EAAA,IAKIC,YALJ;EAAA,IAMIC,iBAAiB,CANrB;EAAA,IAOIC,UAAU,KAPd;EAAA,IAQIC,SAAS,KARb;EAAA,IASIC,WAAW,IATf;;EAWA,IAAI,OAAO34B,IAAP,IAAe,UAAnB,EAA+B;IAC7B,MAAM,IAAI44B,SAAJ,CAAcZ,eAAd,CAAN;EAAmC;;EAErCC,OAAOl5B,SAASk5B,IAAT,KAAkB,CAAzB;;EACA,IAAIz5B,SAAS05B,OAAT,CAAJ,EAAuB;IACrBO,UAAU,CAAC,CAACP,QAAQO,OAApB;IACAC,SAAS,aAAaR,OAAtB;IACAG,UAAUK,SAASxpB,UAAUnQ,SAASm5B,QAAQG,OAAjB,KAA6B,CAAvC,EAA0CJ,IAA1C,CAAT,GAA2DI,OAArE;IACAM,WAAW,cAAcT,OAAd,GAAwB,CAAC,CAACA,QAAQS,QAAlC,GAA6CA,QAAxD;EAAwD;;EAG1D,oBAAoBE,IAApB,EAA0B;IACxB,IAAI7pB,OAAOmpB,QAAX;IAAA,IACIppB,UAAUqpB,QADd;IAGAD,WAAWC,WAAW,MAAtB;IACAI,iBAAiBK,IAAjB;IACAr9B,SAASwE,KAAKiP,KAAL,CAAWF,OAAX,EAAoBC,IAApB,CAAT;IACA,OAAOxT,MAAP;EAAO;;EAGT,qBAAqBq9B,IAArB,EAA2B;IAEzBL,iBAAiBK,IAAjB;IAEAP,UAAUQ,WAAWC,YAAX,EAAyBd,IAAzB,CAAV;IAEA,OAAOQ,UAAUO,WAAWH,IAAX,CAAV,GAA6Br9B,MAApC;EAAoC;;EAGtC,uBAAuBq9B,IAAvB,EAA6B;IAC3B,IAAII,oBAAoBJ,OAAON,YAA/B;IAAA,IACIW,sBAAsBL,OAAOL,cADjC;IAAA,IAEIW,cAAclB,OAAOgB,iBAFzB;IAIA,OAAOP,SACH74B,UAAUs5B,WAAV,EAAuBd,UAAUa,mBAAjC,CADG,GAEHC,WAFJ;EAEI;;EAGN,sBAAsBN,IAAtB,EAA4B;IAC1B,IAAII,oBAAoBJ,OAAON,YAA/B;IAAA,IACIW,sBAAsBL,OAAOL,cADjC;IAMA,OAAQD,iBAAiB,MAAjB,IAA+BU,qBAAqBhB,IAApD,IACLgB,oBAAoB,CADf,IACsBP,UAAUQ,uBAAuBb,OAD/D;EAC+D;;EAGjE,wBAAwB;IACtB,IAAIQ,OAAOhpB,OAAX;;IACA,IAAIupB,aAAaP,IAAb,CAAJ,EAAwB;MACtB,OAAOQ,aAAaR,IAAb,CAAP;IAAwB;;IAG1BP,UAAUQ,WAAWC,YAAX,EAAyBO,cAAcT,IAAd,CAAzB,CAAV;EAAsD;;EAGxD,sBAAsBA,IAAtB,EAA4B;IAC1BP,UAAU,MAAV;;IAIA,IAAIK,YAAYR,QAAhB,EAA0B;MACxB,OAAOa,WAAWH,IAAX,CAAP;IAAsB;;IAExBV,WAAWC,WAAW,MAAtB;IACA,OAAO58B,MAAP;EAAO;;EAGT,kBAAkB;IAChB,IAAI88B,YAAY,MAAhB,EAA2B;MACzBiB,aAAajB,OAAb;IAAoB;;IAEtBE,iBAAiB,CAAjB;IACAL,WAAWI,eAAeH,WAAWE,UAAU,MAA/C;EAA+C;;EAGjD,iBAAiB;IACf,OAAOA,YAAY,MAAZ,GAAwB98B,MAAxB,GAAiC69B,aAAaxpB,OAAb,CAAxC;EAA0D;;EAG5D,qBAAqB;IACnB,IAAIgpB,OAAOhpB,OAAX;IAAA,IACI2pB,aAAaJ,aAAaP,IAAb,CADjB;IAGAV,WAAWpuB,SAAX;IACAquB,WAAW,IAAX;IACAG,eAAeM,IAAf;;IAEA,IAAIW,UAAJ,EAAgB;MACd,IAAIlB,YAAY,MAAhB,EAA2B;QACzB,OAAOmB,YAAYlB,YAAZ,CAAP;MAA+B;;MAEjC,IAAIG,MAAJ,EAAY;QAEVa,aAAajB,OAAb;QACAA,UAAUQ,WAAWC,YAAX,EAAyBd,IAAzB,CAAV;QACA,OAAOe,WAAWT,YAAX,CAAP;MAA8B;;;IAGlC,IAAID,YAAY,MAAhB,EAA2B;MACzBA,UAAUQ,WAAWC,YAAX,EAAyBd,IAAzB,CAAV;IAAuC;;IAEzC,OAAOz8B,MAAP;EAAO;;EAETk+B,UAAUC,MAAV,GAAmBA,MAAnB;EACAD,UAAUE,KAAV,GAAkBA,KAAlB;EACA,OAAOF,SAAP;AACF;;0CCzLE5gC,KACAC,UACA8gC,aACO;;;QACDjV,QAAQ9rB,IAAIghC,cAAJ;QACR5+B,IAAI2+B,YAAY3+B;QAChBG,IAAIw+B,YAAYx+B;QAChB0+B,WAAWnV,MAAMoV,eAAN,CAAsB,eAASC,MAAT,0BAAmBC,OAAnB,EAAtB;SACV;IAAEh/B,GAAG6+B,SAAS7+B,CAAd;IAAiBG,GAAG0+B,SAAS1+B;EAA7B;AACT;;0CAGEvC,KACAC,UACA8gC,aACO;QACDjV,QAAQ9rB,IAAIghC,cAAJ;QACR5+B,IAAI2+B,YAAY3+B;QAChBG,IAAIw+B,YAAYx+B;QAChB8+B,WAAWvV,MAAMoV,eAAN,CAAsBjhC,SAASkhC,MAAT,EAAtB;SACV;IAAE/+B,GAAGi/B,SAASj/B,CAAd;IAAiBG,GAAG8+B,SAAS9+B;EAA7B;AACT;;iCCIExC,WACAs4B,OACA7G,SACAG,YACA4G,eACAp3B,SACA;QACMmgC,wBAAwBzQ,SAC5B,MAAM,CAAC,CAAC1vB,QAAQC,IAAR,CAAa8Y,UAAf,IAA6B/Y,QAAQ2W,IAAR,CAAaQ,mBADpB;QAGxBipB,qBAAqB1Q,SAAS,MAAMwH,MAAM4C,QAAN,CAAe77B,KAAf,KAAyB,eAAxC;QAKrBa,WAAWoyB;QACXmP,eAAenP;QACfhC,SAAS;IACboI,6BAAc7X,GAAd,EADa;IAEbwD,2BAAYxX,GAAZ,EAFa;IAGb60B,YAAY,IAHC;IAIbC,iDAAkC9gB,GAAlC,EAJa;IAKb+gB,eAAe,QALF;IAMbvC,SAAS;MAEPwC,aAAa,WAFN;MAGPD,eAAe,QAHR;MAIPE,2BAA2B;IAJpB;EANI;QAkBTC,uBAAuBC,SAC3B,MAAM;0BAEFliC,QAAQE,UAAUX,KAAlB,EAAyB,WAAzB,GACAS,QAAQI,SAASb,KAAjB,EAAwB,UAAxB,GACAoiC,cACAhQ,QAAQ1pB,OACR6pB,YACA4G,eACAlI,OAAOqR,8BACPrR,OAAOsR;EACT,CAXyB,EAa3B,EAb2B,EAc3B;IAAEpC,SAAS;EAAX,CAd2B;QAoBvByC,sBAAsB,IAAIC,qBAAJ,CAC1BliC,SAD0B,EAE1BmiC,sBAF0B,EAG1BC,oBAH0B,EAI1BC,sBAJ0B,EAK1BC,gBAL0B,EAM1BC,kBAN0B;;4BASF/oB,OAAmB;QACvC8W,OAAO+O,OAAP,CAAewC,WAAf,KAA+B;QAC/BvR,OAAOoI,QAAP,CAAgBxuB,IAAhB,GAAuB;UAErB6hB,QAAQ;MAAE1pB,GAAGmX,MAAMgpB,OAAX;MAAoBhgC,GAAGgX,MAAMipB;IAA7B;;QACVnS,OAAOoR,UAAP,IAAqB9a,SAASiB,UAAT,CAAoByI,OAAOoR,UAA3B,EAAuCva,QAAvC,CAAgD4E,KAAhD,IAAyD,IAAI;;;;;;;kCAMxDvS,OAAqB;UAC7C+gB;UAEAxO,QAAQ;MAAE1pB,GAAGmX,MAAMgpB,OAAX;MAAoBhgC,GAAGgX,MAAMipB;IAA7B;;QACVnS,OAAOoI,QAAP,CAAgBxuB,IAAhB,KAAyB,GAAG;aACvBw3B,aAAa3V;0BAEAnkB;aAEb+5B,6BAA6B/2B;oBACtBmU,QAAQjW,UAAUwnB,OAAOqR,4BAAP,CAAoCnkB,GAApC,CAAwC1U,MAAxC;;UAC5BwnB,OAAO+O,OAAP,CAAeyC,yBAAf,KAA6C,QAAQ;eAChDF,gBAAgBtR,OAAO+O,OAAP,CAAeuC;MAAA,OACjC;eACEA,gBAAgBpoB,MAAMge,QAAN,GACnBlH,OAAO+O,OAAP,CAAeyC,yBADI,GAEnBxR,OAAO+O,OAAP,CAAeuC;MAAA;;;QAGnB,CAACtR,OAAOoI,QAAP,CAAgBttB,GAAhB,CAAoBoO,MAAMgd,SAA1B,GAAsC;aAClCkC,SAASlb,IAAIhE,MAAMgd;IAAS;;WAE9BnS,OAAOvZ,IAAI0O,MAAMgd,WAAWzK;;;;gCAIPvS,OAAqB;WAC1Ckf,SAAS9V,OAAOpJ,MAAMgd;;QACzBlG,OAAOoI,QAAP,CAAgBxuB,IAAhB,KAAyB,GAAG;YACxB6gB,OAAOjrB,QAAQE,UAAUX,KAAlB,EAAyBqjC,qBAAzB;YACP3W,QAAQ;QAAE1pB,GAAGmX,MAAMnX,CAAN,GAAU0oB,KAAK1oB,CAApB;QAAuBG,GAAGgX,MAAMhX,CAAN,GAAUuoB,KAAKvoB;MAAzC;aACPk/B,aAAa3V;IAAA,WACXuE,OAAOoI,QAAP,CAAgBxuB,IAAhB,KAAyB,CADd,EACiB;0BACjBJ;;UAChBwmB,OAAO+O,OAAP,CAAewC,WAAf,KAA+B,aAAa;;;;aAGzCF,6BAA6B/2B;;;;;;kCAKR4O,OAAqB;UAC7CuR,OAAOjrB,QAAQE,UAAUX,KAAlB,EAAyBqjC,qBAAzB;UACP3W,QAAQ;MAAE1pB,GAAGmX,MAAMnX,CAAN,GAAU0oB,KAAK1oB,CAApB;MAAuBG,GAAGgX,MAAMhX,CAAN,GAAUuoB,KAAKvoB;IAAzC;WACP6hB,OAAOvZ,IAAI0O,MAAMgd,WAAWzK;;;;;8BAKTvS,OAAsB;QAC5CA,MAAMrP,GAAN,KAAc,QAAd,IAA0BmmB,OAAO+O,OAAP,CAAewC,WAAf,KAA+B,UAAU;YAC/DtH;;;;;6BAKiB;QACrBoI;QACAC;UACEC,eAAer8B,MAAMic,IAAN,CAAW6N,OAAOoI,QAAlB;;QACjBmK,aAAaliC,MAAb,IAAuB,GAAG;YACtBmiC,QAAQD,aAAa,CAAb;YACRE,OAAOF,aAAaA,aAAaliC,MAAb,GAAsB,CAAnC;aACN2vB,OAAOjM,MAAP,CAAcnZ,GAAd,CAAkB43B,KAAlB;aACAxS,OAAOjM,MAAP,CAAcnZ,GAAd,CAAkB63B,IAAlB;IAAsB,WACpBzS,OAAOoR,UAAP,IAAqBmB,aAAaliC,MAAb,KAAwB,CADzB,EAC4B;YACnDmiC,QAAQD,aAAa,CAAb;aACPvS,OAAOoR;aACPpR,OAAOjM,MAAP,CAAcnZ,GAAd,CAAkB43B,KAAlB;IAAuB,CAJD,MAKxB;aACE;aACA;IAAA;;QAELH,QAAQC,MAAM;mBAEHvjC,QAAQ;QACnB+I,KAAK;UACH/F,GAAGF,KAAK8E,GAAL,CAAS07B,KAAKtgC,CAAd,EAAiBugC,KAAKvgC,CAAtB,CADA;UAEHG,GAAGL,KAAK8E,GAAL,CAAS07B,KAAKngC,CAAd,EAAiBogC,KAAKpgC,CAAtB;QAFA,CADc;QAKnB0H,MAAM;UACJvI,OAAOQ,KAAKC,GAAL,CAASwgC,KAAKvgC,CAAL,GAASsgC,KAAKtgC,CAAvB,CADH;UAEJR,QAAQM,KAAKC,GAAL,CAASwgC,KAAKpgC,CAAL,GAASmgC,KAAKngC,CAAvB;QAFJ;MALa;;UAUjBi/B,aAAapiC,KAAb,CAAmB6K,IAAnB,CAAwBvI,KAAxB,KAAkC,GAAG;qBAC1BtC,MAAM6K,KAAKvI,QAAQ;MAAA;;UAE9B8/B,aAAapiC,KAAb,CAAmB6K,IAAnB,CAAwBrI,MAAxB,KAAmC,GAAG;qBAC3BxC,MAAM6K,KAAKrI,SAAS;MAAA;eAE1B4/B,aAAapiC,OAAO;mBAChBA,QAAQ;IAAA;;;QAOnB2jC,oBAAoB,IAAIC,iBAAJ,CACxBjjC,SADwB,EAGvBwZ,KAAD,IAA0B;QACpB,CAAC+nB,sBAAsBliC;;QACvB+B,QAAQ2W,IAAR,CAAaoB,SAAb,CAAuBI,QAAvB,CAAgCC,KAAhC,GAAwC;wBACxB;QAChB0pB,MAAM,QADU;QAEhBxhC,MAAM,QAFU;QAGhByhC,cAAc;MAHE;wBAKAv7B;;GAXE,EAevB4R,KAAD,IAA0B;QACpB,CAAC+nB,sBAAsBliC;;QACvB+B,QAAQ2W,IAAR,CAAaoB,SAAb,CAAuBI,QAAvB,CAAgCC,KAAhC,GAAwC;UACtC8W,OAAOoI,QAAP,CAAgBxuB,IAAhB,KAAyB,GAAG;;aAEzB;eACEm1B,QAAQwC,cAAc;MAAA;;wBAEb/3B;;EAGxB,CA1B0B;QA4BpBy3B,uBAAuBliC,SAAS;QAChCA,OAAO;wBACS+jC;WACb;wBACaC;;EAErB;YAMS,MAAM;;;aACLhkC,QAAQ,gBAAUA,KAAV,wBAAiBikC,aAAjB,CAA+B,aAA/B;;QACb/B,sBAAsBliC,OAAO;wBACb+jC;;EAErB;cAEW,MAAM;;;QAEZ7B,sBAAsBliC,OAAO;wBACbgkC;;EAErB;;6BAM0BhE,UAAuC,IAAI;;;WAE7DA,UAAU;MACfwC,aAAa,cAAQqB,IAAR,iBAAgB,WADd;MAEftB,eAAe,cAAQlgC,IAAR,iBAAgB,QAFhB;MAGfogC,2BAA2B,cAAQqB,YAAR,iBAAwB;IAHpC;QAMb7K,MAAM4C,QAAN,CAAe77B,KAAf,KAAyB;UACvB67B,SAAS77B,QAAQ;WAEhBq5B,SAAS9tB;wBACIw4B;;;8BAGM;QACtB9K,MAAM4C,QAAN,CAAe77B,KAAf,KAAyB;UACvB67B,SAAS77B,QAAQ;wBACHgkC;;;SAGf;IAAE7B,kBAAF;IAAsBC,YAAtB;IAAoC8B,iBAApC;IAAuDC;EAAvD;AACT;;AAMA,+BACEvjC,GADF,EAEEC,QAFF,EAGEuhC,YAHF,EAIE35B,aAJF,EAKE8pB,UALF,EAME4G,aANF,EAOEmJ,4BAPF,EAQEC,aARF,EASE;MACI,CAACH,aAAapiC;QACZiK,MAAMm4B,aAAapiC;QACnBsjC,OAAOc,iCAAiCxjC,GAAjC,EAAsCC,QAAtC,EAAgDoJ,IAAIlB,GAApD;QACPw6B,OAAOa,iCAAiCxjC,GAAjC,EAAsCC,QAAtC,EAAgD;IAC3DmC,GAAGiH,IAAIlB,GAAJ,CAAQ/F,CAAR,GAAYiH,IAAIY,IAAJ,CAASvI,KADmC;IAE3Da,GAAG8G,IAAIlB,GAAJ,CAAQ5F,CAAR,GAAY8G,IAAIY,IAAJ,CAASrI;EAFmC,CAAhD;QAMP6hC,gBAAgB,IAAI7iB,GAAJ,CACpBtgB,OAAOM,OAAP,CAAeiH,aAAf,EACGrH,MADH,CACU,CAAC,CAACmyB,CAAD,EAAIxqB,GAAJ,CAAD,KAAc;WACbu6B,KAAKtgC,CAAL,IAAU+F,IAAI/F,CAAd,IAAmB+F,IAAI/F,CAAJ,IAASugC,KAAKvgC,CAAjC,IAAsCsgC,KAAKngC,CAAL,IAAU4F,IAAI5F,CAApD,IAAyD4F,IAAI5F,CAAJ,IAASogC,KAAKpgC;EAC/E,CAHH,EAIG1B,GAJH,CAIO,CAAC,CAACgI,MAAD,EAAS8pB,CAAT,CAAD,KAAiB9pB,MAJxB,CADoB;;MAQlB84B,kBAAkB,UAAU;kBAChB7iB,QAAQjW,UAAU;UAC1B,CAAC46B,cAAct4B,GAAd,CAAkBtC,MAAlB,GAA2B;sBAChB8Z,OAAO9Z;MAAM;IAE9B;kBACaiW,QAAQjW,UAAU;;;YACxBqR,aAAa,uBAAWrR,MAAX,yBAAoBqR,UAApB,iBAAkC;;UAEnDA,eAAe,IAAf,IACC,OAAOA,UAAP,KAAsB,QAAtB,IAAkCqe,cAActuB,IAAd,GAAqBiQ,YACxD;sBACcqD,IAAI1U;MAAM;IAE3B;EAAA,OACI;UAEC66B,YAAY,IAAI9iB,GAAJ,CAAgB8gB,4BAAhB;cACR5iB,QAAQjW,UAAU;UACtB46B,cAAct4B,GAAd,CAAkBtC,MAAlB,GAA2B;kBACnB8Z,OAAO9Z;MAAM;IAE1B;kBACaiW,QAAQjW,UAAU;;;UAC1B,CAAC64B,6BAA6Bv2B,GAA7B,CAAiCtC,MAAjC,GAA0C;cACvCqR,aAAa,uBAAWrR,MAAX,yBAAoBqR,UAApB,iBAAkC;;YAEnDA,eAAe,IAAf,IACC,OAAOA,UAAP,KAAsB,QAAtB,IAAkCwpB,UAAUz5B,IAAV,GAAiBiQ,YACpD;oBACUqD,IAAI1U;QAAM;;IAGzB;kBAEa8B;cACJmU,QAAQjW,UAAU0vB,cAAchb,GAAd,CAAkB1U,MAAlB;EAAyB;AAEzD;;AAUA,MAAMo5B,qBAAN,CAA4B;EAS1BzyB,YACEzP,SADF,EAEEmiC,sBAFF,EAGEC,oBAHF,EAIEC,sBAJF,EAKEC,gBALF,EAMEC,kBANF,EAOE;SACKqB,aAAa5jC;SACb6jC,0BAA0B1B;SAC1B2B,wBAAwB1B;SACxB2B,0BAA0B1B;SAC1B2B,oBAAoB1B;SACpB2B,sBAAsB1B;;SACtB2B,eAAgB1qB,KAAD,IAAyBA,MAAM+gB,eAAN;;;EAG/C6I,WAAW;UACH/D,UAAU;MAAE8E,SAAS,IAAX;MAAiBxG,SAAS;IAA1B;UACV39B,YAAYF,QAAQ,KAAK8jC,UAAL,CAAgBvkC,KAAxB,EAA+B,WAA/B;cACRi8B,iBAAiB,eAAe,KAAKuI,yBAAyBxE;cAC9D/D,iBAAiB,SAAS,KAAK0I,mBAAmB3E;cAClD/D,iBAAiB,gBAAgB,KAAK4I,cAAc7E;cACpD/D,iBAAiB,gBAAgB,KAAK4I,cAAc7E;aACrD/D,iBAAiB,WAAW,KAAK2I,qBAAqB5E;EAAO;;EAGxEz3B,WAAW;UACHy3B,UAAU;MAAE8E,SAAS,IAAX;MAAiBxG,SAAS;IAA1B;aACPrC,iBAAiB,eAAe,KAAKyI,yBAAyB1E;aAC9D/D,iBAAiB,aAAa,KAAKwI,uBAAuBzE;EAAO;;EAG5Ev1B,aAAa;UACLu1B,UAAU;MAAE8E,SAAS;IAAX;aACPlJ,oBAAoB,eAAe,KAAK8I,yBAAyB1E;aACjEpE,oBAAoB,aAAa,KAAK6I,uBAAuBzE;EAAO;;EAG/EgE,aAAa;SACNv5B;UACCu1B,UAAU;MAAE8E,SAAS;IAAX;;QACZ,KAAKP,UAAL,CAAgBvkC,OAAO;YACnBW,YAAY,KAAK4jC,UAAL,CAAgBvkC;gBACxB47B,oBAAoB,eAAe,KAAK4I,yBAAyBxE;gBACjEpE,oBAAoB,SAAS,KAAK+I,mBAAmB3E;gBACrDpE,oBAAoB,gBAAgB,KAAKiJ,cAAc7E;gBACvDpE,oBAAoB,gBAAgB,KAAKiJ,cAAc7E;eACxDpE,oBAAoB,WAAW,KAAKgJ,qBAAqB5E;IAAO;;;AAzDnD;;AA8D5B,MAAM4D,iBAAN,CAAwB;EAMtBxzB,YACEzP,SADF,EAEEuiC,kBAFF,EAGE6B,gBAHF,EAIE;SACKR,aAAa5jC;SACbikC,sBAAsB1B;SACtB8B,oBAAoBD;;SACpBE,kBAAmB9qB,KAAD,IAAuB;YACtC+gB;YACAqD;;;;EAIVwF,WAAW;aACA9H,iBAAiB,WAAW,KAAK2I,qBAAqB;MAAEE,SAAS,IAAX;MAAiBxG,SAAS;IAA1B;EAAgC;;EAGjG/1B,WAAW;aACA0zB,iBAAiB,SAAS,KAAK+I,mBAAmB;MAAEF,SAAS,IAAX;MAAiBxG,SAAS;IAA1B;UACrD39B,YAAYF,QAAQ,KAAK8jC,UAAL,CAAgBvkC,KAAxB,EAA+B,WAA/B;cACRi8B,iBAAiB,eAAe,KAAKgJ,iBAAiB;MAAE3G,SAAS;IAAX;EAAkB;;EAGpF7zB,aAAa;aACFmxB,oBAAoB,SAAS,KAAKoJ,mBAAmB;MAAEF,SAAS;IAAX;;QAC1D,KAAKP,UAAL,CAAgBvkC,OAAO;YACnBW,YAAY,KAAK4jC,UAAL,CAAgBvkC;gBACxB47B,oBAAoB,eAAe,KAAKqJ;IAAe;;;EAIrEjB,aAAa;SACNv5B;aACImxB,oBAAoB,WAAW,KAAKgJ,qBAAqB;MAAEE,SAAS;IAAX;EAAiB;;AAxC/D;;ACxWxB,MAAMI,wBAAwB3kC,OAAO,oBAAP,CAA9B;;+BAGEI,WACAyxB,SACAgH,WACA7G,YACAW,YACAO,YACA0F,eACAuD,eACAoC,eACA5F,cACAuD,cACAoC,cACAE,8BACAd,uBACAl8B,SACA4G,SACoB;QACdswB,QAA0B;IAC9B0B,eAAe1H,IAAI,WAAJ,CADe;IAE9B4I,UAAU5I,IAAI,SAAJ;EAFoB;;MAK5BkG,cAActuB,IAAd,GAAqB,GAAG;UACpB8vB,cAAc36B,QAAQ;EAAA,WACnB08B,cAAc7xB,IAAd,GAAqB,CADF,EACK;UAC3B8vB,cAAc36B,QAAQ;EAAA,CAFA,MAEA,IACnB8+B,cAAcj0B,IAAd,GAAqB,CADF,EACK;UAC3B8vB,cAAc36B,QAAQ;EAAA;;QAGxBi5B,MAAM4C,UAAUjB,QAAQ;YACpBK,KAAK,aAAaL;EAC3B;oCAEiCj6B,WAAWs4B,OAAOgF,uBAAuBt1B;;QAErEw8B,WAA+Bv7B;IACnCuvB,aADmC;IAEnCD,YAFmC;IAGnCwD,aAHmC;IAInCD,YAJmC;IAKnCqC,aALmC;IAMnCD;EANmC,GAOhCuG,4BACD7S,UADC,EAEDH,OAFC,EAGD6G,KAHC,EAIDC,YAJC,EAKDC,aALC,EAMDC,SANC,EAODzwB,OAPC,CAPgC,GAgBhC08B,4BAA4BnS,UAA5B,EAAwC+F,KAAxC,EAA+CwD,YAA/C,EAA6DC,aAA7D,EAA4E/zB,OAA5E,CAhBgC,GAiBhC28B,4BACD7R,UADC,EAEDwF,KAFC,EAGD4F,YAHC,EAIDC,aAJC,EAKDC,4BALC,EAMDp2B,OANC,CAjBgC,GAyBhC48B,wBACD5kC,SADC,EAEDs4B,KAFC,EAGD7G,OAHC,EAIDG,UAJC,EAKD4G,aALC,EAMDp3B,OANC,CAzBgC;;UAkC7BmjC,uBAAuBC;SACxBA;AACT;;6BAEwD;SAC/C1kC,QAAQC,OAAOwkC,qBAAP,CAAR,EAAuC,oBAAvC;AACT;;ACjJe,cAASphC,CAAT,EAAW;EAAC,OAAM;IAAC0hC,KAAI1hC,IAAEA,KAAG,mBAAI0J,GAAJ,EAAV;IAAkBlD,IAAG,UAAS0f,CAAT,EAAWxkB,CAAX,EAAa;MAAC,IAAI0f,IAAEphB,EAAE+H,GAAF,CAAMme,CAAN,CAAN;MAAe9E,IAAEA,EAAE5Z,IAAF,CAAO9F,CAAP,CAAF,GAAY1B,EAAE2H,GAAF,CAAMue,CAAN,EAAQ,CAACxkB,CAAD,CAAR,CAAZ;IAAwB,CAA1E;IAA4EgF,KAAI,UAASwf,CAAT,EAAWxkB,CAAX,EAAa;MAAC,IAAI0f,IAAEphB,EAAE+H,GAAF,CAAMme,CAAN,CAAN;MAAe9E,MAAI1f,IAAE0f,EAAEja,MAAF,CAASia,EAAEugB,OAAF,CAAUjgC,CAAV,MAAe,CAAxB,EAA0B,CAA1B,CAAF,GAA+B1B,EAAE2H,GAAF,CAAMue,CAAN,EAAQ,EAAR,CAAnC;IAA+C,CAA5J;IAA8JiR,MAAK,UAASjR,CAAT,EAAWxkB,CAAX,EAAa;MAAC,IAAI0f,IAAEphB,EAAE+H,GAAF,CAAMme,CAAN,CAAN;MAAe9E,KAAGA,EAAExgB,KAAF,GAAUjD,GAAV,CAAc,UAAS4pB,EAAT,EAAW;QAACA,GAAE7lB,CAAF;MAAK,CAA/B,CAAH,EAAqC,KAAE1B,EAAE+H,GAAF,CAAM,GAAN,CAAF,KAAeqZ,EAAExgB,KAAF,GAAUjD,GAAV,CAAc,UAAS4pB,EAAT,EAAW;QAACA,GAAErB,CAAF,EAAIxkB,CAAJ;MAAO,CAAjC,CAApD;IAAsF;EAAtR,CAAN;AAA8R;;ACKzT,MAAMkgC,kBAAkBnlC,OAAO,SAAP,CAAxB;;+BAEuD;QAE/CoI,UAAUg9B;UACRD,iBAAiB/8B;SAClBA;AACT;;2BAEmD;SAC1ClI,QAAQC,OAAOglC,eAAP,CAAR,EAAiC,eAAjC;AACT;;;IChBAE,YAAiB;EAMfC,eAAe,YAAY;IACzB,IAAI,OAAOC,UAAP,KAAsB,WAA1B,EAAuC,OAAOA,UAAP;IACvC,IAAI,OAAO5hC,IAAP,KAAgB,WAApB,EAAiC,OAAOA,IAAP;IACjC,IAAI,OAAO4zB,MAAP,KAAkB,WAAtB,EAAmC,OAAOA,MAAP;IACnC,IAAI,OAAO9zB,cAAP,KAAkB,WAAtB,EAAmC,OAAOA,cAAP;IAEnC,IAAI,OAAO,IAAP,KAAgB,WAApB,EAAiC,OAAO,IAAP;IACjC,MAAM,IAAI3D,KAAJ,CAAU,gCAAV,CAAN;EAAgD,CAbnC;EAuBf0lC,QAAQ,UAAU/kC,MAAV,EAAkB6P,MAAlB,EAA0B;IAChC7P,SAASA,UAAU,EAAnB;;IACA,SAASglC,IAAT,IAAiBn1B,MAAjB,EAAyB;MAEvB,IAAI,KAAKvK,QAAL,CAAcuK,OAAOm1B,IAAP,CAAd,CAAJ,EAAiC;QAC/BhlC,OAAOglC,IAAP,IAAe,KAAKD,MAAL,CAAY/kC,OAAOglC,IAAP,CAAZ,EAA0Bn1B,OAAOm1B,IAAP,CAA1B,CAAf;MAAqD,CADvD,MAEO;QACLhlC,OAAOglC,IAAP,IAAen1B,OAAOm1B,IAAP,CAAf;MAAsB;;;IAG1B,OAAOhlC,MAAP;EAAO,CAjCM;EA0CfilC,WAAW,UAAUC,CAAV,EAAa;IACtB,OACEA,aAAaC,WAAb,IACAD,aAAaE,UADb,IAEAF,aAAaG,aAFb,IAGCH,KACC,OAAOA,CAAP,KAAa,QADd,IAECA,MAAM,IAFP,IAGCA,EAAEt2B,QAAF,KAAe,CAHhB,IAIC,OAAOs2B,EAAEI,QAAT,KAAsB,QAR1B;EAQ0B,CAnDb;EA6DfhgC,UAAU,UAAU4/B,CAAV,EAAa;IACrB,OAAOhlC,OAAO4D,SAAP,CAAiBG,QAAjB,CAA0BI,IAA1B,CAA+B6gC,CAA/B,MAAsC,iBAA7C;EAA6C,CA9DhC;EAuEfK,UAAU,UAAUziC,CAAV,EAAa;IACrB,OAAO,CAACL,MAAM+iC,WAAW1iC,CAAX,CAAN,CAAD,IAAyB4D,SAAS5D,CAAT,CAAhC;EAA0C,CAxE7B;EAiFf2iC,QAAQ,UAAUC,iBAAV,EAA6B;IACnC,IAAIC,OAAJ,EAAa/lC,GAAb;;IAEA,IAAI,CAAC,KAAKqlC,SAAL,CAAeS,iBAAf,CAAL,EAAwC;MAEtC,IACE,OAAOA,iBAAP,KAA6B,QAA7B,IACAA,6BAA6BvxB,MAF/B,EAGE;QAEAwxB,UAAUC,SAAS3C,aAAT,CAAuByC,iBAAvB,CAAV;;QAEA,IAAI,CAACC,OAAL,EAAc;UACZ,MAAM,IAAItmC,KAAJ,CACJ,4DACEqmC,iBAFE,CAAN;;OARJ,MAcO;QACL,MAAM,IAAIrmC,KAAJ,CAAU,oDAAV,CAAN;MAAoE;KAjBxE,MAoBO;MACLsmC,UAAUD,iBAAV;IAAU;;IAGZ,IAAIC,QAAQE,OAAR,CAAgBC,WAAhB,OAAkC,KAAtC,EAA6C;MAC3ClmC,MAAM+lC,OAAN;IAAM,CADR,MAEO;MACL,IAAIA,QAAQE,OAAR,CAAgBC,WAAhB,OAAkC,QAAtC,EAAgD;QAC9ClmC,MAAM+lC,QAAQI,eAAR,CAAwBC,eAA9B;MAA8B,CADhC,MAEO;QACL,IAAIL,QAAQE,OAAR,CAAgBC,WAAhB,OAAkC,OAAtC,EAA+C;UAC7ClmC,MAAM+lC,QAAQM,cAAR,GAAyBD,eAA/B;QAA+B,CADjC,MAEO;UACL,IAAIL,QAAQE,OAAR,CAAgBC,WAAhB,OAAkC,KAAtC,EAA6C;YAC3C,MAAM,IAAIzmC,KAAJ,CACJ,6FADI,CAAN;WADF,MAIO;YACL,MAAM,IAAIA,KAAJ,CAAU,iBAAV,CAAN;UAAiC;;;;;IAOzC,OAAOO,GAAP;EAAO,CAjIM;EA0IfsmC,OAAO,UAAUC,EAAV,EAAcC,OAAd,EAAuB;IAC5B,OAAO,YAAY;MACjB,OAAOD,GAAGpwB,KAAH,CAASqwB,OAAT,EAAkBv1B,SAAlB,CAAP;IAAkC,CADpC;GA3Ia;EAwJfw1B,SAAS,UAAUnB,CAAV,EAAa;IACpB,OAAOhlC,OAAO4D,SAAP,CAAiBG,QAAjB,CACJ8R,KADI,CACEmvB,CADF,EAEJthC,OAFI,CAEI,aAFJ,EAEmB,EAFnB,EAGJA,OAHI,CAGI,KAHJ,EAGW,EAHX,CAAP;EAGoB,CA5JP;EAqKf0iC,wBAAwB,UAAUC,GAAV,EAAe3mC,GAAf,EAAoB;IAE1C,IAAI2mC,IAAItP,OAAJ,KAAgB,MAAhB,IAA0BsP,IAAItP,OAAJ,KAAgB,IAA9C,EAAoD;MAElDsP,IAAItP,OAAJ,GAAc,CAAd;MACAsP,IAAIrP,OAAJ,GAAc,CAAd;;MAGA,IAAIqP,IAAIC,OAAJ,KAAgB,MAAhB,IAA0BD,IAAIC,OAAJ,CAAYlmC,MAA1C,EAAkD;QAChD,IAAIimC,IAAIC,OAAJ,CAAY,CAAZ,EAAevP,OAAf,KAA2B,MAA/B,EAAuC;UACrCsP,IAAItP,OAAJ,GAAcsP,IAAIC,OAAJ,CAAY,CAAZ,EAAevP,OAA7B;UACAsP,IAAIrP,OAAJ,GAAcqP,IAAIC,OAAJ,CAAY,CAAZ,EAAetP,OAA7B;QAA6B,CAF/B,MAE+B,IACpBqP,IAAIC,OAAJ,CAAY,CAAZ,EAAe3M,KAAf,KAAyB,MADL,EACa;UAC1C,IAAInP,OAAO9qB,IAAIyiC,qBAAJ,EAAX;UAEAkE,IAAItP,OAAJ,GAAcsP,IAAIC,OAAJ,CAAY,CAAZ,EAAe3M,KAAf,GAAuBnP,KAAKU,IAA1C;UACAmb,IAAIrP,OAAJ,GAAcqP,IAAIC,OAAJ,CAAY,CAAZ,EAAe1M,KAAf,GAAuBpP,KAAKW,GAA1C;QAA0C;OAR9C,UAWWkb,IAAIE,aAAJ,KAAsB,QAAQ;QACvC,IAAIF,IAAIE,aAAJ,CAAkBxP,OAAlB,KAA8B,MAAlC,EAA0C;UACxCsP,IAAItP,OAAJ,GAAcsP,IAAIE,aAAJ,CAAkBxP,OAAhC;UACAsP,IAAIrP,OAAJ,GAAcqP,IAAIE,aAAJ,CAAkBvP,OAAhC;QAAgC;;;GA3LzB;EAwMfwP,gBAAgB,UAAUH,GAAV,EAAe3mC,GAAf,EAAoB+mC,KAApB,EAA2B;IAEzC,IAAIJ,IAAIC,OAAJ,KAAgB,MAAhB,IAA0BD,IAAIC,OAAJ,CAAYlmC,MAA1C,EAAkD;MAChD,IAAIimC,IAAIC,OAAJ,CAAYG,KAAZ,EAAmB1P,OAAnB,KAA+B,MAAnC,EAA2C;QACzCsP,IAAItP,OAAJ,GAAcsP,IAAIC,OAAJ,CAAYG,KAAZ,EAAmB1P,OAAjC;QACAsP,IAAIrP,OAAJ,GAAcqP,IAAIC,OAAJ,CAAYG,KAAZ,EAAmBzP,OAAjC;MAAiC,CAFnC,MAEmC,IACxBqP,IAAIC,OAAJ,CAAYG,KAAZ,EAAmB9M,KAAnB,KAA6B,MADL,EACa;QAC9C,IAAInP,OAAO9qB,IAAIyiC,qBAAJ,EAAX;QAEAkE,IAAItP,OAAJ,GAAcsP,IAAIC,OAAJ,CAAYG,KAAZ,EAAmB9M,KAAnB,GAA2BnP,KAAKU,IAA9C;QACAmb,IAAIrP,OAAJ,GAAcqP,IAAIC,OAAJ,CAAYG,KAAZ,EAAmB7M,KAAnB,GAA2BpP,KAAKW,GAA9C;MAA8C;KARlD,MAWO;MAEL,IAAIkb,IAAItP,OAAJ,KAAgB,MAAhB,IAA0BsP,IAAItP,OAAJ,KAAgB,IAA9C,EAAoD;QAElDsP,IAAItP,OAAJ,GAAc,CAAd;QACAsP,IAAIrP,OAAJ,GAAc,CAAd;;QACA,IAAIqP,IAAIE,aAAJ,KAAsB,MAA1B,EAAkC;UAChC,IAAIF,IAAIE,aAAJ,CAAkBxP,OAAlB,KAA8B,MAAlC,EAA0C;YACxCsP,IAAItP,OAAJ,GAAcsP,IAAIE,aAAJ,CAAkBxP,OAAhC;YACAsP,IAAIrP,OAAJ,GAAcqP,IAAIE,aAAJ,CAAkBvP,OAAhC;UAAgC;;;;GA9N3B;EA8Of0P,YAAY,UAAUL,GAAV,EAAeM,OAAf,EAAwB;IAElC,IAAIN,IAAIhP,MAAJ,KAAe,CAAnB,EAAsB;MACpB,OAAO,IAAP;IAAO,CADT,MACS,IAGAsP,YAAY,MAAZ,IAAsBA,YAAY,IAHlC,EAGwC;MAC/C,IAAIC,gBAAgBP,IAAIQ,SAAJ,GAAgBF,QAAQE,SAA5C;MAAA,IACEC,kBAAkBllC,KAAKwjB,IAAL,CAChBxjB,KAAKyjB,GAAL,CAASghB,IAAItP,OAAJ,GAAc4P,QAAQ5P,OAA/B,EAAwC,CAAxC,IACEn1B,KAAKyjB,GAAL,CAASghB,IAAIrP,OAAJ,GAAc2P,QAAQ3P,OAA/B,EAAwC,CAAxC,CAFc,CADpB;MAMA,OAAO4P,gBAAgB,GAAhB,IAAuBE,kBAAkB,EAAhD;IAAgD;;IAIlD,OAAO,KAAP;EAAO,CA/PM;EAuQfrwB,KACED,KAAKC,GAAL,IACA,YAAY;IACV,OAAO,IAAID,IAAJ,GAAWuwB,OAAX,EAAP;GA1QW;EAmRfC,UAAU,UAAUpgC,IAAV,EAAgBi4B,IAAhB,EAAsBC,OAAtB,EAA+B;IACvC,IAAImI,OAAO,IAAX;IACA,IAAIf,OAAJ,EAAatwB,IAAb,EAAmBxT,MAAnB;IACA,IAAI8kC,UAAU,IAAd;IACA,IAAIC,WAAW,CAAf;;IACA,IAAI,CAACrI,OAAL,EAAc;MACZA,UAAU,EAAV;;;IAEF,IAAIsI,QAAQ,YAAY;MACtBD,WAAWrI,QAAQO,OAAR,KAAoB,KAApB,GAA4B,CAA5B,GAAgC4H,KAAKxwB,GAAL,EAA3C;MACAywB,UAAU,IAAV;MACA9kC,SAASwE,KAAKiP,KAAL,CAAWqwB,OAAX,EAAoBtwB,IAApB,CAAT;;MACA,IAAI,CAACsxB,OAAL,EAAc;QACZhB,UAAUtwB,OAAO,IAAjB;MAAiB;KALrB;;IAQA,OAAO,YAAY;MACjB,IAAI6gB,OAAMwQ,KAAKxwB,GAAL,EAAV;;MACA,IAAI,CAAC0wB,QAAD,IAAarI,QAAQO,OAAR,KAAoB,KAArC,EAA4C;QAC1C8H,WAAW1Q,IAAX;MAAW;;MAEb,IAAI5f,YAAYgoB,QAAQpI,OAAM0Q,QAAd,CAAhB;MACAjB,UAAU,IAAV;MACAtwB,OAAOjF,SAAP;;MACA,IAAIkG,aAAa,CAAb,IAAkBA,YAAYgoB,IAAlC,EAAwC;QACtCsB,aAAa+G,OAAb;QACAA,UAAU,IAAV;QACAC,WAAW1Q,IAAX;QACAr0B,SAASwE,KAAKiP,KAAL,CAAWqwB,OAAX,EAAoBtwB,IAApB,CAAT;;QACA,IAAI,CAACsxB,OAAL,EAAc;UACZhB,UAAUtwB,OAAO,IAAjB;QAAiB;OANrB,UAQW,CAACsxB,OAAD,IAAYpI,QAAQS,QAAR,KAAqB,OAAO;QACjD2H,UAAUxH,WAAW0H,KAAX,EAAkBvwB,SAAlB,CAAV;MAAqC;;MAEvC,OAAOzU,MAAP;IAAO,CAnBT;GAnSa;EAgUfilC,6BAA6B,UAAUC,WAAV,EAAuB;IAClD,IAAIJ,UAAU,IAAd;;IAGA,IAAII,gBAAgB,MAAhB,IAA0BA,cAAc,EAAxC,IAA8CA,cAAc,CAAhE,EAAmE;MACjEJ,UAAUtlC,KAAK0pB,KAAL,CAAW,MAAOgc,WAAlB,CAAV;IAAuC;;IAGzC,IAAIJ,YAAY,IAAhB,EAAsB;MACpB,OAAOtQ,OAAO2Q,qBAAP,IAAgCC,eAAe,EAAf,CAAvC;IAAwD,CAD1D,MAEO;MACL,OAAOA,eAAeN,OAAf,CAAP;IAA6B;GA3UlB;EAsVfO,mBAAmB,UAAUC,MAAV,EAAkBC,MAAlB,EAA0B;IAC3C,IAAIjjB,KAAKgjB,OAAO5lC,CAAP,GAAW6lC,OAAO7lC,CAA3B;IACA,IAAI6iB,KAAK+iB,OAAOzlC,CAAP,GAAW0lC,OAAO1lC,CAA3B;IACA,OAAOL,KAAKwjB,IAAL,CAAUV,KAAKA,EAAL,GAAUC,KAAKA,EAAzB,CAAP;EAAkC;AAzVrB;;AAmWjB,wBAAwBuiB,OAAxB,EAAiC;EAC/B,OAAO,UAAUxmC,QAAV,EAAoB;IACzBk2B,OAAO8I,UAAP,CAAkBh/B,QAAlB,EAA4BwmC,OAA5B;EAAmC,CADrC;AAGF;;ACnWA,IAAIU,UAAQC,SAAZ;;IAEAC,WAAkB,YAAW;EAG3B,IAAIC,SAAS,EAAb;EAAA,IACEC,iBADF;EAAA,IAEEC,oBAFF;EAAA,IAGEC,OAHF;EAAA,IAIEC,MAAM,EAJR;;EAKA,IAAIC,oBAAoB;IAAEhL,SAAS;EAAX,CAAxB;EACA,IAAIiL,qBAAqB;IAAEjL,SAAS;EAAX,CAAzB;;EAGA,IAAIwK,QAAMjD,aAANiD,GAAsB7M,gBAA1B,EAA4C;IAC1CiN,oBAAoB,kBAApB;IACAC,uBAAuB,qBAAvB;EAAuB,CAFzB,MAGO;IACLD,oBAAoB,aAApB;IACAC,uBAAuB,aAAvB;IACAF,SAAS,IAAT;EAAS;;EAGX,sBAAsB;IACpB,IAAI,CAACG,OAAL,EAAc;MACZA,UACE,aAAaxC,SAAS4C,aAAT,CAAuB,KAAvB,CAAb,GACI,OADJ,GAEI5C,SAAS6C,YAAT,KAA0B,MAA1B,GACA,YADA,GAEA,gBALN;IAKM;;IAER,OAAOL,OAAP;EAAO;;EAGT,wBAAwBzC,OAAxB,EAAiC/kC,QAAjC,EAA2C;IAGzC,IAAIulC,KAAK,UAASM,aAAT,EAAwB;MAC/B,CAACA,aAAD,KAAmBA,gBAAgB3P,OAAO3d,KAA1C;MAGA,IAAIA,QAAQ;QAEVstB,aAFU;QAGVzmC,QAAQymC,cAAczmC,MAAd,IAAwBymC,cAAciC,UAHpC;QAIVrnC,MAAM,OAJI;QAKVsnC,WAAWlC,cAAcplC,IAAd,IAAsB,qBAAtB,GAA8C,CAA9C,GAAkD,CALnD;QAMVunC,QAAQ,CANE;QAOVC,QAAQ,CAPE;QAQVtL,gBAAgB,YAAW;UACzBkJ,cAAclJ,cAAd,GACIkJ,cAAclJ,cAAd,EADJ,GAEKkJ,cAAcqC,WAAd,GAA4B,KAFjC;QAEiC;MAXzB,CAAZ;;MAgBA,IAAIC,gBAAgB,YAApB,EAAkC;QAChC5vB,MAAM6vB,MAAN,GAAgB,KAAK,EAAL,GAAWvC,cAAcwC,UAAzC;QAEAxC,cAAcyC,WAAd,KACG/vB,MAAMyvB,MAAN,GAAgB,KAAK,EAAL,GAAWnC,cAAcyC,WAD5C;MAC4C,CAJ9C,MAKO;QACL/vB,MAAM6vB,MAAN,GAAevC,cAAclP,MAA7B;MAA6B;;MAI/B,OAAO32B,SAASuY,KAAT,CAAP;IAAqB,CA9BvB;;IAiCAkvB,IAAI/9B,IAAJ,CAAS;MACPq7B,OADO;MAEPQ;IAFO,CAAT;IAKA,OAAOA,EAAP;EAAO;;EAGT,qBAAqBR,OAArB,EAA8B;IAC5B,SAASzhB,IAAI,CAAb,EAAgBA,IAAImkB,IAAI/nC,MAAxB,EAAgC4jB,GAAhC,EAAqC;MACnC,IAAImkB,IAAInkB,CAAJ,EAAOyhB,OAAP,KAAmBA,OAAvB,EAAgC;QAC9B,OAAO0C,IAAInkB,CAAJ,EAAOiiB,EAAd;MAAc;;;IAGlB,OAAO,YAAW,EAAlB;;;EAGF,wBAAwBR,OAAxB,EAAiC;IAC/B,SAASzhB,IAAI,CAAb,EAAgBA,IAAImkB,IAAI/nC,MAAxB,EAAgC4jB,GAAhC,EAAqC;MACnC,IAAImkB,IAAInkB,CAAJ,EAAOyhB,OAAP,KAAmBA,OAAvB,EAAgC;QAC9B,OAAO0C,IAAIp+B,MAAJ,CAAWia,CAAX,EAAc,CAAd,CAAP;MAAsB;;;;EAK5B,2BAA2BilB,IAA3B,EAAiCC,SAAjC,EAA4CxoC,QAA5C,EAAsDyoC,iBAAtD,EAAyE;IACvE,IAAIC,EAAJ;;IAEA,IAAIP,iBAAiB,OAArB,EAA8B;MAC5BO,KAAK1oC,QAAL;IAAK,CADP,MAEO;MACL0oC,KAAKC,eAAeJ,IAAf,EAAqBvoC,QAArB,CAAL;IAAkC;;IAGpCuoC,KAAKjB,iBAAL,EACED,SAASmB,SADX,EAEEE,EAFF,EAGED,oBAAoBf,iBAApB,GAAwCC,kBAH1C;;;EAOF,8BAA8BY,IAA9B,EAAoCC,SAApC,EAA+CxoC,QAA/C,EAAyDyoC,iBAAzD,EAA4E;IAC1E,IAAIC,EAAJ;;IAEA,IAAIP,iBAAiB,OAArB,EAA8B;MAC5BO,KAAK1oC,QAAL;IAAK,CADP,MAEO;MACL0oC,KAAKE,YAAYL,IAAZ,CAAL;IAAqB;;IAGvBA,KAAKhB,oBAAL,EACEF,SAASmB,SADX,EAEEE,EAFF,EAGED,oBAAoBf,iBAApB,GAAwCC,kBAH1C;;IAMAkB,eAAeN,IAAf;EAAmB;;EAGrB,0BAA0BA,IAA1B,EAAgCvoC,QAAhC,EAA0CyoC,iBAA1C,EAA6D;IAC3DK,kBAAkBP,IAAlB,EAAwBJ,YAAxB,EAAsCnoC,QAAtC,EAAgDyoC,iBAAhD;;IAGA,IAAIN,gBAAgB,gBAApB,EAAsC;MACpCW,kBACEP,IADF,EAEE,qBAFF,EAGEvoC,QAHF,EAIEyoC,iBAJF;;;;EASJ,6BAA6BF,IAA7B,EAAmCvoC,QAAnC,EAA6CyoC,iBAA7C,EAAgE;IAC9DM,qBAAqBR,IAArB,EAA2BJ,YAA3B,EAAyCnoC,QAAzC,EAAmDyoC,iBAAnD;;IAGA,IAAIN,gBAAgB,gBAApB,EAAsC;MACpCY,qBACER,IADF,EAEE,qBAFF,EAGEvoC,QAHF,EAIEyoC,iBAJF;;;;EASJ,OAAO;IACL//B,IAAIsgC,gBADC;IAELpgC,KAAKqgC;EAFA,CAAP;AAIF,CAhKkB;;ACNlB,IAAI/B,UAAQC,SAAZ;AAAA,IACE+B,WAAW,SADb;;AAIA,IAEG,OAAOlE,QAAP,IAAmB,WAAnB,IAAkC,CAAC,CAACA,SAASmE,YAFhD,EAGE;EAEAD,WAAW,IAAX;AACF;;IAEAE,eAAiB;EACfC,OAAO,4BADQ;EAEfC,OAAO,sCAFQ;EAGfC,SAAS,+BAHM;EAIfC,SAAS,8BAJM;EAKfC,MAAM,mCALS;EAafC,iCAAiC,UAAU1qC,GAAV,EAAe;IAC9C,IAAIA,IAAI2qC,WAAJ,IAAmB3qC,IAAI4qC,YAA3B,EAAyC;MACvC,OAAO;QAAElpC,OAAO1B,IAAI2qC,WAAb;QAA0B/oC,QAAQ5B,IAAI4qC;MAAtC,CAAP;KADF,UAEW,CAAC,CAAC5qC,IAAIyiC,qBAAJ,IAA6B;MACxC,OAAOziC,IAAIyiC,qBAAJ,EAAP;WACK;MACL,MAAM,IAAIhjC,KAAJ,CAAU,wCAAV,CAAN;IAAwD;GAnB7C;EA6BforC,qBAAqB,UAAU7qC,GAAV,EAAe8qC,QAAf,EAAyB;IAC5C,IAAI7qC,WAAW,IAAf;;IAEA,IAAIioC,QAAM7C,SAAN6C,CAAgB4C,QAAhB5C,CAAJ,EAA+B;MAC7BjoC,WAAW6qC,QAAX;IAAW,CADb,MAEO;MACL7qC,WAAWD,IAAIqjC,aAAJ,CAAkByH,QAAlB,CAAX;IAAqC;;IAIvC,IAAI,CAAC7qC,QAAL,EAAe;MACb,IAAI8qC,aAAaxkC,MAAMrC,SAAN,CAAgBJ,KAAhB,CACdW,IADc,CACTzE,IAAI+qC,UAAJ,IAAkB/qC,IAAIgrC,QADb,EAEdxqC,MAFc,CAEP,UAAUyqC,EAAV,EAAc;QACpB,OAAOA,GAAGvF,QAAH,KAAgB,MAAhB,IAA0BuF,GAAGvF,QAAH,KAAgB,OAAjD;MACD,CAJc,CAAjB;;MAQA,IACEqF,WAAWrqC,MAAX,KAAsB,CAAtB,IACAqqC,WAAW,CAAX,EAAcrF,QAAd,KAA2B,GAD3B,IAEAqF,WAAW,CAAX,EAAcG,YAAd,CAA2B,WAA3B,MAA4C,IAH9C,EAIE;QACAjrC,WAAW8qC,WAAW,CAAX,CAAX;MAAsB;;;IAK1B,IAAI,CAAC9qC,QAAL,EAAe;MACb,IAAIkrC,aACF,cAAc,IAAIr0B,IAAJ,GAAWs0B,WAAX,GAAyBpnC,OAAzB,CAAiC,KAAjC,EAAwC,EAAxC,CADhB;MAEA/D,WAAW+lC,SAASqF,eAAT,CAAyB,KAAKhB,KAA9B,EAAqC,GAArC,CAAX;MACApqC,SAASqrC,YAAT,CAAsB,IAAtB,EAA4BH,UAA5B;MAGA,IAAII,cAAcvrC,IAAI+qC,UAAJ,IAAkB/qC,IAAIgrC,QAAxC;;MACA,IAAI,CAAC,CAACO,WAAF,IAAiBA,YAAY7qC,MAAZ,GAAqB,CAA1C,EAA6C;QAC3C,SAAS4jB,IAAIinB,YAAY7qC,MAAzB,EAAiC4jB,IAAI,CAArC,EAAwCA,GAAxC,EAA6C;UAE3C,IAAIinB,YAAYA,YAAY7qC,MAAZ,GAAqB4jB,CAAjC,EAAoCohB,QAApC,KAAiD,MAArD,EAA6D;YAC3DzlC,SAASurC,WAAT,CAAqBD,YAAYA,YAAY7qC,MAAZ,GAAqB4jB,CAAjC,CAArB;UAAwD;;;;MAI9DtkB,IAAIwrC,WAAJ,CAAgBvrC,QAAhB;IAAwB;;IAI1B,IAAIwrC,aAAa,EAAjB;;IACA,IAAIxrC,SAASirC,YAAT,CAAsB,OAAtB,CAAJ,EAAoC;MAClCO,aAAaxrC,SAASirC,YAAT,CAAsB,OAAtB,EAA+BvoC,KAA/B,CAAqC,GAArC,CAAb;IAAqD;;IAIvD,IAAI,CAAC,CAAC8oC,WAAW5G,OAAX,CAAmB,uBAAnB,CAAN,EAAmD;MACjD4G,WAAW/gC,IAAX,CAAgB,uBAAhB;MACAzK,SAASqrC,YAAT,CAAsB,OAAtB,EAA+BG,WAAW3oC,IAAX,CAAgB,GAAhB,CAA/B;IAAmD;;IAGrD,OAAO7C,QAAP;EAAO,CAzFM;EAiGfyrC,oBAAoB,UAAU1rC,GAAV,EAAe;IAEjCA,IAAIsrC,YAAJ,CAAiB,OAAjB,EAA0B,KAAKjB,KAA/B;IACArqC,IAAI2rC,cAAJ,CAAmB,KAAKpB,OAAxB,EAAiC,aAAjC,EAAgD,KAAKC,OAArD;IACAxqC,IAAI2rC,cAAJ,CAAmB,KAAKpB,OAAxB,EAAiC,UAAjC,EAA6C,KAAKE,IAAlD;;IAGA,IAAIzqC,IAAI4rC,UAAJ,KAAmB,IAAvB,EAA6B;MAC3B,IAAIvqC,QAAQrB,IAAIkrC,YAAJ,CAAiB,OAAjB,KAA6B,EAAzC;;MACA,IAAI7pC,MAAM6kC,WAAN,GAAoBrB,OAApB,CAA4B,UAA5B,MAA4C,EAAhD,EAAoD;QAClD7kC,IAAIsrC,YAAJ,CAAiB,OAAjB,EAA0B,uBAAuBjqC,KAAjD;MAAsD;;GA3G7C;EAmHfwqC,mCAAmC,GAnHpB;EAgIfC,mBAAmB5D,QAAMZ,QAANY,CACjB,YAAY;IACV,IAAI6D,UAAU/F,SAASgG,gBAAT,CAA0B,MAA1B,CAAd;IACA,IAAIC,eAAeF,QAAQrrC,MAA3B;;IACA,SAAS4jB,IAAI,CAAb,EAAgBA,IAAI2nB,YAApB,EAAkC3nB,GAAlC,EAAuC;MACrC,IAAI4nB,WAAWH,QAAQznB,CAAR,CAAf;MACA4nB,SAASN,UAAT,CAAoBO,YAApB,CAAiCD,QAAjC,EAA2CA,QAA3C;IAAmD;GANtChE,EASjBkE,iBAAOA,eAAKP,iCAAZO,GAAgD,IAT/BlE,CAhIJ;EAmJfmE,QAAQ,UAAUtG,OAAV,EAAmBuG,MAAnB,EAA2BC,IAA3B,EAAiC;IACvC,IAAIhF,OAAO,IAAX;IAAA,IACEtkC,IACE,YACAqpC,OAAO5vB,CADP,GAEA,GAFA,GAGA4vB,OAAO3vB,CAHP,GAIA,GAJA,GAKA2vB,OAAOhiB,CALP,GAMA,GANA,GAOAgiB,OAAOxc,CAPP,GAQA,GARA,GASAwc,OAAO1nC,CATP,GAUA,GAVA,GAWA0nC,OAAOE,CAXP,GAYA,GAdJ;IAgBAzG,QAAQ4F,cAAR,CAAuB,IAAvB,EAA6B,WAA7B,EAA0C1oC,CAA1C;;IACA,IAAI,eAAe8iC,QAAQ1kC,KAA3B,EAAkC;MAChC0kC,QAAQ1kC,KAAR,CAAciP,SAAd,GAA0BrN,CAA1B;IAA0B,CAD5B,MAC4B,IACjB,mBAAmB8iC,QAAQ1kC,KADV,EACiB;MAC3C0kC,QAAQ1kC,KAAR,CAAc,eAAd,IAAiC4B,CAAjC;IAAiC,CAFP,MAEO,IACxB,uBAAuB8iC,QAAQ1kC,KADP,EACc;MAC/C0kC,QAAQ1kC,KAAR,CAAc,mBAAd,IAAqC4B,CAArC;IAAqC;;IAMvC,IAAIinC,aAAa,IAAb,IAAqB,CAAC,CAACqC,IAA3B,EAAiC;MAE/BA,KAAKX,UAAL,CAAgBO,YAAhB,CAA6BI,IAA7B,EAAmCA,IAAnC;MAIArV,OAAO8I,UAAP,CAAkB,YAAY;QAC5BuH,KAAKuE,iBAAL;OADF,EAEGvE,KAAKsE,iCAFR;IAEyC;GAxL9B;EAmMfY,eAAe,UAAU9F,GAAV,EAAe3mC,GAAf,EAAoB;IACjC,IAAI8rB,QAAQ9rB,IAAIghC,cAAJ,EAAZ;IAEAkH,QAAMxB,sBAANwB,CAA6BvB,GAA7BuB,EAAkCloC,GAAlCkoC;IAEApc,MAAM1pB,CAAN,GAAUukC,IAAItP,OAAd;IACAvL,MAAMvpB,CAAN,GAAUokC,IAAIrP,OAAd;IAEA,OAAOxL,KAAP;EAAO,CA3MM;EAsNf4gB,eAAe,UAAU/F,GAAV,EAAe3mC,GAAf,EAAoB+mC,KAApB,EAA2B;IACxC,IAAIjb,QAAQ9rB,IAAIghC,cAAJ,EAAZ;IAEAkH,QAAMpB,cAANoB,CAAqBvB,GAArBuB,EAA0BloC,GAA1BkoC,EAA+BnB,KAA/BmB;IAEApc,MAAM1pB,CAAN,GAAUukC,IAAItP,OAAd;IACAvL,MAAMvpB,CAAN,GAAUokC,IAAIrP,OAAd;IAEA,OAAOxL,KAAP;EAAO,CA9NM;EAuOf6gB,mBAAmB,UAAU3sC,GAAV,EAAe0B,KAAf,EAAsBE,MAAtB,EAA8B;IAC/C,OAAO,KAAKo/B,cAAL,CAAoBhhC,GAApB,EAAyB0B,QAAQ,CAAjC,EAAoCE,SAAS,CAA7C,CAAP;EAAqD,CAxOxC;EAmPfo/B,gBAAgB,UAAUhhC,GAAV,EAAeoC,CAAf,EAAkBG,CAAlB,EAAqB;IACnC,IAAIupB,QAAQ9rB,IAAIghC,cAAJ,EAAZ;IACAlV,MAAM1pB,CAAN,GAAUA,CAAV;IACA0pB,MAAMvpB,CAAN,GAAUA,CAAV;IAEA,OAAOupB,KAAP;EAAO;AAxPM;ACZjB,IAAI8gB,aAAWzE,YAAf;IAEA0E,eAAiB;EACfC,QAAQ,UAAUC,QAAV,EAAoB;IAE1B,IAAIR,OAAOQ,SAAS/sC,GAAT,CAAaqjC,aAAb,CAA2B,MAA3B,CAAX;;IACA,IAAI,CAACkJ,IAAL,EAAW;MACTA,OAAOvG,SAASqF,eAAT,CAAyBuB,WAASvC,KAAlC,EAAyC,MAAzC,CAAP;MACA0C,SAAS/sC,GAAT,CAAawrC,WAAb,CAAyBe,IAAzB;IAA6B;;IAI/B,IAAIS,UAAUT,KAAKlJ,aAAL,CAAmB,oCAAnB,CAAd;;IACA,IAAI,CAAC2J,OAAL,EAAc;MACZ,IAAI3rC,QAAQ2kC,SAASqF,eAAT,CAAyBuB,WAASvC,KAAlC,EAAyC,OAAzC,CAAZ;MACAhpC,MAAMiqC,YAAN,CAAmB,IAAnB,EAAyB,8BAAzB;MACAjqC,MAAMiqC,YAAN,CAAmB,MAAnB,EAA2B,UAA3B;MACAjqC,MAAM4rC,WAAN,GACE,8PADF;MAEAV,KAAKf,WAAL,CAAiBnqC,KAAjB;IAAsB;;IAIxB,IAAI6rC,YAAYlH,SAASqF,eAAT,CAAyBuB,WAASvC,KAAlC,EAAyC,GAAzC,CAAhB;IACA6C,UAAU5B,YAAV,CAAuB,IAAvB,EAA6B,uBAA7B;IACA4B,UAAU5B,YAAV,CACE,WADF,EAEE,gBACGyB,SAASrrC,KAAT,GAAiB,EADpB,IAEE,GAFF,IAGGqrC,SAASnrC,MAAT,GAAkB,EAHrB,IAIE,eANJ;IAQAsrC,UAAU5B,YAAV,CAAuB,OAAvB,EAAgC,sBAAhC;IAGA4B,UAAU1B,WAAV,CAAsB,KAAK2B,aAAL,CAAmBJ,QAAnB,CAAtB;IACAG,UAAU1B,WAAV,CAAsB,KAAK4B,gBAAL,CAAsBL,QAAtB,CAAtB;IACAG,UAAU1B,WAAV,CAAsB,KAAK6B,cAAL,CAAoBN,QAApB,CAAtB;IAGAA,SAAS/sC,GAAT,CAAawrC,WAAb,CAAyB0B,SAAzB;IAGAH,SAASF,YAAT,GAAwBK,SAAxB;EAAwB,CA1CX;EA6CfC,eAAe,UAAUJ,QAAV,EAAoB;IACjC,IAAIO,SAAStH,SAASqF,eAAT,CAAyBuB,WAASvC,KAAlC,EAAyC,GAAzC,CAAb;IACAiD,OAAOhC,YAAP,CAAoB,IAApB,EAA0B,sBAA1B;IACAgC,OAAOhC,YAAP,CAAoB,WAApB,EAAiC,gCAAjC;IACAgC,OAAOhC,YAAP,CAAoB,OAApB,EAA6B,sBAA7B;IACAgC,OAAOjS,gBAAP,CACE,OADF,EAEE,YAAY;MACV0R,SAASQ,iBAAT,GAA6BD,MAA7B;KAHJ,EAKE,KALF;IAOAA,OAAOjS,gBAAP,CACE,YADF,EAEE,YAAY;MACV0R,SAASQ,iBAAT,GAA6BD,MAA7B;KAHJ,EAKE,KALF;IAQA,IAAIE,mBAAmBxH,SAASqF,eAAT,CAAyBuB,WAASvC,KAAlC,EAAyC,MAAzC,CAAvB;IACAmD,iBAAiBlC,YAAjB,CAA8B,GAA9B,EAAmC,GAAnC;IACAkC,iBAAiBlC,YAAjB,CAA8B,GAA9B,EAAmC,GAAnC;IACAkC,iBAAiBlC,YAAjB,CAA8B,OAA9B,EAAuC,MAAvC;IACAkC,iBAAiBlC,YAAjB,CAA8B,QAA9B,EAAwC,MAAxC;IACAkC,iBAAiBlC,YAAjB,CAA8B,OAA9B,EAAuC,iCAAvC;IACAgC,OAAO9B,WAAP,CAAmBgC,gBAAnB;IAEA,IAAIC,cAAczH,SAASqF,eAAT,CAAyBuB,WAASvC,KAAlC,EAAyC,MAAzC,CAAlB;IACAoD,YAAYnC,YAAZ,CACE,GADF,EAEE,sXAFF;IAIAmC,YAAYnC,YAAZ,CAAyB,OAAzB,EAAkC,8BAAlC;IACAgC,OAAO9B,WAAP,CAAmBiC,WAAnB;IAEA,OAAOH,MAAP;EAAO,CAjFM;EAoFfF,kBAAkB,UAAUL,QAAV,EAAoB;IAEpC,IAAIW,sBAAsB1H,SAASqF,eAAT,CAAyBuB,WAASvC,KAAlC,EAAyC,GAAzC,CAA1B;IACAqD,oBAAoBpC,YAApB,CAAiC,IAAjC,EAAuC,6BAAvC;IACAoC,oBAAoBpC,YAApB,CAAiC,WAAjC,EAA8C,4BAA9C;IACAoC,oBAAoBpC,YAApB,CAAiC,OAAjC,EAA0C,sBAA1C;IACAoC,oBAAoBrS,gBAApB,CACE,OADF,EAEE,YAAY;MACV0R,SAASQ,iBAAT,GAA6BI,KAA7B;KAHJ,EAKE,KALF;IAOAD,oBAAoBrS,gBAApB,CACE,YADF,EAEE,YAAY;MACV0R,SAASQ,iBAAT,GAA6BI,KAA7B;KAHJ,EAKE,KALF;IAQA,IAAIC,gCAAgC5H,SAASqF,eAAT,CAClCuB,WAASvC,KADyB,EAElC,MAFkC,CAApC;IAIAuD,8BAA8BtC,YAA9B,CAA2C,GAA3C,EAAgD,GAAhD;IACAsC,8BAA8BtC,YAA9B,CAA2C,GAA3C,EAAgD,GAAhD;IACAsC,8BAA8BtC,YAA9B,CAA2C,OAA3C,EAAoD,KAApD;IACAsC,8BAA8BtC,YAA9B,CAA2C,QAA3C,EAAqD,IAArD;IACAsC,8BAA8BtC,YAA9B,CACE,OADF,EAEE,iCAFF;IAIAoC,oBAAoBlC,WAApB,CAAgCoC,6BAAhC;IAEA,IAAIC,4BAA4B7H,SAASqF,eAAT,CAC9BuB,WAASvC,KADqB,EAE9B,MAF8B,CAAhC;IAIAwD,0BAA0BvC,YAA1B,CACE,GADF,EAEE,uLAFF;IAIAuC,0BAA0BvC,YAA1B,CACE,OADF,EAEE,8BAFF;IAIAoC,oBAAoBlC,WAApB,CAAgCqC,yBAAhC;IAEA,IAAIC,4BAA4B9H,SAASqF,eAAT,CAC9BuB,WAASvC,KADqB,EAE9B,MAF8B,CAAhC;IAIAyD,0BAA0BxC,YAA1B,CACE,GADF,EAEE,szDAFF;IAIAwC,0BAA0BxC,YAA1B,CACE,OADF,EAEE,8BAFF;IAIAoC,oBAAoBlC,WAApB,CAAgCsC,yBAAhC;IAEA,OAAOJ,mBAAP;EAAO,CAnJM;EAsJfL,gBAAgB,UAAUN,QAAV,EAAoB;IAElC,IAAIgB,UAAU/H,SAASqF,eAAT,CAAyBuB,WAASvC,KAAlC,EAAyC,GAAzC,CAAd;IACA0D,QAAQzC,YAAR,CAAqB,IAArB,EAA2B,uBAA3B;IACAyC,QAAQzC,YAAR,CAAqB,WAArB,EAAkC,iCAAlC;IACAyC,QAAQzC,YAAR,CAAqB,OAArB,EAA8B,sBAA9B;IACAyC,QAAQ1S,gBAAR,CACE,OADF,EAEE,YAAY;MACV0R,SAASQ,iBAAT,GAA6BQ,OAA7B;KAHJ,EAKE,KALF;IAOAA,QAAQ1S,gBAAR,CACE,YADF,EAEE,YAAY;MACV0R,SAASQ,iBAAT,GAA6BQ,OAA7B;KAHJ,EAKE,KALF;IAQA,IAAIC,oBAAoBhI,SAASqF,eAAT,CAAyBuB,WAASvC,KAAlC,EAAyC,MAAzC,CAAxB;IACA2D,kBAAkB1C,YAAlB,CAA+B,GAA/B,EAAoC,GAApC;IACA0C,kBAAkB1C,YAAlB,CAA+B,GAA/B,EAAoC,GAApC;IACA0C,kBAAkB1C,YAAlB,CAA+B,OAA/B,EAAwC,MAAxC;IACA0C,kBAAkB1C,YAAlB,CAA+B,QAA/B,EAAyC,MAAzC;IACA0C,kBAAkB1C,YAAlB,CAA+B,OAA/B,EAAwC,iCAAxC;IACAyC,QAAQvC,WAAR,CAAoBwC,iBAApB;IAEA,IAAIC,eAAejI,SAASqF,eAAT,CAAyBuB,WAASvC,KAAlC,EAAyC,MAAzC,CAAnB;IACA4D,aAAa3C,YAAb,CACE,GADF,EAEE,oQAFF;IAIA2C,aAAa3C,YAAb,CAA0B,OAA1B,EAAmC,8BAAnC;IACAyC,QAAQvC,WAAR,CAAoByC,YAApB;IAEA,OAAOF,OAAP;EAAO,CA3LM;EA8LfG,SAAS,UAAUnB,QAAV,EAAoB;IAC3B,IAAIA,SAASF,YAAb,EAA2B;MACzBE,SAASF,YAAT,CAAsBjB,UAAtB,CAAiCuC,WAAjC,CAA6CpB,SAASF,YAAtD;MACAE,SAASF,YAAT,GAAwB,IAAxB;IAAwB;;AAjMb;ACFjB,IAAID,aAAWzE,YAAf;AAAA,IACED,UAAQkG,SADV;;AAGA,IAAIC,mBAAiB,UAAUpuC,QAAV,EAAoBm/B,OAApB,EAA6B;EAChD,KAAKkP,IAAL,CAAUruC,QAAV,EAAoBm/B,OAApB;AACF,CAFA;;AAUAiP,iBAAenqC,SAAfmqC,CAAyBC,IAAzBD,GAAgC,UAAUpuC,QAAV,EAAoBm/B,OAApB,EAA6B;EAE3D,KAAKn/B,QAAL,GAAgBA,QAAhB;EACA,KAAKm/B,OAAL,GAAeA,OAAf;EAGA,KAAKmP,aAAL,GAAqB;IAAEC,MAAM,CAAR;IAAWpsC,GAAG,CAAd;IAAiBG,GAAG;EAApB,CAArB;EACA,KAAKksC,WAAL,GAAmB;IAAED,MAAM,CAAR;IAAWpsC,GAAG,CAAd;IAAiBG,GAAG;EAApB,CAAnB;EAEA,KAAKmsC,eAAL,GAAuBxG,QAAM5B,KAAN4B,CAAY,KAAKyG,SAAjBzG,EAA4B,IAA5BA,CAAvB;EAGA,KAAKL,qBAAL,GAA6BK,QAAMP,2BAANO,CAC3B,KAAK9I,OAAL,CAAawI,WADcM,CAA7B;EAKA,KAAK0G,OAAL,GAAe;IAAExsC,GAAG,CAAL;IAAQG,GAAG,CAAX;IAAcb,OAAO,CAArB;IAAwBE,QAAQ;EAAhC,CAAf;EACA,KAAKitC,YAAL;EAGA,IAAIC,SAAS,KAAKC,UAAL,EAAb;EAGA,KAAK1C,MAAL,CAAYyC,MAAZ;EAGA,KAAKH,SAAL;AACF,CA5BAN;;AAkCAA,iBAAenqC,SAAfmqC,CAAyBQ,YAAzBR,GAAwC,YAAY;EAClD,IAAIW,aAAa,KAAK5P,OAAL,CAAap/B,GAAb,CAAiBkrC,YAAjB,CAA8B,SAA9B,CAAjB;;EAEA,IAAI8D,UAAJ,EAAgB;IACd,IAAIC,gBAAgBD,WACjBrsC,KADiB,CACX,QADW,EAEjBnC,MAFiB,CAEV,UAAUC,CAAV,EAAa;MACnB,OAAOA,CAAP;IACD,CAJiB,EAKjBI,GALiB,CAKb+kC,UALa,CAApB;IAQA,KAAKgJ,OAAL,CAAaxsC,CAAb,GAAiB6sC,cAAc,CAAd,CAAjB;IACA,KAAKL,OAAL,CAAarsC,CAAb,GAAiB0sC,cAAc,CAAd,CAAjB;IACA,KAAKL,OAAL,CAAaltC,KAAb,GAAqButC,cAAc,CAAd,CAArB;IACA,KAAKL,OAAL,CAAahtC,MAAb,GAAsBqtC,cAAc,CAAd,CAAtB;IAEA,IAAIT,OAAOtsC,KAAK8E,GAAL,CACT,KAAKo4B,OAAL,CAAa19B,KAAb,GAAqB,KAAKktC,OAAL,CAAaltC,KADzB,EAET,KAAK09B,OAAL,CAAax9B,MAAb,GAAsB,KAAKgtC,OAAL,CAAahtC,MAF1B,CAAX;IAMA,KAAK6sC,WAAL,CAAiBD,IAAjB,GAAwBA,IAAxB;IACA,KAAKC,WAAL,CAAiBrsC,CAAjB,GAAsB,MAAKg9B,OAAL,CAAa19B,KAAb,GAAqB,KAAKktC,OAAL,CAAaltC,KAAb,GAAqB8sC,IAA1C,IAAkD,CAAxE;IACA,KAAKC,WAAL,CAAiBlsC,CAAjB,GAAsB,MAAK68B,OAAL,CAAax9B,MAAb,GAAsB,KAAKgtC,OAAL,CAAahtC,MAAb,GAAsB4sC,IAA5C,IAAoD,CAA1E;IAGA,KAAKU,oBAAL;IAEA,KAAK9P,OAAL,CAAap/B,GAAb,CAAiBmvC,eAAjB,CAAiC,SAAjC;EAA0C,CA3B5C,MA4BO;IACL,KAAKC,kBAAL;;AAEJ,CAlCAf;;AAuCAA,iBAAenqC,SAAfmqC,CAAyBe,kBAAzBf,GAA8C,YAAY;EACxD,IAAIgB,OAAO,KAAKpvC,QAAL,CAAcqvC,OAAd,EAAX;EAEA,KAAKV,OAAL,CAAaxsC,CAAb,GAAiBitC,KAAKjtC,CAAtB;EACA,KAAKwsC,OAAL,CAAarsC,CAAb,GAAiB8sC,KAAK9sC,CAAtB;EACA,KAAKqsC,OAAL,CAAaltC,KAAb,GAAqB2tC,KAAK3tC,KAA1B;EACA,KAAKktC,OAAL,CAAahtC,MAAb,GAAsBytC,KAAKztC,MAA3B;AACF,CAPAysC;;AAcAA,iBAAenqC,SAAfmqC,CAAyBkB,UAAzBlB,GAAsC,YAAY;EAChD,OAAOnG,QAAM/C,MAAN+C,CAAa,EAAbA,EAAiB,KAAK0G,OAAtB1G,CAAP;AACF,CAFAmG;;AAUAA,iBAAenqC,SAAfmqC,CAAyBU,UAAzBV,GAAsC,YAAY;EAChD,IAAIS,SAAS,KAAK3N,MAAL,EAAb;;EAEA,IAAI,KAAK/B,OAAL,CAAaoQ,GAAb,IAAoB,KAAKpQ,OAAL,CAAaqQ,OAArC,EAA8C;IAC5C,IAAIC,QAAJ;;IACA,IAAI,KAAKtQ,OAAL,CAAaoQ,GAAjB,EAAsB;MACpBE,WAAWxtC,KAAK8E,GAAL,CACT,KAAKo4B,OAAL,CAAa19B,KAAb,GAAqB,KAAKktC,OAAL,CAAaltC,KADzB,EAET,KAAK09B,OAAL,CAAax9B,MAAb,GAAsB,KAAKgtC,OAAL,CAAahtC,MAF1B,CAAX;KADF,MAKO;MACL8tC,WAAWxtC,KAAKmU,GAAL,CACT,KAAK+oB,OAAL,CAAa19B,KAAb,GAAqB,KAAKktC,OAAL,CAAaltC,KADzB,EAET,KAAK09B,OAAL,CAAax9B,MAAb,GAAsB,KAAKgtC,OAAL,CAAahtC,MAF1B,CAAX;;;IAMFktC,OAAOpyB,CAAP,GAAWgzB,QAAX;IACAZ,OAAOhf,CAAP,GAAW4f,QAAX;IACAZ,OAAOlqC,CAAP,GAAW,CAAC,KAAKgqC,OAAL,CAAaxsC,CAAd,GAAkBstC,QAA7B;IACAZ,OAAOtC,CAAP,GAAW,CAAC,KAAKoC,OAAL,CAAarsC,CAAd,GAAkBmtC,QAA7B;EAA6B;;EAG/B,IAAI,KAAKtQ,OAAL,CAAan2B,MAAjB,EAAyB;IACvB,IAAIs5B,UACC,MAAKnD,OAAL,CAAa19B,KAAb,GACE,MAAKktC,OAAL,CAAaltC,KAAb,GAAqB,KAAKktC,OAAL,CAAaxsC,CAAb,GAAiB,CAAtC,IAA2C0sC,OAAOpyB,CADpD,IAED,GAHJ;IAAA,IAIE8lB,UACG,MAAKpD,OAAL,CAAax9B,MAAb,GACE,MAAKgtC,OAAL,CAAahtC,MAAb,GAAsB,KAAKgtC,OAAL,CAAarsC,CAAb,GAAiB,CAAvC,IAA4CusC,OAAOpyB,CADrD,IAED,GAPJ;IASAoyB,OAAOlqC,CAAP,GAAW29B,OAAX;IACAuM,OAAOtC,CAAP,GAAWhK,OAAX;EAAW;;EAIb,KAAK+L,aAAL,CAAmBC,IAAnB,GAA0BM,OAAOpyB,CAAjC;EACA,KAAK6xB,aAAL,CAAmBnsC,CAAnB,GAAuB0sC,OAAOlqC,CAA9B;EACA,KAAK2pC,aAAL,CAAmBhsC,CAAnB,GAAuBusC,OAAOtC,CAA9B;EAEA,OAAOsC,MAAP;AACF,CA3CAT;;AAkDAA,iBAAenqC,SAAfmqC,CAAyBsB,gBAAzBtB,GAA4C,YAAY;EACtD,OAAOnG,QAAM/C,MAAN+C,CAAa,EAAbA,EAAiB,KAAKqG,aAAtBrG,CAAP;AACF,CAFAmG;;AASAA,iBAAenqC,SAAfmqC,CAAyBuB,QAAzBvB,GAAoC,YAAY;EAC9C,OAAOnG,QAAM/C,MAAN+C,CAAa,EAAbA,EAAiB,KAAKuG,WAAtBvG,CAAP;AACF,CAFAmG;;AASAA,iBAAenqC,SAAfmqC,CAAyBwB,OAAzBxB,GAAmC,YAAY;EAC7C,OAAO,KAAKI,WAAL,CAAiBD,IAAxB;AACF,CAFAH;;AASAA,iBAAenqC,SAAfmqC,CAAyByB,eAAzBzB,GAA2C,YAAY;EACrD,OAAO,KAAKI,WAAL,CAAiBD,IAAjB,GAAwB,KAAKD,aAAL,CAAmBC,IAAlD;AACF,CAFAH;;AASAA,iBAAenqC,SAAfmqC,CAAyB0B,mBAAzB1B,GAA+C,UAAU/sC,KAAV,EAAiB;EAC9D,OAAOA,QAAQ,KAAKitC,aAAL,CAAmBC,IAAlC;AACF,CAFAH;;AASAA,iBAAenqC,SAAfmqC,CAAyB2B,MAAzB3B,GAAkC,YAAY;EAC5C,OAAO;IAAEjsC,GAAG,KAAKqsC,WAAL,CAAiBrsC,CAAtB;IAAyBG,GAAG,KAAKksC,WAAL,CAAiBlsC;EAA7C,CAAP;AACF,CAFA8rC;;AASAA,iBAAenqC,SAAfmqC,CAAyBlN,MAAzBkN,GAAkC,YAAY;EAC5C,IAAI4B,UAAU,KAAK7Q,OAAL,CAAap/B,GAAb,CAAiBkwC,eAAjB,EAAd;EAGAD,QAAQvzB,CAAR,GAAY,KAAK+xB,WAAL,CAAiBD,IAA7B;EACAyB,QAAQtzB,CAAR,GAAY,CAAZ;EACAszB,QAAQ3lB,CAAR,GAAY,CAAZ;EACA2lB,QAAQngB,CAAR,GAAY,KAAK2e,WAAL,CAAiBD,IAA7B;EACAyB,QAAQrrC,CAAR,GAAY,KAAK6pC,WAAL,CAAiBrsC,CAA7B;EACA6tC,QAAQzD,CAAR,GAAY,KAAKiC,WAAL,CAAiBlsC,CAA7B;EAEA,OAAO0tC,OAAP;AACF,CAZA5B;;AAmBAA,iBAAenqC,SAAfmqC,CAAyBhC,MAAzBgC,GAAkC,UAAUS,MAAV,EAAkB;EAClD,IAAIqB,WAAW,KAAKC,eAAL,CAAqBtB,MAArB,CAAf;EAAA,IACEuB,UAAU,KAAKC,cAAL,CAAoBxB,MAApB,CADZ;;EAGA,IAAIqB,YAAYE,OAAhB,EAAyB;IAEvB,IAAIF,QAAJ,EAAc;MAEZ,IACE,KAAK/Q,OAAL,CAAamR,UAAb,CACE,KAAKT,eAAL,EADF,EAEE,KAAKC,mBAAL,CAAyBjB,OAAOpyB,CAAhC,CAFF,MAGM,KAJR,EAKE;QACAoyB,OAAOpyB,CAAP,GAAWoyB,OAAOhf,CAAP,GAAW,KAAK2e,WAAL,CAAiBD,IAAvC;QACA2B,WAAW,KAAX;MAAW,CAPb,MAQO;QACL,KAAKK,WAAL,CAAiB1B,MAAjB;QACA,KAAK1P,OAAL,CAAaqR,MAAb,CAAoB,KAAKX,eAAL,EAApB;MAA0C;;;IAK9C,IAAIO,OAAJ,EAAa;MACX,IAAIK,aAAa,KAAKtR,OAAL,CAAauR,SAAb,CAAuB,KAAKX,MAAL,EAAvB,EAAsC;QACnD5tC,GAAG0sC,OAAOlqC,CADyC;QAEnDrC,GAAGusC,OAAOtC;MAFyC,CAAtC,CAAjB;MAAA,IAKEoE,cAAc,KALhB;MAAA,IAMEC,cAAc,KANhB;;MASA,IAAIH,eAAe,KAAnB,EAA0B;QAExB5B,OAAOlqC,CAAP,GAAW,KAAKorC,MAAL,GAAc5tC,CAAzB;QACA0sC,OAAOtC,CAAP,GAAW,KAAKwD,MAAL,GAAcztC,CAAzB;QAEAquC,cAAcC,cAAc,IAA5B;MAA4B,CAL9B,MAK8B,IACnB3I,QAAMxiC,QAANwiC,CAAewI,UAAfxI,CADmB,EACS;QAErC,IAAIwI,WAAWtuC,CAAX,KAAiB,KAArB,EAA4B;UAE1B0sC,OAAOlqC,CAAP,GAAW,KAAKorC,MAAL,GAAc5tC,CAAzB;UACAwuC,cAAc,IAAd;QAAc,CAHhB,MAGgB,IACL1I,QAAMvC,QAANuC,CAAewI,WAAWtuC,CAA1B8lC,CADK,EACyB;UAEvC4G,OAAOlqC,CAAP,GAAW8rC,WAAWtuC,CAAtB;QAAsB;;QAIxB,IAAIsuC,WAAWnuC,CAAX,KAAiB,KAArB,EAA4B;UAE1BusC,OAAOtC,CAAP,GAAW,KAAKwD,MAAL,GAAcztC,CAAzB;UACAsuC,cAAc,IAAd;QAAc,CAHhB,MAGgB,IACL3I,QAAMvC,QAANuC,CAAewI,WAAWnuC,CAA1B2lC,CADK,EACyB;UAEvC4G,OAAOtC,CAAP,GAAWkE,WAAWnuC,CAAtB;QAAsB;;;MAM1B,IAAKquC,eAAeC,WAAf,IAA+B,CAAC,KAAKP,cAAL,CAAoBxB,MAApB,CAArC,EAAkE;QAChEuB,UAAU,KAAV;MAAU,CADZ,MAEO;QACL,KAAKG,WAAL,CAAiB1B,MAAjB;QACA,KAAK1P,OAAL,CAAa0R,KAAb,CAAmB,KAAKd,MAAL,EAAnB;MAAgC;;;IAKpC,IAAIG,YAAYE,OAAhB,EAAyB;MACvB,KAAKnB,oBAAL;;;AAGN,CA5EAb;;AA8EAA,iBAAenqC,SAAfmqC,CAAyB+B,eAAzB/B,GAA2C,UAAUS,MAAV,EAAkB;EAC3D,OAAO,KAAKL,WAAL,CAAiBD,IAAjB,KAA0BM,OAAOpyB,CAAxC;AACF,CAFA2xB;;AAIAA,iBAAenqC,SAAfmqC,CAAyBiC,cAAzBjC,GAA0C,UAAUS,MAAV,EAAkB;EAC1D,OAAO,KAAKL,WAAL,CAAiBrsC,CAAjB,KAAuB0sC,OAAOlqC,CAA9B,IAAmC,KAAK6pC,WAAL,CAAiBlsC,CAAjB,KAAuBusC,OAAOtC,CAAxE;AACF,CAFA6B;;AASAA,iBAAenqC,SAAfmqC,CAAyBmC,WAAzBnC,GAAuC,UAAUS,MAAV,EAAkB;EACvD,KAAKL,WAAL,CAAiBD,IAAjB,GAAwBM,OAAOpyB,CAA/B;EACA,KAAK+xB,WAAL,CAAiBrsC,CAAjB,GAAqB0sC,OAAOlqC,CAA5B;EACA,KAAK6pC,WAAL,CAAiBlsC,CAAjB,GAAqBusC,OAAOtC,CAA5B;AACF,CAJA6B;;AAMAA,iBAAenqC,SAAfmqC,CAAyB0C,aAAzB1C,GAAyC,KAAzCA;;AAKAA,iBAAenqC,SAAfmqC,CAAyBa,oBAAzBb,GAAgD,YAAY;EAC1D,IAAI,CAAC,KAAK0C,aAAV,EAAyB;IAEvB,KAAKA,aAAL,GAAqB,IAArB;IAGA,KAAKlJ,qBAAL,CAA2BpjC,IAA3B,CAAgCyyB,MAAhC,EAAwC,KAAKwX,eAA7C;EAA4D;AAEhE,CARAL;;AAaAA,iBAAenqC,SAAfmqC,CAAyBM,SAAzBN,GAAqC,YAAY;EAC/C,IAAI2C,MAAM,KAAK7P,MAAL,EAAV;EAGAyL,WAASP,MAATO,CAAgB,KAAK3sC,QAArB2sC,EAA+BoE,GAA/BpE,EAAoC,KAAKL,IAAzCK;EAGA,KAAKmE,aAAL,GAAqB,KAArB;;EAGA,IAAI,KAAK3R,OAAL,CAAa6R,YAAjB,EAA+B;IAC7B,KAAK7R,OAAL,CAAa6R,YAAb,CAA0BD,GAA1B;EAA6B;AAEjC,CAbA3C;;IAeA6C,iBAAiB,UAAUjxC,QAAV,EAAoBm/B,OAApB,EAA6B;EAC5C,OAAO,IAAIiP,gBAAJ,CAAmBpuC,QAAnB,EAA6Bm/B,OAA7B,CAAP;AACF;;AC7WA,IAAI+R,QAAQhJ,QAAZ;AAAA,IACEiJ,eAAehD,YADjB;AAAA,IAEElG,QAAQmJ,SAFV;AAAA,IAGEzE,WAAW0E,YAHb;AAAA,IAIEjD,iBAAiBkD,cAJnB;;AAMA,IAAIC,aAAa,UAAUxxC,GAAV,EAAeo/B,OAAf,EAAwB;EACvC,KAAKkP,IAAL,CAAUtuC,GAAV,EAAeo/B,OAAf;AACF,CAFA;;AAIA,IAAIqS,kBAAkB;EACpBC,kBAAkB,wBADE;EAEpB15B,YAAY,IAFQ;EAGpB25B,qBAAqB,KAHD;EAIpB15B,aAAa,IAJO;EAKpB25B,qBAAqB,IALD;EAMpBv5B,uBAAuB,IANH;EAOpBw5B,2BAA2B,IAPP;EAQpBC,sBAAsB,GARF;EASpBC,SAAS,GATW;EAUpBC,SAAS,EAVW;EAWpBxC,KAAK,IAXe;EAYpBC,SAAS,KAZW;EAapBxmC,QAAQ,IAbY;EAcpB2+B,aAAa,MAdO;EAepB2I,YAAY,IAfQ;EAgBpBE,QAAQ,IAhBY;EAiBpBE,WAAW,IAjBS;EAkBpBG,OAAO,IAlBa;EAmBpBmB,qBAAqB,IAnBD;EAoBpBC,uBAAuB,IApBH;EAqBpBjB,cAAc;AArBM,CAAtB;AAwBA,IAAIkB,4BAA4B;EAAEzU,SAAS;AAAX,CAAhC;AACA,IAAI0U,6BAA6B;EAAE1U,SAAS;AAAX,CAAjC;;AAEA8T,WAAWttC,SAAX,CAAqBoqC,IAArB,GAA4B,UAAUtuC,GAAV,EAAeo/B,OAAf,EAAwB;EAClD,IAAImI,OAAO,IAAX;EAEA,KAAKvnC,GAAL,GAAWA,GAAX;EACA,KAAKusC,IAAL,GAAYvsC,IAAIqjC,aAAJ,CAAkB,MAAlB,CAAZ;EAGAuJ,SAASlB,kBAAT,CAA4B,KAAK1rC,GAAjC;EAGA,KAAKo/B,OAAL,GAAe8I,MAAM/C,MAAN,CAAa+C,MAAM/C,MAAN,CAAa,EAAb,EAAiBsM,eAAjB,CAAb,EAAgDrS,OAAhD,CAAf;EAGA,KAAKxc,KAAL,GAAa,MAAb;EAGA,IAAIyvB,+BACFzF,SAASlC,+BAAT,CAAyC1qC,GAAzC,CADF;EAEA,KAAK0B,KAAL,GAAa2wC,6BAA6B3wC,KAA1C;EACA,KAAKE,MAAL,GAAcywC,6BAA6BzwC,MAA3C;EAGA,KAAK3B,QAAL,GAAgBouC,eACdzB,SAAS/B,mBAAT,CAA6B,KAAK7qC,GAAlC,EAAuC,KAAKo/B,OAAL,CAAasS,gBAApD,CADc,EAEd;IACE1xC,KAAK,KAAKA,GADZ;IAEE0B,OAAO,KAAKA,KAFd;IAGEE,QAAQ,KAAKA,MAHf;IAIE4tC,KAAK,KAAKpQ,OAAL,CAAaoQ,GAJpB;IAKEC,SAAS,KAAKrQ,OAAL,CAAaqQ,OALxB;IAMExmC,QAAQ,KAAKm2B,OAAL,CAAan2B,MANvB;IAOE2+B,aAAa,KAAKxI,OAAL,CAAawI,WAP5B;IASE2I,YAAY,UAAU+B,QAAV,EAAoB5C,QAApB,EAA8B;MACxC,IAAInI,KAAKtnC,QAAL,IAAiBsnC,KAAKnI,OAAL,CAAamR,UAAlC,EAA8C;QAC5C,OAAOhJ,KAAKnI,OAAL,CAAamR,UAAb,CAAwB+B,QAAxB,EAAkC5C,QAAlC,CAAP;MAAiD;KAXvD;IAcEe,QAAQ,UAAUnvC,KAAV,EAAiB;MACvB,IAAIimC,KAAKtnC,QAAL,IAAiBsnC,KAAKnI,OAAL,CAAaqR,MAAlC,EAA0C;QACxC,OAAOlJ,KAAKnI,OAAL,CAAaqR,MAAb,CAAoBnvC,KAApB,CAAP;MAAgC;KAhBtC;IAmBEqvC,WAAW,UAAU4B,QAAV,EAAoBC,QAApB,EAA8B;MACvC,IAAIjL,KAAKtnC,QAAL,IAAiBsnC,KAAKnI,OAAL,CAAauR,SAAlC,EAA6C;QAC3C,OAAOpJ,KAAKnI,OAAL,CAAauR,SAAb,CAAuB4B,QAAvB,EAAiCC,QAAjC,CAAP;MAAgD;KArBtD;IAwBE1B,OAAO,UAAUhlB,KAAV,EAAiB;MACtB,IAAIyb,KAAKtnC,QAAL,IAAiBsnC,KAAKnI,OAAL,CAAa0R,KAAlC,EAAyC;QACvC,OAAOvJ,KAAKnI,OAAL,CAAa0R,KAAb,CAAmBhlB,KAAnB,CAAP;MAA+B;KA1BrC;IA6BEmlB,cAAc,UAAUD,GAAV,EAAe;MAC3B,IAAIzJ,KAAKtnC,QAAL,IAAiBsnC,KAAKnI,OAAL,CAAa6R,YAAlC,EAAgD;QAC9C,OAAO1J,KAAKnI,OAAL,CAAa6R,YAAb,CAA0BD,GAA1B,CAAP;MAAoC;;EA/B1C,CAFc,CAAhB;EAwCA,IAAIyB,iBAAiB,KAAKlF,iBAAL,EAArB;EACAkF,eAAeC,aAAf,CAA6B,KAAKtT,OAAL,CAAamR,UAA1C;EACAkC,eAAeE,SAAf,CAAyB,KAAKvT,OAAL,CAAaqR,MAAtC;EACAgC,eAAeG,YAAf,CAA4B,KAAKxT,OAAL,CAAauR,SAAzC;EACA8B,eAAeI,QAAf,CAAwB,KAAKzT,OAAL,CAAa0R,KAArC;EACA2B,eAAeK,eAAf,CAA+B,KAAK1T,OAAL,CAAa6R,YAA5C;;EAEA,IAAI,KAAK7R,OAAL,CAAauS,mBAAjB,EAAsC;IACpCP,aAAatE,MAAb,CAAoB,IAApB;EAAwB;;EAI1B,KAAKiG,uBAAL,GAA+Bj8B,KAAKC,GAAL,EAA/B;EACA,KAAKi8B,aAAL;AACF,CA5EA;;AAiFAxB,WAAWttC,SAAX,CAAqB8uC,aAArB,GAAqC,YAAY;EAC/C,IAAIzL,OAAO,IAAX;EAAA,IACEN,UAAU,IADZ;EAGA,KAAKgM,cAAL,GAAsB;IAEpBC,aAAa,UAAUvM,GAAV,EAAe;MAC1B,IAAIA,IAAIzO,WAAJ,KAAoB,OAAxB,EAAiC;MACjC,IAAIx1B,SAAS6kC,KAAK4L,eAAL,CAAqBxM,GAArB,EAA0BM,OAA1B,CAAb;MACAA,UAAUN,GAAV;MACA,OAAOjkC,MAAP;IAAO,CANW;IAQpB0wC,YAAY,UAAUzM,GAAV,EAAe;MACzB,IAAIjkC,SAAS6kC,KAAK8L,gBAAL,CAAsB1M,GAAtB,EAA2BM,OAA3B,CAAb;MACAA,UAAUN,GAAV;MACA,OAAOjkC,MAAP;IAAO,CAXW;IAepBw2B,WAAW,UAAUyN,GAAV,EAAe;MACxB,IAAIA,IAAIzO,WAAJ,KAAoB,OAAxB,EAAiC;MACjC,OAAOqP,KAAK+L,aAAL,CAAmB3M,GAAnB,CAAP;IAA6B,CAjBX;IAmBpB4M,UAAU,UAAU5M,GAAV,EAAe;MACvB,OAAOY,KAAKiM,cAAL,CAAoB7M,GAApB,CAAP;IAA8B,CApBZ;IAwBpB3N,aAAa,UAAU2N,GAAV,EAAe;MAC1B,IAAIA,IAAIzO,WAAJ,KAAoB,OAAxB,EAAiC;MACjC,OAAOqP,KAAKkM,eAAL,CAAqB9M,GAArB,CAAP;IAA+B,CA1Bb;IA4BpB+M,WAAW,UAAU/M,GAAV,EAAe;MACxB,OAAOY,KAAKoM,eAAL,CAAqBhN,GAArB,CAAP;IAA+B,CA7Bb;IAiCpBiN,cAAc,UAAUjN,GAAV,EAAe;MAC3B,IAAIA,IAAIzO,WAAJ,KAAoB,OAAxB,EAAiC;MACjC,OAAOqP,KAAK+L,aAAL,CAAmB3M,GAAnB,CAAP;IAA6B,CAnCX;IAqCpBvN,eAAe,UAAUuN,GAAV,EAAe;MAC5B,IAAIA,IAAIzO,WAAJ,KAAoB,OAAxB,EAAiC;MACjC,OAAOqP,KAAK+L,aAAL,CAAmB3M,GAAnB,CAAP;IAA6B,CAvCX;IAyCpBkN,YAAY,UAAUlN,GAAV,EAAe;MACzB,OAAOY,KAAKiM,cAAL,CAAoB7M,GAApB,CAAP;IAA8B,CA1CZ;IA4CpBmN,aAAa,UAAUnN,GAAV,EAAe;MAC1B,OAAOY,KAAKiM,cAAL,CAAoB7M,GAApB,CAAP;IAA8B;EA7CZ,CAAtB;;EAmDA,IAAI,KAAKvH,OAAL,CAAa6S,mBAAb,IAAoC,IAAxC,EAA8C;IAC5C,KAAK7S,OAAL,CAAa6S,mBAAb,CAAiC3D,IAAjC,CAAsC;MACpCyF,YAAY,KAAK/zC,GADmB;MAEpCkyC,uBAAuB,KAAK9S,OAAL,CAAa8S,qBAFA;MAGpCnF,UAAU,KAAKQ,iBAAL;IAH0B,CAAtC;IAOA,IAAIyG,qBACF,KAAK5U,OAAL,CAAa6S,mBAAb,CAAiC+B,kBADnC;;IAEA,IAAIA,sBAAsBA,mBAAmBtzC,MAA7C,EAAqD;MACnD,SAAS4jB,IAAI0vB,mBAAmBtzC,MAAnB,GAA4B,CAAzC,EAA4C4jB,KAAK,CAAjD,EAAoDA,GAApD,EAAyD;QACvD,IAAI,KAAK2uB,cAAL,CAAoB9uC,cAApB,CAAmC6vC,mBAAmB1vB,CAAnB,CAAnC,CAAJ,EAA+D;UAC7D,OAAO,KAAK2uB,cAAL,CAAoBe,mBAAmB1vB,CAAnB,CAApB,CAAP;QAA8C;;;;;EAOtD,SAAS/K,KAAT,IAAkB,KAAK05B,cAAvB,EAAuC;IAEpC,MAAK7T,OAAL,CAAa8S,qBAAb,IAAsC,KAAKlyC,GAA3C,EAAgDq7B,gBAAhD,CACC9hB,KADD,EAEC,KAAK05B,cAAL,CAAoB15B,KAApB,CAFD,EAGC,CAAC,KAAK6lB,OAAL,CAAayS,yBAAd,GACIM,yBADJ,GAEIC,0BALL;;;EAUH,IAAI,KAAKhT,OAAL,CAAa/mB,qBAAjB,EAAwC;IACtC,KAAK+mB,OAAL,CAAa/mB,qBAAb,GAAqC,KAArC;IACA,KAAK47B,oBAAL;;AAEJ,CA3FA;;AAgGAzC,WAAWttC,SAAX,CAAqB+vC,oBAArB,GAA4C,YAAY;EACtD,IAAI,CAAC,KAAK7U,OAAL,CAAa/mB,qBAAlB,EAAyC;IACvC,IAAIkvB,OAAO,IAAX;;IAGA,KAAK2M,aAAL,GAAqB,UAAUvN,GAAV,EAAe;MAClC,OAAOY,KAAK4M,gBAAL,CAAsBxN,GAAtB,CAAP;IAAgC,CADlC;;IAKA,IAAI8C,oBAAoB,CAAC,KAAKrK,OAAL,CAAayS,yBAAtC;IACAV,MAAMznC,EAAN,CACE,KAAK01B,OAAL,CAAa8S,qBAAb,IAAsC,KAAKlyC,GAD7C,EAEE,KAAKk0C,aAFP,EAGEzK,iBAHF;IAMA,KAAKrK,OAAL,CAAa/mB,qBAAb,GAAqC,IAArC;EAAqC;AAEzC,CAnBA;;AAwBAm5B,WAAWttC,SAAX,CAAqBkwC,qBAArB,GAA6C,YAAY;EACvD,IAAI,KAAKhV,OAAL,CAAa/mB,qBAAjB,EAAwC;IACtC,IAAIoxB,oBAAoB,CAAC,KAAKrK,OAAL,CAAayS,yBAAtC;IACAV,MAAMvnC,GAAN,CACE,KAAKw1B,OAAL,CAAa8S,qBAAb,IAAsC,KAAKlyC,GAD7C,EAEE,KAAKk0C,aAFP,EAGEzK,iBAHF;IAKA,KAAKrK,OAAL,CAAa/mB,qBAAb,GAAqC,KAArC;EAAqC;AAEzC,CAVA;;AAiBAm5B,WAAWttC,SAAX,CAAqBiwC,gBAArB,GAAwC,UAAUxN,GAAV,EAAe;EACrD,IAAI,CAAC,KAAKvH,OAAL,CAAannB,WAAd,IAA6B,KAAK2K,KAAL,KAAe,MAAhD,EAAwD;IACtD;EAAA;;EAGF,IAAI,KAAKwc,OAAL,CAAayS,yBAAjB,EAA4C;IAC1C,IAAIlL,IAAIhJ,cAAR,EAAwB;MACtBgJ,IAAIhJ,cAAJ;KADF,MAEO;MACLgJ,IAAIuC,WAAJ,GAAkB,KAAlB;IAAkB;;;EAKtB,IAAImL,QAAQ1N,IAAIyC,MAAJ,IAAc,CAA1B;EAAA,IACEkL,YAAYx9B,KAAKC,GAAL,KAAa,KAAKg8B,uBADhC;EAAA,IAEEwB,UAAU,IAAIryC,KAAKmU,GAAL,CAAS,CAAT,EAAY,KAAKi+B,SAAjB,CAFhB;EAKA,KAAKvB,uBAAL,GAA+Bj8B,KAAKC,GAAL,EAA/B;;EAGA,IAAI,eAAe4vB,GAAf,IAAsBA,IAAIoC,SAAJ,KAAkB,CAAxC,IAA6CpC,IAAI0C,UAArD,EAAiE;IAC/DgL,QAAQ1N,IAAIyC,MAAJ,KAAe,CAAf,GAAmB,CAAnB,GAAuBlnC,KAAKC,GAAL,CAASwkC,IAAI0C,UAAb,IAA2B1C,IAAIyC,MAA9D;EAA8D;;EAGhEiL,QACE,OAAOA,KAAP,IAAgBA,QAAQ,GAAxB,GACIA,KADJ,GAEM,SAAQ,CAAR,GAAY,CAAZ,GAAgB,EAAhB,IAAsBnyC,KAAKsyC,GAAL,CAAStyC,KAAKC,GAAL,CAASkyC,KAAT,IAAkB,EAA3B,CAAtB,GAAwDE,OAHhE;EAKA,IAAIE,oBAAoB,KAAKz0C,GAAL,CAAS00C,YAAT,GAAwBtT,OAAxB,EAAxB;EAAA,IACEuT,qBAAqB/H,SAASH,aAAT,CAAuB9F,GAAvB,EAA4B,KAAK3mC,GAAjC,EAAsCkhC,eAAtC,CACnBuT,iBADmB,CADvB;EAAA,IAIEjG,OAAOtsC,KAAKyjB,GAAL,CAAS,IAAI,KAAKyZ,OAAL,CAAa0S,oBAA1B,EAAgD,KAAKuC,KAArD,CAJT;EAMA,KAAKO,WAAL,CAAiBpG,IAAjB,EAAuBmG,kBAAvB;AACF,CAtCA;;AAgDAnD,WAAWttC,SAAX,CAAqB0wC,WAArB,GAAmC,UAAUC,SAAV,EAAqB/oB,KAArB,EAA4BgpB,YAA5B,EAA0C;EAC3E,IAAIvG,gBAAgB,KAAKtuC,QAAL,CAAc0vC,gBAAd,EAApB;;EAEA,IAAI,CAACmF,YAAL,EAAmB;IAEjB,IACE,KAAKjF,OAAL,KAAiBgF,SAAjB,GACA,KAAKzV,OAAL,CAAa2S,OAAb,GAAuBxD,cAAcC,IAFvC,EAGE;MACAqG,YAAa,KAAKzV,OAAL,CAAa2S,OAAb,GAAuBxD,cAAcC,IAArC,GAA6C,KAAKqB,OAAL,EAA1D;KAJF,UAME,KAAKA,OAAL,KAAiBgF,SAAjB,GACA,KAAKzV,OAAL,CAAa4S,OAAb,GAAuBzD,cAAcC,MACrC;MACAqG,YAAa,KAAKzV,OAAL,CAAa4S,OAAb,GAAuBzD,cAAcC,IAArC,GAA6C,KAAKqB,OAAL,EAA1D;;GAXJ,MAaO;IAELgF,YAAY3yC,KAAKmU,GAAL,CACV,KAAK+oB,OAAL,CAAa2S,OAAb,GAAuBxD,cAAcC,IAD3B,EAEVtsC,KAAK8E,GAAL,CAAS,KAAKo4B,OAAL,CAAa4S,OAAb,GAAuBzD,cAAcC,IAA9C,EAAoDqG,SAApD,CAFU,CAAZ;IAKAA,YAAYA,YAAY,KAAKhF,OAAL,EAAxB;;;EAGF,IAAIkF,SAAS,KAAK90C,QAAL,CAAckhC,MAAd,EAAb;EAAA,IACE6T,gBAAgBlpB,MAAMoV,eAAN,CAAsB6T,OAAO3T,OAAP,EAAtB,CADlB;EAAA,IAEE6T,WAAW,KAAKj1C,GAAL,CACRkwC,eADQ,GAERgF,SAFQ,CAEEF,cAAc5yC,CAFhB,EAEmB4yC,cAAczyC,CAFjC,EAGRjB,KAHQ,CAGFuzC,SAHE,EAIRK,SAJQ,CAIE,CAACF,cAAc5yC,CAJjB,EAIoB,CAAC4yC,cAAczyC,CAJnC,CAFb;EAAA,IAOEusC,SAASiG,OAAOluB,QAAP,CAAgBouB,QAAhB,CAPX;;EASA,IAAInG,OAAOpyB,CAAP,KAAaq4B,OAAOr4B,CAAxB,EAA2B;IACzB,KAAKzc,QAAL,CAAcosC,MAAd,CAAqByC,MAArB;EAA2B;AAE/B,CAtCA;;AA8CA0C,WAAWttC,SAAX,CAAqBsqC,IAArB,GAA4B,UAAUltC,KAAV,EAAiB6zC,QAAjB,EAA2B;EACrD,KAAKP,WAAL,CACEtzC,KADF,EAEEsrC,SAASD,iBAAT,CAA2B,KAAK3sC,GAAhC,EAAqC,KAAK0B,KAA1C,EAAiD,KAAKE,MAAtD,CAFF,EAGEuzC,QAHF;AAKF,CANA;;AAcA3D,WAAWttC,SAAX,CAAqBkxC,UAArB,GAAkC,UAAU9zC,KAAV,EAAiB6zC,QAAjB,EAA2B;EAC3D,IAAIA,QAAJ,EAAc;IACZ7zC,QAAQ,KAAK+zC,uBAAL,CAA6B/zC,KAA7B,CAAR;EAA0C;;EAG5C,KAAKktC,IAAL,CAAUltC,KAAV,EAAiB6zC,QAAjB;AACF,CANA;;AAeA3D,WAAWttC,SAAX,CAAqBoxC,iBAArB,GAAyC,UAAUh0C,KAAV,EAAiBwqB,KAAjB,EAAwBqpB,QAAxB,EAAkC;EACzE,IAAIA,QAAJ,EAAc;IAEZ7zC,QAAQ,KAAK+zC,uBAAL,CAA6B/zC,KAA7B,CAAR;EAA0C;;EAI5C,IAAI4mC,MAAMzB,OAAN,CAAc3a,KAAd,MAAyB,UAA7B,EAAyC;IACvC,IAAI,OAAOA,KAAP,IAAgB,OAAOA,KAA3B,EAAkC;MAChCA,QAAQ8gB,SAAS5L,cAAT,CAAwB,KAAKhhC,GAA7B,EAAkC8rB,MAAM1pB,CAAxC,EAA2C0pB,MAAMvpB,CAAjD,CAAR;IAA0D,CAD5D,MAEO;MACL,MAAM,IAAI9C,KAAJ,CAAU,wBAAV,CAAN;IAAwC;;;EAI5C,KAAKm1C,WAAL,CAAiBtzC,KAAjB,EAAwBwqB,KAAxB,EAA+BqpB,QAA/B;AACF,CAhBA;;AAuBA3D,WAAWttC,SAAX,CAAqB2rC,OAArB,GAA+B,YAAY;EACzC,OAAO,KAAK5vC,QAAL,CAAc4vC,OAAd,EAAP;AACF,CAFA;;AASA2B,WAAWttC,SAAX,CAAqB4rC,eAArB,GAAuC,YAAY;EACjD,OAAO,KAAK7vC,QAAL,CAAc6vC,eAAd,EAAP;AACF,CAFA;;AAUA0B,WAAWttC,SAAX,CAAqBmxC,uBAArB,GAA+C,UAAU7G,IAAV,EAAgB;EAC7D,OAAOA,OAAO,KAAKvuC,QAAL,CAAc0vC,gBAAd,GAAiCnB,IAA/C;AACF,CAFA;;AAOAgD,WAAWttC,SAAX,CAAqBqxC,SAArB,GAAiC,YAAY;EAC3C,IAAIhH,gBAAgB,KAAKtuC,QAAL,CAAc0vC,gBAAd,EAApB;EAEA,KAAKnB,IAAL,CAAUD,cAAcC,IAAxB,EAA8B,IAA9B;AACF,CAJA;;AASAgD,WAAWttC,SAAX,CAAqBsxC,QAArB,GAAgC,YAAY;EAC1C,KAAKC,GAAL,CAAS,KAAKx1C,QAAL,CAAc0vC,gBAAd,EAAT;AACF,CAFA;;AAOA6B,WAAWttC,SAAX,CAAqBypC,KAArB,GAA6B,YAAY;EACvC,KAAK4H,SAAL;EACA,KAAKC,QAAL;AACF,CAHA;;AAWAhE,WAAWttC,SAAX,CAAqBwxC,cAArB,GAAsC,UAAU/O,GAAV,EAAe;EACnD,IAAI,KAAKvH,OAAL,CAAayS,yBAAjB,EAA4C;IAC1C,IAAIlL,IAAIhJ,cAAR,EAAwB;MACtBgJ,IAAIhJ,cAAJ;KADF,MAEO;MACLgJ,IAAIuC,WAAJ,GAAkB,KAAlB;IAAkB;;;EAKtB,IAAI,KAAK9J,OAAL,CAAauS,mBAAjB,EAAsC;IACpC,IAAIgE,cAAchP,IAAIvmC,MAAJ,CAAW8qC,YAAX,CAAwB,OAAxB,KAAoC,EAAtD;;IACA,IAAIyK,YAAY9Q,OAAZ,CAAoB,sBAApB,IAA8C,EAAlD,EAAsD;MACpD,OAAO,KAAP;IAAO;;;EAIX,IAAI+Q,UAAJ;;EAEA,IAAIjP,IAAIpP,QAAR,EAAkB;IAChBqe,aAAa,KAAM,KAAI,KAAKxW,OAAL,CAAa0S,oBAAjB,IAAyC,CAA/C,CAAb;EAA4D,CAD9D,MAEO;IACL8D,aAAc,KAAI,KAAKxW,OAAL,CAAa0S,oBAAjB,IAAyC,CAAvD;EAAuD;;EAGzD,IAAIhmB,QAAQ8gB,SAASH,aAAT,CAAuB9F,GAAvB,EAA4B,KAAK3mC,GAAjC,EAAsCkhC,eAAtC,CACV,KAAKlhC,GAAL,CAAS00C,YAAT,GAAwBtT,OAAxB,EADU,CAAZ;EAGA,KAAKwT,WAAL,CAAiBgB,UAAjB,EAA6B9pB,KAA7B;AACF,CA7BA;;AAoCA0lB,WAAWttC,SAAX,CAAqBivC,eAArB,GAAuC,UAAUxM,GAAV,EAAeM,OAAf,EAAwB;EAC7D,IAAI,KAAK7H,OAAL,CAAayS,yBAAjB,EAA4C;IAC1C,IAAIlL,IAAIhJ,cAAR,EAAwB;MACtBgJ,IAAIhJ,cAAJ;KADF,MAEO;MACLgJ,IAAIuC,WAAJ,GAAkB,KAAlB;IAAkB;;;EAItBhB,MAAMxB,sBAAN,CAA6BC,GAA7B,EAAkC,KAAK3mC,GAAvC;;EAGA,IAAI,KAAKo/B,OAAL,CAAawS,mBAAb,IAAoC1J,MAAMlB,UAAN,CAAiBL,GAAjB,EAAsBM,OAAtB,CAAxC,EAAwE;IACtE,KAAKyO,cAAL,CAAoB/O,GAApB;EAAuB,CADzB,MAEO;IAEL,KAAK/jB,KAAL,GAAa,KAAb;IACA,KAAKizB,aAAL,GAAqB,KAAK51C,QAAL,CAAckhC,MAAd,EAArB;IACA,KAAK2U,WAAL,GAAmBlJ,SAASH,aAAT,CAAuB9F,GAAvB,EAA4B,KAAK3mC,GAAjC,EAAsCkhC,eAAtC,CACjB,KAAK2U,aAAL,CAAmBzU,OAAnB,EADiB,CAAnB;;AAIJ,CAtBA;;AA6BAoQ,WAAWttC,SAAX,CAAqBuvC,eAArB,GAAuC,UAAU9M,GAAV,EAAe;EACpD,IAAI,KAAKvH,OAAL,CAAayS,yBAAjB,EAA4C;IAC1C,IAAIlL,IAAIhJ,cAAR,EAAwB;MACtBgJ,IAAIhJ,cAAJ;KADF,MAEO;MACLgJ,IAAIuC,WAAJ,GAAkB,KAAlB;IAAkB;;;EAItB,IAAI,KAAKtmB,KAAL,KAAe,KAAf,IAAwB,KAAKwc,OAAL,CAAapnB,UAAzC,EAAqD;IAEnD,IAAI8T,QAAQ8gB,SAASH,aAAT,CAAuB9F,GAAvB,EAA4B,KAAK3mC,GAAjC,EAAsCkhC,eAAtC,CACR,KAAK2U,aAAL,CAAmBzU,OAAnB,EADQ,CAAZ;IAAA,IAGE2U,cAAc,KAAKF,aAAL,CAAmBX,SAAnB,CACZppB,MAAM1pB,CAAN,GAAU,KAAK0zC,WAAL,CAAiB1zC,CADf,EAEZ0pB,MAAMvpB,CAAN,GAAU,KAAKuzC,WAAL,CAAiBvzC,CAFf,CAHhB;IAQA,KAAKtC,QAAL,CAAcosC,MAAd,CAAqB0J,WAArB;EAAgC;AAEpC,CArBA;;AA4BAvE,WAAWttC,SAAX,CAAqBovC,aAArB,GAAqC,UAAU3M,GAAV,EAAe;EAClD,IAAI,KAAKvH,OAAL,CAAayS,yBAAjB,EAA4C;IAC1C,IAAIlL,IAAIhJ,cAAR,EAAwB;MACtBgJ,IAAIhJ,cAAJ;KADF,MAEO;MACLgJ,IAAIuC,WAAJ,GAAkB,KAAlB;IAAkB;;;EAItB,IAAI,KAAKtmB,KAAL,KAAe,KAAnB,EAA0B;IAExB,KAAKA,KAAL,GAAa,MAAb;EAAa;AAEjB,CAbA;;AAoBA4uB,WAAWttC,SAAX,CAAqBmvC,gBAArB,GAAwC,UAAU1M,GAAV,EAAeM,OAAf,EAAwB;EAC9D,IAAIN,IAAIC,OAAJ,CAAYlmC,MAAZ,IAAsB,CAA1B,EAA6B;IAC3B,KAAKyyC,eAAL,CAAqBxM,GAArB,EAA0BM,OAA1B;EAAiC,CADnC,MAEO;IACL,IAAI,KAAK7H,OAAL,CAAayS,yBAAjB,EAA4C;MAC1C,IAAIlL,IAAIhJ,cAAR,EAAwB;QACtBgJ,IAAIhJ,cAAJ;OADF,MAEO;QACLgJ,IAAIuC,WAAJ,GAAkB,KAAlB;MAAkB;;;IAItB,KAAK2M,aAAL,GAAqB,KAAK51C,QAAL,CAAckhC,MAAd,EAArB;IACA,IAAI6U,SAASpJ,SAASF,aAAT,CAAuB/F,GAAvB,EAA4B,KAAK3mC,GAAjC,EAAsC,CAAtC,CAAb;IACA,IAAIi2C,SAASrJ,SAASF,aAAT,CAAuB/F,GAAvB,EAA4B,KAAK3mC,GAAjC,EAAsC,CAAtC,CAAb;IACA,KAAKk2C,aAAL,GAAqBhO,MAAMH,iBAAN,CAAwBiO,MAAxB,EAAgCC,MAAhC,CAArB;IACAD,OAAO5zC,CAAP,GAAY,QAAOA,CAAP,GAAW6zC,OAAO7zC,CAAlB,IAAuB,CAAnC;IACA4zC,OAAOzzC,CAAP,GAAY,QAAOA,CAAP,GAAW0zC,OAAO1zC,CAAlB,IAAuB,CAAnC;IACA,KAAKuzC,WAAL,GAAmBE,OAAO9U,eAAP,CAAuB,KAAK2U,aAAL,CAAmBzU,OAAnB,EAAvB,CAAnB;IACA,KAAK+U,cAAL,GAAsB,KAAKtG,OAAL,EAAtB;;AAEJ,CArBA;;AA4BA2B,WAAWttC,SAAX,CAAqByvC,eAArB,GAAuC,UAAUhN,GAAV,EAAe;EACpD,IAAIA,IAAIC,OAAJ,CAAYlmC,MAAZ,IAAsB,CAA1B,EAA6B;IAC3B,KAAK+yC,eAAL,CAAqB9M,GAArB;EAAwB,CAD1B,MAEO;IAEL,IAAI,KAAKvH,OAAL,CAAayS,yBAAjB,EAA4C;MAC1C,IAAIlL,IAAIhJ,cAAR,EAAwB;QACtBgJ,IAAIhJ,cAAJ;OADF,MAEO;QACLgJ,IAAIuC,WAAJ,GAAkB,KAAlB;MAAkB;;;IAGtB,IAAI,CAAC,KAAK9J,OAAL,CAAapnB,UAAd,IAA4B,CAAC,KAAKonB,OAAL,CAAannB,WAA9C,EAA2D;MACzD;IAAA;;IAGF,IAAI+9B,SAASpJ,SAASF,aAAT,CAAuB/F,GAAvB,EAA4B,KAAK3mC,GAAjC,EAAsC,CAAtC,CAAb;IACA,IAAIi2C,SAASrJ,SAASF,aAAT,CAAuB/F,GAAvB,EAA4B,KAAK3mC,GAAjC,EAAsC,CAAtC,CAAb;IACA,IAAIiJ,SAAS,KAAKjJ,GAAL,CAASghC,cAAT,EAAb;IACA/3B,OAAO7G,CAAP,GAAY,QAAOA,CAAP,GAAW6zC,OAAO7zC,CAAlB,IAAuB,CAAnC;IACA6G,OAAO1G,CAAP,GAAY,QAAOA,CAAP,GAAW0zC,OAAO1zC,CAAlB,IAAuB,CAAnC;;IAEA,IAAI,KAAKqgB,KAAL,KAAe,KAAf,IAAwB,KAAKwc,OAAL,CAAapnB,UAAzC,EAAqD;MAEnD,IAAI8T,QAAQ7iB,OAAOi4B,eAAP,CAAuB,KAAK2U,aAAL,CAAmBzU,OAAnB,EAAvB,CAAZ;MACA,IAAI2U,cAAc,KAAKF,aAAL,CAAmBX,SAAnB,CAChBppB,MAAM1pB,CAAN,GAAU,KAAK0zC,WAAL,CAAiB1zC,CADX,EAEhB0pB,MAAMvpB,CAAN,GAAU,KAAKuzC,WAAL,CAAiBvzC,CAFX,CAAlB;MAIA,KAAKtC,QAAL,CAAcosC,MAAd,CAAqB0J,WAArB;IAAgC;;IAGlC,IAAI,KAAK3W,OAAL,CAAannB,WAAjB,EAA8B;MAE5B,IAAI+U,YAAWkb,MAAMH,iBAAN,CAAwBiO,MAAxB,EAAgCC,MAAhC,CAAf;MACA,IAAI30C,QAAQ0rB,YAAW,KAAKkpB,aAA5B;MACA,IAAIzB,oBAAoB,KAAKz0C,GAAL,CAAS00C,YAAT,GAAwBtT,OAAxB,EAAxB;MACA,IAAIgV,qBAAqBntC,OAAOi4B,eAAP,CAAuBuT,iBAAvB,CAAzB;MACA,KAAKG,WAAL,CAAiB,KAAKuB,cAAL,GAAsB70C,KAAvC,EAA8C80C,kBAA9C,EAAkE,IAAlE;IAAsE;;AAG5E,CAzCA;;AAgDA5E,WAAWttC,SAAX,CAAqBsvC,cAArB,GAAsC,UAAU7M,GAAV,EAAe;EACnD,IAAIA,IAAIC,OAAJ,CAAYlmC,MAAZ,IAAsB,CAA1B,EAA6B;IAC3B,KAAK4yC,aAAL,CAAmB3M,GAAnB;EAAsB,CADxB,MAEO;IACL,IAAI,KAAKvH,OAAL,CAAayS,yBAAjB,EAA4C;MAC1C,IAAIlL,IAAIhJ,cAAR,EAAwB;QACtBgJ,IAAIhJ,cAAJ;OADF,MAEO;QACLgJ,IAAIuC,WAAJ,GAAkB,KAAlB;MAAkB;;;IAItB,KAAK2M,aAAL,GAAqB,KAAK51C,QAAL,CAAckhC,MAAd,EAArB;;IACA,IAAIwF,IAAIC,OAAJ,CAAYlmC,MAAZ,IAAsB,CAA1B,EAA6B;MAC3B,KAAKo1C,WAAL,GAAmBlJ,SAASH,aAAT,CAAuB9F,GAAvB,EAA4B,KAAK3mC,GAAjC,EAAsCkhC,eAAtC,CACjB,KAAK2U,aAAL,CAAmBzU,OAAnB,EADiB,CAAnB;KADF,MAIO;MACL,IAAI4U,SAASpJ,SAASF,aAAT,CAAuB/F,GAAvB,EAA4B,KAAK3mC,GAAjC,EAAsC,CAAtC,CAAb;MACA,IAAIi2C,SAASrJ,SAASF,aAAT,CAAuB/F,GAAvB,EAA4B,KAAK3mC,GAAjC,EAAsC,CAAtC,CAAb;MACA,KAAKk2C,aAAL,GAAqBhO,MAAMH,iBAAN,CAAwBiO,MAAxB,EAAgCC,MAAhC,CAArB;MACAD,OAAO5zC,CAAP,GAAY,QAAOA,CAAP,GAAW6zC,OAAO7zC,CAAlB,IAAuB,CAAnC;MACA4zC,OAAOzzC,CAAP,GAAY,QAAOA,CAAP,GAAW0zC,OAAO1zC,CAAlB,IAAuB,CAAnC;MACA,KAAKuzC,WAAL,GAAmBE,OAAO9U,eAAP,CAAuB,KAAK2U,aAAL,CAAmBzU,OAAnB,EAAvB,CAAnB;IAAsE;;AAG5E,CA1BA;;AAgCAoQ,WAAWttC,SAAX,CAAqBsrC,GAArB,GAA2B,YAAY;EACrC,IAAIZ,UAAU,KAAK3uC,QAAL,CAAcsvC,UAAd,EAAd;EAAA,IACEG,WAAWxtC,KAAK8E,GAAL,CACT,KAAKtF,KAAL,GAAaktC,QAAQltC,KADZ,EAET,KAAKE,MAAL,GAAcgtC,QAAQhtC,MAFb,CADb;EAMA,KAAK4sC,IAAL,CAAUkB,QAAV,EAAoB,IAApB;AACF,CARA;;AAcA8B,WAAWttC,SAAX,CAAqBurC,OAArB,GAA+B,YAAY;EACzC,IAAIb,UAAU,KAAK3uC,QAAL,CAAcsvC,UAAd,EAAd;EAAA,IACEG,WAAWxtC,KAAKmU,GAAL,CACT,KAAK3U,KAAL,GAAaktC,QAAQltC,KADZ,EAET,KAAKE,MAAL,GAAcgtC,QAAQhtC,MAFb,CADb;EAMA,KAAK4sC,IAAL,CAAUkB,QAAV,EAAoB,IAApB;AACF,CARA;;AAcA8B,WAAWttC,SAAX,CAAqB+E,MAArB,GAA8B,YAAY;EACxC,IAAI2lC,UAAU,KAAK3uC,QAAL,CAAcsvC,UAAd,EAAd;EAAA,IACEhN,UACG,MAAK7gC,KAAL,GAAc,SAAQA,KAAR,GAAgBktC,QAAQxsC,CAAR,GAAY,CAA5B,IAAiC,KAAKytC,OAAL,EAA/C,IAAiE,GAFtE;EAAA,IAGErN,UACG,MAAK5gC,MAAL,GAAe,SAAQA,MAAR,GAAiBgtC,QAAQrsC,CAAR,GAAY,CAA7B,IAAkC,KAAKstC,OAAL,EAAjD,IAAmE,GAJxE;EAMA,KAAKtC,iBAAL,GAAyBkI,GAAzB,CAA6B;IAAErzC,GAAGmgC,OAAL;IAAchgC,GAAGigC;EAAjB,CAA7B;AACF,CARA;;AAcAgP,WAAWttC,SAAX,CAAqBmyC,UAArB,GAAkC,YAAY;EAC5C,KAAKp2C,QAAL,CAAcmvC,kBAAd;AACF,CAFA;;AASAoC,WAAWttC,SAAX,CAAqBuxC,GAArB,GAA2B,UAAU3pB,KAAV,EAAiB;EAC1C,IAAIiqB,cAAc,KAAK91C,QAAL,CAAckhC,MAAd,EAAlB;EACA4U,YAAYnxC,CAAZ,GAAgBknB,MAAM1pB,CAAtB;EACA2zC,YAAYvJ,CAAZ,GAAgB1gB,MAAMvpB,CAAtB;EACA,KAAKtC,QAAL,CAAcosC,MAAd,CAAqB0J,WAArB;AACF,CALA;;AAYAvE,WAAWttC,SAAX,CAAqBoyC,KAArB,GAA6B,UAAUxqB,KAAV,EAAiB;EAC5C,IAAIiqB,cAAc,KAAK91C,QAAL,CAAckhC,MAAd,EAAlB;EACA4U,YAAYnxC,CAAZ,IAAiBknB,MAAM1pB,CAAvB;EACA2zC,YAAYvJ,CAAZ,IAAiB1gB,MAAMvpB,CAAvB;EACA,KAAKtC,QAAL,CAAcosC,MAAd,CAAqB0J,WAArB;AACF,CALA;;AAYAvE,WAAWttC,SAAX,CAAqB8rC,MAArB,GAA8B,YAAY;EACxC,IAAIptB,QAAQ,KAAK3iB,QAAL,CAAc2vC,QAAd,EAAZ;EAEA,OAAO;IAAExtC,GAAGwgB,MAAMxgB,CAAX;IAAcG,GAAGqgB,MAAMrgB;EAAvB,CAAP;AACF,CAJA;;AASAivC,WAAWttC,SAAX,CAAqBqyC,MAArB,GAA8B,YAAY;EAExC,IAAIlE,+BAA+BzF,SAASlC,+BAAT,CACjC,KAAK1qC,GAD4B,CAAnC;EAGA,KAAK0B,KAAL,GAAa2wC,6BAA6B3wC,KAA1C;EACA,KAAKE,MAAL,GAAcywC,6BAA6BzwC,MAA3C;EAGA,IAAI3B,WAAW,KAAKA,QAApB;EACAA,SAASm/B,OAAT,CAAiB19B,KAAjB,GAAyB,KAAKA,KAA9B;EACAzB,SAASm/B,OAAT,CAAiBx9B,MAAjB,GAA0B,KAAKA,MAA/B;EACA3B,SAAS8uC,UAAT;;EAGA,IAAI,KAAK3P,OAAL,CAAauS,mBAAjB,EAAsC;IACpC,KAAKpE,iBAAL,GAAyBiJ,mBAAzB;IACA,KAAKjJ,iBAAL,GAAyBkJ,kBAAzB;;AAEJ,CAnBA;;AAwBAjF,WAAWttC,SAAX,CAAqBwyC,OAArB,GAA+B,YAAY;EACzC,IAAInP,OAAO,IAAX;EAGA,KAAKgJ,UAAL,GAAkB,IAAlB;EACA,KAAKE,MAAL,GAAc,IAAd;EACA,KAAKE,SAAL,GAAiB,IAAjB;EACA,KAAKG,KAAL,GAAa,IAAb;EACA,KAAKG,YAAL,GAAoB,IAApB;;EAIA,IAAI,KAAK7R,OAAL,CAAa6S,mBAAb,IAAoC,IAAxC,EAA8C;IAC5C,KAAK7S,OAAL,CAAa6S,mBAAb,CAAiCyE,OAAjC,CAAyC;MACvC3C,YAAY,KAAK/zC,GADsB;MAEvCkyC,uBAAuB,KAAK9S,OAAL,CAAa8S,qBAFG;MAGvCnF,UAAU,KAAKQ,iBAAL;IAH6B,CAAzC;EAIC;;EAIH,SAASh0B,KAAT,IAAkB,KAAK05B,cAAvB,EAAuC;IACpC,MAAK7T,OAAL,CAAa8S,qBAAb,IAAsC,KAAKlyC,GAA3C,EAAgDg7B,mBAAhD,CACCzhB,KADD,EAEC,KAAK05B,cAAL,CAAoB15B,KAApB,CAFD,EAGC,CAAC,KAAK6lB,OAAL,CAAayS,yBAAd,GACIM,yBADJ,GAEIC,0BALL;;;EAUH,KAAKgC,qBAAL;EAGA,KAAK7G,iBAAL,GAAyBiJ,mBAAzB;EAGAG,iBAAiBA,eAAen2C,MAAf,CAAsB,UAAUusC,QAAV,EAAoB;IACzD,OAAOA,SAAS/sC,GAAT,KAAiBunC,KAAKvnC,GAA7B;EACD,CAFgB,CAAjB;EAKA,OAAO,KAAKo/B,OAAZ;EAGA,OAAO,KAAKn/B,QAAZ;EAGA,OAAO,KAAKwyC,cAAZ;EACA,OAAO,KAAKmE,EAAZ;;EACA,KAAKrJ,iBAAL,GAAyB,YAAY;IACnC,OAAO,IAAP;EAAO,CADT;AAGF,CAtDA;;AA6DAiE,WAAWttC,SAAX,CAAqBqpC,iBAArB,GAAyC,YAAY;EACnD,IAAIhG,OAAO,IAAX;;EAGA,IAAI,CAAC,KAAKkL,cAAV,EAA0B;IACxB,KAAKA,cAAL,GAAsB,KAAKmE,EAAL,GAAU;MAE9BC,WAAW,YAAY;QACrBtP,KAAKnI,OAAL,CAAapnB,UAAb,GAA0B,IAA1B;QACA,OAAOuvB,KAAKqP,EAAZ;MAAY,CAJgB;MAM9BE,YAAY,YAAY;QACtBvP,KAAKnI,OAAL,CAAapnB,UAAb,GAA0B,KAA1B;QACA,OAAOuvB,KAAKqP,EAAZ;MAAY,CARgB;MAU9BG,cAAc,YAAY;QACxB,OAAO,CAAC,CAACxP,KAAKnI,OAAL,CAAapnB,UAAtB;MAAsB,CAXM;MAa9By9B,KAAK,UAAU3pB,KAAV,EAAiB;QACpByb,KAAKkO,GAAL,CAAS3pB,KAAT;QACA,OAAOyb,KAAKqP,EAAZ;MAAY,CAfgB;MAiB9BN,OAAO,UAAUxqB,KAAV,EAAiB;QACtByb,KAAK+O,KAAL,CAAWxqB,KAAX;QACA,OAAOyb,KAAKqP,EAAZ;MAAY,CAnBgB;MAqB9B5G,QAAQ,YAAY;QAClB,OAAOzI,KAAKyI,MAAL,EAAP;OAtB4B;MAyB9B4C,cAAc,UAAUrM,EAAV,EAAc;QAC1BgB,KAAKnI,OAAL,CAAauR,SAAb,GACEpK,OAAO,IAAP,GAAc,IAAd,GAAqB2B,MAAM5B,KAAN,CAAYC,EAAZ,EAAgBgB,KAAKkL,cAArB,CADvB;QAEA,OAAOlL,KAAKqP,EAAZ;MAAY,CA5BgB;MA8B9B/D,UAAU,UAAUtM,EAAV,EAAc;QACtBgB,KAAKnI,OAAL,CAAa0R,KAAb,GACEvK,OAAO,IAAP,GAAc,IAAd,GAAqB2B,MAAM5B,KAAN,CAAYC,EAAZ,EAAgBgB,KAAKkL,cAArB,CADvB;QAEA,OAAOlL,KAAKqP,EAAZ;MAAY,CAjCgB;MAoC9BI,YAAY,YAAY;QACtBzP,KAAKnI,OAAL,CAAannB,WAAb,GAA2B,IAA3B;QACA,OAAOsvB,KAAKqP,EAAZ;MAAY,CAtCgB;MAwC9BK,aAAa,YAAY;QACvB1P,KAAKnI,OAAL,CAAannB,WAAb,GAA2B,KAA3B;QACA,OAAOsvB,KAAKqP,EAAZ;MAAY,CA1CgB;MA4C9BM,eAAe,YAAY;QACzB,OAAO,CAAC,CAAC3P,KAAKnI,OAAL,CAAannB,WAAtB;MAAsB,CA7CM;MA+C9Bw+B,oBAAoB,YAAY;QAC9B,IAAI,CAAClP,KAAKnI,OAAL,CAAauS,mBAAlB,EAAuC;UACrCpK,KAAKnI,OAAL,CAAauS,mBAAb,GAAmC,IAAnC;UACAP,aAAatE,MAAb,CAAoBvF,IAApB;QAAwB;;QAE1B,OAAOA,KAAKqP,EAAZ;MAAY,CApDgB;MAsD9BJ,qBAAqB,YAAY;QAC/B,IAAIjP,KAAKnI,OAAL,CAAauS,mBAAjB,EAAsC;UACpCpK,KAAKnI,OAAL,CAAauS,mBAAb,GAAmC,KAAnC;UACAP,aAAalD,OAAb,CAAqB3G,IAArB;QAAyB;;QAE3B,OAAOA,KAAKqP,EAAZ;MAAY,CA3DgB;MA6D9BO,uBAAuB,YAAY;QACjC,OAAO,CAAC,CAAC5P,KAAKnI,OAAL,CAAauS,mBAAtB;MAAsB,CA9DM;MAiE9ByF,oBAAoB,YAAY;QAC9B7P,KAAKnI,OAAL,CAAawS,mBAAb,GAAmC,IAAnC;QACA,OAAOrK,KAAKqP,EAAZ;MAAY,CAnEgB;MAqE9BS,qBAAqB,YAAY;QAC/B9P,KAAKnI,OAAL,CAAawS,mBAAb,GAAmC,KAAnC;QACA,OAAOrK,KAAKqP,EAAZ;MAAY,CAvEgB;MAyE9BU,uBAAuB,YAAY;QACjC,OAAO,CAAC,CAAC/P,KAAKnI,OAAL,CAAawS,mBAAtB;MAAsB,CA1EM;MA6E9BqC,sBAAsB,YAAY;QAChC1M,KAAK0M,oBAAL;QACA,OAAO1M,KAAKqP,EAAZ;MAAY,CA/EgB;MAiF9BxC,uBAAuB,YAAY;QACjC7M,KAAK6M,qBAAL;QACA,OAAO7M,KAAKqP,EAAZ;MAAY,CAnFgB;MAqF9BW,yBAAyB,YAAY;QACnC,OAAO,CAAC,CAAChQ,KAAKnI,OAAL,CAAa/mB,qBAAtB;MAAsB,CAtFM;MAyF9Bm/B,yBAAyB,UAAUl2C,KAAV,EAAiB;QACxCimC,KAAKnI,OAAL,CAAa0S,oBAAb,GAAoCxwC,KAApC;QACA,OAAOimC,KAAKqP,EAAZ;MAAY,CA3FgB;MA6F9Ba,YAAY,UAAUjJ,IAAV,EAAgB;QAC1BjH,KAAKnI,OAAL,CAAa2S,OAAb,GAAuBvD,IAAvB;QACA,OAAOjH,KAAKqP,EAAZ;MAAY,CA/FgB;MAiG9Bc,YAAY,UAAUlJ,IAAV,EAAgB;QAC1BjH,KAAKnI,OAAL,CAAa4S,OAAb,GAAuBxD,IAAvB;QACA,OAAOjH,KAAKqP,EAAZ;MAAY,CAnGgB;MAsG9BlE,eAAe,UAAUnM,EAAV,EAAc;QAC3BgB,KAAKnI,OAAL,CAAamR,UAAb,GACEhK,OAAO,IAAP,GAAc,IAAd,GAAqB2B,MAAM5B,KAAN,CAAYC,EAAZ,EAAgBgB,KAAKkL,cAArB,CADvB;QAEA,OAAOlL,KAAKqP,EAAZ;MAAY,CAzGgB;MA2G9BjE,WAAW,UAAUpM,EAAV,EAAc;QACvBgB,KAAKnI,OAAL,CAAaqR,MAAb,GACElK,OAAO,IAAP,GAAc,IAAd,GAAqB2B,MAAM5B,KAAN,CAAYC,EAAZ,EAAgBgB,KAAKkL,cAArB,CADvB;QAEA,OAAOlL,KAAKqP,EAAZ;MAAY,CA9GgB;MAiH9BpI,MAAM,UAAUltC,KAAV,EAAiB;QACrBimC,KAAK6N,UAAL,CAAgB9zC,KAAhB,EAAuB,IAAvB;QACA,OAAOimC,KAAKqP,EAAZ;MAAY,CAnHgB;MAqH9Be,QAAQ,UAAUr2C,KAAV,EAAiB;QACvBimC,KAAK6N,UAAL,CAAgB9zC,KAAhB,EAAuB,KAAvB;QACA,OAAOimC,KAAKqP,EAAZ;MAAY,CAvHgB;MAyH9BhC,aAAa,UAAUtzC,KAAV,EAAiBwqB,KAAjB,EAAwB;QACnCyb,KAAK+N,iBAAL,CAAuBh0C,KAAvB,EAA8BwqB,KAA9B,EAAqC,IAArC;QACA,OAAOyb,KAAKqP,EAAZ;MAAY,CA3HgB;MA6H9BgB,eAAe,UAAUt2C,KAAV,EAAiBwqB,KAAjB,EAAwB;QACrCyb,KAAK+N,iBAAL,CAAuBh0C,KAAvB,EAA8BwqB,KAA9B,EAAqC,KAArC;QACA,OAAOyb,KAAKqP,EAAZ;MAAY,CA/HgB;MAiI9BtJ,QAAQ,YAAY;QAClB,KAAKqK,MAAL,CAAY,IAAIpQ,KAAKnI,OAAL,CAAa0S,oBAA7B;QACA,OAAOvK,KAAKqP,EAAZ;MAAY,CAnIgB;MAqI9B7I,SAAS,YAAY;QACnB,KAAK4J,MAAL,CAAY,KAAK,IAAIpQ,KAAKnI,OAAL,CAAa0S,oBAAtB,CAAZ;QACA,OAAOvK,KAAKqP,EAAZ;MAAY,CAvIgB;MAyI9B/G,SAAS,YAAY;QACnB,OAAOtI,KAAKuI,eAAL,EAAP;OA1I4B;MA6I9BgD,iBAAiB,UAAUvM,EAAV,EAAc;QAC7BgB,KAAKnI,OAAL,CAAa6R,YAAb,GACE1K,OAAO,IAAP,GAAc,IAAd,GAAqB2B,MAAM5B,KAAN,CAAYC,EAAZ,EAAgBgB,KAAKkL,cAArB,CADvB;QAEA,OAAOlL,KAAKqP,EAAZ;MAAY,CAhJgB;MAmJ9BrB,WAAW,YAAY;QACrBhO,KAAKgO,SAAL;QACA,OAAOhO,KAAKqP,EAAZ;MAAY,CArJgB;MAuJ9BpB,UAAU,YAAY;QACpBjO,KAAKiO,QAAL;QACA,OAAOjO,KAAKqP,EAAZ;MAAY,CAzJgB;MA2J9BjJ,OAAO,YAAY;QACjBpG,KAAKoG,KAAL;QACA,OAAOpG,KAAKqP,EAAZ;MAAY,CA7JgB;MAgK9BpH,KAAK,YAAY;QACfjI,KAAKiI,GAAL;QACA,OAAOjI,KAAKqP,EAAZ;MAAY,CAlKgB;MAoK9BnH,SAAS,YAAY;QACnBlI,KAAKkI,OAAL;QACA,OAAOlI,KAAKqP,EAAZ;MAAY,CAtKgB;MAwK9B3tC,QAAQ,YAAY;QAClBs+B,KAAKt+B,MAAL;QACA,OAAOs+B,KAAKqP,EAAZ;MAAY,CA1KgB;MA6K9BP,YAAY,YAAY;QACtB9O,KAAK8O,UAAL;QACA,OAAO9O,KAAKqP,EAAZ;MAAY,CA/KgB;MAiL9BL,QAAQ,YAAY;QAClBhP,KAAKgP,MAAL;QACA,OAAOhP,KAAKqP,EAAZ;MAAY,CAnLgB;MAqL9BiB,UAAU,YAAY;QACpB,OAAO;UACLn2C,OAAO6lC,KAAK7lC,KADP;UAELE,QAAQ2lC,KAAK3lC,MAFR;UAGLk2C,UAAUvQ,KAAKsI,OAAL,EAHL;UAILjB,SAASrH,KAAKtnC,QAAL,CAAcsvC,UAAd;QAJJ,CAAP;OAtL4B;MA8L9BmH,SAAS,YAAY;QACnBnP,KAAKmP,OAAL;QACA,OAAOnP,KAAKqP,EAAZ;MAAY;IAhMgB,CAAhC;;;EAqMF,OAAO,KAAKnE,cAAZ;AACF,CA3MA;;AAmNA,IAAIkE,iBAAiB,EAArB;;AAEA,IAAIz2C,aAAa,UAAU4lC,iBAAV,EAA6B1G,OAA7B,EAAsC;EACrD,IAAIp/B,MAAMkoC,MAAMrC,MAAN,CAAaC,iBAAb,CAAV;;EAEA,IAAI9lC,QAAQ,IAAZ,EAAkB;IAChB,OAAO,IAAP;EAAO,CADT,MAEO;IAEL,SAASskB,IAAIqyB,eAAej2C,MAAf,GAAwB,CAArC,EAAwC4jB,KAAK,CAA7C,EAAgDA,GAAhD,EAAqD;MACnD,IAAIqyB,eAAeryB,CAAf,EAAkBtkB,GAAlB,KAA0BA,GAA9B,EAAmC;QACjC,OAAO22C,eAAeryB,CAAf,EAAkByoB,QAAlB,CAA2BQ,iBAA3B,EAAP;;;;IAKJoJ,eAAejsC,IAAf,CAAoB;MAClB1K,GADkB;MAElB+sC,UAAU,IAAIyE,UAAJ,CAAexxC,GAAf,EAAoBo/B,OAApB;IAFQ,CAApB;IAMA,OAAOuX,eACLA,eAAej2C,MAAf,GAAwB,CADnB,EAELqsC,QAFK,CAEIQ,iBAFJ,EAAP;;AAIJ,CAxBA;;IA0BAwK,eAAiB73C;ACxgCjB,MAAM83C,UAAuC;EAC3CC,gBAAwC;SACjCzI,MACFvmC,SACA8kC,UACAA;WACI;EAAA,CANkC;;EAQ3CnlC,cAAsC;UAC9BsvC,QAAQ,KAAKL,QAAL;UACRpC,MAAM,KAAKzF,MAAL;UACN1uC,QAAQ42C,MAAMJ;QAChB11C,KAAKd;QACLiB,KAAKjB;UACHrB,WAAW;MACfyB,OAAOw2C,MAAMx2C,KAAN,GAAcJ,KADN;MAEfM,QAAQs2C,MAAMt2C,MAAN,GAAeN;IAFR;WAIV;MACL+H,KAAK;QACHoiB,KAAK,CAACgqB,IAAIlzC,CADP;QAEHmpB,QAAQzrB,SAAS2B,MAAT,GAAkB6zC,IAAIlzC,CAF3B;QAGHipB,MAAM,CAACiqB,IAAIrzC,CAHR;QAIHkH,OAAOrJ,SAASyB,KAAT,GAAiB+zC,IAAIrzC;MAJzB,CADA;MAOL6G,QAAQ;QACN7G,GAAGnC,SAASyB,KAAT,GAAiB,CAAjB,GAAqB+zC,IAAIrzC,CADtB;QAENG,GAAGtC,SAAS2B,MAAT,GAAkB,CAAlB,GAAsB6zC,IAAIlzC;MAFvB;IAPH;GAlBkC;;EA+B3CgtC,aAA0C;WACjC,KAAK3mC,WAAL,GAAmBS;EAAA,CAhCe;;EAkC3C8uC,WAAqC9uC,GAArC,EAA+C;UAIvC3H,QAAQ2H,IAAIC,KAAJ,GAAYD,IAAImiB;UACxB5pB,SAASyH,IAAIqiB,MAAJ,GAAariB,IAAIoiB;UAC1B;MAAE/pB,OAAO02C,SAAT;MAAoBx2C,QAAQy2C;IAA5B,IAA2C,KAAKR,QAAL;UAC3CS,QAAQ52C,QAAQE;UAChB22C,eAAeH,YAAYC;UAC3BG,WAAWF,QAAQC,YAAR,GAAuB32C,SAAS22C,YAAhC,GAA+C72C;UAC1D+2C,YAAYH,QAAQC,YAAR,GAAuB72C,QAAQ62C,YAA/B,GAA8C32C;UAC1D82C,eAAex2C,KAAK8E,GAAL,CACnBoxC,YAAYI,QADO,EAEnBH,aAAaI,SAFM;UAIfX,WAAW,KAAKa,WAAL;UACXC,eAAe,KAAK/I,OAAL;UACfgJ,eAAef,WAAWc;SAC3BpK,KAAKkK,eAAeG;UAEnB5vC,SAAS;MACb7G,QAAQopB,IAAR,GAAe9pB,QAAQ,CAAvB,IAA4Bg3C,YADf;MAEbn2C,QAAQkpB,GAAR,GAAc7pB,SAAS,CAAvB,IAA4B82C;IAFf;SAIVjD,IAAI;MACPrzC,GAAG,CAAE6G,OAAO7G,CAAT,GAAco2C,WAAW,CAAX,GAAeE,YADzB;MAEPn2C,GAAG,CAAE0G,OAAO1G,CAAT,GAAck2C,YAAY,CAAZ,GAAgBC;IAF1B;EAGR,CA7DwC;;EA+D3CC,cAAsC;WAC7B,KAAKd,QAAL,GAAgBC;EAAA,CAhEkB;;EAkE3CgB,uBAAiDtgB,SAAjD,EAAoEtgB,YAApE,EAA0FC,YAA1F,EAAgH;UAExGnR,MAAM9E,KAAKmU,GAAL,CAAS,IAAT,EAAiB6B,YAAjB;UACN7B,MAAMnU,KAAKmU,GAAL,CAASrP,GAAT,EAAcmR,YAAd;UACNq2B,OAAOtsC,KAAKmU,GAAL,CAASnU,KAAK8E,GAAL,CAASqP,GAAT,EAAcmiB,SAAd,CAAT,EAAmCxxB,GAAnC;UAEP8wC,WAAW,KAAKa,WAAL;UACXC,eAAe,KAAK/I,OAAL;UACfgJ,eAAef,WAAWc;SAE3BnB,WAAWzwC,MAAM6xC,cACnBnB,WAAWrhC,MAAMwiC,cACjBrK,KAAKA,OAAOqK;EAAY,CA9Ec;;EAgF3C9B,eAAuC;WAC9B,KAAKgC;EAAA,CAjF6B;;EAmF3ClC,YAAoC;SAC7BkC,gBAAgB;;SAChBC;;WACE;EAAA,CAtFkC;;EAwF3ClC,aAAqC;SAC9BiC,gBAAgB;;SAChBE;;WACE;EAAA,CA3FkC;;EA6F3C/B,gBAAwC;WAC/B,KAAKgC;EAAA,CA9F6B;;EAgG3ClC,aAAqC;SAC9BkC,iBAAiB;;SACjBC;;WACE;EAAA,CAnGkC;;EAqG3ClC,cAAsC;SAC/BiC,iBAAiB;;SACjBE;;WACE;EAAA,CAxGkC;;EA0G3CC,cAAwCt+B,OAAxC,EAA0D;QACpDA,SAAS;WACN87B;WACA;WACAC;;;WAEA;EAAA,CAhHkC;;EAkH3CwC,eAAyCv+B,OAAzC,EAA2D;QACrDA,SAAS;WACNi8B;WACAI;WACA;WACAH;WACAI;;;WAEA;EAAA;;AA1HkC,CAA7C;;AA8HA,qBACE1uC,WADF,EAEEy2B,OAFF,EAGsB;;;QACd2N,WAAWpkC;WACRowC,gBAAgB,cAAQ/gC,UAAR,iBAAsB;WACtCkhC,iBAAiB,yCAASjhC,WAAT,iBAAwB;WACzCshC,wBAAwBxM,SAASgK;WACjCiC,qBAAqBjM,SAAS8J;WAC9BoC,sBAAsBlM,SAAS+J;WAC/B0C,yBAAyBzM,SAASmK;WAClCiC,sBAAsBpM,SAASiK;WAC/BoC,uBAAuBrM,SAASkK;SAClC/1C,OAAOyH,aAAYqvC;SACnBjL;AACT;;4BAGE/sC,KACAo/B,SACoB;;;QAEdqa,WAAW,oBAAQxH,mBAAR,wBAA6B3D,IAA7B,iBAAuC3b,CAAvC,IAAkD;QAC7D+mB,cAAc,oBAAQzH,mBAAR,wBAA6ByE,OAA7B,iBAA0C/jB,CAA1C,IAAqD;QACnEqhB,qBAAqB,oBAAQ/B,mBAAR,wBAA6B+B,kBAA7B,iBAAmD;;MAE1E5U,QAAQ/mB,qBAAR,KAAkC,QAAW;YACvCA,wBAAwB+mB,QAAQnnB;EAAA;;UAGlCg6B,sBAAsB;IAC5B3D,MAAMhJ,KAAK;kBACGA,EAAEyH,UAAU3N;eACfkG;IAAC,CAHgB;IAK5BoR,SAASpR,KAAKoU,YAAYpU,CAAZ,CALc;IAM5B0O;EAN4B;SASvB9zC,aAAWF,GAAXE,EAAgBk/B,OAAhBl/B;AACT;;uBC7M8BF,KAAqCo/B,SAA4B;QACvF2N,WAAW1a;MACbzP,QAAQ;QACN+2B,mBAA+B;QAC/BC,qBAAiC;;QAEjCC,kBAAkB,MAAM;YACpB;qBACS/6B,QAAQwL,KAAKA;qBACb5pB,SAAS;EAAA;;QAGtBo5C,oBAAoB,MAAM;YACtB;uBACWh7B,QAAQwL,KAAKA;uBACb5pB,SAAS;EAAA;;YAGpB,MAAM;;;UACRqlC,UAAUlmC,QAAQG,IAAIZ,KAAZ,EAAmB,OAAnB;UAEVq6C,WAAW,oBAAQxH,mBAAR,wBAA6B3D,IAA7B,iBAAuC3b,CAAvC,IAAkD;UAC7D+mB,cAAc,oBAAQzH,mBAAR,wBAA6ByE,OAA7B,iBAA0C/jB,CAA1C,IAAqD;UACnEqhB,qBAAqB,oBAAQ/B,mBAAR,wBAA6B+B,kBAA7B,iBAAmD;YAEtE/B,sBAAsB;MAC5B3D,MAAMhJ,KAAK;iBACAlmC,QAAQkmC,EAAEyH;iBACVzH;;OAHiB;MAM5BoR,SAASpR,KAAK;;oBAEAA;MAAC,CARa;MAU5B0O;IAV4B;;UAaxB+F,aAAa,MAAM;YACjBjvB,OAAOib,QAAQtD,qBAAR;;UAOT3X,KAAKppB,KAAL,KAAe,CAAf,IAAoBopB,KAAKlpB,MAAL,KAAgB,GAAG;2BACtBmkC,SAAS3G;MAAO,OAC9B;mBACM2a,YAAY;MAAG;;;;EAI/B;cAEW,MAAM;;;mBACP36C,6BAAOs3C,OAAP;aACAt3C,QAAQ;EAClB;;QAEK46C,sBAAuBh5C,QAAD,IAAwB;QAC9C4hB,UAAU,GAAe;uBACVlY,KAAK1J;IAAQ,WACrB4hB,UAAU,CADW,EACI;;;;;QAKhCq3B,wBAAyBj5C,QAAD,IAAwB;QAChD4hB,UAAU,CAAV,IAA2BA,UAAU,GAAe;yBACnClY,KAAK1J;IAAQ,OAC3B;;;;;SAKF;IAAEd,YAAY6sC,QAAd;IAAwBiN,mBAAxB;IAA6CC;EAA7C;AACT;;AChFA,MAAMC,eAAev6C,OAAO,WAAP,CAArB;;0BAEiC64B,WAAwB2hB,WAAuB;QACxE74C,QAAQuvB,SAAS,MAAM;WACpBspB,UAAUpiC,cAAV,GAA2B,CAA3B,GAAgC,IAAIygB,UAAUp5B;EACtD,CAFa;UAGN86C,cAAc;IACpB1hB,SADoB;IAEpBl3B;EAFoB;SAIf;IAAEA;EAAF;AACT;;wBAE6C;SACpCzB,QAAQC,OAAOo6C,YAAP,CAAR,EAA8B,WAA9B;AACT;;ACXA,mBAAmB33B,GAAnB,EAAsC;SAC7BA,eAAe5B,OAAf,IAA2B4B,OAAO,OAAOA,IAAI63B,IAAX,KAAoB;AAC/D;;8BAEqC;MAC/B5a,UAAyB;QACvB6a,mBAAmBhoB,IAA0B;IACjDtX,SAAS,KADwC;IAEjDu/B,UAAU,GAFuC;IAGjDC,gBAAgB;EAHiC,CAA1B;;2BAOvBrzC,MACAozC,WAAmB,KACnBC,iBAAiC,UACjC;QACI/a,SAAS;mBACEA;gBACH;IAAA;;qBAEKpgC,QAAQ;MACvB2b,SAAS,IADc;MAEvBu/B,QAFuB;MAGvBC;IAHuB;aAMhB,MAAYC;YACbC,UAAUvzC;;UACZwzC,UAAUD,OAAV,GAAoB;cAChBA;MAAA;;UAGJjb,SAAS;qBACEA;MAAO;;gBAEZtI,iCAAQ8I,UAAR,CAAmB,MAAM;yBAChB5gC,MAAM2b,UAAU;kBACvB;MAAA,CAFF,EAGPu/B,QAHO;IAGP,CAZgB;EAapB;;SAGI;IAAEK,eAAF;IAAmBN;EAAnB;AACT;;mCCtD6CO,OAAwB;QAC7D5qB,UAAUqC,IAA0B,EAA1B;QAEV8L,+BAA+B9L,IAAI,KAAJ;MACjCwoB,UAAS;QACPC,6BAAcluC,GAAd;cAGM,MAAM;QACZguC,MAAMx7C,KAAN,YAAuBmH,OAAO;YAC1Bw0C,iCAAkBn6B,GAAlB,CAA8B,EAA9B;cACExhB,QAAQkB,OAAOK,WAAP,CACdi6C,MAAMx7C,KAAN,CAAYyB,GAAZ,CAAgBob,QAAQ;YAClB/T,KAAK+T,KAAK/T;;YACV,CAACA,IAAI;cACH,CAACi2B,6BAA6B/+B,OAAO;yCACVA,QAAQ;oBAC7B+kB,KACN;UAGF;;eAEG22B,QAAQ7vC,GAAR,CAAYgR,IAAZ;;cACD,CAAC/T,IAAI;iBACF,UAAU2yC;oBACPhwC,IAAIoR,MAAM/T;UAAE;;;oBAGZqV,IAAIrV;eACT,CAACA,EAAD,EAAK+T,IAAL;MACR,CAnBD,CADc;;UAsBZkiB,6BAA6B/+B,OAAO;mBAC3B,CAAC6c,IAAD,EAAO/T,EAAP,KAAc3B,MAAMic,IAAN,CAAWs4B,QAAQl6C,OAAR,EAAX,GAA+B;cAClD,CAACm6C,YAAY5vC,GAAZ,CAAgBjD,EAAhB,GAAqB;oBAChBya,OAAO1G;UAAI;;;WAIpB;cACG7c,QAAQw7C,MAAMx7C;IAAA;EAEzB;SAEM;IAAE4wB,OAAF;IAAWmO;EAAX;AACT;;kBC5CExvB,OACAnP,MACA66B,MACA75B,QACW;MAMPA,QAAQ;UACJw6C,QAAO3oB,IAAU7xB,OAAOmO,MAAMnP,IAAN,CAAP,CAAV;;UACPy7C,SAAUC,QAAD,IAAoB;UAC7B,CAACx4B,QAAQw4B,QAAR,EAAkBF,MAAK57C,KAAvB,GAA+B;cAC7BA,QAAQ87C;MAAA;;UAEX,CAACx4B,QAAQw4B,QAAR,EAAkBvsC,MAAMnP,IAAN,CAAlB,GAAgC;aAC9B,UAAUA,QAAiB07C;MAAQ;;;UAGtC,MAAM16C,OAAOw6C,MAAK57C,KAAZ,GAAoB67C;UAC1B,MAAMtsC,MAAMnP,IAAN,GAAYiB,KAAKw6C,OAAOz6C,OAAOC,CAAP,CAAP;;QACzBu6C,MAAK57C,KAAL,KAAeuP,MAAMnP,IAAN,GAAa;WACzB,UAAUA,QAAiBw7C,MAAK57C;IAAK;;WAErC47C;EAAA;;QAGH5V,OAAO/S,IAAU1jB,MAAMnP,IAAN,CAAV;QAEX,MAAMmP,MAAMnP,IAAN,GACNiB,KAAK;QACC,CAACiiB,QAAQjiB,CAAR,EAAW2kC,KAAKhmC,KAAhB,GAAwB;WACtBA,QAAQqB;IAAA;EAGnB;QACM2kC,MAAM3kC,KAAK;QACX,CAACiiB,QAAQjiB,CAAR,EAAWkO,MAAMnP,IAAN,CAAX,GAAyB;WACvB,UAAUA,QAAiBiB;IAAC;EAEpC;SACM2kC;AACT;;wBAOEz2B,OACAnP,MACA27C,cACA9gB,MACuB;QAGjB+gB,QAAQ97C,6BAA0BshB,GAA1B;QAEZ,MAAMjS,MAAMnP,IAAN,GACN,MAAM;UAGE4lC,OAAiBz2B,MAAMnP,IAAN;UACjB07C,WAAW9V,KAAK5kC,MAAL,CAAY0C,KAAKA,KAAKi4C,aAAa/7C,KAAnC;;QACb,CAACsjB,QAAQw4B,QAAR,EAAkB30C,MAAMic,IAAN,CAAW44B,KAAX,CAAlB,GAAsC;YACnCzwC;eACGmU,QAAQs8B,MAAM79B,KAAK69B;IAAK;KAGrC;IAAEh+B,MAAM,IAAR;IAAcD,WAAW;EAAzB;QAEIi+B,OAAO,MAAM;UACXr4C,QAAQwD,MAAMic,IAAN,CAAW44B,KAAX;;QACV,CAAC14B,QAAQ/T,MAAMnP,IAAN,CAAR,EAAqBuD,KAArB,GAA6B;WAC3B,UAAUvD,QAAiBuD;IAAK;EAExC;SACM8f,SAASu4B,KAAT;AACT;;;;;;;;;;;;;;;;;;;;;;;;;UC/DM;MAAE95C;IAAF,IAAY+5C;UAEZj5C,IAAIiwB,IAAI1jB,MAAM2sC,KAAV;UACJ/4C,IAAI8vB,IAAI1jB,MAAM4sC,KAAV;UACJpiC,cAAckZ,IAAI,CAAJ;UACdjZ,cAAciZ,IAAI,SAAJ;UACdhZ,kBAAkBgZ,IAAiC,MAAjC;UAClB1wB,SAAS0wB,IAAI,CAAJ;UACT3wB,QAAQ2wB,IAAI,CAAJ;UACRzwB,SAASywB,IAAI,CAAJ;UACTvY,eAAeuY,IAAI,CAAJ;gBAET,MAAM;;;YACVpvB,IAAI3B,MAAMlC;kBACJA,QAAQuP,MAAMmO,MAAN,CAAa3D,WAAb,GAA2BlW;kBACnC7D,QAAQ,YAAM0d,MAAN,CAAa1D,WAAb,iBAA4B;sBAChCha,QAAQo8C,sBAAsB7sC,MAAMmO,MAAN,CAAazD,eAAnC,EAAoDpW,CAApD;;UAEpB0L,MAAMmO,MAAN,CAAarb,IAAb,KAAsB,UAAU;UAChCrC,QAAQuP,MAAM2sC;UACdl8C,QAAQuP,MAAM4sC;eACTn8C,QAAQuP,MAAMmO,MAAN,CAAanb,MAAb,GAAsBsB;MAAA,OAChC;cACC7D,QAAQuP,MAAMmO,MAAN,CAAapb,KAAb,GAAqBuB;eAC5B7D,QAAQuP,MAAMmO,MAAN,CAAalb,MAAb,GAAsBqB;qBACxB7D,QAAQuP,MAAMmO,MAAN,CAAahD,YAAb,GAA4B7W;UAC/C7D,QAAQuP,MAAM2sC,KAAN,GAAc55C,MAAMtC,KAAN,GAAc;UACpCA,QAAQuP,MAAM4sC,KAAN,GAAc35C,OAAOxC,KAAP,GAAe;MAAA;IAE1C;WAEY;MACXgD,CADW;MAEXG,CAFW;MAGX4W,WAHW;MAIXC,WAJW;MAKXC,eALW;MAMX1X,MANW;MAOXD,KAPW;MAQXE,MARW;MASXkY;IATW;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;sCC3CX2hC,UACA9Y,MACA+Y,YACA;;;YACMC,OAAOF,SAAQnM,OAAR;WACTltC,IAAIu5C,KAAKv5C;WACTG,IAAIo5C,KAAKp5C;WACTb,QAAQi6C,KAAKj6C;WACbE,SAAS+5C,KAAK/5C;iBACRxC,QAAQ,eAAQ8rC,YAAR,CAAqB,WAArB,kBAAqC;IAAA;;oCAIvDuQ,UACA9Y,MACA+Y,YACA;YACME,YAAW,IAAIC,gBAAJ,CAAqB,MAAM;iCACjBJ,UAAS9Y,MAAK+Y;MACxC,CAFgB;gBAGRI,QAAQL,UAAS;QACxBM,YAAY,IADY;QAExBC,iBAAiB,CAAC,GAAD,EAAM,GAAN,EAAW,WAAX,EAAwB,WAAxB;MAFO;+BAIDP,UAAS9Y,MAAK+Y;aAChCE;IAAA;;UA2BHK,QAAQC;UAER;MAAE56C;IAAF,IAAY+5C;UAEZc,QAAQtrB,SAAS;;;MAAM,yBAAMlW,IAAN,wBAAYtW,QAAZ,GAAuB1B,KAAvB,CAA6B,OAA7B,kBAAyC,EAAzC;IAA2C,CAA1D;UAER0X,WAAWwW,SAAS,MAAM;;;aACvB,YAAM,WAAN,kBAAiCliB,MAAMmO,MAAN,CAAazC,QAAb,GAAwB/Y,MAAMlC;IACvE,CAFgB;UAIXkb,aAAauW,SAAS,MAAMxW,SAASjb,KAAT,GAAiBuP,MAAMmO,MAAN,CAAaxC,UAA7C;UAEb8hC,YAAYvrB,SAAS,MAAM;YACzBwrB,mBAAmB1tC,MAAM0tC;;UAC3BA,qBAAqB,WAAW;eAC3B;MAAA,WACEA,qBAAqB,SADvB,EACkC;eAClC,aAAaj9C,KAAb,IAAa+8C,MAAe/8C,KAAf,CAAqBsB,MAArB,GAA8B,CAA3C,KAAiD;MAAA,CAFjD,MAGF;eAEE,CAAC4Z,WAAWlb,KAAZ,IAAY+8C,MAAe/8C,KAAf,CAAqBsB,MAArB,GAA8B,CAA1C;MAA0C;IAEpD,CAViB;UAYZqlC,UAAU1T;UACV/hB,YAAY+hB,IAAI,EAAJ;UACZlqB,MAAM7I,SAAe;MAAE8C,GAAG,CAAL;MAAQG,GAAG,CAAX;MAAcb,OAAO,CAArB;MAAwBE,QAAQ;IAAhC,CAAf;UACN06C,oBAAoBzrB,SAAS,MAAM;;;YACjC/T,SAASnO,MAAMmO,MAAN,CAAavC;UACxB,CAACuC,eAAe3U;UAChBo0C,iBAAiBC;;UACjB1/B,OAAOjC,OAAP,YAA0Bva,QAAQ;0BAClBwc,OAAOjC,OAAP,CAAe4hC;4BACb3/B,OAAOjC,OAAP,CAAe6hC;MAAA,OAC9B;0BACa,aAAO7hC,OAAP,iBAAkB;4BAChB,aAAOA,OAAP,iBAAkB;MAAA;;YAElC8hC,aAAariC,WAAWlb,KAAX,GAAmBib,SAASjb;aACxC;QACLgD,GAAG+F,IAAI/F,CAAJ,GAAQo6C,oBAAoBl7C,MAAMlC,KADhC;QAELmD,GAAG4F,IAAI5F,CAAJ,GAAQg6C,kBAAkBj7C,MAAMlC,KAAhC,GAAyCu9C,aAAa,CAFpD;QAGLj7C,OAAOyG,IAAIzG,KAAJ,GAAY86C,oBAAoB,CAApB,GAAwBl7C,MAAMlC,KAH5C;QAILwC,QAAQuG,IAAIvG,MAAJ,GAAa26C,kBAAkB,CAAlB,GAAsBj7C,MAAMlC,KAAzC,GAAiDu9C;MAJpD;IAMR,CAlByB;QAoBtBC;;UACEC,iBAAiB,MAAM;UACvBluC,MAAMmO,MAAN,CAAavC,UAAb,IAA2B5L,MAAMmO,MAAN,CAAavC,UAAb,CAAwB3B,SAAS;YAC1D,CAACgkC,QAAD,IAAa7W,QAAQ3mC,OAAO;qBACnB09C,uBAAuB/W,QAAQ3mC,KAA/B,EAAsC+I,GAAtC,EAA2CmI,SAA3C;QAAoD;aAE5D;6CACKysC;mBACC;MAAA;;;cAIL,MAAMF;UAEd,MAAMluC,MAAMmO,MAAN,CAAavC,UAAb,IAA2B5L,MAAMmO,MAAN,CAAavC,UAAb,CAAwB3B,SACzD,CAACnY,CAAD,EAAI8vB,IAAJ,KAAa;UACP9vB,KAAK8vB;;IAGb;gBACY,MAAM;2CACNwsB;iBACC;IACZ;WAEY;MAAE1iC,QAAF;MAAY0rB,OAAZ;MAAqBz1B,SAArB;MAAgCgsC,iBAAhC;MAAmDh7C;IAAnD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpIb,kBAAe,CAAC07C,GAAD,EAAMruC,KAAN,KAAgB;EAC7B,MAAMvO,SAAS48C,IAAIC,SAAJ,IAAiBD,GAAhC;;EACA,WAAW,CAAC9yC,GAAD,EAAM3K,GAAN,CAAX,IAAyBoP,KAAzB,EAAgC;IAC9BvO,OAAO8J,GAAP,IAAc3K,GAAd;EAAc;;EAEhB,OAAOa,MAAP;AACF,CANA;;;;;;;;;;;;;;;;;;;;;;;;;UC0BMgC,IAAIyuB,SAAS;;;MAAM,oBAAM1oB,GAAN,wBAAW/F,CAAX,KAAgB,CAAhB;IAAiB,CAAhC;UACJG,IAAIsuB,SAAS;;;MAAM,oBAAM1oB,GAAN,wBAAW5F,CAAX,KAAgB,CAAhB;IAAiB,CAAhC;UAEJua,SAASogC;UACT;MAAE57C;IAAF,IAAY+5C;UAEZ;MACJ9f,0BADI;MAEJC,0BAFI;MAGJC,yBAHI;MAIJC,oBAJI;MAKJC,0BALI;MAMJC;IANI,IAOFuhB;UAEEC,kBAAkBvsB,SAAS,MAAM;;;UACjCliB,MAAMiU,KAAN,CAAYzI,KAAZ,CAAkBvB,SAAS;eACtB,YAAMgK,KAAN,CAAYwQ,SAAZ,iBAAyB;MAAA;;aAE3B;IACR,CALuB;UAOlBjH,cAAc0E,SAAS,MAAM;UAC7BliB,MAAMiU,KAAN,CAAYzI,KAAZ,CAAkBM,SAAlB,KAAgC1Z,mBAAmBs8C,QAAQ;eACtD;MAAA,OACF;eACE1uC,MAAMiU,KAAN,CAAYzI,KAAZ,CAAkBK,MAAlB,GAA2BlZ,MAAMlC;MAAA;IAE3C,CANmB;UAQdk+C,cAAcjrB,IAAI,CAAJ;UACdkrB,cAAclrB,IAAI,CAAJ;UACdmrB,sBAAsBnrB,IAAI,CAAJ;UACtBorB,sBAAsBprB,IAAI,CAAJ;gBAEhB,MAAM;YACVpvB,IAAI3B,MAAMlC;YACVmC,QAAQoN,MAAMiU,KAAN,CAAYrhB;;UACtBA,MAAME,IAAN,IAAc,UAAU;cACpBE,SAASJ,MAAMI,MAAN,GAAesB;cACxBisB,IAAIvtB,SAASwqB,YAAY/sB;cACzBs+C,iBAAiBx7C,KAAKwjB,IAAL,CAAU2D,SAAK,CAAL,IAAS,CAAnB;oBACXjqB,QAAQuC,SAASwqB,YAAY/sB;oBAC7BA,QAAQuC,SAASwqB,YAAY/sB;4BACrBA,QAAQs+C;4BACRt+C,QAAQs+C;MAAA,OACvB;cACC5jC,eAAevY,MAAMuY,YAAN,GAAqB7W;cACpCvB,QAAQH,MAAMG,KAAN,GAAcuB;cACtBrB,SAASL,MAAMK,MAAN,GAAeqB;cACxBisB,IAAIpV,eAAeqS,YAAY/sB;cAC/Bs+C,iBAAiBx7C,KAAKwjB,IAAL,CAAU2D,SAAK,CAAL,IAAS,CAAnB;oBACXjqB,QAAQwC,SAAS,CAAT,GAAauqB,YAAY/sB;oBACjCA,QAAQsC,QAAQ,CAAR,GAAYyqB,YAAY/sB;4BACxBA,QAAQwC,SAAS,CAAT,GAAakY,YAAb,GAA4B4jC;4BACpCt+C,QAAQsC,QAAQ,CAAR,GAAYoY,YAAZ,GAA2B4jC;MAAA;IAE1D;UAEKC,aAAa9sB,SAAS,MAAM;cACxBliB,MAAMiU,KAAN,CAAYzI,KAAZ,CAAkBM;QAAA,KACnB1Z,mBAAmBs8C,MADA;QACA,KACnBt8C,mBAAmB68C,KADA;QACA,KACnB78C,mBAAmB2Z,KADA;iBAEf;;QAAA,KACJ3Z,mBAAmB88C,IADf;QACe,KACnB98C,mBAAmB+8C,UADA;QACA,KACnB/8C,mBAAmBg9C,UADA;iBAEf;;QAAA,KACJh9C,mBAAmBi9C,IADf;QACe,KACnBj9C,mBAAmBk9C,UADA;QACA,KACnBl9C,mBAAmBm9C,UADA;QACA;iBAEf;;IAEZ,CAhBkB;UAiBb7B,mBAAmBxrB,SAAS,MAAM;cAC9BliB,MAAMiU,KAAN,CAAYzI,KAAZ,CAAkBM;QAAA,KACnB1Z,mBAAmB68C,KADA;QACA,KACnB78C,mBAAmB+8C,UADA;QACA,KACnB/8C,mBAAmBk9C,UADA;iBAEf;;QAAA,KACJl9C,mBAAmB2Z,KADf;QACe,KACnB3Z,mBAAmBg9C,UADA;QACA,KACnBh9C,mBAAmBm9C,UADA;iBAEf;;QAAA,KACJn9C,mBAAmBs8C,MADf;QACe,KACnBt8C,mBAAmB88C,IADA;QACA,KACnB98C,mBAAmBi9C,IADA;QACA;iBAEf;;IAEZ,CAhBwB;UAiBnBG,SAASttB,SAAS,MAAM;cACpBliB,MAAMiU,KAAN,CAAYzI,KAAZ,CAAkBM;QAAA,KACnB1Z,mBAAmBs8C,MADA;QACA,KACnBt8C,mBAAmB68C,KADA;QACA,KACnB78C,mBAAmB2Z,KADA;iBAEf;;QAAA,KACJ3Z,mBAAmB88C,IADf;iBAEAN,YAAYn+C;;QAAA,KAChB2B,mBAAmBi9C,IADH;iBAEZ,CAACT,YAAYn+C;;QAAA,KACjB2B,mBAAmB+8C,UADF;QACE,KACnB/8C,mBAAmBg9C,UADA;iBAEfN,oBAAoBr+C;;QAAA,KACxB2B,mBAAmBk9C,UADK;QACL,KACnBl9C,mBAAmBm9C,UADA;QACA;iBAEf,CAACT,oBAAoBr+C;;IAEjC,CAlBc;UAmBTg/C,SAASvtB,SAAS,MAAM;cACpBliB,MAAMiU,KAAN,CAAYzI,KAAZ,CAAkBM;QAAA,KACnB1Z,mBAAmB68C,KADA;iBAEf,CAACN,YAAYl+C;;QAAA,KACjB2B,mBAAmB2Z,KADF;iBAEb4iC,YAAYl+C;;QAAA,KAChB2B,mBAAmBs8C,MADH;QACG,KACnBt8C,mBAAmB88C,IADA;QACA,KACnB98C,mBAAmBi9C,IADA;iBAEf;;QAAA,KACJj9C,mBAAmB+8C,UADf;QACe,KACnB/8C,mBAAmBk9C,UADA;iBAEf,CAACT,oBAAoBp+C;;QAAA,KACzB2B,mBAAmBg9C,UADM;QACN,KACnBh9C,mBAAmBm9C,UADA;QACA;iBAEfV,oBAAoBp+C;;IAEhC,CAlBc;WAoBF;MACXgD,CADW;MAEXG,CAFW;MAGXua,MAHW;MAIXsgC,eAJW;MAKX7hB,0BALW;MAMXC,0BANW;MAOXC,yBAPW;MAQXC,oBARW;MASXC,0BATW;MAUXC,qBAVW;MAWX+hB,UAXW;MAYXtB,gBAZW;MAaX8B,MAbW;MAcXC,MAdW;MAeX98C;IAfW;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;UCvIPc,IAAIyuB,SAAS;;;MAAM,oBAAM1oB,GAAN,wBAAW/F,CAAX,KAAgB,CAAhB;IAAiB,CAAhC;UACJG,IAAIsuB,SAAS;;;MAAM,oBAAM1oB,GAAN,wBAAW5F,CAAX,KAAgB,CAAhB;IAAiB,CAAhC;UAEJua,SAASogC;UACTmB,cAAc/+C,SAAqB,EAArB;gBAER,MAAM;;;YACVg/C,aAAa3vC,MAAMiU,KAAN,CAAYrhB;;UAC3B+8C,WAAW78C,IAAX,KAAoB,UAAU;cAC1BF,QAA0B;UAC9BE,MAAM,QADwB;UAE9BE,QACE28C,WAAW38C,MAAX,GAAW,kBACCwX,WADD,KACC,IADD,GACColC,EADD,GACgB,CADhB,IACqB,CADhC,GAEAzhC,OAAOlC,SAAP,CAAiBC,OAFjB,GAGAiC,OAAOlC,SAAP,CAAiBlZ,KAAjB,GAAyB,CANG;UAO9BsX,OAAO,MAPuB;UAQ9BG,aAAa2D,OAAOlC,SAAP,CAAiBlZ,KARA;UAS9B0X,aAAa0D,OAAOlC,SAAP,CAAiB5B,KATA;UAU9BK,iBAAiByD,OAAOlC,SAAP,CAAiBnY;QAVJ;eAYzBvB,OAAOm9C,aAAa98C;MAAK,OAC3B;cACCA,QAA6B;UACjCE,MAAM,MAD2B;UAEjCC,OACE48C,WAAW58C,KAAX,IAAW,iBACCyX,WADD,KACC,IADD,GACCqlC,EADD,GACgB,CAD3B,IAEA1hC,OAAOlC,SAAP,CAAiBC,OAAjB,GAA2B,CAF3B,GAGAiC,OAAOlC,SAAP,CAAiBlZ,KANc;UAOjCE,QACE08C,WAAW18C,MAAX,IAAW,iBACCuX,WADD,KACC,IADD,GACC2K,EADD,GACgB,CAD3B,IAEAhH,OAAOlC,SAAP,CAAiBC,OAAjB,GAA2B,CAF3B,GAGAiC,OAAOlC,SAAP,CAAiBlZ,KAXc;UAYjCoY,cACEwkC,WAAWxkC,YAAX,GAA0B,CAA1B,GAA8BwkC,WAAWxkC,YAAX,GAA0BgD,OAAOlC,SAAP,CAAiBC,OAAzE,GAAmF,CAbpD;UAcjC7B,OAAO,MAd0B;UAejCG,aAAa2D,OAAOlC,SAAP,CAAiBlZ,KAfG;UAgBjC0X,aAAa0D,OAAOlC,SAAP,CAAiB5B,KAhBG;UAiBjCK,iBAAiByD,OAAOlC,SAAP,CAAiBnY;QAjBD;eAmB5BvB,OAAOm9C,aAAa98C;MAAK;IAEnC;WAEY;MAAEa,CAAF;MAAKG,CAAL;MAAQ87C;IAAR;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;UChDP;MAAE/8C;IAAF,IAAY+5C;UAEZliC,cAAc0X,SAAS,MAAM;aAC1BliB,MAAMmO,MAAN,CAAapb,KAAb,GAAqBJ,MAAMlC;IACnC,CAFmB;UAIdia,kBAAkBwX,SAAS,MAAM;aAC9B2qB,sBAAsB7sC,MAAMmO,MAAN,CAAara,SAAnC,EAA8CnB,MAAMlC,KAApD;IACR,CAFuB;UAIlBmc,iBAAiBsV,SAAS,MAAM;YAC9B4tB,QAAQ9vC,MAAMmO,MAAN,CAAaxB,OAAb,GACVojC,iBAAiB/vC,MAAMmO,MAAN,CAAara,SAA9B,IAA2CkM,MAAMmO,MAAN,CAAavB,cAAxD,GAAyEja,MAAMlC,KADrE,GAEV;aACGq/C,QAAQ,qBAAqBA,OAA7B,GAAuC;IAC/C,CALsB;WAOV;MAAEtlC,WAAF;MAAeE,eAAf;MAAgCkC;IAAhC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;UCVP;MAAEja;IAAF,IAAY+5C;UAEZsD,QAAQ9tB,SAAS,MAAM;;;YACrBvU,IAAI3N,MAAMiU,KAAN,CAAY4Q;YAChBpP,SAAS,CAAE,IAAG,kBAAMxB,KAAN,CAAY6R,KAAZ,wBAAmBtH,OAAnB,iBAA8B,EAAjC,CAAF,EAAuC;QAAE/qB,GAAGka,EAAEkH,EAAF,CAAKphB,CAAV;QAAaG,GAAG+Z,EAAEkH,EAAF,CAAKjhB;MAArB,CAAvC;YACTutB,IAAc;QAClBplB,KAAK,KAAK4R,EAAEiH,EAAF,CAAKnhB,KAAKka,EAAEiH,EAAF,CAAKhhB;YACrB6hB,QAAQ,GAAGtF,QAAQ,CAAC,CAACyE,EAAD,EAAKC,EAAL,CAAD,KAAcsM,EAAEplB,IAAF,CAAO,KAAK6Y,GAAGnhB,KAAKmhB,GAAGhhB,KAAKihB,GAAGphB,KAAKohB,GAAGjhB,GAAvC;aAChCutB,EAAEhtB,IAAF,CAAO,GAAP;IACR,CAPa;UASRqW,cAAc0X,SAAS,MAAM;aAC1BliB,MAAMmO,MAAN,CAAapb,KAAb,GAAqBJ,MAAMlC;IACnC,CAFmB;UAIdia,kBAAkBwX,SAAS,MAAM;aAC9B2qB,sBAAsB7sC,MAAMmO,MAAN,CAAara,SAAnC,EAA8CnB,MAAMlC,KAApD;IACR,CAFuB;UAIlBmc,iBAAiBsV,SAAS,MAAM;YAC9B4tB,QAAQ9vC,MAAMmO,MAAN,CAAaxB,OAAb,GACVojC,iBAAiB/vC,MAAMmO,MAAN,CAAara,SAA9B,IAA2CkM,MAAMmO,MAAN,CAAavB,cAAxD,GAAyEja,MAAMlC,KADrE,GAEV;aACGq/C,QAAQ,qBAAqBA,OAA7B,GAAuC;IAC/C,CALsB;WAOV;MAAEtlC,WAAF;MAAeE,eAAf;MAAgCkC;IAAhC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;UC1BPuB,SAAS8hC;WAEF;MAAE9hC;IAAF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;UCTPA,SAAS8hC;UACT;MACJ7hB,2BADI;MAEJC,2BAFI;MAGJC,0BAHI;MAIJC,qBAJI;MAKJC,2BALI;MAMJC;IANI,IAOF+f;UAEE;MAAE7qB;IAAF,IAAiBusB;UAIjB12C,MAAMkqB,IAAkB;MAAE9O,IAAI;QAAEnhB,GAAG,CAAL;QAAQG,GAAG;MAAX,CAAN;MAAsBihB,IAAI;QAAEphB,GAAG,CAAL;QAAQG,GAAG;MAAX;IAA1B,CAAlB;UACNu8C,YAAYzsB,IAAc;MAAEjwB,GAAG,CAAL;MAAQG,GAAG;IAAX,CAAd;gBAEN,MAAM;YACVyhB,SAAS1jB,OAAOiJ,IAAP,CAAYoF,MAAM8N,KAAlB,EAAyBia,IAAzB,CAA8BrS,WAAUA,WAAUiO,UAAlD;;UACXtO,QAAQ;YACN5kB,QAAQkzB,WAAWtO,MAAX,EAAmBwP;kBACrBp0B,QAAQ;UAChBgD,QAAQhD,KAAR,CAAcmkB,EAAd,CAAiBnhB,CAAjB,GAAqB+F,IAAI/I,KAAJ,CAAUokB,EAAV,CAAaphB,CAAlC,IAAuC,CADvB;UAEhBG,QAAQnD,KAAR,CAAcmkB,EAAd,CAAiBhhB,CAAjB,GAAqB4F,IAAI/I,KAAJ,CAAUokB,EAAV,CAAajhB,CAAlC,IAAuC;QAFvB;;IAKrB;UAEKw8C,UAAUluB,SAAS,MAAMvwB,OAAOiJ,IAAP,CAAYoF,MAAM8N,KAAlB,CAAf;UACVuiC,cAAcnuB,SAAS,MAAM1wB,OAAOI,MAAP,CAAcuc,OAAOhB,UAAP,CAAkB3B,KAAhC,EAAuCxL,MAAM8N,KAA7C,CAAf;UACd4hC,cAAcxtB,SAAS,MAAM1wB,OAAOI,MAAP,CAAcuc,OAAOhB,UAAP,CAAkBva,KAAhC,EAAuCoN,MAAM8N,KAA7C,CAAf;UACdwiC,eAAepuB,SAAS,MAAM1wB,OAAOI,MAAP,CAAcuc,OAAOhB,UAAP,CAAkBC,MAAhC,EAAwCpN,MAAM8N,KAA9C,CAAf;UAEfwT,UAAUY,SAAS,MAAMkuB,QAAQ3/C,KAAR,CAAco9B,IAAd,CAAmBphB,QAAQkX,WAAWlX,IAAX,EAAiB6U,OAA5C,CAAf;UACV/V,aAAa2W,SAAS,MAAMkuB,QAAQ3/C,KAAR,CAAco9B,IAAd,CAAmBphB,QAAQkX,WAAWlX,IAAX,EAAiBlB,UAA5C,CAAf;UACbF,WAAW6W,SAAS,MAAMkuB,QAAQ3/C,KAAR,CAAco9B,IAAd,CAAmBphB,QAAQkX,WAAWlX,IAAX,EAAiBpB,QAA5C,CAAf;WAEJ;MACX8C,MADW;MAEX3U,GAFW;MAGX22C,SAHW;MAIX/hB,2BAJW;MAKXC,2BALW;MAMXC,0BANW;MAOXC,qBAPW;MAQXC,2BARW;MASXC,sBATW;MAUXnN,OAVW;MAWX/V,UAXW;MAYXF;IAZW;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;UCxBP;MAAEha;IAAF,IAAUk/C;UACV;MAAE59C;IAAF,IAAY+5C;UACZ8D,aAAaP;;+BAEQ;UACrBjwC,MAAM2U,cAAc;eACfnjB,OAAOI,MAAP,CAAc4+C,WAAWrjC,UAAX,CAAsBC,MAApC,EAA4CpN,MAAM8N,KAAlD;MAAuD,OACzD;eACE9N,MAAMiU,KAAN,CAAY7J,IAAZ,CAAiBgD;MAAA;;;4BAIJhD,MAAkC;aACjD;QAAE9I,QAAQ8I,KAAKwK,EAAf;QAAmBnjB,QAAQ2Y,KAAKyK;MAAhC;;;kCAGqBZ,OAAyB;UACjDA,MAAM6R,OAAO;eACR7R,MAAM6R,KAAN,CAAYxrB;MAAA,OACd;cACCsa,KAAKX,MAAM0Q,MAAN,CAAa/P;cAClBC,KAAKZ,MAAM0Q,MAAN,CAAa9P;eACjB;UACLphB,OAAOA,CAAP,GAAWohB,GAAGphB,CAAd,IAAmB,CADd;UAELG,OAAOA,CAAP,GAAWihB,GAAGjhB,CAAd,IAAmB;QAFd;;;;kCAOmB;;;UACxB,CAACvC,IAAIZ,cAAc;YACjB4kB,SAAS,YAAMA,MAAN,iBAAgB1jB,OAAOiJ,IAAP,CAAYoF,MAAM8N,KAAlB,EAAyB,CAAzB;YACzBR,OAAOjc,IAAIZ,KAAJ,CAAUikC,aAAV,CAAwC,sBAAsBrf,UAA9D;UACT,CAAC/H,aAAa;aACXA,KAAKmjC,cAAL;;;oCAGuBpyB,WAAyB;;;UACnD,CAAChtB,IAAIZ,KAAL,IAAc,CAAC0H,SAASkmB,SAAT,UAA2Bre,MAAMiU,KAAN,CAAY4Q,QAAZ,CAAqBjQ;YAG7DX;YAEAoB,SAAS,YAAMA,MAAN,iBAAgB1jB,OAAOiJ,IAAP,CAAYoF,MAAM8N,KAAlB,EAAyB,CAAzB;YAEzBR,OAAOjc,IAAIZ,KAAJ,CAAUikC,aAAV,CAAwC,sBAAsBrf,UAA9D;UACT,CAAC/H,aAAatN,MAAMiU,KAAN,CAAY4Q,QAAZ,CAAqBjQ;YAEjCjH,IAAIL,KAAKojC,gBAAL,CAAsBryB,SAAtB;aACH;QAAE5qB,GAAGka,EAAEla,CAAP;QAAUG,GAAG+Z,EAAE/Z;MAAf;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;UCvEH;MAAE+vB,UAAF;MAAcC,gBAAd;MAAgCL,eAAhC;MAAiDV;IAAjD,IAA6DqtB;WA4BtD;MAAEvsB,UAAF;MAAcC,gBAAd;MAAgCL,eAAhC;MAAiDV;IAAjD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;UCXP;MAAElwB;IAAF,IAAY+5C;UAEZv+B,SAAS8hC;UACT;MACJniB,0BADI;MAEJC,0BAFI;MAGJC,yBAHI;MAIJC,oBAJI;MAKJC,0BALI;MAMJC;IANI,IAOFqgB;UAEEwB,QAAQ9tB,SAAS,MAAM;YACrBvU,IAAI3N,MAAMiU,KAAN,CAAY4Q;;UAClB1W,OAAOrb,IAAP,KAAgB,UAAhB,IAA8B,CAACkN,MAAMiU,KAAN,CAAY6R,OAAO;eAC7C,KAAKnY,EAAEiH,EAAF,CAAKnhB,KAAKka,EAAEiH,EAAF,CAAKhhB,OAAO+Z,EAAEkH,EAAF,CAAKphB,KAAKka,EAAEkH,EAAF,CAAKjhB;MAAA,OAC5C;cACC6hB,SAAS,CAAE,GAAGzV,MAAMiU,KAAN,CAAY6R,KAAZ,CAAkBtH,OAAvB,EAAgC;UAAE/qB,GAAGka,EAAEkH,EAAF,CAAKphB,CAAV;UAAaG,GAAG+Z,EAAEkH,EAAF,CAAKjhB;QAArB,CAAhC;cACTutB,IAAc;UAClBplB,KAAK,KAAK4R,EAAEiH,EAAF,CAAKnhB,KAAKka,EAAEiH,EAAF,CAAKhhB;cACrB6hB,QAAQ,GAAGtF,QAAQ,CAAC,CAACyE,EAAD,EAAKC,EAAL,CAAD,KAAcsM,EAAEplB,IAAF,CAAO,KAAK6Y,GAAGnhB,KAAKmhB,GAAGhhB,KAAKihB,GAAGphB,KAAKohB,GAAGjhB,GAAvC;eAChCutB,EAAEhtB,IAAF,CAAO,GAAP;MAAU;IAEpB,CAXa;UAaRqW,cAAc0X,SAAS,aAAajO,KAAb,CAAmB7J,IAAnB,CAAwBgD,MAAxB,CAA+Bra,KAA/B,GAAuC,EAAvC,IAA6CJ,MAAMlC,KAA5D;WAEP;MACX0d,MADW;MAEX2f,0BAFW;MAGXC,0BAHW;MAIXC,yBAJW;MAKXC,oBALW;MAMXC,0BANW;MAOXC;IAPW;;;;;;;;;;;;;;;;;;;;;;;;;;;;;UCrDP;MAAExK,UAAF;MAAcJ,eAAd;MAA+BV;IAA/B,IAA2CqtB;WAEpC;MAAEvsB,UAAF;MAAcJ,eAAd;MAA+BV;IAA/B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;UCGP2tB,aAAaP;UACb;MAAEjtB,UAAF;MAAcW,UAAd;MAA0BJ,eAA1B;MAA2CR,oBAA3C;MAAiEF;IAAjE,IAA6EqtB;UAC7E;MAAEv9C;IAAF,IAAY+5C;UAGZiE,uBAAuBzuB,SAAS,MACpCvwB,OAAOK,WAAP,CACEL,OAAOM,OAAP,CAAesxB,gBAAgBnP,UAA/B,EAA2CviB,MAA3C,CACE,CAAC,CAACmyB,CAAD,EAAIqC,KAAJ,CAAD,KAAgB,CAACA,MAAMpZ,SAAP,IAAoBtb,OAAOiJ,IAAP,CAAYyrB,MAAMvY,KAAlB,EAAyB/b,MAAzB,GAAkC,CADxE,CADF,CAD2B;UAQvBqiB,aAAa8N,SAAS,MAAM;YAC1B0uB,aAAwC;YACxCzjC,aAAwC;aACvClb,QAAQsxB,gBAAgBnP,YAAYjE,QAAQ,CAAC,CAAC5W,EAAD,EAAK8sB,KAAL,CAAD,KAAiB;YAC9D10B,OAAOiJ,IAAP,CAAYyrB,MAAMvY,KAAlB,EAAyB/b,MAAzB,GAAkC,GAAG;cACnCs0B,MAAMpZ,WAAW;uBACR1T,MAAM8sB;UAAA,OACZ;uBACM9sB,MAAM8sB;UAAA;;MAGtB;aACM;QAAEuqB,UAAF;QAAczjC;MAAd;IACR,CAbkB;UAeb0jC,YAAY3uB,SAAS,MAAOzvB,IAAD,IAAkB;;;aAC1C;QACL+G,KAAK,cAAQL,KAAR,CAAc1G,IAAd,kBAAuB;UAAEgB,GAAG,CAAL;UAAQG,GAAG;QAAX,CADvB;QAELhB,OAAOowB,WAAWvwB,IAAX,EAAiBG;MAFnB;IAIR,CALiB;UAOZk+C,oBAAoB5uB,SAAS,MAAM,CAAC7M,MAAD,EAAiBkI,SAAjB,KAA4C;aAC5EwzB,uBACLptB,WAAWtO,MAAX,EAAmBuP,aADdmsB,EAELxzB,SAFKwzB,EAGLP,WAAWhlC,KAAX,CAAiBK,MAHZklC,EAILP,WAAWhlC,KAAX,CAAiBU,OAJZ6kC,EAKLp+C,MAAMlC,KALDsgD;IAOR,CARyB;UAUpBC,yBAAyB9uB,SAAS,MAAM,CAAC3oB,EAAD,EAAa8sB,KAAb,KAAkC;;;YACxEhR,SAAS1jB,OAAOiJ,IAAP,CAAYyrB,MAAMvY,KAAlB,EAAyB,CAAzB;aACRijC,uBACLptB,WAAWtO,MAAX,EAAmBuP,aADdmsB,EAEL,iCAAqBx3C,EAArB,yBAA0B6T,MAA1B,iBAAoCuW,WAAWtO,MAAX,EAAmBjL,IAAnB,CAAwBgD,MAFvD2jC,EAGLP,WAAWhlC,KAAX,CAAiBK,MAHZklC,EAILP,WAAWhlC,KAAX,CAAiBU,OAJZ6kC,EAKLp+C,MAAMlC,KALDsgD;IAOR,CAT8B;UAWzBE,0BAA0B/uB,SAAS,MAAOmE,KAAD,IAAsB;aAC5D1C,WAAWhyB,OAAOiJ,IAAP,CAAYyrB,MAAMvY,KAAlB,EAAyB,CAAzB,CAAX;IACR,CAF+B;WAInB;MACX6iC,oBADW;MAEXv8B,UAFW;MAGXy8B,SAHW;MAIXC,iBAJW;MAKXE,sBALW;MAMXC,uBANW;MAOXttB,UAPW;MAQX6sB,UARW;MASX79C;IATW;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;UC7DP;MAAErB;IAAF,IAAei/C;UAGf3kC,aAAa8X;;UAEbwtB,mBAAmB,CAAC5D,KAAD,EAAkB6D,OAAlB,EAAwCC,OAAxC,KAAiE;YAClFjhC,QAAQkhC;;;QAAQ,eAAQ1U,YAAR,CAAqB0U,IAArB,EAA2B,cAAQ9U,YAAR,CAAqB8U,IAArB,kBAA8B,EAAzD;MAA4D;IAAA;;UAG9EpD,WAAW,IAAIf,gBAAJ,CAAqBoE,WAAW;UAC3C,CAAC1lC,WAAWnb;YACV68C,QAAQgE,QAAQp/C,GAAR,CAAYq/C;;;QAAK,eAAEC,aAAF,iBAAmB,EAAnB;MAAqB,CAAtC,EAAwC3/C,MAAxC,CAA+C4/C,OAA/C;uBACGnE,OAAO1hC,WAAWnb,OAAOa,SAASb;IACpD,CAJgB;cAMP,MAAM;YACR68C,QAAQ,CAAC,WAAD,EAAc,OAAd;eACLH,QAAQ77C,SAASb,OAAO;QAC/B28C,YAAY,IADmB;QAE/BC,iBAAiBC;MAFc;UAI7B,CAAC1hC,WAAWnb;uBACC68C,OAAO1hC,WAAWnb,OAAOa,SAASb;IACpD;gBAEW,MAAM;eACP29C;IACV;WAEY;MAAExiC;IAAF;;;;;;;;;;;;;;;;;;;;;;;;;;UC1BP;MAAExa,SAAF;MAAaG;IAAb,IAA4Bg/C;UAC5B;MAAE1mB;IAAF,IAAgB6iB;UAChBtzC,UAAUs4C;UACVvjC,SAASwjC;UAGTC,YAAYluB,IAAW;MAAEjwB,GAAG,CAAL;MAAQG,GAAG;IAAX,CAAX;UAGZtC,WAAWoyB,IAAU;MAAE3wB,OAAO,GAAT;MAAcE,QAAQ;IAAtB,CAAV;cAEP,MAAM;;;YACR6zC,MAAM,kBAAWr2C,KAAX,wBAAkB4wC,MAAlB;;UACRyF,KAAK;kBACGr2C,QAAQ;UAChBgD,GAAG,CAACqzC,IAAIrzC,CADQ;UAEhBG,GAAG,CAACkzC,IAAIlzC;QAFQ;;;YAKduoB,OAAO/qB,UAAUX,KAAV,CAAgBqjC,qBAAhB;eACJrjC,QAAQ;QACfsC,OAAOopB,KAAKppB,KADG;QAEfE,QAAQkpB,KAAKlpB;MAFE;IAIlB;YAEO8H,GAAG,eAAeohB,QAAQ;eACvB1rB,QAAQ;QAAEsC,OAAOopB,KAAKppB,KAAd;QAAqBE,QAAQkpB,KAAKlpB;MAAlC;IAClB;YAEO8H,GAAG,YAAY+rC,OAAO;gBAClBr2C,QAAQ;QAAEgD,GAAG,CAACqzC,IAAIrzC,CAAV;QAAaG,GAAG,CAACkzC,IAAIlzC;MAArB;IACnB;YAEOmH,GAAG,aAAa,MAAM;;;YACtB+rC,MAAM,kBAAWr2C,KAAX,wBAAkB4wC,MAAlB;;UACRyF,KAAK;kBACGr2C,QAAQ;UAAEgD,GAAG,CAACqzC,IAAIrzC,CAAV;UAAaG,GAAG,CAACkzC,IAAIlzC;QAArB;;IAErB;UAEKi+C,iBAAiBnuB,IAAqB,EAArB;UACjBouB,mBAAmBpuB,IAAqB,EAArB;UACnBquB,kBAAkBruB,IAAqB,EAArB;UAClBsuB,oBAAoBtuB,IAAqB,EAArB;gBAGd,MAAM;YACVuuB,SAA0B;YAC1BC,SAA0B;YAC1BC,UAA2B;YAC3BC,UAA2B;YAE3B99C,IAAI,IAAIu1B,UAAUp5B;YAClB4hD,KAAKlkC,OAAOnE,IAAP,CAAYE;YACjBzW,IAAIm+C,UAAUnhD,KAAV,CAAgBgD,CAAhB,GAAoBa;YACxBV,IAAIg+C,UAAUnhD,KAAV,CAAgBmD,CAAhB,GAAoBU;YACxBvB,QAAQQ,KAAK0pB,KAAL,CAAW3rB,SAASb,KAAT,CAAesC,KAAf,GAAuBs/C,EAAvB,GAA4B,CAAvC,IAA4CA;YACpDp/C,SAASM,KAAK0pB,KAAL,CAAW3rB,SAASb,KAAT,CAAewC,MAAf,GAAwBo/C,EAAxB,GAA6B,CAAxC,IAA6CA;YACtDC,sBAAsB7hD,KAAtB,CAA4BgD,CAA5B,GAAgCV,KAAhC,IAAyCuB;YACzCi+C,uBAAuB9hD,KAAvB,CAA6BmD,CAA7B,GAAiCX,MAAjC,IAA2CqB;YAC3Ck+C,MAAMrkC,OAAOnE,IAAP,CAAYG;YAClBsoC,kBAAkBtkC,OAAOnE,IAAP,CAAYI,IAAZ,CAAiBtW;YACnC4+C,iBAAiBvkC,OAAOnE,IAAP,CAAYM,KAAZ,CAAkBxW;UAErC6+C,aAAa;QACfvlC,QAAQe,OAAOnE,IAAP,CAAYM,KAAZ,CAAkBD,KADX;QAEf,gBAAgB8D,OAAOnE,IAAP,CAAYM,KAAZ,CAAkBvX,KAFnB;QAGf,oBAAoB2/C,cAHL;QAIf,qBAAqBA,iBAAiBj/C,IAAIa,CAArB,GAAyB;MAJ/B;UAObs+C,cAAc;QAChBxlC,QAAQe,OAAOnE,IAAP,CAAYI,IAAZ,CAAiBC,KADT;QAEhB,gBAAgB8D,OAAOnE,IAAP,CAAYI,IAAZ,CAAiBrX,KAFjB;QAGhB,oBAAoB0/C,eAHJ;QAIhB,qBAAqBA,kBAAkBh/C,IAAIa,CAAtB,GAA0B;MAJ/B;YAQZuY,eAAepc,KAAf,CAAqBgD,CAArB,GAAyBV,KAAzB,IAAkCuB;;eAC/BqhB,IAAI/hB,GAAG+hB,KAAK48B,WAAW58B,KAAK08B,IAAI;cACjCt9C,QAAQxB,KAAK0pB,KAAL,CAAWtH,IAAI08B,EAAf;;YACVG,OAAOz9C,QAAQy9C,GAAR,KAAgB,GAAG;iBACrBz2C,KAAK,CAAChH,KAAD,EAAQA,QAAQs9C,EAAhB,EAAoB5+C,CAApB,EAAuBoZ,CAAvB,EAA0B8lC,UAA1B;QAAqC,OAC5C;kBACG52C,KAAK,CAAChH,KAAD,EAAQA,QAAQs9C,EAAhB,EAAoB5+C,CAApB,EAAuBoZ,CAAvB,EAA0B+lC,WAA1B;QAAsC;;;mBAI1Cv4C,mBAAKs4C,UAAL;iBACF,uBAAuBD,iBAAiB9+C,IAAIU,CAArB,GAAyB;oBAE7C+F,mBAAKu4C,WAAL;kBACF,uBAAuBH,kBAAkB7+C,IAAIU,CAAtB,GAA0B;YAGvDgmB,eAAe7pB,KAAf,CAAqBmD,CAArB,GAAyBX,MAAzB,IAAmCqB;;eAChCqhB,IAAIliB,GAAGkiB,KAAK28B,UAAU38B,KAAK08B,IAAI;cAChCt9C,QAAQxB,KAAK0pB,KAAL,CAAWtH,IAAI08B,EAAf;;YACVG,OAAOz9C,QAAQy9C,GAAR,KAAgB,GAAG;iBACrBz2C,KAAK,CAAChH,KAAD,EAAQA,QAAQs9C,EAAhB,EAAoBz+C,CAApB,EAAuB0mB,CAAvB,EAA0Bq4B,UAA1B;QAAqC,OAC5C;kBACG52C,KAAK,CAAChH,KAAD,EAAQA,QAAQs9C,EAAhB,EAAoBz+C,CAApB,EAAuB0mB,CAAvB,EAA0Bs4B,WAA1B;QAAsC;;;uBAItCniD,QAAQwhD;qBACVxhD,QAAQyhD;wBACLzhD,QAAQ0hD;sBACV1hD,QAAQ2hD;IACzB;WAEY;MACXP,cADW;MAEXC,gBAFW;MAGXC,eAHW;MAIXC;IAJW;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;6BCzH0BpgD,QAAoB;SAClDA,OAAOm2B,IAAP,CAAYj2B,KAAK,CAAC,CAACA,CAAnB;AACT;;ACOA,MAAM+gD,UAAUC,OAAOD,OAAP,GAAiB,GAAjC;;6BAGEvlC,MACA0V,YACA+vB,aACApvB,YACAhxB,OACA8a,aACAulC,aACAnnC,QACmB;;;QAIbiC,QAAQR,KAAKQ;;QAGbmlC,aAAaC,6BAA6BplC,KAA7B;;QACbqlC,UAAUrlC,MAAM5b,GAAN,CAAU,CAACua,IAAD,EAAOkJ,CAAP,KAAay9B,aAAa3mC,IAAb,EAAmBwmC,WAAWt9B,CAAX,CAAnB,EAAkCgO,WAAWlX,KAAK4I,MAAhB,CAAlC,CAAvB;QAGVI,SAAoC;MAEtC49B,uBAAuB;MACvBC,qBAAqB;;UAMjBC,YAAYJ,QAAQ,CAAR;QACdK,aAAaC,eAAezwB,WAAWuwB,UAAUjyC,MAArB,EAA6B1O,KAA5C,IAAqDD;UAChEq7C,aAAaniC,0BAA0B,YAA1B,GAAyC2nC,UAAzC,GAAsD,CAAtD;UACbE,YACJ1F,cAAc,CAAd,GACIuF,UAAUnpC,IAAV,CAAe9I,MADnB,GAEIqyC,qBAAqBJ,SAArB,EAAgCvF,UAAhC,EAA4C+E,WAA5C,EAAyD,IAAzD;WACCh3C,KAAK23C;iBACCD,eAAezwB,WAAWuwB,UAAU9hD,MAArB,EAA6BmB,KAA5C,IAAqDD;;QAC9DkZ,SAAS,GAAG;YACRwS,YAAWtF,EAAER,QAAF,CAAWg7B,UAAUnpC,IAAV,CAAe9I,MAA1B,EAAkCiyC,UAAUnpC,IAAV,CAAe3Y,MAAjD;;UACb4sB,aAAY2vB,aAAawF,YAAY;+BAChB;MAAA;;;QAQvB77C,UAASmW,MAAM/b;;WACZ4jB,IAAI,GAAGA,IAAIhe,SAAQge,KAAK;UACzBiM,OAAOuxB,QAAQx9B,IAAI,CAAZ;UACPi+B,OAAOT,QAAQx9B,CAAR;UAEPzb,SAAS05C,KAAKtyC;UACdpO,UAAU8kB,SAASiB,UAAT,CAAoB,kBAAY/e,MAAZ,kBAAuB;MAAEzG,GAAG,CAAL;MAAQG,GAAG;IAAX,CAA3C;;UAGVigD,aAAaC,wBAAwBlyB,IAAxB,EAA8BgyB,IAA9B,EAAoC1gD,OAApC;;UAMbsgD,aAAaC,eAAezwB,WAAW9oB,MAAX,EAAmBtH,KAAlC,IAA2CD;UACxDohD,iBAAiBxgD,KAAKmU,GAAL,CAAS8rC,kBAAkB,CAAlB,CAAT,EAA+BA,aAAa,IAAI7gD,KAAhD;;UACjBqhD,aAAaC,8BAA8BryB,IAA9B,EAAoC1uB,OAApC,EAA6C6gD,cAA7C,EAA6D,IAA7D;;UACbG,aAAaD,8BAA8BL,IAA9B,EAAoC1gD,OAApC,EAA6C6gD,cAA7C,EAA6D,KAA7D;;UACbI,aAAaF,8BAA8BryB,IAA9B,EAAoC1uB,OAApC,EAA6CsgD,UAA7C,EAAyD,IAAzD;;UACbY,aAAaH,8BAA8BL,IAA9B,EAAoC1gD,OAApC,EAA6CsgD,UAA7C,EAAyD,KAAzD;;QAKfh6C;;QACAq6C,YAAY;YACR1yB,IAAIpI,EAAER,QAAF,CAAWs7B,UAAX,EAAuB3gD,OAAvB;;UACNiuB,IAAI4yB,gBAAgB;cAIhB,CACJM,iBAAiBL,UAAjB,EAA6BG,UAA7B,EAAyCvyB,KAAKxX,IAAL,CAAU3Y,MAAnD,CADI,EAEJoiD,UAFI,EAGJQ,iBAAiBH,UAAjB,EAA6BE,UAA7B,EAAyCR,KAAKxpC,IAAL,CAAU9I,MAAnD,CAHI;iBAKG6f,KAAKqyB,YAAY;YAGtB5+B,IAAcC;;YACds/B,cAAcH,YAAY;eAI1Bj7B,EAAER,QAAF,CAAWs7B,UAAX,EAAuBG,UAAvB,IAAqCj7B,EAAER,QAAF,CAAWs7B,UAAX,EAAuBM,UAAvB,CAArC,GACIH,UADJ,GAEIG;QAAA,OACD;eAGAA,cAAcvyB,KAAKxX,IAAL,CAAU3Y;QAAA;;YAE3B2iD,cAAcF,YAAY;eAI1Bn7B,EAAER,QAAF,CAAWs7B,UAAX,EAAuBK,UAAvB,IAAqCn7B,EAAER,QAAF,CAAWs7B,UAAX,EAAuBO,UAAvB,CAArC,GACIF,UADJ,GAEIE;QAAA,OACD;eAGAA,cAAcR,KAAKxpC,IAAL,CAAU9I;QAAA;;cAEzB,CAACsT,EAAD,EAAKi/B,UAAL,EAAiBh/B,EAAjB;MAAmB,OACpB;YAEDm/B,cAAcE,YAAY;gBAItB,CAACF,UAAD,EAAa9gD,OAAb,EAAsBghD,UAAtB;QAAgC,WAC7BC,cAAcC,UADe,EACH;gBAI7B,CAACD,UAAD,EAAajhD,OAAb,EAAsBkhD,UAAtB;QAAgC,CALA,MAMjC;gBAKC,CACJC,iBAAiBL,UAAjB,EAA6BG,UAA7B,EAAyCvyB,KAAKxX,IAAL,CAAU3Y,MAAnD,CADI,EAEJyB,OAFI,EAGJmhD,iBAAiBH,UAAjB,EAA6BE,UAA7B,EAAyCR,KAAKxpC,IAAL,CAAU9I,MAAnD,CAHI;;;WAOL;UAGD0yC,cAAcE,YAAY;cAGtB,CAACF,UAAD,EAAa9gD,OAAb,EAAsBghD,UAAtB;MAAgC,WAC7BC,cAAcC,UADe,EACH;cAG7B,CAACD,UAAD,EAAajhD,OAAb,EAAsBkhD,UAAtB;MAAgC,CAJA,MAKjC;cAGC,CAACxyB,KAAKxX,IAAL,CAAU3Y,MAAX,EAAmByB,OAAnB,EAA4B0gD,KAAKxpC,IAAL,CAAU9I,MAAtC;MAA4C;;;QAOlDsgB,KAAKkE,OAAO;YAERwuB,aAAa7+B,OAAOA,OAAO1jB,MAAP,GAAgB,CAAvB;;UACfuiD,YAAY;cACRC,YACJD,sBAAsB18C,KAAtB,GAA8B08C,WAAWA,WAAWviD,MAAX,GAAoB,CAA/B,CAA9B,GAAkEuiD;YAChEZ;;YACAl6C,eAAe5B,OAAO;sBAGZ6V,cAAcjU,IAAI,CAAJ,CAAd,GAAuBA,IAAI,CAAJ;QAAI,OAClC;sBACOA;QAAA;;cAERglB,UAAU4I,iCACdmtB,SADcntB,EAEdxF,KAAKkE,KAAL,CAAWuB,MAAX,CAAkB/sB,MAFJ8sB,EAGdssB,SAHctsB,EAIdxF,KAAKkE,KAAL,CAAWxH,KAJG8I;;YAMZ5tB,eAAe5B,KAAf,IAAwB6V,aAAa;iBAChC1R,KAAK,CAAC,GAAGyiB,OAAJ,EAAa,GAAGhlB,GAAhB;QAAoB,OAC3B;iBACEuC,KAAK,CAAC,GAAGyiB,OAAJ,EAAak1B,SAAb;QAAuB;;WAGlC;UACDjmC,eAAe,iBAAiB7V,KAAjB,GAAyB;eACnCmE,KAAKvC;MAAG,OACV;YACDo6C,KAAK9tB,OAAO;iBACP/pB,KAAKvC,IAAI,CAAJ;QAAM,OACb;iBACEuC,KAAKvC,IAAI,CAAJ,GAAQA,IAAI,CAAJ;QAAM;;;;;;UAU1Bg7C,WAAWrB,QAAQA,QAAQphD,MAAR,GAAiB,CAAzB;QACbyhD,aAAaC,eAAezwB,WAAWwxB,SAAS/iD,MAApB,EAA4BmB,KAA3C,IAAoDD;UAC/Dq7C,aAAaniC,0BAA0B,YAA1B,GAAyC2nC,UAAzC,GAAsD,CAAtD;UACbE,YACJ1F,cAAc,CAAd,GACIwG,SAASpqC,IAAT,CAAc3Y,MADlB,GAEIkiD,qBAAqBa,QAArB,EAA+BxG,UAA/B,EAA2C+E,WAA3C,EAAwD,KAAxD;iBACOU,eAAezwB,WAAWwxB,SAASlzC,MAApB,EAA4B1O,KAA3C,IAAoDD;UAC3DmzB,QAAQ0uB,SAAS1uB;;QACnBA,OAAO;YAEHtsB,MAAMic,OAAOA,OAAO1jB,MAAP,GAAgB,CAAvB;YACNwiD,YAAY/6C,eAAe5B,KAAf,GAAuB4B,IAAIA,IAAIzH,MAAJ,GAAa,CAAjB,CAAvB,GAA6CyH;YACzDglB,UAAU4I,iCACdmtB,SADcntB,EAEdtB,MAAMuB,MAAN,CAAa/sB,MAFC8sB,EAGdssB,SAHctsB,EAIdtB,MAAMxH,KAJQ8I;aAMTrrB,KAAK,CAAC,GAAGyiB,OAAJ,EAAak1B,SAAb;IAAuB,OAC9B;aAEE33C,KAAK23C;IAAS;;QAEnB7nC,SAAS,GAAG;YACRwS,YAAWtF,EAAER,QAAF,CAAWi8B,SAASpqC,IAAT,CAAc9I,MAAzB,EAAiCkzC,SAASpqC,IAAT,CAAc3Y,MAA/C;;UACb4sB,aAAY2vB,aAAawF,YAAY;6BAClB;MAAA;;;;MAKvBH,sBAAsB;WACjBrtB;;QACHvQ,OAAO,CAAP,aAAqB7d,OAAO;aACvB68C,QAAQh/B,OAAO,CAAP,EAAU,CAAV;IAAY;;;MAG3B69B,oBAAoB;WACfx3C;;;SAGF2Z;AACT;;AAEA,sCAAsC3H,KAAtC,EAAsE;QAC9DnW,UAASmW,MAAM/b;;MAEjB4F,WAAU,GAAG;WACR,CAAC,IAAD;EAAK;;QAGRs7C,aAAwB;MAC1ByB,WAA0B;;WACrB/+B,IAAI,GAAGA,IAAIhe,SAAQge,KAAK;UACzBrU,SAASwM,MAAM6H,CAAN,EAASlJ,IAAT,CAAcnL;UACvB7P,SAASqc,MAAM6H,CAAN,EAASlJ,IAAT,CAAchb;QACzBkjD;;QACAh/B,MAAM,GAAG;UACPhe,UAAS,GAAG;cAGRi9C,QAAQ,CAACtzC,MAAD,EAAS7P,MAAT,EAAiBujB,IAAjB;cACR6/B,QAAQ,CAAC/mC,MAAM,CAAN,EAASrB,IAAT,CAAcnL,MAAf,EAAuBwM,MAAM,CAAN,EAASrB,IAAT,CAAchb,MAArC,EAA6CujB,IAA7C;;YACV4/B,MAAM,CAAN,MAAaC,MAAM,CAAN,CAAb,IAAyBD,MAAM,CAAN,MAAaC,MAAM,CAAN,GAAU;gBAC5CjB,OAAO,CAAC9lC,MAAM,CAAN,EAASrB,IAAT,CAAcnL,MAAf,EAAuBwM,MAAM,CAAN,EAASrB,IAAT,CAAchb,MAArC;;cACTmiD,KAAK7xB,QAAL,CAAcjU,MAAM,CAAN,EAASrB,IAAT,CAAchb,MAA5B,GAAqC;wBAE3BA,WAAWqc,MAAM,CAAN,EAASrB,IAAT,CAAcnL;UAAA,OAChC;wBAEO7P,WAAWqc,MAAM,CAAN,EAASrB,IAAT,CAAchb;UAAA;eAElC;sBACO,CAACqc,MAAM,CAAN,EAASrB,IAAT,CAAcnL,MAAf,EAAuBwM,MAAM,CAAN,EAASrB,IAAT,CAAchb,MAArC,EAA6CswB,QAA7C,CAAsDtwB,MAAtD;QAA4D;aAErE;oBACO,CAACqc,MAAM,CAAN,EAASrB,IAAT,CAAcnL,MAAf,EAAuBwM,MAAM,CAAN,EAASrB,IAAT,CAAchb,MAArC,EAA6CswB,QAA7C,CAAsDtwB,MAAtD;MAA4D;WAErE;kBACOijD,aAAapzC;IAAA;;eAEhBvF,KAAK44C;eACLA,YAAYljD,MAAZ,GAAqB6P;EAAA;;SAE3B2xC;AACT;;AAEA,8BACExmC,IADF,EAEE+mC,UAFF,EAGET,WAHF,EAIEjnC,SAJF,EAKE;QACM5R,SAAS4R,YAAYW,KAAKnL,MAAjB,GAA0BmL,KAAKhb;QACxCq0B,QAAQrZ,KAAKqZ;;MACfA,OAAO;QACLgvB,UAAUtB,aAAa1tB,MAAMuB,MAAN,CAAar0B;;QACpC8yB,MAAMxH,KAAN,GAAc,GAAG;iBACR;IAAA;;QAET,CAACxS,WAAW;iBACH;IAAA;;WAENkM,SAASiB,UAAT,CACLgO,oBACEnb,YAAYW,KAAKrC,IAAL,CAAU9I,MAAtB,GAA+BmL,KAAKrC,IAAL,CAAU3Y,MAD3Cw1B,EAEEnB,MAAMuB,MAAN,CAAa/sB,MAFf2sB,EAGE6tB,OAHF7tB,CADK;EAMP,OACK;QACD3lB,QAAkB7P;;QAClBqa,WAAW;eACJW,KAAKrC,IAAL,CAAU3Y;eACVgb,KAAKrC,IAAL,CAAU9I;IAAA,OACd;eACImL,KAAKrC,IAAL,CAAU9I;eACVmL,KAAKrC,IAAL,CAAU3Y;IAAA;;UAGfkc,IAAIyP,qCACR9b,MADQ8b,EAER3rB,MAFQ2rB,EAGRpF,SAASiB,UAAT,CAAoB85B,YAAY74C,MAAZ,CAApB,CAHQkjB,EAIRo2B,UAJQp2B;WAMHzP,MAAM,IAAN,GAAarM,MAAb,GAAsBqM;EAAA;AAEjC;;AAEA,iCACEiU,IADF,EAEEgyB,IAFF,EAGE1gD,OAHF,EAImB;MACb2gD,aAA8B;;MAC9BjyB,KAAKkE,OAAO;QACV8tB,KAAK9tB,OAAO;UACVlE,KAAKxX,IAAL,CAAU3Y,MAAV,CAAiBknB,SAAjB,CAA2Bi7B,KAAKxpC,IAAL,CAAU9I,MAArC,GAA8C;eACzCsgB,KAAKxX,IAAL,CAAU3Y,MAAV,CAAiBmnB,KAAjB;;;mBAGIm8B,yBACXnzB,KAAKkE,KAAL,CAAWuB,MAAX,CAAkB/sB,MADPy6C,EAEXnzB,KAAKkE,KAAL,CAAWuB,MAAX,CAAkBr0B,MAFP+hD,EAGXnB,KAAK9tB,KAAL,CAAWuB,MAAX,CAAkB/sB,MAHPy6C,EAIXnB,KAAK9tB,KAAL,CAAWuB,MAAX,CAAkBr0B,MAJP+hD,EAKXnzB,KAAKkE,KAAL,CAAWxrB,MALAy6C;IAMb,OACK;mBAEQC,sCACXpB,KAAKxpC,IAAL,CAAU3Y,MADCujD,EAEXpB,KAAKxpC,IAAL,CAAU9I,MAFC0zC,EAGXpzB,KAAKkE,KAAL,CAAWuB,MAAX,CAAkB/sB,MAHP06C,EAIXpzB,KAAKkE,KAAL,CAAWuB,MAAX,CAAkBr0B,MAJPgiD,EAKX9hD,OALW8hD;IAMb;SAEG;QACDpB,KAAK9tB,OAAO;mBAED1I,qCACXwE,KAAKxX,IAAL,CAAU9I,MADC8b,EAEXwE,KAAKxX,IAAL,CAAU3Y,MAFC2rB,EAGXw2B,KAAK9tB,KAAL,CAAWuB,MAAX,CAAkB/sB,MAHP8iB,EAIXw2B,KAAK9tB,KAAL,CAAWuB,MAAX,CAAkBr0B,MAJPoqB;IAKb,OACK;YAEC63B,YAAYC,UAAUtzB,KAAKxX,IAAf;;YACZ+qC,YAAYD,UAAUtB,KAAKxpC,IAAf;;YACZgrC,aACH,CAACj9C,SAAS88C,SAAT,CAAD,IAAwB,CAAC98C,SAASg9C,SAAT,CAAzB,IAAiD5hD,KAAKC,GAAL,CAASyhD,YAAYE,SAArB,IAAkCtC;;UAClFuC,YAAY;qBACD;MAAA,OACR;qBACQ/1B,4BAAuCuC,KAAKxX,IAA5CiV,EAAkDu0B,KAAKxpC,IAAvDiV;MAA2D;;;;SAIvEw0B;AACT;;AAEA,uCACEpnC,IADF,EAEE4oC,UAFF,EAGE7B,UAHF,EAIE8B,UAJF,EAKmB;MACb7oC,KAAKqZ,OAAO;WACPivB,yBACLM,UADKN,EAELvB,UAFKuB,EAGLtoC,KAAKqZ,KAAL,CAAWuB,MAAX,CAAkB/sB,MAHby6C,EAILtoC,KAAKqZ,KAAL,CAAWuB,MAAX,CAAkBr0B,MAJb+hD,EAKL/8B,SAASiB,UAAT,CAAoBxM,KAAKqZ,KAAL,CAAWxrB,MAA/B,CALKy6C;EAMP,OACK;WACE33B,qCACLk4B,aAAa7oC,KAAKrC,IAAL,CAAU9I,MAAvB,GAAgCmL,KAAKrC,IAAL,CAAU3Y,MADrC2rB,EAELk4B,aAAa7oC,KAAKrC,IAAL,CAAU3Y,MAAvB,GAAgCgb,KAAKrC,IAAL,CAAU9I,MAFrC8b,EAGLi4B,UAHKj4B,EAILo2B,UAJKp2B;EAKP;AAEJ;;AAEA,sBAAsB3Q,IAAtB,EAAwCX,SAAxC,EAA4DmI,KAA5D,EAAwF;MAClF4Q,WAAW5Q,MAAM0Q;MACjBrjB,SAASmL,KAAKA,IAAL,CAAUnL;MACnB7P,SAASgb,KAAKA,IAAL,CAAUhb;MACnBq0B,QAAQ7R,MAAM6R;;MACd,CAACha,WAAW;eACHypC,YAAsB1wB,QAAtB0wB;aACF9oC,KAAKA,IAAL,CAAUhb;aACVgb,KAAKA,IAAL,CAAUnL;;QACfwkB,OAAO;cACD7E,iCAAK6E,KAAL;QAAYxH,OAAO,CAACwH,MAAMxH;MAA1B;;;;QAGNlU,OAAO4O,WAAWQ,gBAAX,CAA4BqL,QAA5B;QACP9wB,SAAmB;IACvBshB,QAAQ5I,KAAK4I,MADU;IAEvB/T,MAFuB;IAGvB7P,MAHuB;IAIvB2Y,IAJuB;IAKvB0b;EALuB;SAOlB/xB;AACT;;AAEA,wBAAwBnB,KAAxB,EAA8C;MACxCA,MAAME,IAAN,IAAc,UAAU;WACnBF,MAAMI;EAAA,OACR;WACEO,KAAK8E,GAAL,CAASzF,MAAMG,KAAf,EAAsBH,MAAMK,MAA5B,IAAsC;EAAA;AAEjD;;AAEA,mBAAmBuG,GAAnB,EAAoC;cACtB/H,OAAOmC,IAAI4F,IAAI8H,MAAJ,CAAW1N,UAAUnC,MAAV,CAAiBgC,CAAjB,GAAqB+F,IAAI8H,MAAJ,CAAW7N;AACpE;;;;;;;;;;;;;;;;;;;;;UCvbM;MAAEd;IAAF,IAAY+5C;UACZ8I,aAAaC;UAEbt0B,IAAIe,SAAS,MAAM;UACnBwzB,OAAO;aACJ11C,MAAMyV,MAAN,CAAavjB,GAAb,CAAiByb,KAAK;YACvBA,MAAM,MAAM;iBACP;QAAA,WACEA,aAAa/V,KADf,EACsB;cACzB,CAAC,GAAG+V,CAAJ;gBACEC,OAAO;;cACTD,EAAE5b,MAAF,GAAW,CAAX,KAAiB,GAAG;kBAChB0B,IAAIka,EAAE,CAAF;gBACNA,EAAExY,KAAF,CAAQ,CAAR;iBACC4G,KAAK,KAAKtI,EAAEA,KAAKA,EAAEG;UAAG;;gBAEvB+Z,GAAG,GAAGzb,IAAI,CAAC,CAAC0iB,EAAD,EAAKC,EAAL,CAAD,KAAcjH,KAAK7R,IAAL,CAAU,KAAK6Y,GAAGnhB,KAAKmhB,GAAGhhB,KAAKihB,GAAGphB,KAAKohB,GAAGjhB,GAA1C;iBACvBga,KAAKzZ,IAAL,CAAU,GAAV;QAAa,CAVb,MAWF;gBACCosB,IAAIm1B;iBACH;iBACA,GAAGn1B,IAAI,IAAJ,GAAW,OAAO5S,EAAEla,KAAKka,EAAE/Z;QAAA;MAExC,CAlBM,EAkBJO,IAlBI,CAkBC,GAlBD;IAmBR,CArBS;UAuBJga,SAAS+T,SAAS,MAAM;YACtBjO,QAAQjU,MAAMsN;;UAChB2G,MAAM5I,UAAU;eACX7Z,OAAOI,MAAP,CAAc4jD,WAAWnqC,QAAzB,EAAmC4I,MAAM3G,IAAzC;MAA6C,WAC3C2G,MAAMqN,OAAN,IAAiBk0B,WAAWpqC,KADe,EACR;eACrC5Z,OAAOI,MAAP,CAAc4jD,WAAWpqC,KAAzB,EAAgC6I,MAAM3G,IAAtC;MAA0C,CAFG,MAG/C;eACE9b,OAAOI,MAAP,CAAc4jD,WAAW3iD,MAAzB,EAAiCohB,MAAM3G,IAAvC;MAA2C;IAErD,CATc;UAWT5C,kBAAkBwX,SAAS,MAAM;aAC9B2qB,sBAAsB1+B,OAAO1d,KAAP,CAAaqD,SAAnC,EAA8CnB,MAAMlC,KAApD;IACR,CAFuB;UAIlBmc,iBAAiBsV,SAAS,MAAM;YAC9B4tB,QAAQ3hC,OAAO1d,KAAP,CAAakc,OAAb,GACVojC,iBAAiB5hC,OAAO1d,KAAP,CAAaqD,SAA9B,IAA2Cqa,OAAO1d,KAAP,CAAamc,cAAxD,GAAyEja,MAAMlC,KADrE,GAEV;aACGq/C,QAAQ,qBAAqBA,OAA7B,GAAuC;IAC/C,CALsB;WAOV;MAAE3uB,CAAF;MAAKxuB,KAAL;MAAYwb,MAAZ;MAAoBzD,eAApB;MAAqCkC;IAArC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;UCzDP;MAAEuX,gBAAF;MAAoBnB,UAApB;MAAgCW,UAAhC;MAA4Cd;IAA5C,IAAwDqtB;UACxD;MAAEv9C;IAAF,IAAY+5C;UACZ8I,aAAaC;UAEb;MACJ3lB,0BADI;MAEJC,0BAFI;MAGJC,yBAHI;MAIJC,oBAJI;MAKJC,0BALI;MAMJC;IANI,IAOFqe;UAEEmH,iBAAiBzzB,SAAS,MAAO5U,IAAD,IAAwC;UACxEA,KAAKQ,KAAL,CAAW/b,MAAX,KAAsB,UAAU;YAC9B8Z,SAASra,OAAOf,KAAP,CAAa+kD,WAAW3pC,MAAxB,EAAgCyB,KAAKA,IAArC,IAA6C3a,MAAMlC;aAC3DmlD,oBACLtoC,IADK,EAEL0V,UAFK,EAGLH,QAAQ1pB,KAHH,EAILwqB,UAJK,EAKLhxB,MAAMlC,KALD,EAML+kD,WAAW/nC,WANN,EAOL+nC,WAAW9nC,GAPN,EAQL7B,MARK;IAUR,CAbsB;WAeV;MACX2pC,UADW;MAEXrxB,gBAFW;MAGXwxB,cAHW;MAIX7lB,0BAJW;MAKXC,0BALW;MAMXC,yBANW;MAOXC,oBAPW;MAQXC,0BARW;MASXC;IATW;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;UCTP0lB,cAAc3zB,SAAS,MAAM;YAC3BrV,IAAI7M,MAAMjN;YACVunB,IAAIta,MAAM/M;;UACZ+M,MAAMwgB,UAAU;eACX,GAAG3T,KAAKyN,QAAQA,IAAI,MAAMzN;MAAA,OAC5B;eACE,QAAQA,KAAKyN,IAAI,QAAQA;MAAA;IAEnC,CARmB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;UCAdw7B,cAAc5zB,SAAS,MAAM;aAC1BliB,MAAMgN,KAAN,KAAgB,aAAhB,GAAgC,CAAhC,GAAoCzZ,KAAK8E,GAAL,CAAS2H,MAAMjN,KAAf,EAAsBiN,MAAM/M,MAA5B,IAAsC;IAClF,CAFmB;UAId8iD,cAAc7zB,SAAS,MAAM;YAC3B3B,IAAIu1B,YAAYrlD,KAAZ,GAAoB;YACxBoc,IAAI7M,MAAMjN;YACVunB,IAAIta,MAAM/M;;UACZ+M,MAAMwgB,UAAU;eACX,GAAG3T,IAAI0T,KAAKjG,IAAIiG,MAAMA,KAAKjG,IAAI,MAAMzN,IAAI0T,KAAKA;MAAA,OAChD;eACE,GAAGA,KAAKA,MAAM1T,IAAI0T,KAAKjG,IAAI,MAAMiG,KAAKjG,IAAIiG;MAAA;IAEpD,CATmB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;UCzBd/b,QAAiC;MACrCwxC,OAAOC,WAD8B;MAErCl+B,OAAOm+B,WAF8B;MAGrC7uB,QAAQ8uB;IAH6B;UAqBjCpjD,QAAQmvB,SACZ,MAAMliB,MAAM+M,MAAN,CAAaha,KAAb,IAAaiN,MAAe+M,MAAf,CAAsBC,KAAtB,KAAgC,aAAhC,GAAgD,CAAhD,GAAoDhN,MAAMrN,KAAvE,CADM;UAIRM,SAASivB,SACb,MAAMliB,MAAM+M,MAAN,CAAa9Z,MAAb,IAAa+M,MAAgB+M,MAAhB,CAAuBC,KAAvB,KAAiC,aAAjC,GAAiD,CAAjD,GAAqDhN,MAAMrN,KAAxE,CADO;UAITyjD,OAAOl0B,SAAS,MAAM;YACpBrW,SAAS7L,MAAM+M,MAAN,CAAalB,MAAb,IAAa7L,MAAgB+M,MAAhB,CAAuBC,KAAvB,KAAiC,aAAjC,GAAiD,CAAjD,GAAqDhN,MAAMrN,KAAxE;aACRqN,MAAM+M,MAAN,CAAayT,QAAb,GAAwBztB,MAAMtC,KAAN,GAAcob,MAAtC,GAA+C,CAACA;IACxD,CAHY;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACsIb,MAAMwqC,eAAe,CACnB,eADmB,EAEnB,qBAFmB,EAGnB,cAHmB,EAInB,YAJmB,EAKnB,aALmB,CAArB;;AAcA,MAAKC,cAAaC,gBAAa;EAC7BC,YAAY;IACVC,KADU;IAEVC,cAFU;IAEVC,aACAA,WAHU;IAGVA,kBACAC,WAJU;IAKVC,WALU;IAKVC,qBACAA,WANU;IAMVA,iBACAC,WAPU;IAQVC,MARU;IAQVC,aACAA,WATU;IAUVC;EAVU,CADiB;EAa7Bl3C,OAAO;IACL7G,OAAO;MACLrG,MAAMnB,MADD;MAELwlD,SAAS;IAFJ,CADF;IAKLrpC,OAAO;MACLhb,MAAMnB,MADD;MAELwlD,SAAS;IAFJ,CALF;IASLv0B,OAAO;MACL9vB,MAAM,CAACnB,MAAD,EAASiG,KAAT,CADD;MAELu/C,SAAS;IAFJ,CATF;IAaLt0B,SAAS;MACP/vB,MAAMnB,MADC;MAEPwlD,SAAS;IAFF,CAbJ;IAiBLttB,WAAW;MACT/2B,MAAMggD,MADG;MAETqE,SAAS;IAFA,CAjBN;IAqBLvtB,eAAe;MACb92B,MAAM8E,KADO;MAEbu/C,SAAS,MAAM;IAFF,CArBV;IAyBLhqB,eAAe;MACbr6B,MAAM8E,KADO;MAEbu/C,SAAS,MAAM;IAFF,CAzBV;IA6BL5nB,eAAe;MACbz8B,MAAM8E,KADO;MAEbu/C,SAAS,MAAM;IAFF,CA7BV;IAiCL3kD,SAAS;MACPM,MAAMnB,MADC;MAEPwlD,SAAS;IAFF,CAjCJ;IAqCLC,QAAQ;MACNtkD,MAAMnB,MADA;MAENwlD,SAAS;IAFH,CArCH;IAyCLE,eAAe;MAKbvkD,MAAMnB,MALO;MAMbwlD,SAAS;IANI;EAzCV,CAbsB;EA+D7BG,OAAO,CACL,kBADK,EAEL,sBAFK,EAGL,sBAHK,EAIL,sBAJK,EAKL,gBALK,CA/DsB;;EAsE7BC,MAAMv3C,KAAN,EAAa;IAAE0rB,IAAF;IAAQ8rB;EAAR,CAAb,EAA8B;UACtBC,WAAWr8C,MAAM4E,KAAN,EAAa,OAAb;UACX03C,WAAWt8C,MAAM4E,KAAN,EAAa,OAAb;UACX;MAAEqhB,SAASs2B,QAAX;MAAqBnoB;IAArB,IAAsDooB,0BAC1Dx8C,MAAM4E,KAAN,EAAa,OAAb,CAD0D;UAKtD5G,UAAUy+C;WACT5lD,QAAQ+N,MAAMq3C,eAAelnC,QAAQ,CAAC,CAACrd,IAAD,EAAO8X,KAAP,CAAD,KAAmB;cACrD7P,GAAGjI,MAAa8X;IACzB;UAGKpY,UAAUslD,eAAe18C,MAAM4E,KAAN,EAAa,SAAb,CAAf;UAGV+3C,YAAY71B,SAAS,MAAM;YACzB81B,eAAe,IAAI/lC,GAAJ,CAAQtgB,OAAOiJ,IAAP,CAAY48C,KAAZ,CAAR;mBACRrnC,QAAQ7b,KAAK0jD,aAAahkC,MAAb,CAAoB1f,CAApB;YAEpB8iD,SAASzlD,OAAOK,WAAP,CAAmBxB,eAAe0B,GAAf,CAAmBqC,KAAK,CAACA,CAAD,EAAI,EAAJ,CAAxB,CAAnB;aACRhC,OACL6kD,QACAzlD,OAAOM,OAAP,CAAe+N,MAAMo3C,MAArB,EAA6B/iD,MAA7B,CAAoC,CAAC4jD,KAAD,EAAQ,CAACpnD,IAAD,EAAOiC,IAAP,CAAR,KAAyB;qBAC9CkhB,OAAOnjB;;YAChBiC,QAAQmlD,OAAO;gBACXnlD,MAAMiJ,KAAKlL;QAAI,OAChB;gBACCiC,QAAQ,CAACjC,IAAD;QAAK;;eAEdonD;MAAA,CAPT,EAQG,EARH;aAWK,QAAQl8C,KAAK,GAAGi8C;aAChBZ;IACR,CApBiB;UAuBZc,aAAah2B,SAAS,MAAM1vB,QAAQ2W,IAAR,CAAaa,IAAb,CAAkBC,OAAjC;UACbkuC,2BAA2Bj2B,SAAS,MAAM;YACxCk1B,SAASW,UAAUtnD;aAClBynD,WAAWznD,KAAX,IAAoB2mD,OAAO,YAAP,EAAqBrlD,MAArB,GAA8B,CAAlD,IAAuDqlD,OAAO,MAAP,EAAerlD,MAAf,GAAwB;IACvF,CAHgC;UAM3BqmD,sBAAsBl2B,SAAS,MAAM,mBAAmBs1B,KAAlC;UACtBa,2BAA2Bn2B,SAAS,MAAM,yBAAyBs1B,KAAxC;UAC3Bc,qBAAqBp2B,SAAS,MAAM,kBAAkBs1B,KAAjC;UACrBe,mBAAmBr2B,SAAS,MAAM,gBAAgBs1B,KAA/B;UACnBgB,oBAAoBt2B,SAAS,MAAM,iBAAiBs1B,KAAhC;UAKpBpmD,YAAYsyB;UACZryB,MAAMqyB;UACNpyB,WAAWoyB;UACXzP,QAAQyP,IAAW,CAAX;UACR+0B,OAAOv2B,SAAS,MAAMjO,MAAMxjB,KAAN,KAAgB,CAA/B;UAEPo5B,YAAY6uB,SAAS14C,KAAT,EAAgB,WAAhB,EAA6B0rB,IAA7B,EAAmC55B,KAAK;UACpDyB,KAAKmU,GAAL,CAAS5V,CAAT,EAAYU,QAAQ2W,IAAR,CAAaI,YAAzB;UACAhW,KAAK8E,GAAL,CAASvG,CAAT,EAAYU,QAAQ2W,IAAR,CAAaK,YAAzB;aACG1X;IACR,CAJiB;UAOZ;MAAEP,uBAAF;MAAc85C,mBAAd;MAAmCC;IAAnC,IAA6DqN,cAActnD,GAAd,EAAmB;MACpF0xC,kBAAkB,aADkE;MAEpFK,SAAS5wC,QAAQ2W,IAAR,CAAaI,YAF8D;MAGpF85B,SAAS7wC,QAAQ2W,IAAR,CAAaK,YAH8D;MAIpFy5B,qBAAqB2V,yBAAyBpmD,QAAQ2W,IAAjC,CAJ+D;MAKpFO,uBAAuBk/B,wBAAwBp2C,QAAQ2W,IAAhC,CAL6D;MAMpF03B,KAAK,IAN+E;MAOpFvmC,QAAQ,IAP4E;MAQpFgP,aAAa9W,QAAQ2W,IAAR,CAAaG,WAR0D;MASpF45B,2BAA2B,KATyD;MAUpFpB,QAAQ9d,KAAK;;;YACP/P,MAAMxjB,KAAN,KAAgB;cACd61B,IAAI,wBAAW71B,KAAX,wBAAkBu5C,WAAlB,mBAAmC;;YACzCz2C,KAAKC,GAAL,CAASq2B,UAAUp5B,KAAV,GAAkB61B,CAA3B,KAAiC,MAAQ;oBACjC71B,QAAQ61B;kBACVoF,KAAK,aAAapF;QAAC;OAfqD;MAkBpFjd,YAAY7W,QAAQ2W,IAAR,CAAaE,UAlB2D;MAmBpF84B,OAAOx0B,KAAK;YACNsG,MAAMxjB,KAAN,KAAgB;gBACZi7B,KAAK,YAAY/d;MAAC;IArBwD,CAAnB;sBAyBjD;MAAEvc,SAAF;MAAaC,GAAb;MAAkBC,QAAlB;MAA4BC;IAA5B;UAGZsnD,WAAW;MAAE9lD,OAAO,CAAT;MAAYE,QAAQ;IAApB;UACX6lD,iBAAiBviB,WAAWwiB,cAAX,GACnB,IAAIA,cAAJ,CAAmB,MAAM;;;wBACZtoD,6BAAOm3C,MAAP;UACP,CAACp1C,QAAQ2W,IAAR,CAAaU;YAEZ0nC,IAAI,gBAAU9gD,KAAV,wBAAiBqjC,qBAAjB;;UACNyd,GAAG;cACC99C,IAAI,WAAWV,KAAX,GAAmBw+C,EAAEx+C,KAArB,IAA8B;cAClCa,IAAI,WAAWX,MAAX,GAAoBs+C,EAAEt+C,MAAtB,IAAgC;0BAC/BxC,6BAAOk3C,KAAP,CAAa;UAAEl0C,CAAF;UAAKG;QAAL,CAAb;cACL;UAAEb,KAAF;UAASE;QAAT,IAAoBs+C;;YACtBsH,SAAS9lD,KAAT,KAAmBA,KAAnB,IAA4B8lD,SAAS5lD,MAAT,KAAoBA,QAAQ;iBACnDV,OAAOsmD,UAAU;YAAE9lD,KAAF;YAASE;UAAT;kBAChBy4B,KAAK,eAAe;YAAEj4B,GAAG89C,EAAE99C,CAAP;YAAUG,GAAG29C,EAAE39C,CAAf;YAAkBb,KAAlB;YAAyBE;UAAzB;QAAiC;;IAGlE,CAfD,CADmB,GAiBnB;wBACgB,MAAM;;;YAClB0oB,IAAIzqB,QAAQE,UAAUX,KAAlB,EAAyB,wBAAzB;uDACM08C,QAAQxxB;0BAChBxS,MAAKY,wDAA0B7Y,QAAQ8I,YAAWvJ,KAAnB,EAA0B,uBAA1B,CAA1B;YACP8gD,IAAI51B,EAAEmY,qBAAF;YACJ;QAAE/gC,KAAF;QAASE;MAAT,IAAoBs+C;aACnBh/C,OAAOsmD,UAAU;QAAE9lD,KAAF;QAASE;MAAT;qBACfxC,6BAAOi8B,gBAAP,CAAwB,YAAxB,EAAsCssB,oBAAtC,EAA4D;QAAEjqB,SAAS;MAAX,CAA5D;IACV;0BACqB,MAAM;;;uDACVqf;qBACP39C,6BAAO47B,mBAAP,CAA2B,YAA3B,EAAyC2sB,oBAAzC;IACV;;UAEK7O,yBAA0B8O,iBAAD,IAA+B;;;wBACjDxoD,6BAAO05C,sBAAP,CACT8O,iBADS,EAETzmD,QAAQ2W,IAAR,CAAaI,YAFJ,EAGT/W,QAAQ2W,IAAR,CAAaK,YAHJ;IAGI;;UAKf,MAAMhX,QAAQ2W,IAAR,CAAaE,YACnBvX,KAAK;;;wBACQrB,6BAAOi6C,aAAP,CAAqB54C,CAArB;IAEf;UAEE,MAAM,CACJU,QAAQ2W,IAAR,CAAaG,WADT,EAEJsvC,yBAAyBpmD,QAAQ2W,IAAjC,CAFI,EAGJy/B,wBAAwBp2C,QAAQ2W,IAAhC,CAHI,GAKNrX,KAAK;uBAEDkI,YAAWvJ,OACX+B,QAAQ2W,IAAR,CAAaG,aACb9W,QAAQ2W,IAAR,CAAaM,wBACbjX,QAAQ2W,IAAR,CAAaO;IAGnB;UAEMmgB,WAAW/3B,KAAKq4C,uBAAuBr4C,CAAvB;UAEpB,MAAM,CAACU,QAAQ2W,IAAR,CAAaI,YAAd,EAA4B/W,QAAQ2W,IAAR,CAAaK,YAAzC,GACNwa,KAAK;6BACoB6F,UAAUp5B;IAErC;UAGM;MAAEkC;IAAF,IAAYumD,iBAAiBrvB,SAAjB,EAA4Br3B,QAAQ2W,IAApC;wBAEE,MAAM;YAElBgwC,mBAAmBn5C,MAAM6pB;6BACRsvB;IACxB;;UAIKC,kBAAmB/mD,QAAD,IAA0B;;;UAC5CV,OAAOiJ,IAAP,CAAYoF,MAAM7G,KAAlB,EAAyBpH,MAAzB,GAAkC,GAAG;0BAC5BtB,6BAAOi3C,UAAP;iBACFr1C;MAAQ,OACZ;;;;;UAMHi3C,gBAAgB,MAAM;sBACV,MAAM;YAChBtvC,YAAWvJ,OAAO;sBACTA,MAAM64C;kBACT5d,KAAK,YAAY;QAAS;MAErC;IAAA;;UAIG2tB,cAAc,MAAM;sBACR,MAAM;;;0BACT5oD,6BAAO6J,MAAP;MACZ;IAAA;;UAIGsmC,aAAa;;;MACjB,+BAAWnwC,KAAX,wBAAkBmwC,UAAlB,mBAAkC;QAChC9jB,KAAK,CAD2B;QAEhCC,QAAQ,CAFwB;QAGhCF,MAAM,CAH0B;QAIhCliB,OAAO;MAJyB,CAAlC;;;UAQI6uC,aAAc9uC,GAAD,IAAC;;;MAAa,yBAAWjK,KAAX,wBAAkB+4C,UAAlB,CAA6B9uC,GAA7B;IAA6B;;UAKxD4+C,uBAAuBC,eAAev5C,KAAf,EAAsB,eAAtB,EAAuCy3C,QAAvC,EAAiD/rB,IAAjD;UACvB4tB,sBAAsBngD,SAASC,QAAQsyB,IAAR,CAAa,aAAb,EAA4B9zB,MAAMic,IAAN,CAAW1a,KAAX,CAA5B;UAE/BqgD,uBAAuBD,eAAev5C,KAAf,EAAsB,eAAtB,EAAuC03C,QAAvC,EAAiDhsB,IAAjD;UACvB8tB,sBAAsB1rC,SAAS1U,QAAQsyB,IAAR,CAAa,aAAb,EAA4B9zB,MAAMic,IAAN,CAAW/F,KAAX,CAA5B;UAE/B2rC,uBAAuBF,eAAev5C,KAAf,EAAsB,eAAtB,EAAuC23C,QAAvC,EAAiDjsB,IAAjD;UACvB+tB,sBAAsB72B,SAASxpB,QAAQsyB,IAAR,CAAa,aAAb,EAA4B9zB,MAAMic,IAAN,CAAW+O,KAAX,CAA5B;UAE/B+G,eAAezV,6BAAajC,GAAb;UACfib,eAAehZ,6BAAajC,GAAb;UACfqd,eAAepb,6BAAajC,GAAb;UACfynC,iBAAiBxlC,SAAkB;MAAE/a,OAAO;IAAT,CAAlB;UAIrB,MAAM6G,MAAM6iB,SACZ,MAAMlxB,OAAOY,MAAP,CAAcmnD,cAAd,EAA8B15C,MAAM6iB,OAApC,GACN;MAAEpU,MAAM,IAAR;MAAcD,WAAW;IAAzB;UAEIkrC,gBAAgB,MAAMhuB,KAAK,gBAAL,EAAuBguB,cAAvB,GAAwC;MAAEjrC,MAAM;IAAR;UAE9DkrC,uBAAuBz3B,SAAS,MAAM;aACnC1vB,QAAQC,IAAR,CAAawZ,SAAb,CAAuBhC;IAC/B,CAF4B;UAOvBqW,cAAcs5B;UAOdC,WAAWn2B,IAAa,KAAb;YACT3oB,GAAG,kBAAkBipB,KAAM61B,SAASppD,KAAT,GAAiB;YAC5CsK,GAAG,gBAAgBipB,KAAM61B,SAASppD,KAAT,GAAiB;YAC1CsK,GAAG,aAAaswB,QAAQ;;;UAE1B74B,QAAQ2W,IAAR,CAAaE,YAAY;YACvBgiB,SAAS,WAAW;4BACX56B,6BAAOy3C,SAAP;QAAO,OACb;4BACMz3C,6BAAO03C,UAAP;QAAO;;;UAGlB31C,QAAQ2W,IAAR,CAAaG,aAAa;YACxB+hB,SAAS,WAAW;4BACX56B,6BAAO43C,UAAP;QAAO,OACb;4BACM53C,6BAAO63C,WAAP;QAAO;;IAGvB;UAEKrQ,UAAU/V,SAAS,MAAM;aACtB1vB,QAAQ2W,IAAR,CAAaE,UAAb,IAA2B7W,QAAQ2W,IAAR,CAAaG,WAAxC,IAAuD9W,QAAQC,IAAR,CAAa6Y;IAC5E,CAFe;UAIV;MAAE0X,UAAF;MAAcC,gBAAd;MAAgCU,UAAhC;MAA4CO;IAA5C,IAA2D41B,cAC/DC,eAAetC,QAAf,EAAyB6B,oBAAzB,EAA+C3vB,YAA/C,CAD+D,EAE/DowB,eAAerC,QAAf,EAAyB8B,oBAAzB,EAA+CtsB,YAA/C,CAF+D,EAG/D6sB,eAAepC,QAAf,EAAyB8B,oBAAzB,EAA+CnqB,YAA/C,CAH+D,EAI/D0qB,SAASxnD,OAAT,CAJ+D,EAK/DknD,cAL+D,EAM/Dp5B,WAN+D,EAO/D3tB,KAP+D;UAU3D+7B,wBAAwBxM,SAAS,MAAM0mB,wBAAwBp2C,QAAQ2W,IAAhC,CAAf;UAGxB;MAAEypB,kBAAF;MAAsBC,YAAtB;MAAoC8B,iBAApC;MAAuDC;IAAvD,IACJqlB,sBACE5oD,GADF,EAEE2oD,SAASN,cAAT,CAFF,EAGEM,SAASnwB,SAAT,CAHF,EAIE7G,UAJF,EAKEW,UALF,EAMEO,UANF,EAOEo1B,oBAPF,EAQEE,oBARF,EASEC,oBATF,EAUE9vB,YAVF,EAWEuD,YAXF,EAYEoC,YAZF,EAaEE,4BAbF,EAcEd,qBAdF,EAeEl8B,OAfF,EAgBE4G,OAhBF;UAsBI8gD,eAAeh4B,SAAS,MAAM1vB,QAAQ8a,IAAR,CAAarD,OAA5B;;UAMfkwC,iBAAiB;MACrBt3B,SAAS3O,SAASwlC,eAAevgD,KAAxB,CADY;MAErBD,eAAekC,MAAMs+C,cAAN,EAAsB,OAAtB,CAFM;MAGrBvgD,OAAOs+C,QAHc;MAIrB3pC,OAAO4pC,QAJc;MAKrBllD,SAASwnD,SAASxnD,OAAT,CALY;MAMrBG,OAAOqnD,SAASrnD,KAAT,CANc;MAOrByG,OAPqB;MAQrB7H,YAAYL,QAAQ8I,YAAWvJ,KAAnB;IARS;;UAWrB,MAAM+B,QAAQ2W,IAAR,CAAaW,eACnB,CAACswC,UAAD,EAAaC,UAAb,KAA4B;iBACfn/C;iBACAlC,SAASmhD;IAExB;UAOM;MAAEnO,eAAF;MAAmBN;IAAnB,IAAwC4O;UACxCC,mBAAmBr4B,SAAS,MAAM;YAChCyU,IAAI+U,iBAAiBj7C;aAEzBkmC,EAAEvqB,OAAF,GACI;QACE,yBAAyBuqB,EAAEgV,QAAF,GAAa,IADxC;QAEE,yBAAyBhV,EAAEiV;MAF7B,CADJ,GAKI;IAEP,CAVwB;wBAgBL,MAAM;sBACR,MAAM;cAEd4O,OAAMtpD,QAAQ8I,YAAWvJ,KAAnB,EAA0B,cAA1B;gBAIJ0Y,KAAKW,cAAc9Q,SAASmhD;iBAE3B,MAAM;gBACPM,iBAAiBjoD,QAAQ2W,IAAR,CAAaS;;cAChCpX,QAAQ2W,IAAR,CAAa03B,GAAb,IAAoB4Z,mBAAmB,OAAO;kBAC1CC,aAAa/oD,OAAOiJ,IAAP,CAAYoF,MAAM7G,KAAlB,EAAyBpH,MAAzB,IAAmC;;gBAClD2oD,cAAcD,mBAAmB,eAAe;oBAE5ClR,QAAQiR,KAAItR,QAAJ;mBACVpC,IAAI;gBACNrzC,GAAG81C,MAAMx2C,KAAN,GAAc,CADX;gBAENa,GAAG21C,MAAMt2C,MAAN,GAAe;cAFZ;YAGP,WACQwnD,mBAAmB,aAAnB,IAAoCjoD,QAAQ2W,IAAR,CAAa03B,GADzD,EAC8D;;aAD9D,UAGQ4Z,mBAAmB,kBAAkB;;;;;kBAK1C/uB,KAAK;gBAGPj7B,QAAQ;QACf;MACF;IACF;0BAEqB,MAAM;YACpBA,QAAQ;cACNi7B,KAAK;cACLviB,KAAKW,cAAc5O;IAC5B;WAEM;MAEL9J,SAFK;MAGLC,GAHK;MAILC,QAJK;MAKLmnD,IALK;MAQLlnD,uBARK;MAWLopD,YAAYnoD,OAXP;MAYLulD,SAZK;MAaLG,UAbK;MAcLC,wBAdK;MAeLC,mBAfK;MAgBLC,wBAhBK;MAiBLC,kBAjBK;MAkBLC,gBAlBK;MAmBLC,iBAnBK;MAoBL7lD,KApBK;MAqBLqwB,UArBK;MAsBLC,gBAtBK;MAuBLq2B,oBAvBK;MAwBLl5B,SAASE,YAAYF,OAxBhB;MAyBLy5B,QAzBK;MA0BL5hB,OA1BK;MA2BLyhB,cA3BK;MA4BLC,oBA5BK;MA6BLO,YA7BK;MA8BLxO,gBA9BK;MA+BL6O,gBA/BK;MAgCL3nB,kBAhCK;MAiCLC,YAjCK;MAoCLyW,aApCK;MAqCL+P,WArCK;MAsCLzY,UAtCK;MAuCL4I,UAvCK;MAwCLwC,eAxCK;MAyCLrX,iBAzCK;MA0CLC;IA1CK;GA1doB;;EAugB7ByU,SAAS;IAIP1K,SAAS;;;iBACFptC,kCAAYotC,MAAZ;IAAY,CALZ;;IAUPS,UAAU;;;iBACH7tC,kCAAY6tC,OAAZ;IAAY,CAXZ;;IAiBPwb,MAAMz9B,KAAN,EAAoB;;;iBACb5rB,kCAAYu1C,GAAZ,CAAgB3pB,KAAhB;IAAgB,CAlBhB;;IAwBPwqB,MAAMxqB,KAAN,EAAoB;;;iBACb5rB,kCAAYo2C,KAAZ,CAAkBxqB,KAAlB;IAAkB,CAzBlB;;IA+BPkkB,SAAgB;aACPnwC,QAAQ,KAAKK,UAAb,EAAyB8vC,MAAzB;KAhCF;;IAqCP6H,WAAkB;YACVK,QAAQr4C,QAAQ,KAAKK,UAAb,EAAyB23C,QAAzB;aACP;QACLn2C,OAAOw2C,MAAMx2C,KADR;QAELE,QAAQs2C,MAAMt2C,MAFT;QAGLgtC,SAASsJ,MAAMtJ;MAHV;KAvCF;;IAiDPpL,iCAAiCzC,WAAjC,EAA4D;aACnDyC,iCACL3jC,QAAQ,KAAKG,GAAb,EAAkB,KAAlB,CADK,EAELH,QAAQ,KAAKI,QAAb,EAAuB,UAAvB,CAFK,EAGL8gC,WAHK;IAIP,CAtDK;;IA4DPyoB,iCAAiCzoB,WAAjC,EAA4D;aACnDyoB,iCACL3pD,QAAQ,KAAKG,GAAb,EAAkB,KAAlB,CADK,EAELH,QAAQ,KAAKI,QAAb,EAAuB,UAAvB,CAFK,EAGL8gC,WAHK;IAIP,CAjEK;;IAuEP0oB,WAAmB;YACX1jB,UAAUlmC,QAAQ,KAAKG,GAAb,EAAkB,KAAlB;YACVC,WAAWJ,QAAQ,KAAKI,QAAb,EAAuB,cAAvB;YAEXG,SAAS2lC,QAAQ2jB,SAAR,CAAkB,IAAlB;YAETrgD,MAAMpJ,SAASqvC,OAAT;YACNra,IAAI,IAAI,KAAK3zB;YACbtB,MAAM;QACVoC,GAAGF,KAAK0pB,KAAL,CAAK,KAAWxpB,CAAX,GAAe,EAAf,IAAqB6yB,CAA1B,CADO;QAEV1yB,GAAGL,KAAK0pB,KAAL,CAAK,KAAWrpB,CAAX,GAAe,EAAf,IAAqB0yB,CAA1B,CAFO;QAGVvzB,OAAOQ,KAAK88B,IAAL,CAAK,KAAUt9B,KAAV,GAAkB,EAAlB,IAAwBuzB,CAA7B,CAHG;QAIVrzB,QAAQM,KAAK88B,IAAL,CAAK,KAAUp9B,MAAV,GAAmB,EAAnB,IAAyBqzB,CAA9B;MAJE;aAMLqW,aAAa,SAAStrC,IAAI0B,KAAJ,CAAU2C,QAAV;aACtBinC,aAAa,UAAUtrC,IAAI4B,MAAJ,CAAWyC,QAAX;YAExB5D,IAAIL,OAAOijC,aAAP,CAAqB,aAArB;QACRiI,aAAa,aAAa,aAAa,CAACtrC,IAAIoC,KAAK,CAACpC,IAAIuC,aAAa0yB;QACnEka,gBAAgB;aAEX7D,aAAa,WAAW,OAAOtrC,IAAI0B,SAAS1B,IAAI4B;UAEnD0I,OAAOlK,OAAOupD;aAGXr/C,KAAKwkB,UAAL,CAAgB,uBAAhB,EAAyC,EAAzC;aACAxkB,KAAKwkB,UAAL,CAAgB,mBAAhB,EAAqC,EAArC;aACAxkB;IAAA;;EAnGF;AAvgBoB,CAAb,CAAlB;;AA+mBA,0BACE3B,WADF,EAEEmkC,MAFF,EAGE8c,cAHF,EAIEC,gBAJF,EAKQ;cACKvQ,eAAexM;;MACtBA,UAAU8c,gBAAgB;gBACjBxS;SACN;gBACMC;;;MAETvK,UAAU+c,kBAAkB;gBACnB5V;SACN;gBACMG;;AAEf;;AAEA,kCAAkCt8B,IAAlC,EAA6D;SACpDA,KAAKG,WAAL,IAAoBH,KAAKM;AAClC;;AAEA,iCAAiCN,IAAjC,EAA4D;SACnDA,KAAKG,WAAL,IAAoBH,KAAKO;AAClC;;AAEA,8BAA8BkB,KAA9B,EAA4C;QACpC+gB;AACR;;;EAt0BOjI,KAAI;EAAYy3B,OAAM;;;;;;EAsDlBA,OAAM;;;;EA2BsBA,OAAM;;;;;;;;;;;;;;;;;;;;;;;;sBAjF3CC,mBA0IM,KA1INA,cA0IM,eAzIJA,mBAwIM,KAxINA,EAwIM;IAvIJ13B,KAAI,KAuIA;IAtIJy3B,OAAKE,gBAAC,UAADA,EAAW;MAAA5C,MACN6C,SADM;MACFzB,UAAEyB,aADA;MACQrjB,SAAEqjB,YADV;MACiB,sBAAwBA;IADzC,CAAXD,EAsID;IApIJtoD,OAAM,KAoIF;IAnIJE,QAAO,KAmIH;IAlIJgtC,SAAQ;EAkIJ,CAxINmb,EAMU,mBAGRA,mBAKEG,QALFH,EAKEG,IALFH,EAKEG,WAJoBD,eAAS,MAAT,CAIpBC,EAJOC,SAAsB,IAAb;WADlBC,WAKEH,WALFG,EAGSD,SAHTC,EAGkB;MADflgD,KAAKigD,SACU;MACf7oD,OAAO2oD;IADQ,CAHlBG;GAKEF,CALFH,MAHQ,GAUIzpD,OAAOiJ,IAAP,CAAY0gD,YAAZ,EAAqBvpD,MAArB,GAA2B,CAA3B,IAA2B2pD,aAAvCN,mBAQO,MARPA,EAQOO,UARPP,EAQO,mBAPLA,mBAMEG,QANFH,EAMEG,IANFH,EAMEG,WALuBD,YAKvBC,EAL8B,CAAtBxuC,MAAsB,EAAdxT,EAAc,KAAZ;wBADpBqiD,YAMEC,wBANFD,EAME;MAJCriD,EAID;MAHCgC,KAAKhC,EAGN;MAFCwT,MAED;MADCpa,OAAO2oD;IACR,CANFM;GAMEL,CANFH,MAOK,EARPA,CAAY,gCAVJ,EAsBqBE,8CAA7BM,YAWwBE,gCAXxBF,EAWwB;IAAArgD;EAAA,CAXxBqgD,EAWwB;qBAVnB,MAA4C,mBAA/CR,mBAEIG,QAFJH,EAEIG,IAFJH,EAEIG,WAFmBD,eAAS,YAAT,CAEnBC,EAFMC,SAAsB,IAAb;0BAAnBJ,mBAEI,GAFJA,EAEI;QAF6C7/C,KAAKigD,SAElD;QAF6DL,OAAM;MAEnE,CAFJC,EAAuE,CACrEK,WAAyCH,WAAzCG,EAAaD,SAAbC,EAAsB;QAAG9oD,OAAO2oD;MAAV,CAAtBG,EAAgC,MAAhCA,EAAgC,IAAhCA,CADqE,CAAvEL;KAEIG,CAFJH,MAA+C,GAKtBE,gCAAzBM,YAAuCG,4BAAvCH,EAAuC;MAAArgD;IAAA,CAAvCqgD,CAAyB,IAAcI,4BALQ,oBAO/CZ,mBAEIG,QAFJH,EAEIG,IAFJH,EAEIG,WAFmBD,eAAS,MAAT,CAEnBC,EAFMC,SAAsB,IAAb;0BAAnBJ,mBAEI,GAFJA,EAEI;QAFuC7/C,KAAKigD,SAE5C;QAFuDL,OAAM;MAE7D,CAFJC,EAAiE,CAC/DK,WAAyCH,WAAzCG,EAAaD,SAAbC,EAAsB;QAAG9oD,OAAO2oD;MAAV,CAAtBG,EAAgC,MAAhCA,EAAgC,IAAhCA,CAD+D,CAAjEL;KAEIG,CAFJH,MAP+C,GAUzB;;EAAA,CAXxBQ,CAA6B,gCAtBrB,EAoCRK,mBAsFI,GAtFJA,EAsFI;IArFFv4B,KAAI,UAqFF;IApFFy3B,OAAKE,gBAAC,YAADA,EAAa;MAAA,gBACQC,sBAAiBlvC;IADzB,CAAbivC,EAoFH;IAlFD3oD,OAAKwpD,eAAEZ,qBAAFY;EAkFJ,CAtFJD,EAI0B,mBAExBb,mBAEIG,QAFJH,EAEIG,IAFJH,EAEIG,WAFmBD,eAAS,MAAT,CAEnBC,EAFMC,SAAsB,IAAb;wBAAnBJ,mBAEI,GAFJA,EAEI;MAFuC7/C,KAAKigD,SAE5C;MAFuDL,OAAM;IAE7D,CAFJC,EAAiE,CAC/DK,WAAyCH,WAAzCG,EAAaD,SAAbC,EAAsB;MAAG9oD,OAAO2oD;IAAV,CAAtBG,EAAgC,MAAhCA,EAAgC,IAAhCA,CAD+D,CAAjEL;GAEIG,CAFJH,MAFwB,GAOxBa,mBAOI,GAPJA,cAOI,CANFE,YAAsBC,6BAAtBD,CAME,EALFA,YAIgBE,wBAJhBF,EAIgB;IAJA7D,oBAAoBgD;EAIpB,CAJhBa,EAAoC;IACvBhF,SAAOmF,QAAEC,SAClB,IAD2B,CAC3Bd,WAA+CH,WAA/CG,EAA+C,cAA/CA,EAA+Ce,kCAAbD,SAAa,EAA/Cd,EAA2C,MAA3CA,EAA2C,IAA3CA,CAD2B,CAAXa,CADgB;;EAAA,CAApCH,4BAKE,CAPJF,CAPwB,oBAgBxBb,mBAEIG,QAFJH,EAEIG,IAFJH,EAEIG,WAFmBD,eAAS,OAAT,CAEnBC,EAFMC,SAAsB,IAAb;wBAAnBJ,mBAEI,GAFJA,EAEI;MAFwC7/C,KAAKigD,SAE7C;MAFwDL,OAAM;IAE9D,CAFJC,EAAkE,CAChEK,WAAyCH,WAAzCG,EAAaD,SAAbC,EAAsB;MAAG9oD,OAAO2oD;IAAV,CAAtBG,EAAgC,MAAhCA,EAAgC,IAAhCA,CADgE,CAAlEL;GAEIG,CAFJH,MAhBwB,GAqBHE,yBAAoBA,sBAApB,IAAoBI,aAAzCE,YAUgBa,wBAVhBb,EAUgB;IAAArgD;EAAA,CAVhBqgD,EAUgBc;IAAA14B;EAAA,IAREs3B;UAAmB,YAAnB;IAAmB1jB,YAAY2kB,SAC7C,IADsD,CACtDd,WAA6CH,WAA7CG,EAA6C,YAA7CA,EAA6Ce,kCAAbD,SAAa,EAA7Cd,EAAyC,MAAzCA,EAAyC,IAAzCA,CADsD,CAArB;EAAnB,UAQF,EAHEH;UAAoB,aAApB;IAAoB1jB,YAAa2kB,SAC/C,IADwD,CACxDd,WAA8CH,WAA9CG,EAA8C,aAA9CA,EAA8Ce,kCAAbD,SAAa,EAA9Cd,EAA0C,MAA1CA,EAA0C,IAA1CA,CADwD,CAAtB;EAApB,UAGF,EAVhBG,OAAqB,gCArBG,EAkCfN,0CAATF,mBAQI,GARJA,cAQI,mBAPFA,mBAMEG,QANFH,EAMEG,IANFH,EAMEG,WALiBD,yBAKjBC,EALOrhD,MAA8B,IAAxB;wBADf0hD,YAMEe,4BANFf,EAME;MAJCriD,IAAIW,MAIL;MAHCqB,KAAKrB,MAGN;MAFC+Z,OAAOqnC,gBAAWphD,MAAX,CAER;MADCV,KAAK8hD,oBAAeniD,KAAf,CAAqBe,MAArB;IACN,CANF0hD,EAK6B,IAL7BA,EAK6B,CAL7BA,EAK6B,sBAL7BA;GAMEL,CANFH,MAOE,EARJA,CAAS,gCAlCe,oBA4CxBA,mBAEIG,QAFJH,EAEIG,IAFJH,EAEIG,WAFmBD,eAAS,WAAT,CAEnBC,EAFMC,SAAsB,IAAb;wBAAnBJ,mBAEI,GAFJA,EAEI;MAF4C7/C,KAAKigD,SAEjD;MAF4DL,OAAM;IAElE,CAFJC,EAAsE,CACpEK,WAAyCH,WAAzCG,EAAaD,SAAbC,EAAsB;MAAG9oD,OAAO2oD;IAAV,CAAtBG,EAAgC,MAAhCA,EAAgC,IAAhCA,CADoE,CAAtEL;GAEIG,CAFJH,MA5CwB,GAiDxBe,YAsBmBS,eAtBnBT,EAsBmBS;IArBhB/rD,MAAMyqD,gBAAW7oD,IAAX,CAAgB+Z,UAqBNowC;IApBhBC,KAAG,EAAIvB,gBAAW7oD,IAAX,CAAgB+Z,UAoBPowC;IAnBjB7mD,KAAI,GAmBa6mD;IAlBjBzB,OAAM;EAkBWyB,CAtBnBT,EAIQ;qBAGJ,MAAiC,mBADnCf,mBAeSG,QAfTH,EAeSG,IAfTH,EAeSG,WAdSD,qBAcTC,EAdAtnC,KAAyB,IAApB;0BADd2nC,YAeSkB,iBAfTlB,EAeS;QAbNriD,IAAI0a,MAAM1a,EAaJ;QAZNgC,KAAK0Y,MAAM1a,EAYL;QAXN0a,KAWM;QAVNza,KAAK8hD,oBAAeniD,KAAf,CAAqB8a,MAAM1a,EAA3B;MAUC,CAfTqiD,EAKmCc;QAAA14B;MAAA,IAGjBs3B;cAAsB,eAAtB;QAAsB1jB,YAAe2kB,SACnD,IAD4D,CAC5Dd,WAAgDH,WAAhDG,EAAgD,eAAhDA,EAAgDe,kCAAbD,SAAa,EAAhDd,EAA4C,MAA5CA,EAA4C,IAA5CA,CAD4D,CAAxB;MAAtB,UAHiB,EAOjBH;cAA2B,qBAA3B;QAA2B1jB,YAAqB2kB,SAC9D,IADuE,CACvEd,WAAsDH,WAAtDG,EAAsD,qBAAtDA,EAAsDe,kCAAbD,SAAa,EAAtDd,EAAkD,MAAlDA,EAAkD,IAAlDA,CADuE,CAA9B;MAA3B,UAPiB,EALnCG;KAeSL,CAfTH,MACmC,GAH7B;;EAAA,CAJRe,qBAjDwB,oBAyExBf,mBAEIG,QAFJH,EAEIG,IAFJH,EAEIG,WAFmBD,eAAS,OAAT,CAEnBC,EAFMC,SAAsB,IAAb;wBAAnBJ,mBAEI,GAFJA,EAEI;MAFwC7/C,KAAKigD,SAE7C;MAFwDL,OAAM;IAE9D,CAFJC,EAAkE,CAChEK,WAAyCH,WAAzCG,EAAaD,SAAbC,EAAsB;MAAG9oD,OAAO2oD;IAAV,CAAtBG,EAAgC,MAAhCA,EAAgC,IAAhCA,CADgE,CAAlEL;GAEIG,CAFJH,MAzEwB,GA6ETE,kCAAfM,YAA+BmB,kBAA/BnB,EAA+B;IAAArgD;EAAA,CAA/BqgD,CAAe,IAAgBI,4BA7EP,oBA+ExBZ,mBAEIG,QAFJH,EAEIG,IAFJH,EAEIG,WAFmBD,eAAS,OAAT,CAEnBC,EAFMC,SAAsB,IAAb;wBAAnBJ,mBAEI,GAFJA,EAEI;MAFwC7/C,KAAKigD,SAE7C;MAFwDL,OAAM;IAE9D,CAFJC,EAAkE,CAChEK,WAAyCH,WAAzCG,EAAaD,SAAbC,EAAsB;MAAG9oD,OAAO2oD;IAAV,CAAtBG,EAAgC,MAAhCA,EAAgC,IAAhCA,CADgE,CAAlEL;GAEIG,CAFJH,MA/EwB,EAJ1Ba,IApCQ,EA8HAX,kCADRM,YAIEoB,0BAJFpB,EAIE;UAAA;IAFClhD,KAAK4gD,iBAEN;IADCntC,QAAQmtC,gBAAWnyC,IAAX,CAAgBoB,SAAhB,CAA0B7P;EACnC,CAJFkhD,EAGqC,IAHrCA,EAGqC,CAHrCA,EAGqC,iBAHrCA,CACQ,IAE6BI,4BAhI7B,CANVZ,IAyII,EA1INA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;UCsDI3nD,IAAIiwB,IAAI,CAAJ;UACJ9vB,IAAI8vB,IAAI,CAAJ;UACJsrB,aAA8CtrB,IAAI,QAAJ;UAC9CgqB,mBAA4DhqB,IAAI,SAAJ;UAC5DnM,SAAQmM,IAAI,CAAJ;gBAEF,MAAM;YACVpvB,IAAI0L,MAAMjG,IAAN,CAAWuH;YACfmZ,IAAIza,MAAMjG,IAAN,CAAWtI;;UACjBuO,MAAMi9C,KAAN,KAAgB,UAAU;YACxB3oD,EAAEwpB,KAAF,CAAQrqB,CAAR,IAAagnB,EAAEqD,KAAF,CAAQrqB,GAAG;qBACfhD,QAAQ6D,EAAEwpB,KAAF,CAAQlqB,CAAR,GAAY6mB,EAAEqD,KAAF,CAAQlqB,CAApB,GAAwB,OAAxB,GAAkC;QAAA,OAChD;qBACMnD,QAAQ6D,EAAEwpB,KAAF,CAAQrqB,CAAR,GAAYgnB,EAAEqD,KAAF,CAAQrqB,CAApB,GAAwB,OAAxB,GAAkC;QAAA;;YAEnDuM,MAAMk9C,aAAN,KAAwB,SAAS;YACjCzsD,QAAQ6D,EAAEwpB,KAAF,CAAQrqB;YAChBhD,QAAQ6D,EAAEwpB,KAAF,CAAQlqB;2BACDnD,QAAQ;QAAA,WAChBuP,MAAMk9C,aAAN,KAAwB,OADR,EACiB;YACxCzsD,QAAQ6D,EAAEypB,KAAF,CAAQtqB;YAChBhD,QAAQ6D,EAAEypB,KAAF,CAAQnqB;2BACDnD,QAAQ;QAAA,CAJA,MAKpB;YAEHA,WAAWqtB,KAAX,CAAiBrqB,CAAjB,GAAqBa,EAAEypB,KAAF,CAAQtqB,CAA7B,IAAkC;YAClChD,WAAWqtB,KAAX,CAAiBlqB,CAAjB,GAAqBU,EAAEypB,KAAF,CAAQnqB,CAA7B,IAAkC;2BACnBnD,QAAQ;QAAA;iBAElBuP,MAAMi9C,KAAN,KAAgB,UAAU;YAC/B3oD,EAAEwpB,KAAF,CAAQrqB,CAAR,IAAagnB,EAAEqD,KAAF,CAAQrqB,GAAG;qBACfhD,QAAQ6D,EAAEwpB,KAAF,CAAQlqB,CAAR,GAAY6mB,EAAEqD,KAAF,CAAQlqB,CAApB,GAAwB,OAAxB,GAAkC;QAAA,OAChD;qBACMnD,QAAQ6D,EAAEwpB,KAAF,CAAQrqB,CAAR,GAAYgnB,EAAEqD,KAAF,CAAQrqB,CAApB,GAAwB,OAAxB,GAAkC;QAAA;;YAEnDuM,MAAMk9C,aAAN,KAAwB,SAAS;YACjCzsD,QAAQgqB,EAAEqD,KAAF,CAAQrqB;YAChBhD,QAAQgqB,EAAEqD,KAAF,CAAQlqB;2BACDnD,QAAQ;QAAA,WAChBuP,MAAMk9C,aAAN,KAAwB,OADR,EACiB;YACxCzsD,QAAQgqB,EAAEsD,KAAF,CAAQtqB;YAChBhD,QAAQgqB,EAAEsD,KAAF,CAAQnqB;2BACDnD,QAAQ;QAAA,CAJA,MAKpB;YAEHA,WAAWqtB,KAAX,CAAiBrqB,CAAjB,GAAqBgnB,EAAEsD,KAAF,CAAQtqB,CAA7B,IAAkC;YAClChD,WAAWqtB,KAAX,CAAiBlqB,CAAjB,GAAqB6mB,EAAEsD,KAAF,CAAQnqB,CAA7B,IAAkC;2BACnBnD,QAAQ;QAAA;aAEtB;mBAEMA,QAAQ;;YACfuP,MAAMk9C,aAAN,KAAwB,SAAS;YACjCzsD,WAAWqtB,KAAX,CAAiBrqB,CAAjB,GAAqBgnB,EAAEqD,KAAF,CAAQrqB,CAA7B,IAAkC;YAClChD,WAAWqtB,KAAX,CAAiBlqB,CAAjB,GAAqB6mB,EAAEqD,KAAF,CAAQlqB,CAA7B,IAAkC;2BACnBnD,QAAQ;QAAA,WAChBuP,MAAMk9C,aAAN,KAAwB,OADR,EACiB;YACxCzsD,WAAWstB,KAAX,CAAiBtqB,CAAjB,GAAqBgnB,EAAEsD,KAAF,CAAQtqB,CAA7B,IAAkC;YAClChD,WAAWstB,KAAX,CAAiBnqB,CAAjB,GAAqB6mB,EAAEsD,KAAF,CAAQnqB,CAA7B,IAAkC;2BACnBnD,QAAQ;QAAA,CAJA,MAKpB;YAEHA,WAAWqtB,KAAX,CAAiBrqB,CAAjB,GAAqBgnB,EAAEsD,KAAF,CAAQtqB,CAA7B,IAAkC;YAClChD,WAAWqtB,KAAX,CAAiBlqB,CAAjB,GAAqB6mB,EAAEsD,KAAF,CAAQnqB,CAA7B,IAAkC;2BACnBnD,QAAQ;QAAA;;;UAGzB0sD,SAASnkC,WAAWqD,aAAX,CAAyB/nB,EAAEwpB,KAA3B,EAAkCrD,EAAEqD,KAApC,EAA2ChsB,CAA3C,CAA6C2mB,WAA7C;;UACT0kC,SAAS,GAAT,IAAgBA,UAAU,IAAI;iBACvBA,SAAS;;YACdA,SAAS,KAAK;oBACN;QAAA;;;aAGR1sD,QAAQ0sD;IACf;UAIKC,gBAAgBl7B,SAAS,MAAM;UAC/BwrB,iBAAiBj9C,KAAjB,KAA2B,SAA3B,IAAwC,CAACuP,MAAMmO,MAAN,CAAavC,YAAY;eAC7DqV,iCACFjhB,MAAMmO,MADJ;UAELvC,YAAY;YACV3B,SAAS,IADC;YAEVI,OAAO,SAFG;YAGV6B,SAAS;cACP4hC,UAAU,CADH;cAEPC,YAAY;YAFL,CAHC;YAOV5iC,cAAc;UAPJ;QAFP;aAYF;eACEnL,MAAMmO;MAAA;IAEhB,CAjBqB;WAmBT;MAAE1a,CAAF;MAAKG,CAAL;MAAQo7C,UAAR;MAAoBtB,gBAApB;MAAsC31B,aAAtC;MAA6CqlC;IAA7C;;;;;;;;;;;;;;;;;;;;;;;;;ACrJb,MAAMC,eAAe,EAArB;;MAMaC,mBAAmBvkD,aAAa;EAC3C8H,YAAoB4vB,UAAgC,EAApD,EAAwD;;;;;EAI9C92B,gBAAgBwB,UAAhB,EAA2C3B,GAA3C,EAA0D;UAC5DwQ,OAAO,KAAKymB,OAAL,CAAazmB,IAAb,IAAqBqzC;eACvB5sD,MAAMgD,IAAIF,KAAK0pB,KAAL,CAAWzjB,IAAI/F,CAAJ,GAAQuW,IAAnB,IAA2BA;eACrCvZ,MAAMmD,IAAIL,KAAK0pB,KAAL,CAAWzjB,IAAI5F,CAAJ,GAAQoW,IAAnB,IAA2BA;EAAA;;AARP;;MCJvCuzC,UAAiD,UAAUC,GAAV,EAAoB;SAClEvrD,QAAQukD,YAAYrmC,QAAQ,CAAC,CAACstC,aAAD,EAAgBC,SAAhB,CAAD,KAAgC;QAC7DA,UAAUD,eAAeC;EAC9B;AACH","names":["LayerPositions","value","isReactive","reactive","val","name","Error","containersKey","Symbol","containers","nonNull","inject","container","svg","viewport","svgPanZoom","Config","target","Function","Object","values","filter","v","length","fromEntries","entries","map","k","NodeLabelDirection","callback","self2","assign","configs","node","style","scale","shape","normal","type","width","radius","height","nodePos","nodeSize","targetNodePos","targetNodeSize","distanceX","Math","abs","x","collisionX","distanceY","y","collisionY","dasharray","result","split","parseInt","isNaN","join","array","reduce","s","n","freeGlobal","global","freeSelf","self","root","reWhitespace","string","index","test","charAt","reTrimStart","slice","trimmedEndIndex","replace","objectProto","prototype","hasOwnProperty","nativeObjectToString","toString","symToStringTag","toStringTag","isOwn","call","tag","unmasked","e","nullTag","undefinedTag","getRawTag","objectToString","symbolTag","isObjectLike","baseGetTag","NAN","reIsBadHex","reIsBinary","reIsOctal","freeParseInt","isSymbol","isObject","other","valueOf","baseTrim","isBinary","INFINITY","MAX_INTEGER","toNumber","sign","toFinite","remainder","iteratee","length2","Array","isArray","symbolProto","symbolToString","arrayMap","baseToString","nativeIsFinite","isFinite","nativeMin","min","methodName","func","number","precision","toInteger","pair","round","createRound","NEW_NODE_POSITION_MARGIN","SimpleLayout","activate","parameters","nodePositions","nodes","emitter","onDrag","positions","id","pos","layout","getOrCreateNodePosition","setNodePosition","setNewNodePositions","nodeIds","newNodes","area","svgPanZoom2","getViewArea","nodeId","getNodeSize","candidate","__spreadValues","center","collision","targetNode","areNodesCollision","box","right","keys","stopNodeWatch","watch","on","onDeactivate","off","deactivate","nodeLayout","toRef","__data__","size","key","eq","arrayProto","splice","data","assocIndexOf","lastIndex","pop","push","clear","entry","set","ListCache","listCacheClear","listCacheDelete","get","listCacheGet","has","listCacheHas","listCacheSet","asyncTag","funcTag","genTag","proxyTag","coreJsData","maskSrcKey","uid","exec","IE_PROTO","funcProto","funcToString","reRegExpChar","reIsHostCtor","reIsNative","RegExp","isMasked","pattern","isFunction","toSource","object","getValue","baseIsNative","Map","getNative","nativeCreate","HASH_UNDEFINED","Hash","hashClear","hashDelete","hashGet","hashHas","hashSet","isKeyable","getMapData","MapCache","mapCacheClear","mapCacheDelete","mapCacheGet","mapCacheHas","mapCacheSet","LARGE_ARRAY_SIZE","pairs","Stack","stackClear","stackDelete","stackGet","stackHas","stackSet","defineProperty","baseAssignValue","fromRight","keysFunc","iterable","props","baseFor","createBaseFor","freeExports","exports","nodeType","freeModule","module","moduleExports","Buffer","allocUnsafe","buffer","isDeep","constructor","copy","Uint8Array2","Uint8Array","arrayBuffer","byteLength","typedArray","cloneArrayBuffer","byteOffset","source","objectCreate","create","baseCreate","proto","transform","arg","getPrototype","overArg","getPrototypeOf","Ctor","isPrototype","argsTag","propertyIsEnumerable","isArguments","baseIsArguments","arguments","MAX_SAFE_INTEGER","isLength","isArrayLike","nativeIsBuffer","isBuffer","stubFalse","objectTag","objectCtorString","arrayTag","boolTag","dateTag","errorTag","mapTag","numberTag","regexpTag","setTag","stringTag","weakMapTag","arrayBufferTag","dataViewTag","float32Tag","float64Tag","int8Tag","int16Tag","int32Tag","uint8Tag","uint8ClampedTag","uint16Tag","uint32Tag","typedArrayTags","freeProcess","process","nodeUtil","types","require","binding","nodeIsTypedArray","isTypedArray","baseUnary","baseIsTypedArray","objValue","customizer","isNew","newValue","assignValue","reIsUint","inherited","isArr","isArg","isBuff","isType","skipIndexes","baseTimes","String","isIndex","nativeKeysIn","isProto","arrayLikeKeys","baseKeysIn","copyObject","keysIn","srcIndex","mergeFunc","stack","safeGet","srcValue","stacked","assignMergeValue","isCommon","isTyped","isArrayLikeObject","copyArray","cloneBuffer","cloneTypedArray","isPlainObject","toPlainObject","initCloneObject","baseMergeDeep","baseMerge","thisArg","args","apply","nativeMax","max","start","otherArgs","baseSetToString","identity","constant","HOT_COUNT","HOT_SPAN","nativeNow","Date","now","count","lastCalled","stamp","remaining","setToString","shortOut","overRest","assigner","baseRest","sources","guard","isIterateeCall","merge","createAssigner","view","scalingObjects","panEnabled","zoomEnabled","minZoomLevel","maxZoomLevel","doubleClickZoomEnabled","mouseWheelZoomEnabled","boxSelectionEnabled","autoPanAndZoomOnLoad","autoPanOnResize","layoutHandler","onSvgPanZoomInitialized","grid","visible","interval","thickIncrements","line","color","thick","selection","strokeWidth","strokeColor","strokeDasharray","detector","event","detect","navigator","userAgent","metaKey","ctrlKey","withSelf","borderRadius","hover","selected","draggable","selectable","label","fontFamily","fontSize","lineHeight","background","margin","direction","SOUTH","text","focusring","padding","zOrder","enabled","zIndex","bringToFrontOnHover","bringToFrontOnSelected","transition","edge","linecap","animate","animationSpeed","w","gap","marker","units","summarize","_edges","summarized","stroke","keepOrder","path","clickable","hoverable","curveInNode","end","p","list","hash","edges","a","b","charCodeAt","linejoin","config","getConfigDefaults","injectionKey","results","styleKeys","immediate","deep","injectConfig","nextId","add","SetCache","setCacheAdd","setCacheHas","predicate","cache","COMPARE_PARTIAL_FLAG","COMPARE_UNORDERED_FLAG","bitmask","equalFunc","isPartial","arrLength","othLength","arrStacked","othStacked","seen","arrValue","othValue","compared","arraySome","othValue2","othIndex","cacheHas","forEach","symbolValueOf","message","convert","mapToArray","setToArray","equalArrays","offset","symbolsFunc","arrayPush","resIndex","nativeGetSymbols","getOwnPropertySymbols","getSymbols","stubArray","arrayFilter","symbol","nativeKeys","baseKeys","baseGetAllKeys","objProps","getAllKeys","objLength","othProps","objStacked","skipCtor","objCtor","othCtor","DataView","Promise","Set","WeakMap","promiseTag","dataViewCtorString","mapCtorString","promiseCtorString","setCtorString","weakMapCtorString","getTag","ArrayBuffer","resolve","ctorString","objIsArr","othIsArr","objTag","othTag","objIsObj","othIsObj","isSameTag","equalByTag","objIsWrapped","othIsWrapped","objUnwrapped","othUnwrapped","equalObjects","baseIsEqualDeep","baseIsEqual","obj","from","keys2","isEqual","delete","state","Reactive","edgeLayoutPoints","edgeGroups","summarizedEdges","calculateEdgeGroupAndPositions","groupWidth","edges2","defaultCheckSummarize","id2","isSummarized","p1","p2","calculateEdgePositionInner","pointInGroup","sort","calcGap","_e","_c","edgeLen","edgeId","lineHalfWidths","edge2","warn","points","edgeId2","i","pointInGroup2","edgeCount","minWidth","flatMap","x1","y1","x2","y2","calculateLinePosition","dx","dy","diff","radian","atan2","perpendicular","PI","slope","moveSlope","diffX","sqrt","pow","v1","v2","scalar","lengthSquared","distanceSquared","len","angle2","newX","cos","sin","newY","DEGREES","rad","rad2deg","angle","Vector2D","subtract","multiply","multiplyScalar","divide","dot","cross","distance","normalize","angleDegree","rotate","isEqualTo","clone","toObject","toArray","V","VectorLine","fromObject","toLineVector","sourcePos","targetPos","linePos","sourceMargin","targetMargin","fromLinePosition","applyMarginInner","normalized","sv","tv","check","c1","c2","n1","fromVectors","lp","dot2","near","contains","h","getNearestPoint","hpLen","t","__pow","nearBy","ip1","ip2","d1","d2","line1","line2","t2","center1","radius1","center2","radius2","vC1C2","sumR","subR","isLarge","c","rc","rs","n2","tn1","sn2","result1","result2","rect","centerLine","fromPositions","halfWidth","halfHeight","angleVRad","angleHRad","tan","isCrossedVLine","isCrossedHLine","left","top","bottom","vertexes","floor","centerOfNearestCircle","point","PointUtils.getIntersectionOfLineTargetAndCircle","PointUtils.getNearestPoint","LineUtils.toLineVector","edgeStyle","labelMargin","vMargin","sourceAbove","sourceBelow","targetAbove","targetBelow","above","below","sourceNodePos","sourceNodeShape","targetNodeShape","distance1","calculateDistanceToAvoidOverlapsWithRect","distance2","theta","theta0","control","centerToSource","centerToTarget","calculateRelativeAngleRadian","reverseAngleRadian","middle","moveOnCircumference","centerToMp","mpTangent","LineUtils.calculatePerpendicularLine","theta1","tangent","cp","PointUtils.getIntersectionPointOfLines","mp","tangent2","cp1","cp2","theta2","p3","x3","y3","x12","y12","x32","y32","btoa","replaceAll","markers","referenceCount","markerState","m","isSource","previousId","instanceId","customId","headMarker","toHeadMarker","buildKey","makeMarker","clearMarker","__spreadProps","convertToAscii","d","u","objects","hovered","createState","terminateState","entriesForZOrder","states","idSet","prev","objects2","append","includes","removed","zOrderedList","computed","makeZOrderedList","stateObject","unref","hover1","hover2","selected1","selected2","statesKey","NONE_MARKER","paths","layouts","makerState","summarizedEdgeStates","nodeStates","nodeZOrderedList","useObjectState","nodes2","newState","_state","useId","edgeGroupStates","EdgeGroup.makeEdgeGroupStates","edgeEntries","ref","edgeStates","edgeZOrderedList","_edgeId","stopWatchHandle","createEdgeEntries","_","createSummarizedEdgeStates","pathStates","pathZOrderedList","paths2","item","getNodeStaticShape","getNodeShape","staticShape","labelText","useMarker","origin","labelPosition","position","getEdgeStroke","normalWidth","toEdgeMarker","edgeLayoutPoint","isEdgeSummarized","stopCalcHandle","watchEffect","sourceShape","targetShape","shiftedPosition","EdgeGroup.calculateEdgeShiftedPosition","sourceShapeMargin","targetShapeMargin","v2d.calculateDistancesFromCenterOfNodeToEndOfNode","LineUtils.applyMargin","l","curve","LineUtils.toLinePosition","shift","calculateCurvePositionAndState","stopUpdateMarkerHandle","sourceMarkerId","targetMarkerId","group","z","flat","originPosition","shifted","shiftedCenter","LineUtils.getCenterOfLinePosition","v2d.calculateCircleCenterAndRadiusBy3Points","centerToTop","v2d.calculateRelativeAngleRadian","sourceMoveRad","targetMoveRad","v2d.moveOnCircumference","v2d.reverseAngleRadian","LineUtils.toVectorsFromLinePosition","v2d.calculateBezierCurveControlPoint","circle","groups","MapUtil","MOUSE_MOVE_DETECTION_THRESHOLD","TOUCH_MOVE_DETECTION_THRESHOLD","DOUBLE_CLICK_THRESHOLD","clickStates","pointerId","clickState","idAndState","find","oldPointerId","clickEvent","doubleClickEvent","createClickEvents","now2","lastTime","initDict","window","screenX","screenY","clientX","clientY","shiftKey","altKey","button","buttons","detail","PointerEvent","pressure","tangentialPressure","tiltX","tiltY","twist","pointerType","isPrimary","MouseEvent","modes","hoveredNodes","selectedNodes","zoomLevel","pointers","follow","followedPointerId","nodeBasePositions","hoveredNodesPre","clicks","nodePointerHandlers","pointermove","handleNodePointerMoveEvent","pointerup","handleNodePointerUpEvent","pointercancel","handleNodePointerCancelEvent","pointerState","isFollowed","isSelectedNode","followed","userGrabs","_unwrapNodePosition","dragBasePosition","latestPosition","nodeBasePosition","selectionMode","mode","pageX","pageY","isTrusted","isTouchAnySelectedNode","emit","stopPropagation","moveCounter","threshold","getPointerMoveDetectionThreshold","draggingNodes2","_calculateNodeNewPosition","draggingNodes","isMoved","ev","handler","removeEventListener","viewMode","detectClicks","eventTarget","dispatchEvent","addEventListener","currentTarget","handleNodePointerDownEvent","handleNodePointerOverEvent","handleNodePointerOutEvent","handleNodeClickEvent","handleNodeDoubleClickEvent","handleNodeContextMenu","hoveredEdges","selectedEdges","pointerPeekCount","edgePointerHandlers","handleEdgePointerUpEvent","handleEdgePointerCancelEvent","_makeEdgeEventObject","pointerState2","isTouchAnySelectedEdge","every","selectableEdges","some","handleEdgePointerDownEvent","handleEdgePointerOverEvent","handleEdgePointerOutEvent","handleEdgeClickEvent","handleEdgeDoubleClickEvent","handleEdgeContextMenu","handleEdgesPointerDownEvent","handleEdgesPointerOverEvent","handleEdgesPointerOutEvent","handleEdgesClickEvent","handleEdgesDoubleClickEvent","handleEdgesContextMenu","isSvgWheelZoomEnabled","pointerCounter","containerPointerHandlers","handleContainerPointerMoveEvent","handleContainerPointerUpEvent","passive","preventDefault","handleContainerPointerDownEvent","handleContainerClickEvent","handleContainerDoubleClickEvent","handleContainerContextMenuEvent","old","hoveredPaths","selectedPaths","isInCompatibilityModeForPath","pathPointerHandlers","handlePathPointerUpEvent","handlePathPointerCancelEvent","_makePathEventObject","isTouchAnySelectedPath","handlePathPointerDownEvent","handlePathPointerOverEvent","handlePathPointerOutEvent","handlePathClickEvent","handlePathDoubleClickEvent","handlePathContextMenu","nativeCeil","ceil","baseSlice","FUNC_ERROR_TEXT","wait","options","lastArgs","lastThis","maxWait","timerId","lastCallTime","lastInvokeTime","leading","maxing","trailing","TypeError","time","setTimeout","timerExpired","invokeFunc","timeSinceLastCall","timeSinceLastInvoke","timeWaiting","shouldInvoke","trailingEdge","remainingWait","clearTimeout","isInvoking","leadingEdge","debounced","cancel","flush","coordinates","createSVGPoint","svgPoint","matrixTransform","getCTM","inverse","domPoint","isBoxSelectionEnabled","isBoxSelectionMode","selectionBox","startPoint","selectedNodesAtSelectStarted","selectionType","stopTrigger","selectionTypeWithShiftKey","updateNodesSelection","debounce","pointerEventHandler","PointerEventRegistrar","handlePointerDownEvent","handlePointerUpEvent","handlePointerMoveEvent","handleClickEvent","handleKeyDownEvent","offsetX","offsetY","getBoundingClientRect","pos1","pos2","pointerArray","first","last","keyEventRegistrar","KeyEventRegistrar","stop","withShiftKey","register","unregister","querySelector","startBoxSelection","stopBoxSelection","translateFromDomToSvgCoordinates","enclosedNodes","temporary","_container","_handlePointerDownEvent","_handlePointerUpEvent","_handlePointerMoveEvent","_handleClickEvent","_handleKeyDownEvent","_ignoreEvent","capture","handleKeyUpEvent","_handleKeyUpEvent","_preventDefault","mouseEventHandlersKey","provides","makeNodeInteractionHandlers","makeEdgeInteractionHandlers","makePathInteractionHandlers","makeBoxSelectionMethods","all","indexOf","eventEmitterKey","mitt","utilities","getGlobalThis","globalThis","extend","prop","isElement","o","HTMLElement","SVGElement","SVGSVGElement","nodeName","isNumber","parseFloat","getSvg","elementOrSelector","element","document","tagName","toLowerCase","contentDocument","documentElement","getSVGDocument","proxy","fn","context","getType","mouseAndTouchNormalize","evt","touches","originalEvent","touchNormalize","touch","isDblClick","prevEvt","timeStampDiff","timeStamp","touchesDistance","getTime","throttle","that","timeout","previous","later","createRequestAnimationFrame","refreshRate","requestAnimationFrame","requestTimeout","calculateDistance","point1","point2","Utils","require$$0","uniwheel","prefix","_addEventListener","_removeEventListener","support","fns","passiveTrueOption","passiveFalseOption","createElement","onmousewheel","srcElement","deltaMode","deltaX","delatZ","returnValue","getSupport","deltaY","wheelDelta","wheelDeltaX","elem","eventName","isPassiveListener","cb","createCallback","getCallback","removeCallback","_addWheelListener","_removeWheelListener","addWheelListener","removeWheelListener","_browser","documentMode","svgUtilities","svgNS","xmlNS","xmlnsNS","xlinkNS","evNS","getBoundingClientRectNormalized","clientWidth","clientHeight","getOrCreateViewport","selector","childNodes","children","el","getAttribute","viewportId","toISOString","createElementNS","setAttribute","svgChildren","appendChild","classNames","setupSvgAttributes","setAttributeNS","parentNode","internetExplorerRedisplayInterval","refreshDefsGlobal","allDefs","querySelectorAll","allDefsCount","thisDefs","insertBefore","this","setCTM","matrix","defs","f","getEventPoint","getTouchPoint","getSvgCenterPoint","SvgUtils","controlIcons","enable","instance","styleEl","textContent","zoomGroup","_createZoomIn","_createZoomReset","_createZoomOut","zoomIn","getPublicInstance","zoomInBackground","zoomInShape","resetPanZoomControl","reset","resetPanZoomControlBackground","resetPanZoomControlShape1","resetPanZoomControlShape2","zoomOut","zoomOutBackground","zoomOutShape","disable","removeChild","require$$1","ShadowViewport","init","originalState","zoom","activeState","updateCTMCached","updateCTM","viewBox","cacheViewBox","newCTM","processCTM","svgViewBox","viewBoxValues","updateCTMOnNextFrame","removeAttribute","simpleViewBoxCache","bBox","getBBox","getViewBox","fit","contain","newScale","getOriginalState","getState","getZoom","getRelativeZoom","computeRelativeZoom","getPan","safeCTM","createSVGMatrix","willZoom","isZoomDifferent","willPan","isPanDifferent","beforeZoom","updateCache","onZoom","preventPan","beforePan","preventPanX","preventPanY","onPan","pendingUpdate","ctm","onUpdatedCTM","shadowViewport","Wheel","ControlIcons","require$$2","require$$3","require$$4","SvgPanZoom","optionsDefaults","viewportSelector","controlIconsEnabled","dblClickZoomEnabled","preventMouseEventsDefault","zoomScaleSensitivity","minZoom","maxZoom","customEventsHandler","eventsListenerElement","passiveListenerTrueOption","passiveListenerFalseOption","boundingClientRectNormalized","oldScale","oldPoint","newPoint","publicInstance","setBeforeZoom","setOnZoom","setBeforePan","setOnPan","setOnUpdatedCTM","lastMouseWheelEventTime","setupHandlers","eventListeners","pointerdown","handleMouseDown","touchstart","handleTouchStart","handleMouseUp","touchend","handleTouchEnd","handleMouseMove","touchmove","handleTouchMove","pointerleave","touchleave","touchcancel","svgElement","haltEventListeners","enableMouseWheelZoom","wheelListener","handleMouseWheel","disableMouseWheelZoom","delta","timeDelta","divider","log","inversedScreenCTM","getScreenCTM","relativeMousePoint","zoomAtPoint","zoomScale","zoomAbsolute","oldCTM","relativePoint","modifier","translate","absolute","publicZoom","computeFromRelativeZoom","publicZoomAtPoint","resetZoom","resetPan","pan","handleDblClick","targetClass","zoomFactor","firstEventCTM","stateOrigin","viewportCTM","touch1","touch2","firstDistance","firstZoomLevel","relativeTouchPoint","updateBBox","panBy","resize","disableControlIcons","enableControlIcons","destroy","instancesStore","pi","enablePan","disablePan","isPanEnabled","enableZoom","disableZoom","isZoomEnabled","isControlIconsEnabled","enableDblClickZoom","disableDblClickZoom","isDblClickZoomEnabled","isMouseWheelZoomEnabled","setZoomScaleSensitivity","setMinZoom","setMaxZoom","zoomBy","zoomAtPointBy","getSizes","realZoom","svgPanZoom_1","methods","fitToContents","sizes","setViewBox","sizeWidth","sizeHeight","ratio","currentRatio","newWidth","newHeight","absoluteZoom","getRealZoom","relativeZoom","originalZoom","applyAbsoluteZoomLevel","_isPanEnabled","_internalEnablePan","_internalDisablePan","_isZoomEnabled","_internalEnableZoom","_internalDisableZoom","setPanEnabled","setZoomEnabled","_internalIsPanEnabled","_internalIsZoomEnabled","userInit","userDestroy","mountedCallbacks","unmountedCallbacks","instanceMounted","instanceUnmounted","initialize","onSvgPanZoomMounted","onSvgPanZoomUnmounted","zoomLevelKey","viewStyle","then","transitionOption","duration","timingFunction","__async","promise","isPromise","transitionWhile","input","nextId2","idStore","containKeys","prop2","update","filtered","sourceObject","bound","useZoomLevel","baseX","baseY","applyScaleToDasharray","element2","transform2","bbox","observer2","MutationObserver","observe","attributes","attributeFilter","attrs","useAttrs","texts","topDeltaY","dominantBaseline","backgroundRectPos","paddingVertical","paddingHorizontal","vertical","horizontal","lineMargin","observer","updateObserver","enableMutationObserver","disconnect","sfc","__vccOpts","useNodeConfig","useMouseOperation","labelVisibility","CENTER","labelShiftV","labelShiftH","labelDiagonalShiftV","labelDiagonalShiftH","diagonalMargin","textAnchor","NORTH","EAST","NORTH_EAST","SOUTH_EAST","WEST","NORTH_WEST","SOUTH_WEST","labelX","labelY","shapeConfig","shapeStyle","_a","_b","speed","getDasharrayUnit","pathD","useEdgeConfig","useStates","centerPos","edgeIds","labelConfig","strokeConfig","useContainers","edgeConfig","getTotalLength","getPointAtLength","individualEdgeGroups","individual","nodeShape","labelAreaPosition","v2d.calculateEdgeLabelArea","groupLabelAreaPosition","representativeEdgeState","updateAttributes","bgLayer","vpLayer","attr","records","r","attributeName","Boolean","useEventEmitter","useViewConfig","basePoint","thickVerticals","thickHorizontals","normalVerticals","normalHorizontals","thickH","thickV","normalH","normalV","gi","maxWidth","maxHeight","inc","normalDasharray","thickDasharray","thickAttrs","normalAttrs","EPSILON","Number","nodeLayouts","pathEndType","directions","_detectDirectionsOfPathEdges","edgePos","_getEdgeLine","isMarginOverRunStart","isMarginOverRunEnd","firstEdge","nodeRadius","_getNodeRadius","nextPoint","_calculateEdgeOfNode","next","crossPoint","_getIntersectionOfLines","nodeCoreRadius","prevCoreIp","_getIntersectionOfLineAndNode","nextCoreIp","prevNodeIp","nextNodeIp","findFirstNonNull","lastPoints","lastPoint","lastEdge","unshift","lastNode","isForward","edge0","edge1","moveRad","PointUtils.getIntersectionOfCircles","PointUtils.getIntersectionOfLineTargetAndCircle2","prevSlope","_getSlope","nextSlope","isParallel","nodeCenter","targetSide","LineUtils.inverseLine","pathConfig","usePathConfig","move","calcPathPoints","calculatePathPoints","arrowPoints","angleStroke","anglePoints","arrow","VMarkerHeadArrow","VMarkerHeadAngle","VMarkerHeadCircle","refX","SYSTEM_SLOTS","_sfc_main","defineComponent","components","VNode","VNodeFocusRing","VEdgeGroups","VEdgeBackgrounds","VEdgeLabels","VBackgroundViewport","VBackgroundGrid","VPaths","VMarkerHead","VSelectionBox","default","layers","eventHandlers","emits","setup","slots","nodesRef","edgesRef","pathsRef","useTranslatePathsToObject","provideEventEmitter","provideConfigs","layerDefs","definedSlots","accum","isShowGrid","isShowBackgroundViewport","hasOverrideNodeSlot","hasOverrideNodeLabelSlot","hasEdgeOverlaySlot","hasEdgeLabelSlot","hasEdgesLabelSlot","show","bindProp","useSvgPanZoom","isDoubleClickZoomEnabled","rectSize","resizeObserver","ResizeObserver","stopEventPropagation","absoluteZoomLevel","provideZoomLevel","initialZoomLevel","updateBorderBox","panToCenter","currentSelectedNodes","bindPropKeySet","currentSelectedEdges","currentSelectedPaths","currentLayouts","visibleNodeFocusRing","makeMarkerState","dragging","provideStates","makeStateInput","readonly","provideMouseOperation","visiblePaths","activateParams","newHandler","oldHandler","useTransitionWhile","transitionStyles","svg2","autoPanAndZoom","nodesEmpty","allConfigs","panTo","translateFromSvgToDomCoordinates","getAsSvg","cloneNode","outerHTML","enableDblClick","enableMouseWheel","class","_createElementBlock","_normalizeClass","_ctx","_Fragment","layerName","_renderSlot","openBlock","_hoisted_2","_createBlock","_component_v_marker_head","_component_v_background_viewport","_component_v_background_grid","createCommentVNode","_createElementVNode","_normalizeStyle","_createVNode","_component_v_edge_backgrounds","_component_v_edge_groups","_withCtx","slotProps","normalizeProps","_component_v_edge_labels","createSlots","_component_v_node_focus_ring","_TransitionGroup","css","_component_v_node","_component_v_paths","_component_v_selection_box","align","verticalAlign","degree","updatedConfig","DEFAULT_GRID","GridLayout","install","app","componentName","component"],"sources":["../src/common/types.ts","../src/common/common.ts","../src/composables/container.ts","../src/common/configs.ts","../src/utils/visual.ts","../node_modules/lodash-es/_freeGlobal.js","../node_modules/lodash-es/_root.js","../node_modules/lodash-es/_trimmedEndIndex.js","../node_modules/lodash-es/_baseTrim.js","../node_modules/lodash-es/isObject.js","../node_modules/lodash-es/_Symbol.js","../node_modules/lodash-es/_getRawTag.js","../node_modules/lodash-es/_objectToString.js","../node_modules/lodash-es/_baseGetTag.js","../node_modules/lodash-es/isObjectLike.js","../node_modules/lodash-es/isSymbol.js","../node_modules/lodash-es/toNumber.js","../node_modules/lodash-es/toFinite.js","../node_modules/lodash-es/toInteger.js","../node_modules/lodash-es/_arrayMap.js","../node_modules/lodash-es/isArray.js","../node_modules/lodash-es/_baseToString.js","../node_modules/lodash-es/toString.js","../node_modules/lodash-es/_createRound.js","../node_modules/lodash-es/round.js","../src/layouts/simple.ts","../node_modules/lodash-es/_listCacheClear.js","../node_modules/lodash-es/eq.js","../node_modules/lodash-es/_assocIndexOf.js","../node_modules/lodash-es/_listCacheDelete.js","../node_modules/lodash-es/_listCacheGet.js","../node_modules/lodash-es/_listCacheHas.js","../node_modules/lodash-es/_listCacheSet.js","../node_modules/lodash-es/_ListCache.js","../node_modules/lodash-es/_stackClear.js","../node_modules/lodash-es/_stackDelete.js","../node_modules/lodash-es/_stackGet.js","../node_modules/lodash-es/_stackHas.js","../node_modules/lodash-es/isFunction.js","../node_modules/lodash-es/_coreJsData.js","../node_modules/lodash-es/_isMasked.js","../node_modules/lodash-es/_toSource.js","../node_modules/lodash-es/_baseIsNative.js","../node_modules/lodash-es/_getValue.js","../node_modules/lodash-es/_getNative.js","../node_modules/lodash-es/_Map.js","../node_modules/lodash-es/_nativeCreate.js","../node_modules/lodash-es/_hashClear.js","../node_modules/lodash-es/_hashDelete.js","../node_modules/lodash-es/_hashGet.js","../node_modules/lodash-es/_hashHas.js","../node_modules/lodash-es/_hashSet.js","../node_modules/lodash-es/_Hash.js","../node_modules/lodash-es/_mapCacheClear.js","../node_modules/lodash-es/_isKeyable.js","../node_modules/lodash-es/_getMapData.js","../node_modules/lodash-es/_mapCacheDelete.js","../node_modules/lodash-es/_mapCacheGet.js","../node_modules/lodash-es/_mapCacheHas.js","../node_modules/lodash-es/_mapCacheSet.js","../node_modules/lodash-es/_MapCache.js","../node_modules/lodash-es/_stackSet.js","../node_modules/lodash-es/_Stack.js","../node_modules/lodash-es/_defineProperty.js","../node_modules/lodash-es/_baseAssignValue.js","../node_modules/lodash-es/_assignMergeValue.js","../node_modules/lodash-es/_createBaseFor.js","../node_modules/lodash-es/_baseFor.js","../node_modules/lodash-es/_cloneBuffer.js","../node_modules/lodash-es/_Uint8Array.js","../node_modules/lodash-es/_cloneArrayBuffer.js","../node_modules/lodash-es/_cloneTypedArray.js","../node_modules/lodash-es/_copyArray.js","../node_modules/lodash-es/_baseCreate.js","../node_modules/lodash-es/_overArg.js","../node_modules/lodash-es/_getPrototype.js","../node_modules/lodash-es/_isPrototype.js","../node_modules/lodash-es/_initCloneObject.js","../node_modules/lodash-es/_baseIsArguments.js","../node_modules/lodash-es/isArguments.js","../node_modules/lodash-es/isLength.js","../node_modules/lodash-es/isArrayLike.js","../node_modules/lodash-es/isArrayLikeObject.js","../node_modules/lodash-es/stubFalse.js","../node_modules/lodash-es/isBuffer.js","../node_modules/lodash-es/isPlainObject.js","../node_modules/lodash-es/_baseIsTypedArray.js","../node_modules/lodash-es/_baseUnary.js","../node_modules/lodash-es/_nodeUtil.js","../node_modules/lodash-es/isTypedArray.js","../node_modules/lodash-es/_safeGet.js","../node_modules/lodash-es/_assignValue.js","../node_modules/lodash-es/_copyObject.js","../node_modules/lodash-es/_baseTimes.js","../node_modules/lodash-es/_isIndex.js","../node_modules/lodash-es/_arrayLikeKeys.js","../node_modules/lodash-es/_nativeKeysIn.js","../node_modules/lodash-es/_baseKeysIn.js","../node_modules/lodash-es/keysIn.js","../node_modules/lodash-es/toPlainObject.js","../node_modules/lodash-es/_baseMergeDeep.js","../node_modules/lodash-es/_baseMerge.js","../node_modules/lodash-es/identity.js","../node_modules/lodash-es/_apply.js","../node_modules/lodash-es/_overRest.js","../node_modules/lodash-es/constant.js","../node_modules/lodash-es/_baseSetToString.js","../node_modules/lodash-es/_shortOut.js","../node_modules/lodash-es/_setToString.js","../node_modules/lodash-es/_baseRest.js","../node_modules/lodash-es/_isIterateeCall.js","../node_modules/lodash-es/_createAssigner.js","../node_modules/lodash-es/merge.js","../src/common/config-defaults.ts","../src/composables/config.ts","../src/composables/id.ts","../node_modules/lodash-es/_setCacheAdd.js","../node_modules/lodash-es/_setCacheHas.js","../node_modules/lodash-es/_SetCache.js","../node_modules/lodash-es/_arraySome.js","../node_modules/lodash-es/_cacheHas.js","../node_modules/lodash-es/_equalArrays.js","../node_modules/lodash-es/_mapToArray.js","../node_modules/lodash-es/_setToArray.js","../node_modules/lodash-es/_equalByTag.js","../node_modules/lodash-es/_arrayPush.js","../node_modules/lodash-es/_baseGetAllKeys.js","../node_modules/lodash-es/_arrayFilter.js","../node_modules/lodash-es/stubArray.js","../node_modules/lodash-es/_getSymbols.js","../node_modules/lodash-es/_nativeKeys.js","../node_modules/lodash-es/_baseKeys.js","../node_modules/lodash-es/keys.js","../node_modules/lodash-es/_getAllKeys.js","../node_modules/lodash-es/_equalObjects.js","../node_modules/lodash-es/_DataView.js","../node_modules/lodash-es/_Promise.js","../node_modules/lodash-es/_Set.js","../node_modules/lodash-es/_WeakMap.js","../node_modules/lodash-es/_getTag.js","../node_modules/lodash-es/_baseIsEqualDeep.js","../node_modules/lodash-es/_baseIsEqual.js","../node_modules/lodash-es/isEqual.js","../src/utils/object.ts","../src/modules/edge/group.ts","../src/modules/vector2d/methods.ts","../src/modules/vector2d/vector2d.ts","../src/modules/vector2d/index.ts","../src/modules/calculation/line.ts","../src/modules/calculation/point.ts","../src/modules/calculation/2d.ts","../src/utils/string.ts","../src/composables/marker.ts","../src/composables/objectState.ts","../src/composables/state.ts","../src/utils/map.ts","../src/composables/mouse/core.ts","../src/composables/mouse/node.ts","../src/composables/mouse/edge.ts","../src/composables/mouse/container.ts","../src/composables/mouse/path.ts","../node_modules/lodash-es/_baseSlice.js","../node_modules/lodash-es/chunk.js","../node_modules/lodash-es/now.js","../node_modules/lodash-es/debounce.js","../src/utils/svg.ts","../src/composables/mouse/boxSelection.ts","../src/composables/mouse/index.ts","../node_modules/mitt/dist/mitt.mjs","../src/composables/event-emitter.ts","../node_modules/@dash14/svg-pan-zoom/src/utilities.js","../node_modules/@dash14/svg-pan-zoom/src/uniwheel.js","../node_modules/@dash14/svg-pan-zoom/src/svg-utilities.js","../node_modules/@dash14/svg-pan-zoom/src/control-icons.js","../node_modules/@dash14/svg-pan-zoom/src/shadow-viewport.js","../node_modules/@dash14/svg-pan-zoom/src/svg-pan-zoom.js","../src/modules/svg-pan-zoom-ex.ts","../src/composables/svg-pan-zoom.ts","../src/composables/zoom.ts","../src/composables/transition.ts","../src/composables/object.ts","../src/utils/props.ts","../src/components/base/VShape.vue","../src/components/base/VLabelText.vue","../plugin-vue:export-helper","../src/components/node/VNode.vue","../src/components/node/VNodeFocusRing.vue","../src/components/base/VLine.vue","../src/components/edge/VEdgeCurved.vue","../src/components/edge/VEdge.vue","../src/components/edge/VEdgeSummarized.vue","../src/components/edge/VEdgeOverlay.vue","../src/components/edge/VEdgeGroups.vue","../src/components/edge/VEdgeBackground.vue","../src/components/edge/VEdgeBackgrounds.vue","../src/components/edge/VEdgeLabels.vue","../src/components/background/VBackgroundViewport.vue","../src/components/background/VBackgroundGrid.vue","../src/utils/collection.ts","../src/modules/calculation/path.ts","../src/components/path/VPathLine.vue","../src/components/path/VPaths.vue","../src/components/marker/VMarkerHeadArrow.vue","../src/components/marker/VMarkerHeadAngle.vue","../src/components/marker/VMarkerHead.vue","../src/components/VNetworkGraph.vue","../src/components/edge/VEdgeLabel.vue","../src/layouts/grid.ts","../src/index.ts"],"sourcesContent":["import { RecursivePartial } from \"./common\"\n\n/* ------------------------------------------ *\n * Core types\n * ------------------------------------------ */\n\nexport interface Position {\n  x: number\n  y: number\n}\n\nexport interface LinePosition {\n  p1: Position\n  p2: Position\n}\n\nexport interface Size {\n  width: number\n  height: number\n}\n\nexport interface Rectangle {\n  pos: Position\n  size: Size\n}\n\n/** An object with a field named id */\nexport interface IdentifiedObject {\n  id: string\n}\n\n/* ------------------------------------------ *\n * Network graph elements\n * ------------------------------------------ */\n\nexport interface Node {\n  name?: string\n  // any properties\n  [x: string]: any\n}\n\nexport type Nodes = Record<string, Node>\nexport type NodeWithId = Node & IdentifiedObject\n\nexport interface Edge {\n  source: string\n  target: string\n  // any properties\n  [x: string]: any\n}\n\nexport type Edges = Record<string, Edge>\nexport type EdgeWithId = Edge & IdentifiedObject\n\nexport type LayerPosition =\n  \"paths\"\n  | \"nodes\"\n  | \"focusring\"\n  | \"edges\"\n  | \"base\"\n  | \"grid\"\n  | \"background\"\n  | \"root\"\nexport const LayerPositions: readonly LayerPosition[] = [\n  \"paths\",\n  \"nodes\",\n  \"focusring\",\n  \"edges\",\n  \"base\",\n  \"grid\",\n  \"background\",\n  \"root\",\n]\nexport type Layers = Record<string, LayerPosition>\n\n/* ------------------------------------------ *\n * View\n * ------------------------------------------ */\n\nexport type ViewMode = \"default\" | \"node\" | \"edge\" | \"path\" | \"box-selection\"\n\n/* ------------------------------------------ *\n * Layouts\n * ------------------------------------------ */\n\nexport interface FixablePosition extends Position {\n  fixed?: boolean\n}\n\nexport type NodePositions = Record<string, FixablePosition>\n\nexport interface Layouts {\n  nodes: NodePositions\n}\n/**  optionalinterface */\nexport type UserLayouts = RecursivePartial<Layouts>\n\n/* ------------------------------------------ *\n * Edge labels\n * ------------------------------------------ */\n\nexport interface EdgePosition {\n  source: Position\n  target: Position\n}\n\nexport interface EdgeLabelArea {\n  source: {\n    above: Position\n    below: Position\n  }\n  target: {\n    above: Position\n    below: Position\n  }\n}\n\n/* ------------------------------------------ *\n * Paths\n * ------------------------------------------ */\n\nexport interface Path {\n  id?: string\n  edges: string[]\n  // any properties\n  [x: string]: any\n}\n\nexport type Paths = Record<string, Path>\n\n// When specified in a list, the ID is not needed for a while to\n// keep compatibility.\n// TODO: After a while, remove `| Path[]`.\nexport type InputPaths = Record<string, Path> | Path[]\n\n// line: point | curve: [control-point, control-point, target-point] | move to next point: null\nexport type PositionOrCurve = Position | Position[] | null\n\n/* ------------------------------------------ *\n * Events\n * ------------------------------------------ */\n\nexport type ViewEvent<T extends Event> = { event: T }\nexport type NodeEvent<T extends Event> = { node: string; event: T }\nexport type EdgeEvent<T extends Event> = { edge: string; edges: string[], summarized: false; event: T } | { edge?: undefined, edges: string[]; summarized: true; event: T }\nexport type PathEvent<T extends Event> = { path: string, event: T }\n\n// For compatibility with previous versions\nexport type NodePointerEvent = NodeEvent<PointerEvent>\nexport type EdgePointerEvent = EdgeEvent<PointerEvent>\n\nexport type Events = {\n  \"view:load\": undefined\n  \"view:unload\": undefined\n  \"view:mode\": ViewMode\n  \"view:zoom\": number\n  \"view:pan\": { x: number; y: number }\n  \"view:fit\": undefined\n  \"view:resize\": { x: number; y: number; width: number; height: number }\n  \"view:click\": ViewEvent<MouseEvent>\n  \"view:dblclick\": ViewEvent<MouseEvent>\n  \"view:contextmenu\": ViewEvent<MouseEvent>\n  \"node:click\": NodeEvent<MouseEvent>\n  \"node:dblclick\": NodeEvent<MouseEvent>\n  \"node:pointerover\": NodeEvent<PointerEvent>\n  \"node:pointerout\": NodeEvent<PointerEvent>\n  \"node:pointerup\": NodeEvent<PointerEvent>\n  \"node:pointerdown\": NodeEvent<PointerEvent>\n  \"node:contextmenu\": NodeEvent<MouseEvent>\n  \"node:dragstart\": { [name: string]: Position }\n  \"node:pointermove\": { [name: string]: Position }\n  \"node:dragend\": { [name: string]: Position }\n  \"node:select\": string[]\n  \"edge:pointerup\": EdgeEvent<PointerEvent>\n  \"edge:pointerdown\": EdgeEvent<PointerEvent>\n  \"edge:click\": EdgeEvent<MouseEvent>\n  \"edge:dblclick\": EdgeEvent<MouseEvent>\n  \"edge:pointerover\": EdgeEvent<PointerEvent>\n  \"edge:pointerout\": EdgeEvent<PointerEvent>\n  \"edge:contextmenu\": EdgeEvent<MouseEvent>\n  \"edge:select\": string[]\n  \"path:select\": string[]\n  \"path:pointerup\": PathEvent<PointerEvent>\n  \"path:pointerdown\": PathEvent<PointerEvent>\n  \"path:click\": PathEvent<MouseEvent>\n  \"path:dblclick\": PathEvent<MouseEvent>\n  \"path:pointerover\": PathEvent<PointerEvent>\n  \"path:pointerout\": PathEvent<PointerEvent>\n  \"path:contextmenu\": PathEvent<MouseEvent>\n}\n\nexport type EventHandlers = {\n  \"*\"?: <T extends keyof Events>(type: T, event: Events[T]) => void\n} & {\n  [K in keyof Events]?: (event: Events[K]) => void\n}\n\nexport type OnClickHandler = (param: NodeEvent<MouseEvent>) => void\nexport type OnDragHandler = (param: { [name: string]: Position }) => void\n\n/* ------------------------------------------ *\n * SVG area\n * ------------------------------------------ */\n\nexport interface Point {\n  x: number\n  y: number\n}\n\nexport interface Sizes {\n  width: number\n  height: number\n  viewBox: {\n    x: number\n    y: number\n    width: number\n    height: number\n  }\n}\n","import { isReactive, reactive } from \"vue\"\n\n/* ------------------------------------------ *\n * Utility\n * ------------------------------------------ */\n\nexport type RecursivePartial<T> = {\n  [P in keyof T]?: T[P] extends (infer U)[]\n    ? RecursivePartial<U>[]\n    : T[P] extends (infer U)[] | undefined\n    ? RecursivePartial<U>[]\n    : // eslint-disable-next-line @typescript-eslint/ban-types\n    T[P] extends object\n    ? RecursivePartial<T[P]>\n    : // eslint-disable-next-line @typescript-eslint/ban-types\n    T[P] extends object | undefined\n    ? RecursivePartial<T[P]>\n    : T[P]\n}\n\ndeclare class Id<T extends string> {\n  private IDENTITY: T\n}\n\nexport type Reactive<T> = Id<\"Reactive\"> & T\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function Reactive<T extends object>(value: T): Reactive<T> {\n  if (isReactive(value)) {\n    return value as Reactive<T>\n  } else {\n    return reactive(value) as Reactive<T>\n  }\n}\n\nexport interface ReadonlyRef<T> {\n  readonly value: T\n}\n\nexport function nonNull<T>(val?: T | null, name = \"Parameter\"): T {\n  if (val === undefined || val === null) {\n    throw new Error(`${name} is null`)\n  }\n  return val\n}\n","import { provide, inject, InjectionKey, Ref } from \"vue\"\nimport { SvgPanZoomInstance } from \"@/modules/svg-pan-zoom-ex\"\nimport { nonNull } from \"@/common/common\"\n\ninterface ProvideContainers {\n  container: Ref<HTMLDivElement>\n  svg: Ref<SVGElement>\n  viewport: Ref<SVGGElement>\n  svgPanZoom: Ref<SvgPanZoomInstance | undefined>\n}\n\ninterface Containers {\n  container: Ref<HTMLDivElement | undefined>\n  svg: Ref<SVGElement | undefined>\n  viewport: Ref<SVGGElement | undefined>\n  svgPanZoom: Ref<SvgPanZoomInstance | undefined>\n}\n\nconst containersKey = Symbol(\"containers\") as InjectionKey<Containers>\n\nexport function provideContainers(containers: Containers): void {\n  provide(containersKey, containers)\n}\n\nexport function useContainers(): ProvideContainers {\n  const containers = nonNull(inject(containersKey), \"containers\")\n  return {\n    container: containers.container as Ref<HTMLDivElement>,\n    svg: containers.svg as Ref<SVGElement>,\n    viewport: containers.viewport as Ref<SVGGElement>,\n    svgPanZoom: containers.svgPanZoom\n  }\n}\n","import { SvgPanZoomInstance } from \"@/modules/svg-pan-zoom-ex\"\nimport { LayoutHandler } from \"../layouts/handler\"\nimport { RecursivePartial } from \"./common\"\nimport { Node, Edge, Edges, Path } from \"./types\"\n\ntype CallableValue<V, T> = V | ((target: T) => V)\n\ntype CallableValues<V, T> = {\n  [K in keyof V]: CallableValue<V[K], T>\n}\n\nexport class Config {\n  static value<V, T>(value: CallableValue<V, T>, target: T): V {\n    return value instanceof Function ? value(target) : value\n  }\n\n  static values<V, T>(value: CallableValues<V, T>, target: T): V {\n    if (Object.values(value).filter(v => v instanceof Function).length === 0) {\n      return value as V // all config are literals\n    }\n    return Object.fromEntries(\n      Object.entries(value).map(([k, v]) => [k, v instanceof Function ? v(target) : v])\n    ) as V\n  }\n}\n\n/* View configuration */\n\nexport interface GridLine {\n  color: string\n  width: number\n  dasharray?: string | number\n}\n\nexport interface GridConfig {\n  visible: boolean\n  interval: number\n  thickIncrements: number | false\n  line: GridLine\n  thick: GridLine\n}\n\nexport interface BasicShapeStyle {\n  strokeWidth: number\n  strokeColor?: string\n  strokeDasharray?: string | number\n  color: string\n}\n\nexport interface ViewConfig {\n  scalingObjects: boolean\n  panEnabled: boolean\n  zoomEnabled: boolean\n  minZoomLevel: number\n  maxZoomLevel: number\n  doubleClickZoomEnabled: boolean\n  mouseWheelZoomEnabled: boolean\n  boxSelectionEnabled: boolean\n  fit?: boolean // Deprecated\n  autoPanAndZoomOnLoad: false | \"center-zero\" | \"center-content\" | \"fit-content\"\n  autoPanOnResize: boolean\n  layoutHandler: LayoutHandler\n  onSvgPanZoomInitialized?: (instance: SvgPanZoomInstance) => void\n  grid: GridConfig\n  selection: {\n    box: BasicShapeStyle\n    detector: (event: KeyboardEvent) => boolean\n  }\n}\n\n/* Shape style */\n\nexport interface ShapeStyleBase extends BasicShapeStyle {}\n\nexport type ShapeType = \"circle\" | \"rect\"\n\ninterface CircleShape extends ShapeStyleBase {\n  radius: number\n}\n\ninterface RectangleShape extends ShapeStyleBase {\n  width: number\n  height: number\n  borderRadius: number\n}\n\n// `Shape` is an object whose fields can change depending on\n// the type value.\n// Normally, Union Types would be used, but in order to minimize\n// the use of type guards when users build and use the configuration,\n// we define it as an object that contains all fields.\n\ntype ShapeBase<T extends ShapeType = ShapeType> = {\n  type: T\n}\n\nexport type ShapeStyle = ShapeBase & CircleShape & RectangleShape\nexport type CircleShapeStyle = ShapeBase<\"circle\"> & CircleShape\nexport type RectangleShapeStyle = ShapeBase<\"rect\"> & RectangleShape\nexport type AnyShapeStyle = CircleShapeStyle | RectangleShapeStyle\n\n/* Label style */\n\ninterface Padding {\n  vertical: number\n  horizontal: number\n}\nexport interface LabelBackgroundStyle {\n  visible: boolean\n  color?: string\n  padding?: number | Padding\n  borderRadius?: number\n}\n\nexport interface LabelStyle {\n  fontFamily?: string\n  fontSize: number\n  color: string\n  background?: LabelBackgroundStyle\n  lineHeight: number\n}\n\n/* Z-Order config */\n\nexport interface ZOrderConfig<T> {\n  enabled: boolean\n  zIndex: CallableValue<number, T>\n  bringToFrontOnHover: boolean\n  bringToFrontOnSelected: boolean\n}\n\n/* Object common config */\n\nexport interface ObjectConfigs<O> {\n  selectable: CallableValue<boolean, O> | number\n  zOrder: ZOrderConfig<O>\n}\n\n/* Node style */\n\nexport enum NodeLabelDirection {\n  CENTER = \"center\",\n  NORTH = \"north\",\n  NORTH_EAST = \"north-east\",\n  EAST = \"east\",\n  SOUTH_EAST = \"south-east\",\n  SOUTH = \"south\",\n  SOUTH_WEST = \"south-west\",\n  WEST = \"west\",\n  NORTH_WEST = \"north-west\",\n}\n\nexport type NodeLabelDirectionType = \"center\" | \"north\" | \"north-east\" | \"east\" | \"south-east\" | \"south\" | \"south-west\" | \"west\" | \"north-west\"\n\nexport interface NodeLabelStyle extends LabelStyle {\n  visible: boolean\n  margin: number\n  direction: NodeLabelDirectionType\n  text: string\n}\n\nexport interface NodeFocusRingStyle {\n  visible: boolean\n  width: number\n  padding: number\n  color: string\n  dasharray?: string | number\n}\n\nexport interface NodeConfig<N extends Node = Node> {\n  normal: CallableValues<ShapeStyle, N>\n  hover?: CallableValues<ShapeStyle, N>\n  selected?: CallableValues<ShapeStyle, N>\n  draggable: CallableValue<boolean, N>\n  selectable: CallableValue<boolean, N> | number\n  label: CallableValues<NodeLabelStyle, N>\n  focusring: NodeFocusRingStyle\n  zOrder: ZOrderConfig<N>\n  transition?: string\n}\n\n/* Edge style */\n\nexport interface StrokeStyle {\n  width: number\n  color: string\n  dasharray?: string | number\n  linecap?: \"butt\" | \"round\" | \"square\"\n  animate: boolean\n  animationSpeed: number\n}\n\nexport interface EdgeLabelStyle extends LabelStyle {\n  margin: number\n  padding: number\n}\n\nexport type EdgeHeadType = \"none\" | \"arrow\" | \"angle\" | \"circle\" | \"custom\"\nexport type MarkerUnits = \"strokeWidth\" | \"userSpaceOnUse\"\n\nexport interface MarkerStyle {\n  type: EdgeHeadType\n  width: number\n  height: number\n  margin: number\n  units: MarkerUnits\n  color: string | null\n  customId?: string\n}\n\nexport type EdgeType = \"straight\" | \"curve\"\n\n// Orientation to be considered when keeping multiple edge alignments.\n//   \"clock\": Keep the forward/backward when viewed as a clock.\n//   \"vertical\": Keep the vertical alignment.\n//   \"horizontal\": Keep the horizontal alignment.\nexport type EdgeKeepOrderType = \"clock\" | \"vertical\" | \"horizontal\"\n\nexport interface EdgeConfig<E extends Edge = Edge> {\n  normal: CallableValues<StrokeStyle, E>\n  hover?: CallableValues<StrokeStyle, E>\n  selected: CallableValues<StrokeStyle, E>\n  selectable: CallableValue<boolean, E> | number\n  gap: number | ((edges: Edges, configs: Configs) => number)\n  type: EdgeType\n  marker: {\n    source: CallableValues<MarkerStyle, [E, StrokeStyle]>\n    target: CallableValues<MarkerStyle, [E, StrokeStyle]>\n  }\n  margin: number | null\n  summarize: boolean | ((edges: Edges, configs: Configs) => boolean | null)\n  summarized: {\n    label: CallableValues<LabelStyle, Record<string, E>>\n    shape: CallableValues<ShapeStyle, Record<string, E>>\n    stroke: CallableValues<StrokeStyle, Record<string, E>>\n  }\n  keepOrder: EdgeKeepOrderType\n  label: EdgeLabelStyle\n  zOrder: ZOrderConfig<E>\n}\n\n/* Path config */\nexport interface PathStrokeStyle extends StrokeStyle {\n  linejoin: \"miter\" | \"round\" | \"bevel\"\n}\n\nexport type PathEndType = \"centerOfNode\" | \"edgeOfNode\"\n\nexport interface PathConfig<P extends Path = Path> {\n  visible: boolean\n  clickable: CallableValue<boolean, P>\n  hoverable: CallableValue<boolean, P>\n  curveInNode: boolean\n  end: PathEndType\n  margin: CallableValue<number, P>\n\n  // @Deprecated\n  path: CallableValues<PathStrokeStyle, P>\n\n  normal: CallableValues<PathStrokeStyle, P>\n  hover?: CallableValues<PathStrokeStyle, P>\n  selected: CallableValues<PathStrokeStyle, P>\n\n  selectable: CallableValue<boolean, P> | number\n  zOrder: ZOrderConfig<P>\n  transition?: string\n}\n\n/* Configuration */\n\nexport interface Configs<N extends Node = Node, E extends Edge = Edge, P extends Path = Path> {\n  view: ViewConfig\n  node: NodeConfig<N>\n  edge: EdgeConfig<E>\n  path: PathConfig<P>\n}\n\n/** For specification by the user */\nexport type UserConfigs<\n  N extends Node = Node,\n  E extends Edge = Edge,\n  P extends Path = Path\n> = RecursivePartial<Configs<N, E, P>>\n\n/** Make a config with self object */\nexport function withSelf<T extends { [name: string]: any }>(callback: (self: T) => T): T {\n  const self = {} as T\n  return Object.assign(self, callback(self))\n}\n\n/** @deprecated */\nexport function configsWithType<\n  N extends Node = Node,\n  E extends Edge = Edge,\n  P extends Path = Path,\n  U extends UserConfigs<N, E, P> = UserConfigs<N, E, P>\n>(configs: U): U & UserConfigs<N, E, P> {\n  return configs\n}\n\n/** Define configurations */\nexport function defineConfigs<\n  N extends Node = Node,\n  E extends Edge = Edge,\n  P extends Path = Path,\n  U extends UserConfigs<N, E, P> = UserConfigs<N, E, P>\n>(configs: U): U & UserConfigs<N, E, P> {\n  return configs\n}\n","import { Node, Position, Size } from \"@/common/types\"\nimport { Config, NodeConfig } from \"@/common/configs\"\n\nexport function getNodeSize(node: Node, style: NodeConfig, scale: number): Size {\n  const shape = Config.values(style.normal, node)\n  if (shape.type == \"circle\") {\n    return {\n      width: shape.radius * 2 * scale,\n      height: shape.radius * 2 * scale,\n    }\n  } else {\n    return {\n      width: shape.width * scale,\n      height: shape.height * scale,\n    }\n  }\n}\n\nexport function areNodesCollision(\n  nodePos: Position,\n  nodeSize: Size,\n  targetNodePos: Position,\n  targetNodeSize: Size\n): boolean {\n  // x\n  const distanceX = Math.abs(nodePos.x - targetNodePos.x)\n  const collisionX = distanceX < nodeSize.width / 2 + targetNodeSize.width / 2\n\n  // y\n  const distanceY = Math.abs(nodePos.y - targetNodePos.y)\n  const collisionY = distanceY < nodeSize.height / 2 + targetNodeSize.height / 2\n  return collisionX && collisionY\n}\n\nexport function applyScaleToDasharray(dasharray: number | string | undefined, scale: number) {\n  let result: number | string = 0\n  if (scale === 1 || dasharray === undefined || dasharray === \"none\") {\n    result = dasharray ?? 0\n  } else if (typeof dasharray === \"string\") {\n    result = dasharray\n      .split(/\\s+/)\n      .map(v => parseInt(v) * scale)\n      .filter(v => !isNaN(v))\n      .join(\" \")\n  } else {\n    result = dasharray * scale\n  }\n  return result && result !== \"0\" ? result : undefined\n}\n\nexport function getDasharrayUnit(dasharray: number | string | undefined) {\n  let result: number | string = 0\n  if (dasharray === undefined || dasharray === \"none\") {\n    result = 0\n  } else if (typeof dasharray === \"string\") {\n    const array = dasharray\n      .split(/\\s+/)\n      .map(v => parseInt(v))\n      .filter(v => !isNaN(v))\n    if (array.length % 2 === 0) {\n      // ex: 1 2 -> -  -  -  - ...\n      result = array.reduce((s, n) => s + n, 0)\n    } else {\n      // ex: 1 2 3 -> -  --- --   -  --- ...\n      result = array.reduce((s, n) => s + n, 0) * 2\n    }\n  } else {\n    result = dasharray * 2 // 2 <- border and space\n  }\n  return result\n}\n","/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nexport default freeGlobal;\n","import freeGlobal from './_freeGlobal.js';\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nexport default root;\n","/** Used to match a single whitespace character. */\nvar reWhitespace = /\\s/;\n\n/**\n * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace\n * character of `string`.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {number} Returns the index of the last non-whitespace character.\n */\nfunction trimmedEndIndex(string) {\n  var index = string.length;\n\n  while (index-- && reWhitespace.test(string.charAt(index))) {}\n  return index;\n}\n\nexport default trimmedEndIndex;\n","import trimmedEndIndex from './_trimmedEndIndex.js';\n\n/** Used to match leading whitespace. */\nvar reTrimStart = /^\\s+/;\n\n/**\n * The base implementation of `_.trim`.\n *\n * @private\n * @param {string} string The string to trim.\n * @returns {string} Returns the trimmed string.\n */\nfunction baseTrim(string) {\n  return string\n    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')\n    : string;\n}\n\nexport default baseTrim;\n","/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nexport default isObject;\n","import root from './_root.js';\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nexport default Symbol;\n","import Symbol from './_Symbol.js';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nexport default getRawTag;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nexport default objectToString;\n","import Symbol from './_Symbol.js';\nimport getRawTag from './_getRawTag.js';\nimport objectToString from './_objectToString.js';\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nexport default baseGetTag;\n","/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nexport default isObjectLike;\n","import baseGetTag from './_baseGetTag.js';\nimport isObjectLike from './isObjectLike.js';\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\nexport default isSymbol;\n","import baseTrim from './_baseTrim.js';\nimport isObject from './isObject.js';\nimport isSymbol from './isSymbol.js';\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = baseTrim(value);\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nexport default toNumber;\n","import toNumber from './toNumber.js';\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0,\n    MAX_INTEGER = 1.7976931348623157e+308;\n\n/**\n * Converts `value` to a finite number.\n *\n * @static\n * @memberOf _\n * @since 4.12.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted number.\n * @example\n *\n * _.toFinite(3.2);\n * // => 3.2\n *\n * _.toFinite(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toFinite(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toFinite('3.2');\n * // => 3.2\n */\nfunction toFinite(value) {\n  if (!value) {\n    return value === 0 ? value : 0;\n  }\n  value = toNumber(value);\n  if (value === INFINITY || value === -INFINITY) {\n    var sign = (value < 0 ? -1 : 1);\n    return sign * MAX_INTEGER;\n  }\n  return value === value ? value : 0;\n}\n\nexport default toFinite;\n","import toFinite from './toFinite.js';\n\n/**\n * Converts `value` to an integer.\n *\n * **Note:** This method is loosely based on\n * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted integer.\n * @example\n *\n * _.toInteger(3.2);\n * // => 3\n *\n * _.toInteger(Number.MIN_VALUE);\n * // => 0\n *\n * _.toInteger(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toInteger('3.2');\n * // => 3\n */\nfunction toInteger(value) {\n  var result = toFinite(value),\n      remainder = result % 1;\n\n  return result === result ? (remainder ? result - remainder : result) : 0;\n}\n\nexport default toInteger;\n","/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\nexport default arrayMap;\n","/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\nexport default isArray;\n","import Symbol from './_Symbol.js';\nimport arrayMap from './_arrayMap.js';\nimport isArray from './isArray.js';\nimport isSymbol from './isSymbol.js';\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isArray(value)) {\n    // Recursively convert values (susceptible to call stack limits).\n    return arrayMap(value, baseToString) + '';\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nexport default baseToString;\n","import baseToString from './_baseToString.js';\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\nexport default toString;\n","import root from './_root.js';\nimport toInteger from './toInteger.js';\nimport toNumber from './toNumber.js';\nimport toString from './toString.js';\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeIsFinite = root.isFinite,\n    nativeMin = Math.min;\n\n/**\n * Creates a function like `_.round`.\n *\n * @private\n * @param {string} methodName The name of the `Math` method to use when rounding.\n * @returns {Function} Returns the new round function.\n */\nfunction createRound(methodName) {\n  var func = Math[methodName];\n  return function(number, precision) {\n    number = toNumber(number);\n    precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);\n    if (precision && nativeIsFinite(number)) {\n      // Shift with exponential notation to avoid floating-point issues.\n      // See [MDN](https://mdn.io/round#Examples) for more details.\n      var pair = (toString(number) + 'e').split('e'),\n          value = func(pair[0] + 'e' + (+pair[1] + precision));\n\n      pair = (toString(value) + 'e').split('e');\n      return +(pair[0] + 'e' + (+pair[1] - precision));\n    }\n    return func(number);\n  };\n}\n\nexport default createRound;\n","import createRound from './_createRound.js';\n\n/**\n * Computes `number` rounded to `precision`.\n *\n * @static\n * @memberOf _\n * @since 3.10.0\n * @category Math\n * @param {number} number The number to round.\n * @param {number} [precision=0] The precision to round to.\n * @returns {number} Returns the rounded number.\n * @example\n *\n * _.round(4.006);\n * // => 4\n *\n * _.round(4.006, 2);\n * // => 4.01\n *\n * _.round(4060, -2);\n * // => 4100\n */\nvar round = createRound('round');\n\nexport default round;\n","import { Ref, toRef, watch } from \"vue\"\nimport { NodePositions, OnDragHandler, Position } from \"@/common/types\"\nimport { getNodeSize, areNodesCollision } from \"@/utils/visual\"\nimport { LayoutActivateParameters, LayoutHandler } from \"./handler\"\nimport round from \"lodash-es/round\"\n\nconst NEW_NODE_POSITION_MARGIN = 20\n\nexport class SimpleLayout implements LayoutHandler {\n  private onDeactivate?: () => void\n\n  activate(parameters: LayoutActivateParameters): void {\n    const { nodePositions, nodes, configs, emitter, scale, svgPanZoom } = parameters\n    const onDrag: OnDragHandler = positions => {\n      for (const [id, pos] of Object.entries(positions)) {\n        const layout = this.getOrCreateNodePosition(nodePositions, id)\n        this.setNodePosition(layout, pos)\n      }\n    }\n\n    const setNewNodePositions = (nodeIds: string[]) => {\n      // decide new node's position\n      const newNodes = nodeIds.filter(n => !(n in nodePositions.value))\n      const area = svgPanZoom.getViewArea()\n      const s = scale.value\n      for (const nodeId of newNodes) {\n        const node = nodes.value[nodeId]\n        const nodeSize = getNodeSize(node, configs.node, s)\n        const candidate = { ...area.center }\n        for (;;) {\n          let collision = false\n          for (const [id, pos] of Object.entries(nodePositions.value)) {\n            if (nodeId === id) continue\n            const targetNode = nodes.value[id]\n            if (!targetNode) continue\n            const targetNodeSize = getNodeSize(targetNode, configs.node, s)\n            collision = areNodesCollision(candidate, nodeSize, pos, targetNodeSize)\n            if (collision) {\n              break\n            }\n          }\n          if (collision) {\n            // Slide the width of one node + margin in the horizontal direction.\n            // If it reaches the edge of the display area, it moves downward.\n            candidate.x += nodeSize.width + NEW_NODE_POSITION_MARGIN * s\n            if (candidate.x + nodeSize.width / 2 > area.box.right) {\n              candidate.x = area.center.x\n              candidate.y += nodeSize.height + NEW_NODE_POSITION_MARGIN * s\n            }\n          } else {\n            break\n          }\n        }\n        const layout = this.getOrCreateNodePosition(nodePositions, nodeId)\n        this.setNodePosition(layout, candidate)\n      }\n    }\n\n    setNewNodePositions(Object.keys(nodes.value))\n    const stopNodeWatch = watch(() => Object.keys(nodes.value), setNewNodePositions)\n\n    emitter.on(\"node:dragstart\", onDrag)\n    emitter.on(\"node:pointermove\", onDrag)\n    emitter.on(\"node:dragend\", onDrag)\n\n    this.onDeactivate = () => {\n      stopNodeWatch()\n      emitter.off(\"node:dragstart\", onDrag)\n      emitter.off(\"node:pointermove\", onDrag)\n      emitter.off(\"node:dragend\", onDrag)\n    }\n  }\n\n  deactivate(): void {\n    if (this.onDeactivate) {\n      this.onDeactivate()\n    }\n  }\n\n  protected setNodePosition(nodeLayout: Ref<Position>, pos: Position) {\n    nodeLayout.value.x = round(pos.x, 3)\n    nodeLayout.value.y = round(pos.y, 3)\n  }\n\n  private getOrCreateNodePosition(nodePositions: Ref<NodePositions>, node: string) {\n    const layout = toRef(nodePositions.value, node)\n    if (!layout.value) {\n      layout.value = { x: 0, y: 0 }\n    }\n    return layout\n  }\n}\n","/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\nexport default listCacheClear;\n","/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\nexport default eq;\n","import eq from './eq.js';\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\nexport default assocIndexOf;\n","import assocIndexOf from './_assocIndexOf.js';\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype;\n\n/** Built-in value references. */\nvar splice = arrayProto.splice;\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\nexport default listCacheDelete;\n","import assocIndexOf from './_assocIndexOf.js';\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\nexport default listCacheGet;\n","import assocIndexOf from './_assocIndexOf.js';\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\nexport default listCacheHas;\n","import assocIndexOf from './_assocIndexOf.js';\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\nexport default listCacheSet;\n","import listCacheClear from './_listCacheClear.js';\nimport listCacheDelete from './_listCacheDelete.js';\nimport listCacheGet from './_listCacheGet.js';\nimport listCacheHas from './_listCacheHas.js';\nimport listCacheSet from './_listCacheSet.js';\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\nexport default ListCache;\n","import ListCache from './_ListCache.js';\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n  this.size = 0;\n}\n\nexport default stackClear;\n","/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\nexport default stackDelete;\n","/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\nexport default stackGet;\n","/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\nexport default stackHas;\n","import baseGetTag from './_baseGetTag.js';\nimport isObject from './isObject.js';\n\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    proxyTag = '[object Proxy]';\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\nexport default isFunction;\n","import root from './_root.js';\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\nexport default coreJsData;\n","import coreJsData from './_coreJsData.js';\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\nexport default isMasked;\n","/** Used for built-in method references. */\nvar funcProto = Function.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\nexport default toSource;\n","import isFunction from './isFunction.js';\nimport isMasked from './_isMasked.js';\nimport isObject from './isObject.js';\nimport toSource from './_toSource.js';\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\nexport default baseIsNative;\n","/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\nexport default getValue;\n","import baseIsNative from './_baseIsNative.js';\nimport getValue from './_getValue.js';\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\nexport default getNative;\n","import getNative from './_getNative.js';\nimport root from './_root.js';\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map');\n\nexport default Map;\n","import getNative from './_getNative.js';\n\n/* Built-in method references that are verified to be native. */\nvar nativeCreate = getNative(Object, 'create');\n\nexport default nativeCreate;\n","import nativeCreate from './_nativeCreate.js';\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\nexport default hashClear;\n","/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nexport default hashDelete;\n","import nativeCreate from './_nativeCreate.js';\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\nexport default hashGet;\n","import nativeCreate from './_nativeCreate.js';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\nexport default hashHas;\n","import nativeCreate from './_nativeCreate.js';\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\nexport default hashSet;\n","import hashClear from './_hashClear.js';\nimport hashDelete from './_hashDelete.js';\nimport hashGet from './_hashGet.js';\nimport hashHas from './_hashHas.js';\nimport hashSet from './_hashSet.js';\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\nexport default Hash;\n","import Hash from './_Hash.js';\nimport ListCache from './_ListCache.js';\nimport Map from './_Map.js';\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\nexport default mapCacheClear;\n","/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\nexport default isKeyable;\n","import isKeyable from './_isKeyable.js';\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\nexport default getMapData;\n","import getMapData from './_getMapData.js';\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nexport default mapCacheDelete;\n","import getMapData from './_getMapData.js';\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\nexport default mapCacheGet;\n","import getMapData from './_getMapData.js';\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\nexport default mapCacheHas;\n","import getMapData from './_getMapData.js';\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\nexport default mapCacheSet;\n","import mapCacheClear from './_mapCacheClear.js';\nimport mapCacheDelete from './_mapCacheDelete.js';\nimport mapCacheGet from './_mapCacheGet.js';\nimport mapCacheHas from './_mapCacheHas.js';\nimport mapCacheSet from './_mapCacheSet.js';\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\nexport default MapCache;\n","import ListCache from './_ListCache.js';\nimport Map from './_Map.js';\nimport MapCache from './_MapCache.js';\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\nexport default stackSet;\n","import ListCache from './_ListCache.js';\nimport stackClear from './_stackClear.js';\nimport stackDelete from './_stackDelete.js';\nimport stackGet from './_stackGet.js';\nimport stackHas from './_stackHas.js';\nimport stackSet from './_stackSet.js';\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\nexport default Stack;\n","import getNative from './_getNative.js';\n\nvar defineProperty = (function() {\n  try {\n    var func = getNative(Object, 'defineProperty');\n    func({}, '', {});\n    return func;\n  } catch (e) {}\n}());\n\nexport default defineProperty;\n","import defineProperty from './_defineProperty.js';\n\n/**\n * The base implementation of `assignValue` and `assignMergeValue` without\n * value checks.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction baseAssignValue(object, key, value) {\n  if (key == '__proto__' && defineProperty) {\n    defineProperty(object, key, {\n      'configurable': true,\n      'enumerable': true,\n      'value': value,\n      'writable': true\n    });\n  } else {\n    object[key] = value;\n  }\n}\n\nexport default baseAssignValue;\n","import baseAssignValue from './_baseAssignValue.js';\nimport eq from './eq.js';\n\n/**\n * This function is like `assignValue` except that it doesn't assign\n * `undefined` values.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignMergeValue(object, key, value) {\n  if ((value !== undefined && !eq(object[key], value)) ||\n      (value === undefined && !(key in object))) {\n    baseAssignValue(object, key, value);\n  }\n}\n\nexport default assignMergeValue;\n","/**\n * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseFor(fromRight) {\n  return function(object, iteratee, keysFunc) {\n    var index = -1,\n        iterable = Object(object),\n        props = keysFunc(object),\n        length = props.length;\n\n    while (length--) {\n      var key = props[fromRight ? length : ++index];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object;\n  };\n}\n\nexport default createBaseFor;\n","import createBaseFor from './_createBaseFor.js';\n\n/**\n * The base implementation of `baseForOwn` which iterates over `object`\n * properties returned by `keysFunc` and invokes `iteratee` for each property.\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */\nvar baseFor = createBaseFor();\n\nexport default baseFor;\n","import root from './_root.js';\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;\n\n/**\n * Creates a clone of  `buffer`.\n *\n * @private\n * @param {Buffer} buffer The buffer to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Buffer} Returns the cloned buffer.\n */\nfunction cloneBuffer(buffer, isDeep) {\n  if (isDeep) {\n    return buffer.slice();\n  }\n  var length = buffer.length,\n      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n\n  buffer.copy(result);\n  return result;\n}\n\nexport default cloneBuffer;\n","import root from './_root.js';\n\n/** Built-in value references. */\nvar Uint8Array = root.Uint8Array;\n\nexport default Uint8Array;\n","import Uint8Array from './_Uint8Array.js';\n\n/**\n * Creates a clone of `arrayBuffer`.\n *\n * @private\n * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n * @returns {ArrayBuffer} Returns the cloned array buffer.\n */\nfunction cloneArrayBuffer(arrayBuffer) {\n  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n  new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n  return result;\n}\n\nexport default cloneArrayBuffer;\n","import cloneArrayBuffer from './_cloneArrayBuffer.js';\n\n/**\n * Creates a clone of `typedArray`.\n *\n * @private\n * @param {Object} typedArray The typed array to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned typed array.\n */\nfunction cloneTypedArray(typedArray, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n}\n\nexport default cloneTypedArray;\n","/**\n * Copies the values of `source` to `array`.\n *\n * @private\n * @param {Array} source The array to copy values from.\n * @param {Array} [array=[]] The array to copy values to.\n * @returns {Array} Returns `array`.\n */\nfunction copyArray(source, array) {\n  var index = -1,\n      length = source.length;\n\n  array || (array = Array(length));\n  while (++index < length) {\n    array[index] = source[index];\n  }\n  return array;\n}\n\nexport default copyArray;\n","import isObject from './isObject.js';\n\n/** Built-in value references. */\nvar objectCreate = Object.create;\n\n/**\n * The base implementation of `_.create` without support for assigning\n * properties to the created object.\n *\n * @private\n * @param {Object} proto The object to inherit from.\n * @returns {Object} Returns the new object.\n */\nvar baseCreate = (function() {\n  function object() {}\n  return function(proto) {\n    if (!isObject(proto)) {\n      return {};\n    }\n    if (objectCreate) {\n      return objectCreate(proto);\n    }\n    object.prototype = proto;\n    var result = new object;\n    object.prototype = undefined;\n    return result;\n  };\n}());\n\nexport default baseCreate;\n","/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\nexport default overArg;\n","import overArg from './_overArg.js';\n\n/** Built-in value references. */\nvar getPrototype = overArg(Object.getPrototypeOf, Object);\n\nexport default getPrototype;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\nexport default isPrototype;\n","import baseCreate from './_baseCreate.js';\nimport getPrototype from './_getPrototype.js';\nimport isPrototype from './_isPrototype.js';\n\n/**\n * Initializes an object clone.\n *\n * @private\n * @param {Object} object The object to clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneObject(object) {\n  return (typeof object.constructor == 'function' && !isPrototype(object))\n    ? baseCreate(getPrototype(object))\n    : {};\n}\n\nexport default initCloneObject;\n","import baseGetTag from './_baseGetTag.js';\nimport isObjectLike from './isObjectLike.js';\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]';\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\nexport default baseIsArguments;\n","import baseIsArguments from './_baseIsArguments.js';\nimport isObjectLike from './isObjectLike.js';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\nexport default isArguments;\n","/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\nexport default isLength;\n","import isFunction from './isFunction.js';\nimport isLength from './isLength.js';\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\nexport default isArrayLike;\n","import isArrayLike from './isArrayLike.js';\nimport isObjectLike from './isObjectLike.js';\n\n/**\n * This method is like `_.isArrayLike` except that it also checks if `value`\n * is an object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array-like object,\n *  else `false`.\n * @example\n *\n * _.isArrayLikeObject([1, 2, 3]);\n * // => true\n *\n * _.isArrayLikeObject(document.body.children);\n * // => true\n *\n * _.isArrayLikeObject('abc');\n * // => false\n *\n * _.isArrayLikeObject(_.noop);\n * // => false\n */\nfunction isArrayLikeObject(value) {\n  return isObjectLike(value) && isArrayLike(value);\n}\n\nexport default isArrayLikeObject;\n","/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nexport default stubFalse;\n","import root from './_root.js';\nimport stubFalse from './stubFalse.js';\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\nexport default isBuffer;\n","import baseGetTag from './_baseGetTag.js';\nimport getPrototype from './_getPrototype.js';\nimport isObjectLike from './isObjectLike.js';\n\n/** `Object#toString` result references. */\nvar objectTag = '[object Object]';\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to infer the `Object` constructor. */\nvar objectCtorString = funcToString.call(Object);\n\n/**\n * Checks if `value` is a plain object, that is, an object created by the\n * `Object` constructor or one with a `[[Prototype]]` of `null`.\n *\n * @static\n * @memberOf _\n * @since 0.8.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n * }\n *\n * _.isPlainObject(new Foo);\n * // => false\n *\n * _.isPlainObject([1, 2, 3]);\n * // => false\n *\n * _.isPlainObject({ 'x': 0, 'y': 0 });\n * // => true\n *\n * _.isPlainObject(Object.create(null));\n * // => true\n */\nfunction isPlainObject(value) {\n  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {\n    return false;\n  }\n  var proto = getPrototype(value);\n  if (proto === null) {\n    return true;\n  }\n  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n  return typeof Ctor == 'function' && Ctor instanceof Ctor &&\n    funcToString.call(Ctor) == objectCtorString;\n}\n\nexport default isPlainObject;\n","import baseGetTag from './_baseGetTag.js';\nimport isLength from './isLength.js';\nimport isObjectLike from './isObjectLike.js';\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\nexport default baseIsTypedArray;\n","/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\nexport default baseUnary;\n","import freeGlobal from './_freeGlobal.js';\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    // Use `util.types` for Node.js 10+.\n    var types = freeModule && freeModule.require && freeModule.require('util').types;\n\n    if (types) {\n      return types;\n    }\n\n    // Legacy `process.binding('util')` for Node.js < 10.\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\nexport default nodeUtil;\n","import baseIsTypedArray from './_baseIsTypedArray.js';\nimport baseUnary from './_baseUnary.js';\nimport nodeUtil from './_nodeUtil.js';\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\nexport default isTypedArray;\n","/**\n * Gets the value at `key`, unless `key` is \"__proto__\" or \"constructor\".\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction safeGet(object, key) {\n  if (key === 'constructor' && typeof object[key] === 'function') {\n    return;\n  }\n\n  if (key == '__proto__') {\n    return;\n  }\n\n  return object[key];\n}\n\nexport default safeGet;\n","import baseAssignValue from './_baseAssignValue.js';\nimport eq from './eq.js';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignValue(object, key, value) {\n  var objValue = object[key];\n  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n      (value === undefined && !(key in object))) {\n    baseAssignValue(object, key, value);\n  }\n}\n\nexport default assignValue;\n","import assignValue from './_assignValue.js';\nimport baseAssignValue from './_baseAssignValue.js';\n\n/**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property identifiers to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @param {Function} [customizer] The function to customize copied values.\n * @returns {Object} Returns `object`.\n */\nfunction copyObject(source, props, object, customizer) {\n  var isNew = !object;\n  object || (object = {});\n\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index];\n\n    var newValue = customizer\n      ? customizer(object[key], source[key], key, object, source)\n      : undefined;\n\n    if (newValue === undefined) {\n      newValue = source[key];\n    }\n    if (isNew) {\n      baseAssignValue(object, key, newValue);\n    } else {\n      assignValue(object, key, newValue);\n    }\n  }\n  return object;\n}\n\nexport default copyObject;\n","/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\nexport default baseTimes;\n","/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  var type = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n\n  return !!length &&\n    (type == 'number' ||\n      (type != 'symbol' && reIsUint.test(value))) &&\n        (value > -1 && value % 1 == 0 && value < length);\n}\n\nexport default isIndex;\n","import baseTimes from './_baseTimes.js';\nimport isArguments from './isArguments.js';\nimport isArray from './isArray.js';\nimport isBuffer from './isBuffer.js';\nimport isIndex from './_isIndex.js';\nimport isTypedArray from './isTypedArray.js';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nexport default arrayLikeKeys;\n","/**\n * This function is like\n * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * except that it includes inherited enumerable properties.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction nativeKeysIn(object) {\n  var result = [];\n  if (object != null) {\n    for (var key in Object(object)) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nexport default nativeKeysIn;\n","import isObject from './isObject.js';\nimport isPrototype from './_isPrototype.js';\nimport nativeKeysIn from './_nativeKeysIn.js';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeysIn(object) {\n  if (!isObject(object)) {\n    return nativeKeysIn(object);\n  }\n  var isProto = isPrototype(object),\n      result = [];\n\n  for (var key in object) {\n    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nexport default baseKeysIn;\n","import arrayLikeKeys from './_arrayLikeKeys.js';\nimport baseKeysIn from './_baseKeysIn.js';\nimport isArrayLike from './isArrayLike.js';\n\n/**\n * Creates an array of the own and inherited enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keysIn(new Foo);\n * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n */\nfunction keysIn(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n}\n\nexport default keysIn;\n","import copyObject from './_copyObject.js';\nimport keysIn from './keysIn.js';\n\n/**\n * Converts `value` to a plain object flattening inherited enumerable string\n * keyed properties of `value` to own properties of the plain object.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {Object} Returns the converted plain object.\n * @example\n *\n * function Foo() {\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.assign({ 'a': 1 }, new Foo);\n * // => { 'a': 1, 'b': 2 }\n *\n * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));\n * // => { 'a': 1, 'b': 2, 'c': 3 }\n */\nfunction toPlainObject(value) {\n  return copyObject(value, keysIn(value));\n}\n\nexport default toPlainObject;\n","import assignMergeValue from './_assignMergeValue.js';\nimport cloneBuffer from './_cloneBuffer.js';\nimport cloneTypedArray from './_cloneTypedArray.js';\nimport copyArray from './_copyArray.js';\nimport initCloneObject from './_initCloneObject.js';\nimport isArguments from './isArguments.js';\nimport isArray from './isArray.js';\nimport isArrayLikeObject from './isArrayLikeObject.js';\nimport isBuffer from './isBuffer.js';\nimport isFunction from './isFunction.js';\nimport isObject from './isObject.js';\nimport isPlainObject from './isPlainObject.js';\nimport isTypedArray from './isTypedArray.js';\nimport safeGet from './_safeGet.js';\nimport toPlainObject from './toPlainObject.js';\n\n/**\n * A specialized version of `baseMerge` for arrays and objects which performs\n * deep merges and tracks traversed objects enabling objects with circular\n * references to be merged.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @param {string} key The key of the value to merge.\n * @param {number} srcIndex The index of `source`.\n * @param {Function} mergeFunc The function to merge values.\n * @param {Function} [customizer] The function to customize assigned values.\n * @param {Object} [stack] Tracks traversed source values and their merged\n *  counterparts.\n */\nfunction baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {\n  var objValue = safeGet(object, key),\n      srcValue = safeGet(source, key),\n      stacked = stack.get(srcValue);\n\n  if (stacked) {\n    assignMergeValue(object, key, stacked);\n    return;\n  }\n  var newValue = customizer\n    ? customizer(objValue, srcValue, (key + ''), object, source, stack)\n    : undefined;\n\n  var isCommon = newValue === undefined;\n\n  if (isCommon) {\n    var isArr = isArray(srcValue),\n        isBuff = !isArr && isBuffer(srcValue),\n        isTyped = !isArr && !isBuff && isTypedArray(srcValue);\n\n    newValue = srcValue;\n    if (isArr || isBuff || isTyped) {\n      if (isArray(objValue)) {\n        newValue = objValue;\n      }\n      else if (isArrayLikeObject(objValue)) {\n        newValue = copyArray(objValue);\n      }\n      else if (isBuff) {\n        isCommon = false;\n        newValue = cloneBuffer(srcValue, true);\n      }\n      else if (isTyped) {\n        isCommon = false;\n        newValue = cloneTypedArray(srcValue, true);\n      }\n      else {\n        newValue = [];\n      }\n    }\n    else if (isPlainObject(srcValue) || isArguments(srcValue)) {\n      newValue = objValue;\n      if (isArguments(objValue)) {\n        newValue = toPlainObject(objValue);\n      }\n      else if (!isObject(objValue) || isFunction(objValue)) {\n        newValue = initCloneObject(srcValue);\n      }\n    }\n    else {\n      isCommon = false;\n    }\n  }\n  if (isCommon) {\n    // Recursively merge objects and arrays (susceptible to call stack limits).\n    stack.set(srcValue, newValue);\n    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);\n    stack['delete'](srcValue);\n  }\n  assignMergeValue(object, key, newValue);\n}\n\nexport default baseMergeDeep;\n","import Stack from './_Stack.js';\nimport assignMergeValue from './_assignMergeValue.js';\nimport baseFor from './_baseFor.js';\nimport baseMergeDeep from './_baseMergeDeep.js';\nimport isObject from './isObject.js';\nimport keysIn from './keysIn.js';\nimport safeGet from './_safeGet.js';\n\n/**\n * The base implementation of `_.merge` without support for multiple sources.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @param {number} srcIndex The index of `source`.\n * @param {Function} [customizer] The function to customize merged values.\n * @param {Object} [stack] Tracks traversed source values and their merged\n *  counterparts.\n */\nfunction baseMerge(object, source, srcIndex, customizer, stack) {\n  if (object === source) {\n    return;\n  }\n  baseFor(source, function(srcValue, key) {\n    stack || (stack = new Stack);\n    if (isObject(srcValue)) {\n      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);\n    }\n    else {\n      var newValue = customizer\n        ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)\n        : undefined;\n\n      if (newValue === undefined) {\n        newValue = srcValue;\n      }\n      assignMergeValue(object, key, newValue);\n    }\n  }, keysIn);\n}\n\nexport default baseMerge;\n","/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\nexport default identity;\n","/**\n * A faster alternative to `Function#apply`, this function invokes `func`\n * with the `this` binding of `thisArg` and the arguments of `args`.\n *\n * @private\n * @param {Function} func The function to invoke.\n * @param {*} thisArg The `this` binding of `func`.\n * @param {Array} args The arguments to invoke `func` with.\n * @returns {*} Returns the result of `func`.\n */\nfunction apply(func, thisArg, args) {\n  switch (args.length) {\n    case 0: return func.call(thisArg);\n    case 1: return func.call(thisArg, args[0]);\n    case 2: return func.call(thisArg, args[0], args[1]);\n    case 3: return func.call(thisArg, args[0], args[1], args[2]);\n  }\n  return func.apply(thisArg, args);\n}\n\nexport default apply;\n","import apply from './_apply.js';\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * A specialized version of `baseRest` which transforms the rest array.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @param {Function} transform The rest array transform.\n * @returns {Function} Returns the new function.\n */\nfunction overRest(func, start, transform) {\n  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);\n  return function() {\n    var args = arguments,\n        index = -1,\n        length = nativeMax(args.length - start, 0),\n        array = Array(length);\n\n    while (++index < length) {\n      array[index] = args[start + index];\n    }\n    index = -1;\n    var otherArgs = Array(start + 1);\n    while (++index < start) {\n      otherArgs[index] = args[index];\n    }\n    otherArgs[start] = transform(array);\n    return apply(func, this, otherArgs);\n  };\n}\n\nexport default overRest;\n","/**\n * Creates a function that returns `value`.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {*} value The value to return from the new function.\n * @returns {Function} Returns the new constant function.\n * @example\n *\n * var objects = _.times(2, _.constant({ 'a': 1 }));\n *\n * console.log(objects);\n * // => [{ 'a': 1 }, { 'a': 1 }]\n *\n * console.log(objects[0] === objects[1]);\n * // => true\n */\nfunction constant(value) {\n  return function() {\n    return value;\n  };\n}\n\nexport default constant;\n","import constant from './constant.js';\nimport defineProperty from './_defineProperty.js';\nimport identity from './identity.js';\n\n/**\n * The base implementation of `setToString` without support for hot loop shorting.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */\nvar baseSetToString = !defineProperty ? identity : function(func, string) {\n  return defineProperty(func, 'toString', {\n    'configurable': true,\n    'enumerable': false,\n    'value': constant(string),\n    'writable': true\n  });\n};\n\nexport default baseSetToString;\n","/** Used to detect hot functions by number of calls within a span of milliseconds. */\nvar HOT_COUNT = 800,\n    HOT_SPAN = 16;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeNow = Date.now;\n\n/**\n * Creates a function that'll short out and invoke `identity` instead\n * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`\n * milliseconds.\n *\n * @private\n * @param {Function} func The function to restrict.\n * @returns {Function} Returns the new shortable function.\n */\nfunction shortOut(func) {\n  var count = 0,\n      lastCalled = 0;\n\n  return function() {\n    var stamp = nativeNow(),\n        remaining = HOT_SPAN - (stamp - lastCalled);\n\n    lastCalled = stamp;\n    if (remaining > 0) {\n      if (++count >= HOT_COUNT) {\n        return arguments[0];\n      }\n    } else {\n      count = 0;\n    }\n    return func.apply(undefined, arguments);\n  };\n}\n\nexport default shortOut;\n","import baseSetToString from './_baseSetToString.js';\nimport shortOut from './_shortOut.js';\n\n/**\n * Sets the `toString` method of `func` to return `string`.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */\nvar setToString = shortOut(baseSetToString);\n\nexport default setToString;\n","import identity from './identity.js';\nimport overRest from './_overRest.js';\nimport setToString from './_setToString.js';\n\n/**\n * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @returns {Function} Returns the new function.\n */\nfunction baseRest(func, start) {\n  return setToString(overRest(func, start, identity), func + '');\n}\n\nexport default baseRest;\n","import eq from './eq.js';\nimport isArrayLike from './isArrayLike.js';\nimport isIndex from './_isIndex.js';\nimport isObject from './isObject.js';\n\n/**\n * Checks if the given arguments are from an iteratee call.\n *\n * @private\n * @param {*} value The potential iteratee value argument.\n * @param {*} index The potential iteratee index or key argument.\n * @param {*} object The potential iteratee object argument.\n * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n *  else `false`.\n */\nfunction isIterateeCall(value, index, object) {\n  if (!isObject(object)) {\n    return false;\n  }\n  var type = typeof index;\n  if (type == 'number'\n        ? (isArrayLike(object) && isIndex(index, object.length))\n        : (type == 'string' && index in object)\n      ) {\n    return eq(object[index], value);\n  }\n  return false;\n}\n\nexport default isIterateeCall;\n","import baseRest from './_baseRest.js';\nimport isIterateeCall from './_isIterateeCall.js';\n\n/**\n * Creates a function like `_.assign`.\n *\n * @private\n * @param {Function} assigner The function to assign values.\n * @returns {Function} Returns the new assigner function.\n */\nfunction createAssigner(assigner) {\n  return baseRest(function(object, sources) {\n    var index = -1,\n        length = sources.length,\n        customizer = length > 1 ? sources[length - 1] : undefined,\n        guard = length > 2 ? sources[2] : undefined;\n\n    customizer = (assigner.length > 3 && typeof customizer == 'function')\n      ? (length--, customizer)\n      : undefined;\n\n    if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n      customizer = length < 3 ? undefined : customizer;\n      length = 1;\n    }\n    object = Object(object);\n    while (++index < length) {\n      var source = sources[index];\n      if (source) {\n        assigner(object, source, index, customizer);\n      }\n    }\n    return object;\n  });\n}\n\nexport default createAssigner;\n","import baseMerge from './_baseMerge.js';\nimport createAssigner from './_createAssigner.js';\n\n/**\n * This method is like `_.assign` except that it recursively merges own and\n * inherited enumerable string keyed properties of source objects into the\n * destination object. Source properties that resolve to `undefined` are\n * skipped if a destination value exists. Array and plain object properties\n * are merged recursively. Other objects and value types are overridden by\n * assignment. Source objects are applied from left to right. Subsequent\n * sources overwrite property assignments of previous sources.\n *\n * **Note:** This method mutates `object`.\n *\n * @static\n * @memberOf _\n * @since 0.5.0\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @returns {Object} Returns `object`.\n * @example\n *\n * var object = {\n *   'a': [{ 'b': 2 }, { 'd': 4 }]\n * };\n *\n * var other = {\n *   'a': [{ 'c': 3 }, { 'e': 5 }]\n * };\n *\n * _.merge(object, other);\n * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }\n */\nvar merge = createAssigner(function(object, source, srcIndex) {\n  baseMerge(object, source, srcIndex);\n});\n\nexport default merge;\n","import { reactive } from \"vue\"\nimport { NodeLabelDirection, Configs, withSelf, Config, UserConfigs } from \"./configs\"\nimport { Node, Edge, Path, Edges } from \"./types\"\nimport { SimpleLayout } from \"../layouts/simple\"\nimport merge from \"lodash-es/merge\"\n\n/**\n * Get all default configs.\n * @returns configs\n */\nexport function getConfigDefaults(): Configs {\n  return {\n    view: {\n      scalingObjects: false,\n      panEnabled: true,\n      zoomEnabled: true,\n      minZoomLevel: 0.1,\n      maxZoomLevel: 64,\n      doubleClickZoomEnabled: true,\n      mouseWheelZoomEnabled: true,\n      boxSelectionEnabled: false,\n      autoPanAndZoomOnLoad: \"center-content\",\n      autoPanOnResize: true,\n      layoutHandler: new SimpleLayout(),\n      onSvgPanZoomInitialized: undefined,\n      grid: {\n        visible: false,\n        interval: 10,\n        thickIncrements: 5,\n        line: {\n          color: \"#e0e0e0\",\n          width: 1,\n          dasharray: 1,\n        },\n        thick: {\n          color: \"#cccccc\",\n          width: 1,\n          dasharray: 0,\n        },\n      },\n      selection: {\n        box: {\n          color: \"#0000ff20\",\n          strokeWidth: 1,\n          strokeColor: \"#aaaaff\",\n          strokeDasharray: 0,\n        },\n        detector: (event: KeyboardEvent) => {\n          const detect = /Mac OS/.test(navigator.userAgent) ? event.metaKey : event.ctrlKey\n          return (event.type === \"keydown\") ? detect : !detect\n        }\n      }\n    },\n    node: withSelf(self => ({\n      normal: {\n        type: \"circle\",\n        radius: 16,\n        // for rect -->\n        width: 32,\n        height: 32,\n        borderRadius: 4,\n        // <-- for rect\n        color: \"#4466cc\",\n        strokeWidth: 0,\n        strokeColor: \"#000000\",\n        strokeDasharray: 0,\n      },\n      hover: {\n        type: node => Config.value(self.normal.type, node) as any,\n        radius: node => (Config.value(self.normal.radius, node) ?? 0) + 2,\n        width: node => (Config.value(self.normal.width, node) ?? 0) + 2,\n        height: node => (Config.value(self.normal.height, node) ?? 0) + 2,\n        borderRadius: node => Config.value(self.normal.borderRadius, node) ?? 0,\n        strokeWidth: node => Config.value(self.normal.strokeWidth, node),\n        strokeColor: node => Config.value(self.normal.strokeColor, node),\n        strokeDasharray: node => Config.value(self.normal.strokeDasharray, node),\n        color: \"#3355bb\",\n      },\n      selected: undefined,\n      draggable: true,\n      selectable: false,\n      label: {\n        visible: true,\n        fontFamily: undefined,\n        fontSize: 11,\n        lineHeight: 1.1,\n        color: \"#000000\",\n        background: undefined,\n        // background: {\n        //   visible: true,\n        //   color: \"#ffffff\",\n        //   padding: {\n        //     vertical: 1,\n        //     horizontal: 4,\n        //   },\n        //   borderRadius: 2\n        // },\n        margin: 4,\n        direction: NodeLabelDirection.SOUTH,\n        text: \"name\",\n      },\n      focusring: {\n        visible: true,\n        width: 4,\n        padding: 3,\n        color: \"#eebb00\",\n      },\n      zOrder: {\n        enabled: false,\n        zIndex: 0,\n        bringToFrontOnHover: true,\n        bringToFrontOnSelected: true\n      },\n      transition: undefined\n    })),\n    edge: withSelf(self => ({\n      normal: {\n        width: 2,\n        color: \"#4466cc\",\n        dasharray: 0,\n        linecap: \"butt\",\n        animate: false,\n        animationSpeed: 50,\n      },\n      hover: {\n        width: edge => Config.value(self.normal.width, edge) + 1,\n        color: \"#3355bb\",\n        dasharray: edge => Config.value(self.normal.dasharray, edge),\n        linecap: edge => Config.value(self.normal.linecap, edge),\n        animate: edge => Config.value(self.normal.animate, edge),\n        animationSpeed: edge => Config.value(self.normal.animationSpeed, edge),\n      },\n      selected: {\n        width: edge => Config.value(self.normal.width, edge) + 1,\n        color: \"#dd8800\",\n        dasharray: edge => {\n          const w = Config.value(self.normal.width, edge)\n          return `${w * 1.5} ${w * 2}`\n        },\n        linecap: edge => Config.value(self.normal.linecap, edge),\n        animate: edge => Config.value(self.normal.animate, edge),\n        animationSpeed: edge => Config.value(self.normal.animationSpeed, edge),\n      },\n      selectable: false,\n      gap: 3,\n      type: \"straight\",\n      marker: {\n        source: {\n          type: \"none\",\n          width: 5,\n          height: 5,\n          margin: -1,\n          units: \"strokeWidth\",\n          color: null\n        },\n        target: {\n          type: \"none\",\n          width: 5,\n          height: 5,\n          margin: -1,\n          units: \"strokeWidth\",\n          color: null\n        },\n      },\n      margin: null,\n      summarize: (_edges: Edges, configs: Configs) => {\n        return configs.edge.type == \"curve\" ? false : null\n      },\n      summarized: {\n        label: {\n          fontSize: 10,\n          lineHeight: 1,\n          color: \"#4466cc\",\n        },\n        shape: {\n          type: \"rect\",\n          // for circle -->\n          radius: 6,\n          // <-- for circle\n          width: 12,\n          height: 12,\n          borderRadius: 3,\n          color: \"#ffffff\",\n          strokeWidth: 1,\n          strokeColor: \"#4466cc\",\n          strokeDasharray: undefined,\n        },\n        stroke: {\n          width: 5,\n          color: \"#4466cc\",\n          dasharray: undefined,\n          linecap: undefined,\n          animate: false,\n          animationSpeed: 50,\n        },\n      },\n      keepOrder: \"clock\",\n      label: {\n        fontFamily: undefined,\n        fontSize: 11,\n        lineHeight: 1.1,\n        color: \"#000000\",\n        background: undefined,\n        // background: {\n        //   visible: true,\n        //   color: \"#ffffff\",\n        //   padding: {\n        //     vertical: 1,\n        //     horizontal: 4,\n        //   },\n        //   borderRadius: 2\n        // },\n        margin: 4,\n        padding: 4\n      },\n      zOrder: {\n        enabled: false,\n        zIndex: 0,\n        bringToFrontOnHover: true,\n        bringToFrontOnSelected: true\n      }\n    })),\n    path: withSelf(self => ({\n      visible: false,\n      clickable: false,\n      hoverable: false,\n      curveInNode: false,\n      end: \"centerOfNode\",\n      margin: 0,\n      // @Deprecated\n      path: reactive({\n        width: 6,\n        color: p => {\n          const list = [\n            \"#d5000088\",\n            \"#c5116288\",\n            \"#aa00ff88\",\n            \"#6200ea88\",\n            \"#304ffe88\",\n            \"#2962ff88\",\n            \"#0091ea88\",\n            \"#00b8d488\",\n            \"#00bfa588\",\n            \"#00c85388\",\n            \"#64dd1788\",\n            \"#aeea0088\",\n            \"#ffd60088\",\n            \"#ffab0088\",\n            \"#ff6d0088\",\n            \"#dd2c0088\",\n          ]\n          const hash = p.edges\n            .map(s =>\n              s.split(\"\").reduce((a, b) => {\n                a = (a << 5) - a + b.charCodeAt(0)\n                return a & a\n              }, 0)\n            )\n            .reduce((a, b) => a + b, 0)\n          return list[Math.abs(hash) % list.length]\n        },\n        dasharray: undefined,\n        linecap: \"round\",\n        linejoin: \"round\",\n        animate: false,\n        animationSpeed: 50,\n      }),\n      normal: {\n        width: path => Config.value(self.path.width, path),\n        color: path => Config.value(self.path.color, path),\n        dasharray: path => Config.value(self.path.dasharray, path),\n        linecap: path => Config.value(self.path.linecap, path),\n        linejoin: path => Config.value(self.path.linejoin, path),\n        animate: path => Config.value(self.path.animate, path),\n        animationSpeed: path => Config.value(self.path.animationSpeed, path),\n      },\n      hover: {\n        width: path => Config.value(self.normal.width, path) + 2,\n        color: path => Config.value(self.normal.color, path),\n        dasharray: path => Config.value(self.normal.dasharray, path),\n        linecap: path => Config.value(self.normal.linecap, path),\n        linejoin: path => Config.value(self.normal.linejoin, path),\n        animate: path => Config.value(self.normal.animate, path),\n        animationSpeed: path => Config.value(self.normal.animationSpeed, path),\n      },\n      selected: {\n        width: path => Config.value(self.normal.width, path) + 2,\n        color: path => Config.value(self.normal.color, path),\n        dasharray: \"6 12\",\n        linecap: path => Config.value(self.normal.linecap, path),\n        linejoin: path => Config.value(self.normal.linejoin, path),\n        animate: path => Config.value(self.normal.animate, path),\n        animationSpeed: path => Config.value(self.normal.animationSpeed, path),\n      },\n      selectable: false,\n      zOrder: {\n        enabled: false,\n        zIndex: 0,\n        bringToFrontOnHover: true,\n        bringToFrontOnSelected: true\n      },\n      transition: undefined\n    })),\n  }\n}\n\nexport function getFullConfigs<N extends Node = Node, E extends Edge = Edge, P extends Path = Path>(config?: UserConfigs<N, E, P>): Configs {\n  const configs = getConfigDefaults()\n  if (config) {\n    merge(configs, config)\n  }\n  return configs\n}\n","import { inject, InjectionKey, provide, reactive, Ref, watch } from \"vue\"\nimport { nonNull } from \"@/common/common\"\nimport { Configs, UserConfigs } from \"@/common/configs\"\nimport { getConfigDefaults } from \"@/common/config-defaults\"\nimport merge from \"lodash-es/merge\"\n\nconst injectionKey = Symbol(\"style\") as InjectionKey<Configs>\n\nexport function provideConfigs(configs: Ref<UserConfigs>) {\n  const results: Configs = reactive(getConfigDefaults())\n  const styleKeys = Object.keys(results) as (keyof Configs)[]\n  for (const key of styleKeys) {\n    watch(() => configs.value[key], () => {\n      merge(results[key], configs.value[key] || {})\n    }, { immediate: true, deep: true })\n  }\n\n  provide(injectionKey, results)\n  return results\n}\n\nfunction injectConfig<T extends keyof Configs>(key: T) {\n  return nonNull(inject(injectionKey), `Configs(${key})`)[key]\n}\n\nexport function useAllConfigs() {\n  return nonNull(inject(injectionKey))\n}\n\nexport function useViewConfig() {\n  return injectConfig(\"view\")\n}\n\nexport function useNodeConfig() {\n  return injectConfig(\"node\")\n}\n\nexport function useEdgeConfig() {\n  return injectConfig(\"edge\")\n}\n\nexport function usePathConfig() {\n  return injectConfig(\"path\")\n}\n","let nextId = 1\n\n/** Generate unique ID in v-network-graph instances */\nexport function useId(): number {\n  return nextId++\n}\n","/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n  return this;\n}\n\nexport default setCacheAdd;\n","/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\nexport default setCacheHas;\n","import MapCache from './_MapCache.js';\nimport setCacheAdd from './_setCacheAdd.js';\nimport setCacheHas from './_setCacheHas.js';\n\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var index = -1,\n      length = values == null ? 0 : values.length;\n\n  this.__data__ = new MapCache;\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\n\n// Add methods to `SetCache`.\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\n\nexport default SetCache;\n","/**\n * A specialized version of `_.some` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction arraySome(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport default arraySome;\n","/**\n * Checks if a `cache` value for `key` exists.\n *\n * @private\n * @param {Object} cache The cache to query.\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction cacheHas(cache, key) {\n  return cache.has(key);\n}\n\nexport default cacheHas;\n","import SetCache from './_SetCache.js';\nimport arraySome from './_arraySome.js';\nimport cacheHas from './_cacheHas.js';\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `array` and `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */\nfunction equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n    return false;\n  }\n  // Check that cyclic values are equal.\n  var arrStacked = stack.get(array);\n  var othStacked = stack.get(other);\n  if (arrStacked && othStacked) {\n    return arrStacked == other && othStacked == array;\n  }\n  var index = -1,\n      result = true,\n      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\n\n  stack.set(array, other);\n  stack.set(other, array);\n\n  // Ignore non-index properties.\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, arrValue, index, other, array, stack)\n        : customizer(arrValue, othValue, index, array, other, stack);\n    }\n    if (compared !== undefined) {\n      if (compared) {\n        continue;\n      }\n      result = false;\n      break;\n    }\n    // Recursively compare arrays (susceptible to call stack limits).\n    if (seen) {\n      if (!arraySome(other, function(othValue, othIndex) {\n            if (!cacheHas(seen, othIndex) &&\n                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n              return seen.push(othIndex);\n            }\n          })) {\n        result = false;\n        break;\n      }\n    } else if (!(\n          arrValue === othValue ||\n            equalFunc(arrValue, othValue, bitmask, customizer, stack)\n        )) {\n      result = false;\n      break;\n    }\n  }\n  stack['delete'](array);\n  stack['delete'](other);\n  return result;\n}\n\nexport default equalArrays;\n","/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\nexport default mapToArray;\n","/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\nexport default setToArray;\n","import Symbol from './_Symbol.js';\nimport Uint8Array from './_Uint8Array.js';\nimport eq from './eq.js';\nimport equalArrays from './_equalArrays.js';\nimport mapToArray from './_mapToArray.js';\nimport setToArray from './_setToArray.js';\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/** `Object#toString` result references. */\nvar boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]';\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n  switch (tag) {\n    case dataViewTag:\n      if ((object.byteLength != other.byteLength) ||\n          (object.byteOffset != other.byteOffset)) {\n        return false;\n      }\n      object = object.buffer;\n      other = other.buffer;\n\n    case arrayBufferTag:\n      if ((object.byteLength != other.byteLength) ||\n          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n        return false;\n      }\n      return true;\n\n    case boolTag:\n    case dateTag:\n    case numberTag:\n      // Coerce booleans to `1` or `0` and dates to milliseconds.\n      // Invalid dates are coerced to `NaN`.\n      return eq(+object, +other);\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case regexpTag:\n    case stringTag:\n      // Coerce regexes to strings and treat strings, primitives and objects,\n      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n      // for more details.\n      return object == (other + '');\n\n    case mapTag:\n      var convert = mapToArray;\n\n    case setTag:\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n      convert || (convert = setToArray);\n\n      if (object.size != other.size && !isPartial) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked) {\n        return stacked == other;\n      }\n      bitmask |= COMPARE_UNORDERED_FLAG;\n\n      // Recursively compare objects (susceptible to call stack limits).\n      stack.set(object, other);\n      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n      stack['delete'](object);\n      return result;\n\n    case symbolTag:\n      if (symbolValueOf) {\n        return symbolValueOf.call(object) == symbolValueOf.call(other);\n      }\n  }\n  return false;\n}\n\nexport default equalByTag;\n","/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\nexport default arrayPush;\n","import arrayPush from './_arrayPush.js';\nimport isArray from './isArray.js';\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\nexport default baseGetAllKeys;\n","/**\n * A specialized version of `_.filter` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction arrayFilter(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (predicate(value, index, array)) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\nexport default arrayFilter;\n","/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\nexport default stubArray;\n","import arrayFilter from './_arrayFilter.js';\nimport stubArray from './stubArray.js';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols;\n\n/**\n * Creates an array of the own enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n  if (object == null) {\n    return [];\n  }\n  object = Object(object);\n  return arrayFilter(nativeGetSymbols(object), function(symbol) {\n    return propertyIsEnumerable.call(object, symbol);\n  });\n};\n\nexport default getSymbols;\n","import overArg from './_overArg.js';\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeKeys = overArg(Object.keys, Object);\n\nexport default nativeKeys;\n","import isPrototype from './_isPrototype.js';\nimport nativeKeys from './_nativeKeys.js';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nexport default baseKeys;\n","import arrayLikeKeys from './_arrayLikeKeys.js';\nimport baseKeys from './_baseKeys.js';\nimport isArrayLike from './isArrayLike.js';\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\nexport default keys;\n","import baseGetAllKeys from './_baseGetAllKeys.js';\nimport getSymbols from './_getSymbols.js';\nimport keys from './keys.js';\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\nexport default getAllKeys;\n","import getAllKeys from './_getAllKeys.js';\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1;\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      objProps = getAllKeys(object),\n      objLength = objProps.length,\n      othProps = getAllKeys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isPartial) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n      return false;\n    }\n  }\n  // Check that cyclic values are equal.\n  var objStacked = stack.get(object);\n  var othStacked = stack.get(other);\n  if (objStacked && othStacked) {\n    return objStacked == other && othStacked == object;\n  }\n  var result = true;\n  stack.set(object, other);\n  stack.set(other, object);\n\n  var skipCtor = isPartial;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, objValue, key, other, object, stack)\n        : customizer(objValue, othValue, key, object, other, stack);\n    }\n    // Recursively compare objects (susceptible to call stack limits).\n    if (!(compared === undefined\n          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n          : compared\n        )) {\n      result = false;\n      break;\n    }\n    skipCtor || (skipCtor = key == 'constructor');\n  }\n  if (result && !skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    // Non `Object` object instances with different constructors are not equal.\n    if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n      result = false;\n    }\n  }\n  stack['delete'](object);\n  stack['delete'](other);\n  return result;\n}\n\nexport default equalObjects;\n","import getNative from './_getNative.js';\nimport root from './_root.js';\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView');\n\nexport default DataView;\n","import getNative from './_getNative.js';\nimport root from './_root.js';\n\n/* Built-in method references that are verified to be native. */\nvar Promise = getNative(root, 'Promise');\n\nexport default Promise;\n","import getNative from './_getNative.js';\nimport root from './_root.js';\n\n/* Built-in method references that are verified to be native. */\nvar Set = getNative(root, 'Set');\n\nexport default Set;\n","import getNative from './_getNative.js';\nimport root from './_root.js';\n\n/* Built-in method references that are verified to be native. */\nvar WeakMap = getNative(root, 'WeakMap');\n\nexport default WeakMap;\n","import DataView from './_DataView.js';\nimport Map from './_Map.js';\nimport Promise from './_Promise.js';\nimport Set from './_Set.js';\nimport WeakMap from './_WeakMap.js';\nimport baseGetTag from './_baseGetTag.js';\nimport toSource from './_toSource.js';\n\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    setTag = '[object Set]',\n    weakMapTag = '[object WeakMap]';\n\nvar dataViewTag = '[object DataView]';\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = baseGetTag(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : '';\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\nexport default getTag;\n","import Stack from './_Stack.js';\nimport equalArrays from './_equalArrays.js';\nimport equalByTag from './_equalByTag.js';\nimport equalObjects from './_equalObjects.js';\nimport getTag from './_getTag.js';\nimport isArray from './isArray.js';\nimport isBuffer from './isBuffer.js';\nimport isTypedArray from './isTypedArray.js';\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    objectTag = '[object Object]';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = objIsArr ? arrayTag : getTag(object),\n      othTag = othIsArr ? arrayTag : getTag(other);\n\n  objTag = objTag == argsTag ? objectTag : objTag;\n  othTag = othTag == argsTag ? objectTag : othTag;\n\n  var objIsObj = objTag == objectTag,\n      othIsObj = othTag == objectTag,\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && isBuffer(object)) {\n    if (!isBuffer(other)) {\n      return false;\n    }\n    objIsArr = true;\n    objIsObj = false;\n  }\n  if (isSameTag && !objIsObj) {\n    stack || (stack = new Stack);\n    return (objIsArr || isTypedArray(object))\n      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n  }\n  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n      var objUnwrapped = objIsWrapped ? object.value() : object,\n          othUnwrapped = othIsWrapped ? other.value() : other;\n\n      stack || (stack = new Stack);\n      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  stack || (stack = new Stack);\n  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n}\n\nexport default baseIsEqualDeep;\n","import baseIsEqualDeep from './_baseIsEqualDeep.js';\nimport isObjectLike from './isObjectLike.js';\n\n/**\n * The base implementation of `_.isEqual` which supports partial comparisons\n * and tracks traversed objects.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Unordered comparison\n *  2 - Partial comparison\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(value, other, bitmask, customizer, stack) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n}\n\nexport default baseIsEqual;\n","import baseIsEqual from './_baseIsEqual.js';\n\n/**\n * Performs a deep comparison between two values to determine if they are\n * equivalent.\n *\n * **Note:** This method supports comparing arrays, array buffers, booleans,\n * date objects, error objects, maps, numbers, `Object` objects, regexes,\n * sets, strings, symbols, and typed arrays. `Object` objects are compared\n * by their own, not inherited, enumerable properties. Functions and DOM\n * nodes are compared by strict equality, i.e. `===`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.isEqual(object, other);\n * // => true\n *\n * object === other;\n * // => false\n */\nfunction isEqual(value, other) {\n  return baseIsEqual(value, other);\n}\n\nexport default isEqual;\n","import isEqual from \"lodash-es/isEqual\"\n\nexport function keyOf<T>(obj: T): (keyof T)[] {\n  return Object.keys(obj) as (keyof T)[]\n}\n\nexport function entriesOf<T, K extends keyof T>(obj: T): [K, T[K]][] {\n  return Object.entries(obj) as [K, T[K]][]\n}\n\nexport function updateObjectDiff<T extends Record<string, any>>(target: T, from: T) {\n  const keys = new Set<keyof T>(Object.keys(target))\n  entriesOf(from).forEach(([key, value]) => {\n    if (!isEqual(target[key], value)) {\n      target[key] = value\n    }\n    keys.delete(key)\n  })\n  keys.forEach(k => delete target[k])\n}\n","import { Ref, watchEffect } from \"vue\"\nimport { Reactive } from \"@/common/common\"\nimport { Edge, Edges, LinePosition, Nodes, Position } from \"@/common/types\"\nimport { Config, Configs, EdgeKeepOrderType } from \"@/common/configs\"\nimport { EdgeGroup, EdgeGroupStates, EdgeLayoutPoint } from \"@/models/edge\"\nimport { updateObjectDiff } from \"@/utils/object\"\n\n// -----------------------------------------------------------------------\n// Type definition\n// -----------------------------------------------------------------------\n\n// -----------------------------------------------------------------------\n// Exported functions\n// -----------------------------------------------------------------------\n\n/**\n * Make the states for edge group.\n * @param nodes nodes\n * @param edges edges\n * @param configs configs\n * @returns the states object for edge group\n */\nexport function makeEdgeGroupStates(\n  nodes: Ref<Nodes>,\n  edges: Ref<Edges>,\n  configs: Readonly<Configs>\n): Reactive<EdgeGroupStates> {\n  // Calculate position map\n  const state = Reactive<EdgeGroupStates>({\n    edgeLayoutPoints: {},\n    edgeGroups: {},\n    summarizedEdges: {},\n  })\n\n  watchEffect(() => {\n    const { edgeLayoutPoints, edgeGroups } = calculateEdgeGroupAndPositions(\n      configs,\n      nodes.value,\n      edges.value\n    )\n    updateObjectDiff(state.edgeLayoutPoints, edgeLayoutPoints)\n    updateObjectDiff(state.edgeGroups, edgeGroups)\n  })\n\n  // calc layout and check summarize\n  watchEffect(() => {\n    const summarizedEdges: Record<string, true> = {}\n    for (const [id, { edges, groupWidth }] of Object.entries(state.edgeGroups)) {\n      let summarize = false\n      if (groupWidth == 0) {\n        summarize = false\n      } else if (configs.edge.summarize instanceof Function) {\n        const s = configs.edge.summarize(edges, configs)\n        if (s === null) {\n          summarize = defaultCheckSummarize(nodes.value, edges, configs, groupWidth)\n        } else {\n          summarize = s\n        }\n      } else if (configs.edge.summarize) {\n        summarize = defaultCheckSummarize(nodes.value, edges, configs, groupWidth)\n      } else {\n        summarize = false\n      }\n      state.edgeGroups[id].summarize = summarize\n      if (summarize) {\n        Object.keys(edges).forEach(id => (summarizedEdges[id] = true))\n      }\n    }\n    updateObjectDiff(state.summarizedEdges, summarizedEdges)\n  })\n\n  return state\n}\n\n/**\n * Calculate the edge position by applying a shift.\n * @param p relative layout information of edges\n * @param isSummarized summarize or not\n * @param source position of source node\n * @param target position of target node\n * @param scale scale factor\n * @param keepOrder edge positional type config\n * @returns the edge position by applying a shift\n */\nexport function calculateEdgeShiftedPosition(\n  p: EdgeLayoutPoint | undefined,\n  isSummarized: boolean,\n  source: Position,\n  target: Position,\n  scale: number,\n  keepOrder: EdgeKeepOrderType\n): LinePosition {\n  if (!p) {\n    return { p1: { x: 0, y: 0 }, p2: { x: 0, y: 0 } } // sanitized\n  }\n  if (isSummarized) {\n    // summarize\n    return calculateEdgePositionInner(p.edge, source, target, scale, 0, 0, keepOrder)\n  } else {\n    return calculateEdgePositionInner(\n      p.edge,\n      source,\n      target,\n      scale,\n      p.groupWidth,\n      p.pointInGroup,\n      keepOrder\n    )\n  }\n}\n\n// -----------------------------------------------------------------------\n// Private functions\n// -----------------------------------------------------------------------\n\nfunction calculateEdgeGroupAndPositions(configs: Configs, nodes: Nodes, edges: Edges) {\n  const edgeLayoutPoints: Record<string, EdgeLayoutPoint> = {}\n  const edgeGroups: Record<string, EdgeGroup> = {}\n\n  // make edge groups that between same nodes\n  const map: Record<string, Edges> = {}\n  for (const [id, edge] of Object.entries(edges)) {\n    if (!(edge.source in nodes && edge.target in nodes)) {\n      // reject if no node ID is found on the nodes\n      continue\n    }\n    const key = [edge.source, edge.target].sort().join(\"<=>\")\n    const values = map[key] || {}\n    values[id] = edge\n    map[key] = values\n  }\n\n  // Calculate the following:\n  // - the starting point of each line\n  // - the width between the centers of the lines at both ends\n  // *Note*: the drawing position of the line is the center of the line.\n  const calcGap =\n    configs.edge.gap instanceof Function\n      ? configs.edge.gap\n      : (_e: Edges, _c: Configs) => configs.edge.gap as number\n  for (const [key, edges] of Object.entries(map)) {\n    const edgeLen = Object.keys(edges).length\n    if (edgeLen == 0) continue\n\n    const gap = calcGap(edges, configs)\n    const [edgeId, edge] = Object.entries(edges)[0]\n    if (edgeLen === 1) {\n      edgeLayoutPoints[edgeId] = { edge, pointInGroup: 0, groupWidth: 0 }\n      edgeGroups[key] = { edges, groupWidth: 0, summarize: false }\n    } else {\n      let pointInGroup = 0\n      const lineHalfWidths = Object.entries(edges).map(([id, edge]) => {\n        let width = Config.value(configs.edge.normal.width, edge)\n        if (isNaN(+width)) {\n          console.warn(\n            \"[v-network-graph] Edge width is invalid value. id=[%s] value=[%s]\",\n            id,\n            width\n          )\n          width = 1\n        }\n        return width / 2\n      })\n      const points = Object.entries(edges).map(([edgeId, edge], i) => {\n        if (i > 0) {\n          pointInGroup += lineHalfWidths[i - 1] + gap + lineHalfWidths[i]\n        }\n        return [edgeId, edge, pointInGroup] as [string, Edge, number]\n      })\n      const groupWidth = pointInGroup\n      points.forEach(([edgeId, edge, pointInGroup]) => {\n        edgeLayoutPoints[edgeId] = { edge, pointInGroup, groupWidth }\n      })\n      edgeGroups[key] = { edges, groupWidth, summarize: false }\n    }\n  }\n\n  return { edgeLayoutPoints, edgeGroups }\n}\n\nfunction defaultCheckSummarize(nodes: Nodes, edges: Edges, configs: Configs, width: number) {\n  // aggregate if the edge width and gap width exceed the size of the node\n  const edgeCount = Object.entries(edges).length\n  if (edgeCount === 1) return false\n\n  // const width =\n  //   Object.values(edges)\n  //     .map(e => Config.value(configs.edge.normal.width, e))\n  //     .reduce((sum, v) => sum + v, 0) +\n  //   configs.edge.gap * (edgeCount - 1)\n\n  const minWidth = Math.min(\n    ...Object.values(edges)\n      .flatMap(e => [nodes[e.source], nodes[e.target]])\n      .filter(v => v)\n      .map(node => {\n        const shape = Config.values(configs.node.normal, node)\n        if (shape.type === \"circle\") {\n          return shape.radius * 2\n        } else {\n          return Math.min(shape.width, shape.height)\n        }\n      })\n  )\n  return width > minWidth\n}\n\nfunction calculateEdgePositionInner(\n  edge: Edge,\n  source: Position | undefined,\n  target: Position | undefined,\n  scale: number,\n  groupWidth: number,\n  pointInGroup: number,\n  keepOrder: EdgeKeepOrderType\n): LinePosition {\n  let x1, y1, x2, y2\n  if (edge.source < edge.target) {\n    ;[x1, y1, x2, y2] = calculateLinePosition(\n      source?.x ?? 0,\n      source?.y ?? 0,\n      target?.x ?? 0,\n      target?.y ?? 0,\n      scale,\n      groupWidth,\n      pointInGroup,\n      keepOrder\n    )\n  } else {\n    ;[x2, y2, x1, y1] = calculateLinePosition(\n      target?.x ?? 0,\n      target?.y ?? 0,\n      source?.x ?? 0,\n      source?.y ?? 0,\n      scale,\n      groupWidth,\n      pointInGroup,\n      keepOrder\n    )\n  }\n  return { p1: { x: x1, y: y1 }, p2: { x: x2, y: y2 } }\n}\n\nfunction calculateLinePosition(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  scale: number,\n  groupWidth: number,\n  pointInGroup: number,\n  keepOrder: EdgeKeepOrderType\n): [number, number, number, number] {\n  const dx = x2 - x1\n  const dy = y2 - y1\n\n  // Shifting width from center\n  let diff = (groupWidth / 2 - pointInGroup) * scale\n\n  // Adjust the relative position.\n  if (diff !== 0 && keepOrder !== \"clock\") {\n    const radian = Math.atan2(y2 - y1, x2 - x1)\n    if (keepOrder === \"vertical\") {\n      // Keep the vertical alignment of multiple edges.\n      const perpendicular = Math.PI / 2\n      if (radian < -perpendicular || radian >= perpendicular) {\n        diff *= -1\n      }\n    } else if (keepOrder === \"horizontal\") {\n      // Keep the horizontal alignment of multiple edges.\n      if (radian < 0) {\n        diff *= -1\n      }\n    }\n  }\n\n  if (dx === 0) {\n    const sign = dy < 0 ? -1 : 1\n    return [x1 + diff * sign, y1, x2 + diff * sign, y2]\n  } else if (dy === 0) {\n    const sign = dx < 0 ? 1 : -1\n    return [x1, y1 + diff * sign, x2, y2 + diff * sign]\n  } else {\n    const slope = dy / dx\n    const moveSlope = -1 / slope\n    if (dy < 0) {\n      diff = -diff\n    }\n    const diffX = diff / Math.sqrt(1 + Math.pow(moveSlope, 2))\n    return [x1 + diffX, y1 + diffX * moveSlope, x2 + diffX, y2 + diffX * moveSlope]\n  }\n}\n","import { Point2D } from \"./core\"\n\nexport function add(v1: Point2D, v2: Point2D): Point2D\nexport function add<T extends Point2D>(v1: Point2D, v2: Point2D, target: T): T\nexport function add(v1: Point2D, v2: Point2D, target?: Point2D): Point2D {\n  if (!target) {\n    target = { x: 0, y: 0 }\n  }\n  target.x = v1.x + v2.x\n  target.y = v1.y + v2.y\n  return target\n}\n\nexport function subtract(v1: Point2D, v2: Point2D): Point2D\nexport function subtract<T extends Point2D>(v1: Point2D, v2: Point2D, target: T): T\nexport function subtract(v1: Point2D, v2: Point2D, target?: Point2D): Point2D {\n  if (!target) {\n    target = { x: 0, y: 0 }\n  }\n  target.x = v1.x - v2.x\n  target.y = v1.y - v2.y\n  return target\n}\n\nexport function multiply(v1: Point2D, v2: Point2D): Point2D\nexport function multiply<T extends Point2D>(v1: Point2D, v2: Point2D, target: T): T\nexport function multiply(v1: Point2D, v2: Point2D, target?: Point2D): Point2D {\n  if (!target) {\n    target = { x: 0, y: 0 }\n  }\n  target.x = v1.x * v2.x\n  target.y = v1.y * v2.y\n  return target\n}\n\nexport function multiplyScalar(v: Point2D, scalar: number): Point2D\nexport function multiplyScalar<T extends Point2D>(v: Point2D, scalar: number, target: T): T\nexport function multiplyScalar(v: Point2D, scalar: number, target?: Point2D): Point2D {\n  if (!target) {\n    target = { x: 0, y: 0 }\n  }\n  target.x = v.x * scalar\n  target.y = v.y * scalar\n  return target\n}\n\nexport function divide(v1: Point2D, v2: Point2D): Point2D\nexport function divide<T extends Point2D>(v1: Point2D, v2: Point2D, target: T): T\nexport function divide(v1: Point2D, v2: Point2D, target?: Point2D): Point2D {\n  if (!target) {\n    target = { x: 0, y: 0 }\n  }\n  target.x = v1.x / v2.x\n  target.y = v1.y / v2.y\n  return target\n}\n\nexport function dot(v1: Point2D, v2: Point2D): number {\n  return v1.x * v2.x + v1.y * v2.y\n}\n\nexport function cross(v1: Point2D, v2: Point2D): number {\n  return v1.x * v2.y - v1.y * v2.x\n}\n\nexport function lengthSquared(v: Point2D): number {\n  return v.x * v.x + v.y * v.y\n}\n\nexport function length(v: Point2D): number {\n  return Math.sqrt(lengthSquared(v))\n}\n\nexport function distanceSquared(v1: Point2D, v2: Point2D): number {\n  const dx = v1.x - v2.x\n  const dy = v1.y - v2.y\n  return dx * dx + dy * dy\n}\n\nexport function distance(v1: Point2D, v2: Point2D): number {\n  return Math.sqrt(distanceSquared(v1, v2))\n}\n\nexport function normalize(v: Point2D): Point2D\nexport function normalize<T extends Point2D>(v: Point2D, target: T): T\nexport function normalize(v: Point2D, target?: Point2D): Point2D {\n  if (!target) {\n    target = { x: 0, y: 0 }\n  }\n  const len = length(v)\n  if (len === 0) {\n    target.x = 1\n    target.y = 0\n  } else {\n    divide(v, { x: len, y: len }, target)\n  }\n  return target\n}\n\nexport function rotate(v: Point2D, angle: number): Point2D\nexport function rotate<T extends Point2D>(v: Point2D, angle: number, target: T): T\nexport function rotate(v: Point2D, angle: number, target?: Point2D): Point2D {\n  if (!target) {\n    target = { x: 0, y: 0 }\n  }\n  // rotate in radians CCW from +X axis\n  const newX = v.x * Math.cos(angle) - v.y * Math.sin(angle)\n  const newY = v.x * Math.sin(angle) + v.y * Math.cos(angle)\n  target.x = newX\n  target.y = newY\n  return target\n}\n\nconst DEGREES = 180 / Math.PI\n\nfunction rad2deg(rad: number) {\n  return rad * DEGREES\n}\n\nexport function angle(v: Point2D) {\n  return Math.atan2(v.y, v.x)\n}\n\nexport function angleDegree(v: Point2D) {\n  return rad2deg(angle(v))\n}\n","import { Point2D } from \"./core\"\nimport { add, angle, angleDegree, cross, distance, distanceSquared, divide } from \"./methods\"\nimport { dot, length, lengthSquared, multiply, multiplyScalar, normalize } from \"./methods\"\nimport { rotate, subtract } from \"./methods\"\n\nexport class Vector2D implements Point2D {\n  public x: number\n  public y: number\n\n  static fromArray(array: number[]) {\n    return new Vector2D(array[0] || 0, array[1] || 0)\n  }\n\n  static fromObject(obj: Point2D) {\n    return new Vector2D(obj.x, obj.y)\n  }\n\n  constructor(x: number, y: number) {\n    this.x = x\n    this.y = y\n  }\n\n  // instance methods\n  add(v: Point2D): Vector2D {\n    return add(this, v, this)\n  }\n\n  subtract(v: Point2D): Vector2D {\n    return subtract(this, v, this)\n  }\n\n  multiply(v: Point2D): Vector2D {\n    return multiply(this, v, this)\n  }\n\n  multiplyScalar(scalar: number): Vector2D {\n    return multiplyScalar(this, scalar, this)\n  }\n\n  divide(v: Point2D): Vector2D {\n    return divide(this, v, this)\n  }\n\n  dot(v: Point2D): number {\n    return dot(this, v)\n  }\n\n  cross(v: Point2D): number {\n    return cross(this, v)\n  }\n\n  lengthSquared(): number {\n    return lengthSquared(this)\n  }\n\n  length(): number {\n    return length(this)\n  }\n\n  distanceSquared(v: Point2D): number {\n    return distanceSquared(this, v)\n  }\n\n  distance(v: Point2D): number {\n    return distance(this, v)\n  }\n\n  normalize(): Vector2D {\n    return normalize(this, this)\n  }\n\n  angle(): number {\n    return angle(this)\n  }\n\n  angleDegree(): number {\n    return angleDegree(this)\n  }\n\n  rotate(angle: number): Vector2D {\n    return rotate(this, angle, this)\n  }\n\n  isEqualTo(v: Point2D): boolean {\n    return this.x === v.x && this.y === v.y\n  }\n\n  clone(): Vector2D {\n    return new Vector2D(this.x, this.y)\n  }\n\n  toObject(): Point2D {\n    return { x: this.x, y: this.y }\n  }\n\n  toArray(): [number, number] {\n    return [this.x, this.y]\n  }\n}\n","export { Vector2D } from \"./vector2d\"\nexport * from \"./methods\"\n\nimport { Vector2D } from \"./vector2d\"\nimport * as V from \"./methods\"\n\nexport default {\n  Vector2D,\n  ...V\n}\n","import { LinePosition, Position } from \"@/common/types\"\nimport { Vector2D } from \"@/modules/vector2d\"\n\n// ---------------------------\n// Line information by vectors\n// ---------------------------\n\nexport class VectorLine {\n  public source: Vector2D\n  public target: Vector2D\n  public v: Vector2D\n\n  constructor(source: Vector2D, target: Vector2D, v: Vector2D) {\n    this.source = source\n    this.target = target\n    this.v = v\n  }\n\n  static fromLinePosition(line: LinePosition): VectorLine {\n    const source = Vector2D.fromObject(line.p1)\n    const target = Vector2D.fromObject(line.p2)\n    return new VectorLine(source, target, toLineVector(source, target))\n  }\n\n  static fromPositions(sourcePos: Position, targetPos: Position): VectorLine {\n    const source = Vector2D.fromObject(sourcePos)\n    const target = Vector2D.fromObject(targetPos)\n    return new VectorLine(source, target, toLineVector(source, target))\n  }\n\n  static fromVectors(source: Vector2D, target: Vector2D): VectorLine {\n    return new VectorLine(source, target, toLineVector(source, target))\n  }\n}\n\nexport function toLineVector(source: Vector2D, target: Vector2D): Vector2D {\n  return target.clone().subtract(source)\n}\n\nexport function toVectorsFromLinePosition(line: LinePosition): [Vector2D, Vector2D] {\n  return [Vector2D.fromObject(line.p1), Vector2D.fromObject(line.p2)]\n}\n\nexport function getCenterOfLinePosition(line: LinePosition): Vector2D {\n  return new Vector2D((line.p1.x + line.p2.x) / 2, (line.p1.y + line.p2.y) / 2)\n}\n\n// -------------------------------\n// Calculation functions for Lines\n// -------------------------------\n\n/**\n * Convert two `Position` to `LinePosition`\n * @param p1 source position of the line\n * @param p2 target position of the line\n * @returns `LinePosition` instance\n */\n export function toLinePosition(p1: Position, p2: Position): LinePosition {\n  return { p1, p2 }\n}\n\n/**\n * Calculates the line position to which the margin is applied.\n * @param linePos original position of the line\n * @param sourceMargin margin for source side\n * @param targetMargin margin for target side\n * @returns the line position\n */\n export function applyMargin(\n  linePos: LinePosition,\n  sourceMargin: number,\n  targetMargin: number\n): LinePosition {\n  const line = VectorLine.fromLinePosition(linePos)\n  return applyMarginInner(line, sourceMargin, targetMargin)\n}\n\nfunction applyMarginInner(\n  line: VectorLine,\n  sourceMargin: number,\n  targetMargin: number\n): LinePosition {\n  const normalized = line.v.clone().normalize()\n\n  const sv = line.source.clone().add(normalized.clone().multiplyScalar(sourceMargin))\n\n  const tv = line.target.clone().subtract(normalized.clone().multiplyScalar(targetMargin))\n\n  let p1 = sv.toObject()\n  let p2 = tv.toObject()\n\n  const check = toLineVector(sv, tv)\n  if (line.v.angle() * check.angle() < 0) {\n    // reversed\n    const c1 = new Vector2D((p1.x + p2.x) / 2, (p1.y + p2.y) / 2)\n    const c2 = c1.clone().add(normalized.multiplyScalar(0.5))\n    p1 = c1.toObject()\n    p2 = c2.toObject()\n  }\n\n  return { p1, p2 }\n}\n\nexport function inverseLine(line: LinePosition): LinePosition {\n  return { p1: line.p2, p2: line.p1 }\n}\n\nexport function calculatePerpendicularLine(line: VectorLine) {\n  const n1 = line.v\n    .clone()\n    .normalize()\n    .rotate(Math.PI / 2)\n  return VectorLine.fromVectors(line.target, line.target.clone().add(n1))\n}\n","import V, { Vector2D } from \"@/modules/vector2d\"\nimport { VectorLine } from \"./line\"\n\n/**\n * Calculate the nearest point from a point to a line.\n * @param p point\n * @param line line\n * @returns point on the line\n */\nexport function getNearestPoint(p: Vector2D, line: VectorLine): Vector2D {\n  const n = line.v.clone().normalize()\n\n  // Let `a` be a vector from any one point on a line to a point\n  const lp = line.source\n  const a = V.subtract(p, lp)\n\n  // Inner product of `n` and `a`\n  const dot = n.dot(a)\n\n  // The nearest point is the sum of a point on the line and a\n  // vector of n multiplied by dot.\n  const near = lp.clone().add(n.multiplyScalar(dot))\n\n  return near\n}\n\n// /**\n//  * Calculate the distance of nearest point from a point to a line.\n//  * @param p point\n//  * @param line line\n//  * @returns distance\n//  */\n// export function getDistanceToNearestPoint(p: Vector2D, line: VectorLine): number {\n//   const p2 = line.source\n//   const v2 = line.v\n\n//   const v2len = v2.lengthSquared()\n//   if (v2len === 0) {\n//     return 0\n//   }\n//   const t = V.dot(v2, V.subtract(p, p2)) / v2len\n//   const tv2 = V.multiplyScalar(v2, t)\n//   const h = p2.clone().add(tv2)\n//   return h.subtract(p).length()\n// }\n\nexport function getIntersectionOfLineTargetAndCircle(\n  source: Vector2D,\n  target: Vector2D,\n  center: Vector2D,\n  radius: number\n): Vector2D | null {\n  // Does the node contain a point?\n  const length = V.lengthSquared(V.subtract(target, center))\n  const contains = length - radius * radius <= Math.pow(1, -10)\n\n  if (!contains) return null // Not contained.\n\n  // If contained, calculate the intersection point.\n\n  // Find the nearest point `h` between `c` and the line\n  const line = VectorLine.fromVectors(source, target)\n  const h = getNearestPoint(center, line)\n\n  // Let `hp` be the vector from `c` to `h`.\n  const hpLen = V.length(V.subtract(h, center))\n\n  // If `hpLen` is larger than the radius of the circle,\n  // there is no intersection.\n  if (radius < hpLen) return null\n\n  // When a straight line and a circle are tangent, `hpLen` is `r`.\n  // Then the point of contact is the nearest point between the\n  // center and the line.\n  if (radius === hpLen) return h\n\n  // Let `t` be the distance from `h` to the contact point, and\n  // derive t from the Three Square Theorem.\n  const t = Math.sqrt(radius ** 2 - hpLen ** 2)\n\n  // Let `tv` be the vector of the normalized direction vector of\n  // the line multiplied by t\n  // - intersection point 1p + tv\n  // - intersection point 2p - tv\n  const tv = line.v.normalize().multiplyScalar(t)\n\n  // Calculate the addition or subtraction depending on which side\n  // of the line to focus on.\n  return h.subtract(tv)\n}\n\nexport function getIntersectionOfLineTargetAndCircle2(\n  source: Vector2D,\n  target: Vector2D,\n  center: Vector2D,\n  radius: number,\n  nearBy: Vector2D\n): Vector2D | null {\n  // Does the node contain a point?\n  const length = V.lengthSquared(V.subtract(target, center))\n  const contains = length - radius * radius <= Math.pow(1, -10)\n\n  if (!contains) return null // Not contained.\n\n  // If contained, calculate the intersection point.\n\n  // Find the nearest point `h` between `c` and the line\n  const line = VectorLine.fromVectors(source, target)\n  const h = getNearestPoint(center, line)\n\n  // Let `hp` be the vector from `c` to `h`.\n  const hpLen = V.length(V.subtract(h, center))\n\n  // If `hpLen` is larger than the radius of the circle,\n  // there is no intersection.\n  if (radius < hpLen) return null\n\n  // When a straight line and a circle are tangent, `hpLen` is `r`.\n  // Then the point of contact is the nearest point between the\n  // center and the line.\n  if (radius === hpLen) return h\n\n  // Let `t` be the distance from `h` to the contact point, and\n  // derive t from the Three Square Theorem.\n  const t = Math.sqrt(radius ** 2 - hpLen ** 2)\n\n  // Let `tv` be the vector of the normalized direction vector of\n  // the line multiplied by t\n  // - intersection point 1p + tv\n  // - intersection point 2p - tv\n  const tv = line.v.normalize().multiplyScalar(t)\n  const ip1 = h.clone().add(tv)\n  const ip2 = h.clone().subtract(tv)\n\n  const d1 = nearBy.distance(ip1)\n  const d2 = nearBy.distance(ip2)\n\n  if (Math.abs(d1 - d2) < 2) {\n    // Calculate the addition or subtraction depending on which side\n    // of the line to focus on.\n    return ip2\n  }\n\n  return d1 < d2 ? ip1 : ip2\n}\n\n/**\n * Calculate the intersection of two lines.\n * @param line1 line 1\n * @param line2 line 2\n * @returns intersection point\n */\nexport function getIntersectionPointOfLines(line1: VectorLine, line2: VectorLine): Vector2D {\n  const v = V.subtract(line2.source, line1.source)\n\n  const v1 = line1.v\n  const v2 = line2.v\n\n  const t2 = V.cross(v, v1) / V.cross(v1, v2)\n\n  return line2.source.clone().add(v2.clone().multiplyScalar(t2))\n}\n\nexport function getIntersectionOfCircles(\n  center1: Vector2D,\n  radius1: number,\n  center2: Vector2D,\n  radius2: number,\n  near: Vector2D\n): Vector2D | null {\n  const c1 = center1\n  const c2 = center2\n\n  // vector of C1-->C2\n  const vC1C2 = c2.clone().subtract(c1)\n\n  // length of C1--C2\n  const a = vC1C2.length()\n\n  const sumR = radius1 + radius2\n  if (sumR < a) return null // no overlap\n\n  // When a circle is contained, there is no contact point.\n  const subR = Math.abs(radius1 - radius2)\n  if (a < subR) return null\n\n  // When the circles are circumscribed, [a] and the sum of\n  // radius of two circles are equal. And there is only one\n  // contact point.\n  if (a === sumR) {\n    const n = vC1C2.clone().normalize()\n    const p = center1.clone().add(n.multiplyScalar(radius1))\n    return p\n  }\n\n  // When the circles are inscribed, [a] and the difference\n  // between the radius of two circles are equal. And there\n  // is only one point of contact.\n  if (a === subR) {\n    const n = vC1C2.clone().normalize()\n    const isLarge = radius1 > radius2\n    // Let [P] be the contact point:\n    // * C1 is larger : P = C1 + r1 * n\n    // * C1 is smaller: P = C1 - r1 * n\n    const p = center1.clone().add(n.multiplyScalar(isLarge ? radius1 : -radius1))\n    return p\n  }\n\n  // All three sides of triangle C1C2P are known.\n  // [b] := length of C1--P\n  // [c] := length of C2--P\n  const b = radius1\n  const c = radius2\n\n  // The cos  of angle C1 is given by the cosine theorem:\n  const cos = (a ** 2 + b ** 2 - c ** 2) / (2 * a * b)\n\n  // Let [H] be the point where the vertical line from [P] to\n  // C1--C2 is dropped, and let [rc] be the length of C1--H.\n  const rc = b * cos\n\n  // Let the length of the H--P be [rs]\n  const rs = Math.sqrt(b ** 2 - rc ** 2)\n\n  // normalized vector of vC1C2\n  const n1 = vC1C2.clone().normalize()\n\n  // vector with n1 rotated 90 degrees to the left\n  const n2 = new Vector2D(-n1.y, n1.x)\n\n  // The point of intersection [P]\n  // P  = C1 + tn1 + sn2\n  // P' = C1 + tn1 - sn2\n  const tn1 = n1.clone().multiplyScalar(rc)\n  const sn2 = n2.clone().multiplyScalar(rs)\n\n  const result1 = center1.clone().add(tn1).add(sn2)\n  const result2 = center1.clone().add(tn1).subtract(sn2)\n\n  const d1 = result1.distance(near)\n  const d2 = result2.distance(near)\n\n  return d1 < d2 ? result1 : result2\n}\n","import { AnyShapeStyle, RectangleShapeStyle, StrokeStyle } from \"@/common/configs\"\nimport { EdgeLabelArea, LinePosition, Position } from \"@/common/types\"\nimport V, { Vector2D } from \"@/modules/vector2d\"\nimport * as PointUtils from \"./point\"\nimport * as LineUtils from \"./line\"\nimport { VectorLine } from \"./line\"\nimport minBy from \"lodash-es/minBy\"\n\n// /**\n//  * Calculate whether a point is contained in a circle.\n//  * @param point point\n//  * @param center center of the circle\n//  * @param radius radius of the circle\n//  * @returns whether point is contained in a circle\n//  */\n// export function isPointContainedInCircle(\n//   point: Position,\n//   center: Position,\n//   radius: number\n// ): boolean {\n//   const p = Vector2D.fromObject(point)\n//   const c = Vector2D.fromObject(center)\n//   const v = p.subtract(c)\n//   return v.lengthSquared() < radius * radius\n// }\n\n// /**\n//  * Calculate the distance of the line.\n//  * @param line line\n//  * @returns distance\n//  */\n// export function calculateDistance(line: LinePosition): number {\n//   return V.distance(line.p1, line.p2)\n// }\n\n/**\n * Get the distance that a line should be away from the\n * edge to avoid contacting a rounded rectangle.\n * @param sourcePos source position of the line\n * @param targetPos target position of the line\n * @param rect rectangle style\n * @param scale scale factor\n * @returns distance from target position\n */\nfunction calculateDistanceToAvoidOverlapsWithRect(\n  sourcePos: Position,\n  targetPos: Position, // position of the target rounded rectangle\n  rect: RectangleShapeStyle,\n  scale: number\n) {\n  const centerLine = VectorLine.fromPositions(sourcePos, targetPos)\n  const halfWidth = ((rect.width + rect.strokeWidth) / 2) * scale\n  const halfHeight = ((rect.height + rect.strokeWidth) / 2) * scale\n\n  const borderRadius =\n    rect.borderRadius > 0 ? (rect.borderRadius + rect.strokeWidth / 2) * scale : 0\n\n  // check whether it crosses over the vertical or horizontal boundary\n  const angleVRad = (centerLine.v.angle() - Math.PI / 2) % Math.PI\n  const angleHRad = Math.PI / 2 - (angleVRad % Math.PI)\n  const w = halfHeight * Math.abs(Math.tan(angleVRad))\n  const h = halfWidth * Math.abs(Math.tan(angleHRad))\n  const isCrossedVLine = w <= halfWidth - borderRadius\n  const isCrossedHLine = h <= halfHeight - borderRadius\n  if (isCrossedVLine || isCrossedHLine || borderRadius === 0) {\n    if (isCrossedVLine) {\n      return Math.sqrt(halfHeight ** 2 + w ** 2)\n    } else {\n      return Math.sqrt(halfWidth ** 2 + h ** 2)\n    }\n  } else {\n    // on the border radius: calculate the center of circles\n    const left = targetPos.x - halfWidth + borderRadius\n    const top = targetPos.y - halfHeight + borderRadius\n    const right = targetPos.x + halfWidth - borderRadius\n    const bottom = targetPos.y + halfHeight - borderRadius\n    const vertexes = [\n      new Vector2D(left, top),\n      new Vector2D(right, top),\n      new Vector2D(right, bottom),\n      new Vector2D(left, bottom),\n    ]\n    const index = Math.floor(((centerLine.v.angleDegree() + 360) % 360) / 90)\n    const centerOfNearestCircle = vertexes[index]\n    const point = PointUtils.getIntersectionOfLineTargetAndCircle(\n      centerLine.source,\n      PointUtils.getNearestPoint(centerOfNearestCircle, centerLine),\n      centerOfNearestCircle,\n      borderRadius\n    )\n    return point\n      ? LineUtils.toLineVector(point, centerLine.target).length()\n      : LineUtils.toLineVector(centerOfNearestCircle, centerLine.target).length() + borderRadius\n  }\n}\n\n/**\n * Calculate the position to display the edge label from the\n * positions of the edge.\n * @param linePos line segment between the outermost of the nodes\n * @param edgeStyle stroke style of edges\n * @param margin margin from line\n * @param padding padding from outside\n * @param scale scale factor\n * @returns edge label display area\n */\nexport function calculateEdgeLabelArea(\n  linePos: LinePosition,\n  edgeStyle: StrokeStyle,\n  margin: number,\n  padding: number,\n  scale: number\n): EdgeLabelArea {\n  // the line segment between the outermost of the nodes\n  const line = VectorLine.fromLinePosition(linePos)\n  const normalized = line.v.clone().normalize()\n\n  // source side\n  const sv =\n    padding === 0\n      ? line.source\n      : line.source.clone().add(normalized.clone().multiplyScalar(padding * scale))\n\n  // target side\n  const tv =\n    padding === 0\n      ? line.target\n      : line.target.clone().subtract(normalized.clone().multiplyScalar(padding * scale))\n\n  // margin for edges\n  const labelMargin = (edgeStyle.width / 2 + margin) * scale\n  const vMargin = new Vector2D(-normalized.y, normalized.x).multiplyScalar(labelMargin)\n  let sourceAbove = V.subtract(sv, vMargin)\n  let sourceBelow = V.add(sv, vMargin)\n  let targetAbove = V.subtract(tv, vMargin)\n  let targetBelow = V.add(tv, vMargin)\n\n  const angle = line.v.angleDegree()\n  if (angle < -90 || angle >= 90) {\n    // upside down\n    ;[sourceAbove, sourceBelow] = [sourceBelow, sourceAbove]\n    ;[targetAbove, targetBelow] = [targetBelow, targetAbove]\n  }\n  return {\n    source: { above: sourceAbove, below: sourceBelow },\n    target: { above: targetAbove, below: targetBelow },\n  }\n}\n\n/**\n * Calculate the distances between center of node and edge of node.\n * @param sourceNodePos position of source node\n * @param targetNodePos position of target node\n * @param sourceNodeShape shape config of source node\n * @param targetNodeShape shape config of target node\n * @returns the distances\n */\nexport function calculateDistancesFromCenterOfNodeToEndOfNode(\n  sourceNodePos: Position,\n  targetNodePos: Position,\n  sourceNodeShape: AnyShapeStyle,\n  targetNodeShape: AnyShapeStyle\n): [number, number] {\n  // source side\n  let distance1: number\n  if (sourceNodeShape.type === \"circle\") {\n    distance1 = sourceNodeShape.radius + (sourceNodeShape.strokeWidth / 2)\n  } else {\n    distance1 = calculateDistanceToAvoidOverlapsWithRect(\n      targetNodePos,\n      sourceNodePos,\n      sourceNodeShape,\n      1 // scale\n    )\n  }\n\n  // target side\n  let distance2: number\n  if (targetNodeShape.type === \"circle\") {\n    distance2 = targetNodeShape.radius + (targetNodeShape.strokeWidth / 2)\n  } else {\n    distance2 = calculateDistanceToAvoidOverlapsWithRect(\n      sourceNodePos,\n      targetNodePos,\n      targetNodeShape,\n      1 // scale\n    )\n  }\n\n  return [distance1, distance2]\n}\n\n/**\n * Calculates the position of a given distance along the circumference.\n * @param pos original position\n * @param center center of the circle\n * @param radian radius of the circle\n * @returns the moved position\n */\nexport function moveOnCircumference(pos: Position, center: Position, radian: number) {\n  const { x, y } = pos\n  const dx = x - center.x\n  const dy = y - center.y\n\n  return {\n    x: dx * Math.cos(radian) - dy * Math.sin(radian) + center.x,\n    y: dx * Math.sin(radian) + dy * Math.cos(radian) + center.y,\n  }\n}\n\n/**\n * Reverse the direction of the angle.\n * @param theta angle\n * @returns reversed angle\n */\nexport function reverseAngleRadian(theta: number): number {\n  if (theta > 0) {\n    return -(Math.PI * 2 - theta)\n  } else {\n    return Math.PI * 2 + theta\n  }\n}\n\nexport function calculateBezierCurveControlPoint(\n  p1: Vector2D,\n  center: Vector2D,\n  p2: Vector2D,\n  theta0: number\n): Vector2D[] {\n  const control: Vector2D[] = []\n  const centerToSource = VectorLine.fromVectors(center, p1)\n  const centerToTarget = VectorLine.fromVectors(center, p2)\n\n  let theta = calculateRelativeAngleRadian(centerToSource, centerToTarget)\n  if (theta0 * theta < 0) {\n    theta = reverseAngleRadian(theta)\n  }\n  const middle = Vector2D.fromObject(moveOnCircumference(p1, center, -theta / 2))\n  const centerToMp = VectorLine.fromVectors(center, middle)\n  const mpTangent = LineUtils.calculatePerpendicularLine(centerToMp)\n\n  const theta1 = calculateRelativeAngleRadian(centerToSource, centerToMp)\n  let tangent = LineUtils.calculatePerpendicularLine(centerToSource)\n  if (Math.abs(theta1) < Math.PI / 2) {\n    const cp = PointUtils.getIntersectionPointOfLines(tangent, mpTangent)\n    control.push(cp)\n  } else {\n    // If greater than 90 degrees, go through the midpoint.\n    const mp = Vector2D.fromObject(moveOnCircumference(middle, center, theta1 / 2))\n    const tangent2 = LineUtils.calculatePerpendicularLine(\n      VectorLine.fromVectors(center, Vector2D.fromObject(mp))\n    )\n    const cp1 = PointUtils.getIntersectionPointOfLines(tangent, tangent2)\n    const cp2 = PointUtils.getIntersectionPointOfLines(tangent2, mpTangent)\n    control.push(cp1, mp, cp2)\n  }\n\n  control.push(middle)\n\n  const theta2 = calculateRelativeAngleRadian(centerToTarget, centerToMp)\n  tangent = LineUtils.calculatePerpendicularLine(centerToTarget)\n  if (Math.abs(theta2) < Math.PI / 2) {\n    const cp = PointUtils.getIntersectionPointOfLines(tangent, mpTangent)\n    control.push(cp)\n  } else {\n    // If greater than 90 degrees, go through the midpoint.\n    const mp = Vector2D.fromObject(moveOnCircumference(middle, center, theta2 / 2))\n    const tangent2 = LineUtils.calculatePerpendicularLine(\n      VectorLine.fromVectors(center, Vector2D.fromObject(mp))\n    )\n    const cp1 = PointUtils.getIntersectionPointOfLines(mpTangent, tangent2)\n    const cp2 = PointUtils.getIntersectionPointOfLines(tangent2, tangent)\n    control.push(cp1, mp, cp2)\n  }\n\n  return control\n}\n\nexport function calculateRelativeAngleRadian(line1: VectorLine, line2: VectorLine) {\n  return Math.atan2(\n    line1.v.y * line2.v.x - line1.v.x * line2.v.y,\n    line1.v.x * line2.v.x + line1.v.y * line2.v.y\n  )\n}\n\nexport function calculateCircleCenterAndRadiusBy3Points(\n  p1: Vector2D,\n  p2: Vector2D,\n  p3: Vector2D\n): [Vector2D, number] {\n  const x1 = p1.x\n  const y1 = p1.y\n  const x2 = p2.x\n  const y2 = p2.y\n  const x3 = p3.x\n  const y3 = p3.y\n  const x12 = x1 - x2\n  const y12 = y1 - y2\n  const x32 = x3 - x2\n  const y32 = y3 - y2\n\n  const x =\n    (y32 * (x12 * (x1 + x2) + y12 * (y1 + y2)) - y12 * (x32 * (x3 + x2) + y32 * (y3 + y2))) /\n    (2 * x12 * y32 - 2 * y12 * x32)\n  const y =\n    (-x32 * (x12 * (x1 + x2) + y12 * (y1 + y2)) + x12 * (x32 * (x3 + x2) + y32 * (y3 + y2))) /\n    (2 * x12 * y32 - 2 * y12 * x32)\n\n  const radius = Math.sqrt(Math.pow(x1 - x, 2) + Math.pow(y1 - y, 2))\n  const center = new Vector2D(x, y)\n  return [center, radius]\n}\n","\nexport function convertToAscii(source: string): string {\n  if (typeof btoa === undefined) {\n    return Buffer.from(source).toString(\"base64\").replaceAll(\"=\", \"\")\n  } else {\n    return btoa(source).replaceAll(\"=\", \"\")\n  }\n}\n","import { reactive } from \"vue\"\nimport { MarkerStyle } from \"@/common/configs\"\nimport { convertToAscii } from \"@/utils/string\"\n\nexport type MarkerBuilder = (marker: MarkerStyle | null, isSource?: boolean) => string\n\nexport interface HeadMarker extends MarkerStyle {\n  color: string\n  isSource: boolean\n}\n\nexport interface MarkerState {\n  markers: Record<string, HeadMarker>\n  referenceCount: Record<string, number>\n}\n\nexport function makeMarkerState(): MarkerState {\n  const markers: Record<string, HeadMarker> = reactive({})\n  const referenceCount: Record<string, number> = {}\n  return { markers, referenceCount }\n}\n\nexport function useMarker(markerState: MarkerState) {\n  const { markers, referenceCount } = markerState\n\n  function addMarker(key: string, marker: HeadMarker) {\n    const m = referenceCount[key] ?? 0\n    referenceCount[key] = m + 1\n    if (!m) {\n      markers[key] = marker\n    }\n  }\n\n  function removeMarker(key: string) {\n    const m = referenceCount[key] ?? 0\n    if (m) {\n      if (m - 1 === 0) {\n        delete markers[key]\n        delete referenceCount[key]\n      } else {\n        referenceCount[key] = m - 1\n      }\n    }\n  }\n\n  function clearMarker(id: string | undefined) {\n    if (id) {\n      removeMarker(id)\n    }\n  }\n\n  function makeMarker(\n    marker: MarkerStyle,\n    isSource: boolean,\n    previousId: string | undefined,\n    strokeColor: string,\n    instanceId: number\n  ) {\n    if (marker.type === \"none\") {\n      clearMarker(previousId)\n      return undefined\n    }\n\n    if (marker.type === \"custom\") {\n      clearMarker(previousId)\n      return marker.customId\n    }\n\n    const headMarker = toHeadMarker(marker, isSource, strokeColor)\n    const id = buildKey(headMarker, instanceId)\n    if (id === previousId) {\n      return id\n    }\n    clearMarker(previousId)\n    addMarker(id, headMarker)\n    return id\n  }\n\n  return {\n    makeMarker,\n    clearMarker,\n  }\n}\n\nfunction toHeadMarker(marker: MarkerStyle, isSource: boolean, strokeColor: string) {\n  return {\n    ...marker,\n    color: marker.color ?? strokeColor,\n    isSource,\n  }\n}\n\nfunction buildKey(m: HeadMarker, instanceId: number) {\n  // If the same marker ID exists in the previous instance and is hidden by\n  // `display: none`, the marker in the other instance will disappear.\n  // For safety, marker IDs will be unique in the entire page.\n  const c = convertToAscii(m.color)\n  const d = m.isSource ? \"L\" : \"R\"\n  const u = m.units === \"strokeWidth\" ? \"rel\" : \"abs\"\n  return `marker_${instanceId}_${m.type}_${m.width}_${m.height}_${m.margin}_${c}_${d}_${u}`\n}\n","// Management states of objects\n\nimport { computed, ComputedRef, reactive, Ref, unref, UnwrapRef, watch } from \"vue\"\nimport { Reactive } from \"@/common/common\"\nimport { Config, ObjectConfigs, ZOrderConfig } from \"@/common/configs\"\n\ntype Objects<T> = Record<string, T>\n\ninterface ObjectStateDatumBase {\n  id: string\n  selected: boolean\n  hovered: boolean\n  selectable: ComputedRef<boolean | number>\n  zIndex: ComputedRef<number>\n}\ntype ObjectState<S extends ObjectStateDatumBase> = UnwrapRef<S>\n\ntype PartiallyPartial<T, K extends keyof T> = Pick<T, K> & Partial<Omit<T, K>>\ntype NewStateDatum<T extends ObjectStateDatumBase> = PartiallyPartial<T, keyof ObjectStateDatumBase>\n\nexport function useObjectState<\n  T,\n  S extends ObjectStateDatumBase,\n  E extends { id: string; zIndex: number } = ObjectState<S>\n>(\n  objects: Ref<Record<string, T>>,\n  config: ObjectConfigs<T>,\n  selected: Reactive<Set<string>>,\n  hovered: Reactive<Set<string>>,\n  createState: (obj: Ref<Objects<T>>, id: string, state: NewStateDatum<S>) => void,\n  terminateState?: (id: string, state: ObjectState<S>) => void,\n  entriesForZOrder?: () => E[]\n): {\n  states: Record<string, ObjectState<S>>\n  zOrderedList: ComputedRef<E[]>\n} {\n  // Object states\n  const states: Record<string, ObjectState<S>> = reactive({})\n\n  // Handle object added/removed\n  watch(\n    () => new Set(Object.keys(objects.value)),\n    (idSet, prev) => {\n      if (!prev) prev = new Set([])\n      for (const id of idSet) {\n        if (prev.has(id)) continue\n        // object added\n        createNewState(objects, states, id, false, config, createState)\n        // adding to layouts is done by layout handler\n      }\n\n      for (const id of prev) {\n        if (idSet.has(id)) continue\n        // object removed\n        selected.delete(id)\n        hovered.delete(id)\n        terminateState?.(id, states[id] as ObjectState<S>)\n        delete states[id]\n      }\n    },\n    { immediate: true }\n  )\n\n  // Object selection\n  // - update `{obj}.selected` flag\n  watch(\n    () => [...selected],\n    (objects, prev) => {\n      const append = prev ? objects.filter(n => !prev.includes(n)) : objects\n      const removed = prev ? prev.filter(n => !objects.includes(n)) : []\n      append.forEach(id => {\n        const state = states[id]\n        if (state && !state.selected) state.selected = true\n      })\n      removed.forEach(id => {\n        const state = states[id]\n        if (state && state.selected) state.selected = false\n      })\n    },\n    { immediate: true } // for specified from the beginning\n  )\n\n  // - update `node.hovered` flag\n  watch(\n    () => [...hovered],\n    (nodes, prev) => {\n      const append = nodes.filter(n => !prev.includes(n))\n      const removed = prev.filter(n => !nodes.includes(n))\n      append.forEach(id => {\n        const state = states[id]\n        if (state && !state.hovered) state.hovered = true\n      })\n      removed.forEach(id => {\n        const state = states[id]\n        if (state && state.hovered) state.hovered = false\n      })\n    }\n  )\n\n  // z-order\n  // z-index applied Object List\n  const zOrderedList = computed(() => {\n    const list: E[] = entriesForZOrder ? entriesForZOrder() : (Object.values(states) as E[])\n    if (config.zOrder.enabled) {\n      return makeZOrderedList(list, config.zOrder, hovered, selected)\n    } else {\n      return list\n    }\n  })\n\n  return { states, zOrderedList }\n}\n\nfunction createNewState<T, S extends ObjectStateDatumBase>(\n  objects: Ref<Objects<T>>,\n  states: Record<string, ObjectState<S>>,\n  id: string,\n  selected: boolean,\n  config: ObjectConfigs<T>,\n  createState: (obj: Ref<Objects<T>>, id: string, state: NewStateDatum<S>) => void\n) {\n  const stateObject = <NewStateDatum<S>>{\n    id,\n    selected,\n    hovered: false,\n    selectable: computed(() => {\n      if (!objects.value[id]) return unref(stateObject.selectable) // Return the previous value\n      return Config.value(config.selectable, objects.value[id])\n    }),\n    zIndex: computed(() => {\n      if (!objects.value[id]) return unref(stateObject.zIndex) // Return the previous value\n      return Config.value(config.zOrder.zIndex, objects.value[id])\n    }),\n  }\n  states[id] = stateObject as ObjectState<S>\n  createState(objects, id, states[id] as NewStateDatum<S> /* get reactive object */)\n}\n\nfunction makeZOrderedList<S extends { id: string; zIndex: number }, T>(\n  states: S[],\n  zOrder: ZOrderConfig<T>,\n  hovered: Reactive<Set<string>>,\n  selected: Reactive<Set<string>>\n) {\n  if (zOrder.bringToFrontOnHover && zOrder.bringToFrontOnSelected) {\n    return states.sort((a, b) => {\n      const hover1 = hovered.has(a.id)\n      const hover2 = hovered.has(b.id)\n      if (hover1 != hover2) {\n        return hover1 ? 1 : -1\n      }\n      const selected1 = selected.has(a.id)\n      const selected2 = selected.has(b.id)\n      if (selected1 != selected2) {\n        return selected1 ? 1 : -1\n      }\n      return a.zIndex - b.zIndex\n    })\n  } else if (zOrder.bringToFrontOnHover) {\n    return states.sort((a, b) => {\n      const hover1 = hovered.has(a.id)\n      const hover2 = hovered.has(b.id)\n      if (hover1 != hover2) {\n        return hover1 ? 1 : -1\n      }\n      return a.zIndex - b.zIndex\n    })\n  } else if (zOrder.bringToFrontOnSelected) {\n    return states.sort((a, b) => {\n      const selected1 = selected.has(a.id)\n      const selected2 = selected.has(b.id)\n      if (selected1 != selected2) {\n        return selected1 ? 1 : -1\n      }\n      return a.zIndex - b.zIndex\n    })\n  } else {\n    return states.sort((a, b) => {\n      return a.zIndex - b.zIndex\n    })\n  }\n}\n","// the states of nodes and edges\n\nimport { computed, ComputedRef, reactive, ref, Ref, toRef, unref } from \"vue\"\nimport { watch, watchEffect } from \"vue\"\nimport { inject, InjectionKey, provide } from \"vue\"\nimport { nonNull, Reactive } from \"@/common/common\"\nimport { Config, Configs, EdgeConfig, MarkerStyle, NodeConfig } from \"@/common/configs\"\nimport { StrokeStyle } from \"@/common/configs\"\nimport { Edge, Edges, Layouts, Node, Nodes, Path, Paths } from \"@/common/types\"\nimport { LinePosition } from \"@/common/types\"\nimport { useId } from \"@/composables/id\"\nimport * as NodeModel from \"@/models/node\"\nimport * as EdgeModel from \"@/models/edge\"\nimport * as EdgeGroup from \"@/modules/edge/group\"\nimport * as PathModel from \"@/models/path\"\nimport * as v2d from \"@/modules/calculation/2d\"\nimport * as LineUtils from \"@/modules/calculation/line\"\nimport { VectorLine } from \"@/modules/calculation/line\"\nimport { MarkerState, useMarker } from \"./marker\"\nimport { useObjectState } from \"./objectState\"\n\n// -----------------------------------------------------------------------\n// Type definitions\n// -----------------------------------------------------------------------\n\nexport type { EdgeGroupStates } from \"@/models/edge\"\n\n// States of nodes\n\n// Provide states\n\ninterface States {\n  nodeStates: NodeModel.NodeStates\n  edgeStates: EdgeModel.EdgeStates\n  edgeGroupStates: EdgeModel.EdgeGroupStates\n  summarizedEdgeStates: EdgeModel.SummarizedEdgeStates\n  pathStates: PathModel.PathStates\n  nodeZOrderedList: ComputedRef<NodeModel.NodeState[]>\n  edgeZOrderedList: ComputedRef<EdgeModel.EdgeEntry[]>\n  pathZOrderedList: ComputedRef<PathModel.PathState[]>\n  layouts: Layouts\n}\n\nexport type ReadonlyStates = Readonly<States>\n\ninterface InputObjects<T> {\n  objects: Ref<T>\n  selected: Reactive<Set<string>>\n  hovered: Reactive<Set<string>>\n}\n\nexport function makeStateInput<T>(\n  objects: Ref<T>,\n  selected: Reactive<Set<string>>,\n  hovered: Reactive<Set<string>>\n) {\n  return {\n    objects,\n    selected,\n    hovered,\n  }\n}\n\n// -----------------------------------------------------------------------\n// Constants\n// -----------------------------------------------------------------------\n\nconst statesKey = Symbol(\"states\") as InjectionKey<States>\n\nconst NONE_MARKER: MarkerStyle = {\n  type: \"none\",\n  width: 0,\n  height: 0,\n  margin: 0,\n  units: \"strokeWidth\",\n  color: null,\n}\n\n// -----------------------------------------------------------------------\n// Exported functions\n// -----------------------------------------------------------------------\n\nexport function provideStates(\n  nodes: InputObjects<Nodes>,\n  edges: InputObjects<Edges>,\n  paths: InputObjects<Paths>,\n  configs: Readonly<Configs>,\n  layouts: Reactive<Layouts>,\n  makerState: MarkerState,\n  scale: ComputedRef<number>\n) {\n  const summarizedEdgeStates: EdgeModel.SummarizedEdgeStates = reactive({})\n\n  // -----------------------------------------------------------------------\n  // States for nodes\n  // -----------------------------------------------------------------------\n\n  const {\n    states: nodeStates,\n    zOrderedList: nodeZOrderedList, //\n  } = useObjectState<Node, NodeModel.NodeStateDatum, NodeModel.NodeState>(\n    nodes.objects,\n    configs.node,\n    nodes.selected,\n    nodes.hovered,\n    (nodes, id, newState) => {\n      createNewNodeState(nodes, id, newState as NodeModel.NodeStateDatum, configs.node)\n    },\n    (nodeId, _state) => {\n      const positions = layouts.nodes\n      delete positions[nodeId]\n    }\n  )\n\n  // -----------------------------------------------------------------------\n  // States for edges\n  // -----------------------------------------------------------------------\n  // Instance ID number for using to make marker ID generation unique for the\n  // entire page.\n  // If the same marker ID exists in the previous instance and is hidden by\n  // `display: none`, the marker in the other instance will disappear.\n  // To be safe, markers should be unique in the entire page.\n  const instanceId = useId()\n\n  // grouping\n  const edgeGroupStates = EdgeGroup.makeEdgeGroupStates(nodes.objects, edges.objects, configs)\n\n  // edge entries for applying z-order\n  const edgeEntries = ref<EdgeModel.EdgeEntry[]>([])\n\n  const {\n    states: edgeStates,\n    zOrderedList: edgeZOrderedList, //\n  } = useObjectState<Edge, EdgeModel.EdgeStateDatum, EdgeModel.EdgeEntry>(\n    edges.objects,\n    configs.edge,\n    edges.selected,\n    edges.hovered,\n    (edges, id, newState) => {\n      createNewEdgeState(\n        edges,\n        id,\n        newState as EdgeModel.EdgeStateDatum,\n        configs.edge,\n        makerState,\n        nodeStates,\n        edgeGroupStates,\n        layouts,\n        scale,\n        instanceId\n      )\n    },\n    (_edgeId, state) => {\n      state.stopWatchHandle?.()\n    },\n    () => edgeEntries.value\n  )\n\n  // Edge item for display (an edge or summarized edges)\n  watchEffect(() => {\n    edgeEntries.value = createEdgeEntries(edgeGroupStates.edgeGroups, edgeStates)\n  })\n\n  watch(\n    edgeGroupStates.edgeGroups,\n    _ => createSummarizedEdgeStates(summarizedEdgeStates, edgeGroupStates, configs),\n    { immediate: true }\n  )\n\n  // -----------------------------------------------------------------------\n  // States for paths\n  // -----------------------------------------------------------------------\n\n  const {\n    states: pathStates,\n    zOrderedList: pathZOrderedList, //\n  } = useObjectState<Path, PathModel.PathStateDatum, PathModel.PathState>(\n    paths.objects,\n    configs.path,\n    paths.selected,\n    paths.hovered,\n    (paths, id, newState) => {\n      const state = newState as PathModel.PathStateDatum\n\n      state.clickable = computed(() => {\n        if (!paths.value[id]) return false\n        return Config.value(configs.path.clickable, paths.value[id])\n      })\n      state.hoverable = computed(() => {\n        if (!paths.value[id]) return false\n        return Config.value(configs.path.hoverable, paths.value[id])\n      })\n\n      state.path = paths.value[id]\n      state.edges = computed(() => {\n        const path = paths.value[id]\n        return path.edges\n          .map(edgeId => ({ edgeId, edge: edges.objects.value[edgeId] }))\n          .filter(e => e.edge)\n      })\n    }\n  )\n\n  const states = <States>{\n    nodeStates,\n    edgeStates,\n    edgeGroupStates,\n    summarizedEdgeStates,\n    pathStates,\n    layouts,\n    nodeZOrderedList,\n    edgeZOrderedList,\n    pathZOrderedList,\n  }\n  provide(statesKey, states)\n  return states\n}\n\nexport function isSummarizedEdges(item: EdgeModel.EdgeItem): item is EdgeModel.SummarizedEdgeItem {\n  return item.summarized\n}\n\nexport function useStates() {\n  return nonNull(inject(statesKey), \"states\") as ReadonlyStates\n}\n\n// -----------------------------------------------------------------------\n// Local functions\n// -----------------------------------------------------------------------\n\nfunction getNodeShape(node: Node, selected: boolean, hovered: boolean, config: NodeConfig) {\n  if (hovered && config.hover) {\n    return Config.values(config.hover, node)\n  } else {\n    return getNodeStaticShape(node, selected, config)\n  }\n}\n\nfunction getNodeStaticShape(node: Node, selected: boolean, config: NodeConfig) {\n  // get shape without hovered state\n  if (selected && config.selected) {\n    return Config.values(config.selected, node)\n  } else {\n    return Config.values(config.normal, node)\n  }\n}\n\nfunction createNewNodeState(\n  nodes: Ref<Nodes>,\n  id: string,\n  state: NodeModel.NodeStateDatum,\n  config: NodeConfig\n) {\n  state.shape = computed(() => {\n    if (!nodes.value[id]) return unref(state.shape) // Return the previous value\n    return getNodeShape(nodes.value[id], state.selected, state.hovered, config)\n  })\n\n  state.staticShape = computed(() => {\n    if (!nodes.value[id]) return unref(state.staticShape) // Return the previous value\n    return getNodeStaticShape(nodes.value[id], state.selected, config)\n  })\n\n  state.label = computed(() => {\n    if (!nodes.value[id]) return unref(state.label) // Return the previous value\n    return Config.values(config.label, nodes.value[id])\n  })\n\n  state.labelText = computed(() => {\n    if (config.label.text instanceof Function) {\n      return unref(state.label).text\n    } else {\n      if (!nodes.value[id]) return unref(state.labelText) // Return the previous value\n      return nodes.value[id]?.[unref(state.label).text] ?? \"\"\n    }\n  })\n\n  state.draggable = computed(() => {\n    if (!nodes.value[id]) return unref(state.draggable) // Return the previous value\n    return Config.value(config.draggable, nodes.value[id])\n  })\n}\n\nfunction getEdgeStroke(edge: Edge, selected: boolean, hovered: boolean, config: EdgeConfig) {\n  if (selected) {\n    return Config.values(config.selected, edge)\n  } else if (hovered && config.hover) {\n    return Config.values(config.hover, edge)\n  } else {\n    return Config.values(config.normal, edge)\n  }\n}\n\nfunction toEdgeMarker(marker: MarkerStyle): MarkerStyle {\n  if (marker.type === \"none\") {\n    return NONE_MARKER\n  } else {\n    return marker\n  }\n}\n\nfunction createNewEdgeState(\n  edges: Ref<Edges>,\n  id: string,\n  state: EdgeModel.EdgeStateDatum,\n  config: EdgeConfig,\n  makerState: MarkerState,\n  nodeStates: NodeModel.NodeStates,\n  edgeGroupStates: Reactive<EdgeModel.EdgeGroupStates>,\n  layouts: Layouts,\n  scale: Ref<number>,\n  instanceId: number\n) {\n  const { makeMarker, clearMarker } = useMarker(makerState)\n\n  Object.assign(state, {\n    origin: { p1: { x: 0, y: 0 }, p2: { x: 0, y: 0 } },\n    labelPosition: { p1: { x: 0, y: 0 }, p2: { x: 0, y: 0 } },\n    position: { p1: { x: 0, y: 0 }, p2: { x: 0, y: 0 } },\n  })\n\n  const line = computed<EdgeModel.Line>(() => {\n    const edge = edges.value[id]\n    const stroke = getEdgeStroke(edge, state.selected, state.hovered, config)\n    // Minimum error checking required for drawing\n    if (isNaN(+stroke.width)) {\n      console.warn(\n        \"[v-network-graph] Edge width is invalid value. id=[%s] value=[%s]\",\n        id,\n        stroke.width\n      )\n      stroke.width = 1\n    }\n    if (stroke.color === undefined || stroke.color === null) {\n      console.warn(\n        \"[v-network-graph] Edge color is invalid value. id=[%s] value=[%s]\",\n        id,\n        stroke.color\n      )\n      stroke.color = \"#000000\"\n    }\n    let normalWidth = Config.value(config.normal.width, edge)\n    if (isNaN(+normalWidth)) {\n      normalWidth = 1\n    }\n    const source = toEdgeMarker(Config.values(config.marker.source, [edge, stroke]))\n    const target = toEdgeMarker(Config.values(config.marker.target, [edge, stroke]))\n    return { stroke, normalWidth, source, target }\n  })\n  state.line = line\n  const edgeLayoutPoint: Ref<EdgeModel.EdgeLayoutPoint | undefined> = toRef(\n    edgeGroupStates.edgeLayoutPoints,\n    id\n  )\n  const isEdgeSummarized: Ref<true | undefined> = toRef(edgeGroupStates.summarizedEdges, id)\n\n  const stopCalcHandle = watchEffect(() => {\n    const edge = edges.value[id]\n    if (!edge) return\n\n    const source = layouts.nodes[edge?.source]\n    const target = layouts.nodes[edge?.target]\n\n    const sourceShape = nodeStates[edge?.source]?.staticShape\n    const targetShape = nodeStates[edge?.target]?.staticShape\n    if (!source || !target || !sourceShape || !targetShape) {\n      return\n    }\n\n    // calculate the line segment between center of nodes\n    const shiftedPosition = EdgeGroup.calculateEdgeShiftedPosition(\n      edgeLayoutPoint.value,\n      isEdgeSummarized.value ?? false,\n      source,\n      target,\n      scale.value,\n      config.keepOrder\n    )\n\n    const [sourceShapeMargin, targetShapeMargin] =\n      v2d.calculateDistancesFromCenterOfNodeToEndOfNode(source, target, sourceShape, targetShape)\n\n    const s = scale.value\n\n    // calculate the line segment between the outermost of the nodes\n    state.labelPosition = LineUtils.applyMargin(\n      shiftedPosition,\n      sourceShapeMargin * s,\n      targetShapeMargin * s\n    )\n\n    // calculate margins\n    let sourceMargin = 0\n    let targetMargin = 0\n    const l = line.value\n    if (l.source.type !== \"none\") {\n      const marker = l.source\n      sourceMargin = marker.margin + marker.width\n      if (marker.units === \"strokeWidth\") {\n        sourceMargin *= l.normalWidth\n      }\n    }\n    if (l.target.type !== \"none\") {\n      const marker = l.target\n      targetMargin = marker.margin + marker.width\n      if (marker.units === \"strokeWidth\") {\n        targetMargin *= l.normalWidth\n      }\n    }\n\n    if (config.margin === null || config.margin === undefined) {\n      if (l.source.type !== \"none\" || l.target.type !== \"none\") {\n        sourceMargin += sourceShapeMargin\n        targetMargin += targetShapeMargin\n      }\n    } else {\n      sourceMargin += config.margin + sourceShapeMargin\n      targetMargin += config.margin + targetShapeMargin\n    }\n\n    // calculate the line segments to be displayed with margins applied\n    const type = config.type\n    if (type === \"straight\") {\n      state.origin = shiftedPosition\n      state.curve = undefined\n      if (sourceMargin === 0 && targetMargin === 0) {\n        state.position = state.origin\n      } else {\n        state.position = LineUtils.applyMargin(state.origin, sourceMargin * s, targetMargin * s)\n      }\n    } else {\n      // curve\n      state.origin = LineUtils.toLinePosition(source, target)\n\n      const shift = edgeLayoutPoint.value // undefined after node deletion\n        ? edgeLayoutPoint.value.groupWidth / 2 - edgeLayoutPoint.value.pointInGroup\n        : 0\n\n      const [position, curve] = calculateCurvePositionAndState(\n        state.origin,\n        shiftedPosition,\n        shift,\n        sourceMargin * s,\n        targetMargin * s\n      )\n      state.position = position\n      state.curve = curve\n    }\n  })\n\n  const stopUpdateMarkerHandle = watchEffect(() => {\n    if (!edges.value[id]) return\n    state.sourceMarkerId = makeMarker(\n      line.value.source,\n      true /* isSource */,\n      state.sourceMarkerId,\n      line.value.stroke.color,\n      instanceId\n    )\n    state.targetMarkerId = makeMarker(\n      line.value.target,\n      false /* isSource */,\n      state.targetMarkerId,\n      line.value.stroke.color,\n      instanceId\n    )\n  })\n\n  state.stopWatchHandle = () => {\n    stopCalcHandle()\n    stopUpdateMarkerHandle()\n    clearMarker(state.sourceMarkerId)\n    clearMarker(state.targetMarkerId)\n  }\n}\n\nfunction createEdgeEntries(\n  edgeGroups: Record<string, EdgeModel.EdgeGroup>,\n  edgeStates: EdgeModel.EdgeStates\n) {\n  return Object.entries(edgeGroups)\n    .map(([key, group]) => {\n      if (group.summarize) {\n        return <EdgeModel.SummarizedEdgeItem>{\n          id: Object.keys(group.edges)[0] ?? key,\n          summarized: true,\n          key,\n          group,\n          zIndex: Object.keys(group.edges)\n            .map(id => edgeStates[id]?.zIndex ?? 0)\n            .reduce((s, z) => Math.max(s, z)),\n        }\n      } else {\n        return Object.entries(group.edges).map(\n          ([id, edge]) =>\n            <EdgeModel.SingleEdgeItem>{\n              id,\n              summarized: false,\n              key: id,\n              edge,\n              zIndex: edgeStates[id]?.zIndex ?? 0,\n            }\n        )\n      }\n    })\n    .flat()\n}\n\nfunction calculateCurvePositionAndState(\n  originPosition: LinePosition,\n  shiftedPosition: LinePosition,\n  shift: number,\n  sourceMargin: number,\n  targetMargin: number\n): [LinePosition, EdgeModel.Curve | undefined] {\n  // The curve is assumed to be part of a perfect circle and is drawn\n  // as a Bezier curve.\n\n  const origin = VectorLine.fromLinePosition(originPosition)\n  const shifted = VectorLine.fromLinePosition(shiftedPosition)\n  const shiftedCenter = LineUtils.getCenterOfLinePosition(shiftedPosition)\n\n  // Calculate the center and radius of the circle of the curve.\n  const [center, radius] = v2d.calculateCircleCenterAndRadiusBy3Points(\n    origin.source,\n    origin.target,\n    shiftedCenter\n  )\n\n  let position: LinePosition\n  let curve: EdgeModel.Curve | undefined = undefined\n\n  if (shift === 0) {\n    // The line connecting the centers of the nodes is regarded as a straight line.\n    if (sourceMargin === 0 && targetMargin === 0) {\n      position = originPosition\n    } else {\n      position = LineUtils.applyMargin(originPosition, sourceMargin, targetMargin)\n    }\n    return [position, curve]\n  }\n\n  // Apply margin to the line.\n  const centerToTop = VectorLine.fromVectors(center, shiftedCenter)\n\n  // Direction of rotation from source to center:\n  const theta0 = v2d.calculateRelativeAngleRadian(\n    VectorLine.fromVectors(center, origin.source),\n    centerToTop\n  )\n\n  if (sourceMargin === 0 && targetMargin === 0) {\n    position = originPosition\n  } else {\n    // The endpoints of the display line are the point on the circumference\n    // moved by the margin from the origin end points.\n    let sourceMoveRad = sourceMargin / radius\n    let targetMoveRad = targetMargin / radius\n\n    // Determine which direction to move.\n    if (theta0 > 0) {\n      sourceMoveRad *= -1\n      targetMoveRad *= -1\n    }\n    position = LineUtils.toLinePosition(\n      v2d.moveOnCircumference(origin.source, center, sourceMoveRad),\n      v2d.moveOnCircumference(origin.target, center, -targetMoveRad)\n    )\n\n    // If the endpoints are swapped by applying the margin,\n    // a short line is shown at the center.\n    let theta1 = v2d.calculateRelativeAngleRadian(\n      VectorLine.fromVectors(center, origin.source),\n      VectorLine.fromVectors(center, origin.target)\n    )\n    let theta2 = v2d.calculateRelativeAngleRadian(\n      VectorLine.fromPositions(center, position.p1),\n      VectorLine.fromPositions(center, position.p2)\n    )\n    if (theta0 * theta1 < 0) {\n      theta1 = v2d.reverseAngleRadian(theta1)\n      if (theta0 * theta2 < 0) {\n        theta2 = v2d.reverseAngleRadian(theta2)\n      }\n    }\n    if (theta1 * theta2 < 0) {\n      // reversed\n      const c = shiftedCenter.clone().add(shifted.v.normalize().multiplyScalar(0.5))\n      position = LineUtils.toLinePosition(shiftedCenter, c)\n      return [position, curve]\n    }\n  }\n\n  // Calculate the control/via points of a Bezier curve.\n  const [p1, p2] = LineUtils.toVectorsFromLinePosition(position)\n  const control = v2d\n    .calculateBezierCurveControlPoint(p1, center, p2, theta0)\n    .map(p => p.toObject())\n\n  curve = {\n    center: shiftedCenter,\n    theta: theta0,\n    circle: { center, radius },\n    control,\n  }\n  return [position, curve]\n}\n\nfunction createSummarizedEdgeStates(\n  summarizedEdgeStates: EdgeModel.SummarizedEdgeStates,\n  edgeGroupStates: Reactive<EdgeModel.EdgeGroupStates>,\n  configs: Configs\n) {\n  const groups = edgeGroupStates.edgeGroups\n  Object.entries(groups)\n    .filter(([id, group]) => group.summarize && !(id in summarizedEdgeStates))\n    .forEach(([id, group]) => {\n      const state = { stroke: undefined as any }\n      state.stroke = computed<StrokeStyle>(() =>\n        Config.values(configs.edge.summarized.stroke, group.edges)\n      )\n      summarizedEdgeStates[id] = state\n    })\n  Object.keys(summarizedEdgeStates).forEach(id => {\n    if (!edgeGroupStates.edgeGroups[id]?.summarize) {\n      delete summarizedEdgeStates[id]\n    }\n  })\n}\n","\nexport class MapUtil {\n  static valueOf<K, V>(map: Map<K, V>) {\n    return Array.from(map.values())\n  }\n}\n","import { Ref } from \"vue\"\nimport { Position, ViewMode } from \"@/common/types\"\n\nconst MOUSE_MOVE_DETECTION_THRESHOLD = 3 // Sensitivity to start dragging\nconst TOUCH_MOVE_DETECTION_THRESHOLD = 6 // Sensitivity to start dragging in touches\nexport const DOUBLE_CLICK_THRESHOLD = 500\n\nexport type SelectionMode = \"container\" | \"node\" | \"edge\" | \"path\"\n\n// state for each pointer of multi touch\nexport interface NodePointerState {\n  pointerId: number // pointer ID provided by the event\n  nodeId: string // pointer down node ID\n  moveCounter: number // count for pointermove event occurred\n  dragBasePosition: Position // drag started position\n  nodeBasePosition: Position // node position at drag started\n  latestPosition: Position // latest position\n  eventTarget: EventTarget | null // event target\n}\n\nexport interface EdgePointerState {\n  pointerId: number // pointer ID provided by the event\n  id: string | string[] // pointer down edge ID\n  eventTarget: EventTarget | null // event target\n}\n\nexport interface PathPointerState {\n  pointerId: number // pointer ID provided by the event\n  id: string // pointer down path ID\n  eventTarget: EventTarget | null // event target\n}\n\nexport interface ClickState {\n  lastTime: number\n  count: number\n  id: string // clicked object ID\n}\n\nexport interface InteractionModes {\n  selectionMode: Ref<SelectionMode>\n  viewMode: Ref<ViewMode>\n}\n\nexport function getPointerMoveDetectionThreshold(type: string): number {\n  return type === \"touch\" ? TOUCH_MOVE_DETECTION_THRESHOLD : MOUSE_MOVE_DETECTION_THRESHOLD\n}\n\nexport function detectClicks(\n  clickStates: Map<number, ClickState>,\n  pointerId: number,\n  id: string,\n  event: MouseEvent,\n): [MouseEvent, MouseEvent | undefined] {\n  // search click states\n  let clickState = clickStates.get(pointerId)\n  if (clickState) {\n    if (clickState.id !== id) {\n      // click an other object\n      clickState = undefined\n    }\n  } else {\n    const idAndState = Array.from(clickStates.entries()).find(([_, state]) => state.id === id)\n    if (idAndState) {\n      const [oldPointerId, state] = idAndState\n      clickStates.delete(oldPointerId)\n      clickState = state\n    }\n  }\n\n  let clickEvent: MouseEvent, doubleClickEvent: MouseEvent | undefined\n  [clickState, clickEvent, doubleClickEvent] = createClickEvents(clickState, event, id)\n\n  // update\n  clickStates.set(pointerId, clickState)\n\n  return [ clickEvent, doubleClickEvent ]\n}\n\nexport function createClickEvents(\n  clickState: ClickState | undefined,\n  event: MouseEvent,\n  id: string\n): [ClickState, MouseEvent, MouseEvent | undefined] {\n  const now = Date.now()\n  if (clickState && now - clickState.lastTime <= DOUBLE_CLICK_THRESHOLD) {\n    // continuous clicked\n    clickState.count++\n    clickState.lastTime = now\n  } else {\n    // single clicked\n    clickState = { count: 1, lastTime: now, id }\n  }\n\n  const initDict = {\n    view: window,\n    screenX: event.screenX,\n    screenY: event.screenY,\n    clientX: event.clientX,\n    clientY: event.clientY,\n    ctrlKey: event.ctrlKey,\n    shiftKey: event.shiftKey,\n    altKey: event.altKey,\n    metaKey: event.metaKey,\n    button: event.button,\n    buttons: event.buttons,\n    detail: clickState.count,\n  }\n\n  let clickEvent: MouseEvent\n  let doubleClickEvent: MouseEvent | undefined = undefined\n  if (event instanceof PointerEvent) {\n    Object.assign(initDict, {\n      pointerId: event.pointerId,\n      width: event.width,\n      height: event.height,\n      pressure: event.pressure,\n      tangentialPressure: event.tangentialPressure,\n      tiltX: event.tiltX,\n      tiltY: event.tiltY,\n      twist: event.twist,\n      pointerType: event.pointerType,\n      isPrimary: event.isPrimary,\n    })\n    clickEvent = new PointerEvent(\"click\", initDict)\n    if (clickState.count === 2) {\n      doubleClickEvent = new PointerEvent(\"dblclick\", initDict)\n    }\n  } else {\n    clickEvent = new MouseEvent(\"click\", initDict)\n    if (clickState.count === 2) {\n      doubleClickEvent = new MouseEvent(\"dblclick\", initDict)\n    }\n  }\n\n  return [clickState, clickEvent, doubleClickEvent]\n}\n\nexport function cleanClickState(states: Map<number, ClickState>) {\n  const now = Date.now()\n  Array.from(states.entries())\n    .filter(([_, state]) => now - state.lastTime > DOUBLE_CLICK_THRESHOLD)\n    .map(([pointerId, _]) => states.delete(pointerId))\n}\n","import { watch } from \"vue\"\nimport { Emitter } from \"mitt\"\nimport { Reactive, ReadonlyRef } from \"@/common/common\"\nimport { Events, Layouts, NodePositions, Position } from \"@/common/types\"\nimport { NodeStates } from \"@/models/node\"\nimport { entriesOf } from \"@/utils/object\"\nimport { MapUtil } from \"@/utils/map\"\nimport {\n  cleanClickState,\n  ClickState,\n  detectClicks,\n  getPointerMoveDetectionThreshold,\n  InteractionModes,\n  NodePointerState,\n} from \"./core\"\n\ntype PointerPosition = Pick<PointerEvent, \"pageX\" | \"pageY\" | \"pointerId\">\n\ninterface NodeInteractionState {\n  pointers: Map<number, NodePointerState> // <PointerId, ...>\n  follow: {\n    followedPointerId: number\n    nodeBasePositions: { [name: string]: Position }\n  }\n  hoveredNodesPre: Set<string> // to keep the hover state while dragging\n  clicks: Map<number, ClickState> // <PointerId, ...>\n}\n\nexport function makeNodeInteractionHandlers(\n  nodeStates: NodeStates,\n  layouts: Readonly<Layouts>,\n  modes: InteractionModes,\n  hoveredNodes: Reactive<Set<string>>,\n  selectedNodes: Reactive<Set<string>>,\n  zoomLevel: ReadonlyRef<number>,\n  emitter: Emitter<Events>\n) {\n  const state: NodeInteractionState = {\n    pointers: new Map(),\n    follow: {\n      followedPointerId: -1,\n      nodeBasePositions: {},\n    },\n    hoveredNodesPre: new Set(),\n    clicks: new Map(),\n  }\n\n  const nodePointerHandlers = {\n    pointermove: handleNodePointerMoveEvent,\n    pointerup: handleNodePointerUpEvent,\n    pointercancel: handleNodePointerCancelEvent,\n  }\n\n  function _updateFollowNodes(pointerState: NodePointerState) {\n    const isFollowed = state.follow.followedPointerId === pointerState.pointerId\n    const isSelectedNode = selectedNodes.has(pointerState.nodeId)\n\n    const removed = !(pointerState.pointerId in state.pointers)\n    if ((isFollowed && removed) || (isFollowed && !isSelectedNode)) {\n      // selected => unselected\n      const candidate = MapUtil.valueOf(state.pointers).find(p => selectedNodes.has(p.nodeId))\n      if (!candidate) {\n        state.follow = { followedPointerId: -1, nodeBasePositions: {} }\n        return\n      }\n      pointerState = candidate\n      state.follow.followedPointerId = pointerState.pointerId\n    } else {\n      const followed = state.pointers.get(state.follow.followedPointerId)\n      if (!followed) {\n        state.follow = { followedPointerId: -1, nodeBasePositions: {} }\n        return\n      }\n      pointerState = followed\n    }\n\n    if (isFollowed || isSelectedNode) {\n      // reset state for following:\n      // followed by selected nodes without user grabs\n      const userGrabs = MapUtil.valueOf(state.pointers).map(n => n.nodeId)\n      state.follow.nodeBasePositions = Object.fromEntries(\n        Array.from(selectedNodes)\n          .filter(n => !userGrabs.includes(n))\n          .filter(n => nodeStates[n]?.draggable)\n          .map(n => [n, _unwrapNodePosition(layouts.nodes, n)])\n      )\n      pointerState.dragBasePosition = { ...pointerState.latestPosition }\n      pointerState.nodeBasePosition = _unwrapNodePosition(layouts.nodes, pointerState.nodeId)\n    }\n  }\n\n  watch(selectedNodes, selected => {\n    const pointerState = state.pointers.get(state.follow.followedPointerId)\n    if (pointerState) {\n      _updateFollowNodes(pointerState)\n    }\n    if (selected.size > 0 && modes.selectionMode.value !== \"node\") {\n      modes.selectionMode.value = \"node\"\n    } else if (selected.size === 0 && modes.selectionMode.value === \"node\") {\n      modes.selectionMode.value = \"container\"\n    }\n  })\n\n  watch(modes.selectionMode, mode => {\n    if (mode !== \"node\") {\n      selectedNodes.clear()\n    }\n  })\n\n  function _calculateNodeNewPosition(pointerState: NodePointerState, event: PointerPosition) {\n    const dx = pointerState.dragBasePosition.x - event.pageX\n    const dy = pointerState.dragBasePosition.y - event.pageY\n    const positions =\n      state.follow.followedPointerId == pointerState.pointerId\n        ? {\n            [pointerState.nodeId]: pointerState.nodeBasePosition,\n            ...state.follow.nodeBasePositions,\n          }\n        : { [pointerState.nodeId]: pointerState.nodeBasePosition }\n    const z = zoomLevel.value\n\n    return Object.fromEntries(\n      Object.entries(positions).map(([node, pos]) => [\n        node,\n        {\n          x: pos.x - dx / z,\n          y: pos.y - dy / z,\n        },\n      ])\n    )\n  }\n\n  function handleNodeClickEvent(node: string, event: MouseEvent) {\n    if (event.isTrusted) return // native event\n    // When a finger is placed on any object and another object is tapped,\n    // no click event is fired. Thus, click events are emulated by using\n    // pointerdown/up. The following is processing for emulated events only.\n\n    if (event.shiftKey && ![\"container\", \"node\"].includes(modes.selectionMode.value)) {\n      return\n    }\n    modes.selectionMode.value = \"node\"\n\n    const selectable = nodeStates[node]?.selectable ?? false\n    if (selectable) {\n      const isTouchAnySelectedNode =\n        MapUtil.valueOf(state.pointers).filter(p => selectedNodes.has(p.nodeId)).length > 0\n      if (event.shiftKey || isTouchAnySelectedNode) {\n        // select multiple nodes\n        if (selectedNodes.has(node)) {\n          selectedNodes.delete(node)\n        } else if (!(typeof selectable === \"number\" && selectedNodes.size >= selectable)) {\n          selectedNodes.add(node)\n        }\n      } else if (!selectedNodes.has(node)) {\n        // make the selectedNodes the clicked one\n        selectedNodes.clear()\n        selectedNodes.add(node)\n      }\n    }\n    emitter.emit(\"node:click\", { node, event })\n  }\n\n  function handleNodeDoubleClickEvent(node: string, event: MouseEvent) {\n    if (event.isTrusted) return // native event\n    emitter.emit(\"node:dblclick\", { node, event })\n  }\n\n  function handleNodePointerMoveEvent(event: PointerEvent) {\n    event.stopPropagation()\n\n    const pointerState = state.pointers.get(event.pointerId)\n    if (!pointerState) {\n      return\n    }\n    pointerState.latestPosition = { x: event.pageX, y: event.pageY }\n    pointerState.moveCounter++\n\n    const threshold = getPointerMoveDetectionThreshold(event.pointerType)\n    if (pointerState.moveCounter <= threshold) {\n      return // pending for click and drag distinguish\n    }\n\n    if (!nodeStates[pointerState.nodeId]?.draggable) {\n      return\n    }\n\n    if (pointerState.moveCounter === threshold + 1) {\n      const draggingNodes = _calculateNodeNewPosition(pointerState, {\n        pointerId: pointerState.pointerId,\n        pageX: pointerState.dragBasePosition.x,\n        pageY: pointerState.dragBasePosition.y,\n      })\n      emitter.emit(\"node:dragstart\", draggingNodes)\n    }\n    const draggingNodes = _calculateNodeNewPosition(pointerState, event)\n    emitter.emit(\"node:pointermove\", draggingNodes)\n  }\n\n  function handleNodePointerCancelEvent(event: PointerEvent) {\n    event.stopPropagation()\n\n    let pointerState = state.pointers.get(event.pointerId)\n    if (!pointerState) {\n      return\n    }\n\n    for (pointerState of state.pointers.values()) {\n      const node = pointerState.nodeId\n\n      const threshold = getPointerMoveDetectionThreshold(event.pointerType)\n      const isMoved = pointerState.moveCounter > threshold\n      if (isMoved) {\n        // pageX/Y in cancel event are zero => use latest position\n        const draggingNodes = _calculateNodeNewPosition(pointerState, {\n          pointerId: pointerState.pointerId,\n          pageX: pointerState.latestPosition.x,\n          pageY: pointerState.latestPosition.y,\n        })\n        emitter.emit(\"node:dragend\", draggingNodes)\n      }\n      emitter.emit(\"node:pointerup\", { node, event })\n    }\n\n    // reset state\n    state.pointers.clear()\n    state.follow = { followedPointerId: -1, nodeBasePositions: {} }\n    entriesOf(nodePointerHandlers).forEach(([ev, handler]) => {\n      document.removeEventListener(ev, handler)\n    })\n    modes.viewMode.value = \"default\"\n  }\n\n  function handleNodePointerUpEvent(event: PointerEvent) {\n    event.stopPropagation()\n\n    const pointerState = state.pointers.get(event.pointerId)\n    if (!pointerState) {\n      return\n    }\n\n    state.pointers.delete(event.pointerId)\n\n    const node = pointerState.nodeId\n\n    const threshold = getPointerMoveDetectionThreshold(event.pointerType)\n    const isMoved = pointerState.moveCounter > threshold\n    if (isMoved) {\n      if (nodeStates[pointerState.nodeId]?.draggable) {\n        const draggingNodes = _calculateNodeNewPosition(pointerState, event)\n        emitter.emit(\"node:dragend\", draggingNodes)\n        emitter.emit(\"node:pointerup\", { node, event })\n      }\n    } else {\n      emitter.emit(\"node:pointerup\", { node, event })\n    }\n\n    if (!isMoved /* Don't fire the click event if the node is being dragged */) {\n      // click handling\n      const [clickEvent, doubleClickEvent] = detectClicks(\n        state.clicks,\n        pointerState.pointerId,\n        node,\n        event\n      )\n      pointerState.eventTarget?.dispatchEvent(clickEvent)\n      if (doubleClickEvent) {\n        pointerState.eventTarget?.dispatchEvent(doubleClickEvent)\n      }\n    }\n\n    if (state.pointers.size === 0) {\n      // re-initialize state\n      state.follow = { followedPointerId: -1, nodeBasePositions: {} }\n      entriesOf(nodePointerHandlers).forEach(([ev, handler]) => {\n        document.removeEventListener(ev, handler)\n      })\n      cleanClickState(state.clicks)\n      modes.viewMode.value = \"default\"\n    } else {\n      _updateFollowNodes(pointerState)\n    }\n\n    // reflect changes while dragging.\n    hoveredNodes.clear()\n    state.hoveredNodesPre.forEach(hoveredNodes.add, hoveredNodes)\n  }\n\n  function handleNodePointerDownEvent(node: string, event: PointerEvent) {\n    if (event.button == 2 /* right button */) {\n      return\n    }\n    event.stopPropagation()\n\n    if (![\"default\", \"node\"].includes(modes.viewMode.value)) {\n      return\n    }\n\n    if (state.pointers.size == 0) {\n      // Add event listeners\n      modes.viewMode.value = \"node\"\n      entriesOf(nodePointerHandlers).forEach(([ev, handler]) => {\n        document.addEventListener(ev, handler)\n      })\n    }\n\n    // Create new pointer state\n    const pointerState: NodePointerState = {\n      pointerId: event.pointerId,\n      nodeId: node,\n      moveCounter: 0,\n      nodeBasePosition: _unwrapNodePosition(layouts.nodes, node),\n      dragBasePosition: { x: event.pageX, y: event.pageY },\n      latestPosition: { x: event.pageX, y: event.pageY },\n      eventTarget: event.currentTarget,\n    }\n    state.pointers.set(event.pointerId, pointerState)\n\n    if (selectedNodes.has(node)) {\n      if (state.follow.followedPointerId < 0) {\n        // pointer followed by selected nodes\n        state.follow.followedPointerId = event.pointerId\n        _updateFollowNodes(pointerState)\n      } else {\n        // current pointer is in charge of this node.\n        // do not follow another node anymore.\n        delete state.follow.nodeBasePositions[pointerState.nodeId]\n      }\n    }\n\n    emitter.emit(\"node:pointerdown\", { node, event })\n  }\n\n  function handleNodePointerOverEvent(node: string, event: PointerEvent) {\n    state.hoveredNodesPre.add(node)\n    if (state.pointers.size > 0) {\n      return // dragging\n    }\n    hoveredNodes.add(node)\n    emitter.emit(\"node:pointerover\", { node, event })\n  }\n\n  function handleNodePointerOutEvent(node: string, event: PointerEvent) {\n    state.hoveredNodesPre.delete(node)\n    if (state.pointers.size > 0) {\n      return // dragging\n    }\n    hoveredNodes.delete(node)\n    emitter.emit(\"node:pointerout\", { node, event })\n  }\n\n  function handleNodeContextMenu(node: string, event: MouseEvent) {\n    event.stopPropagation()\n    emitter.emit(\"node:contextmenu\", { node, event })\n  }\n\n  return {\n    handleNodePointerDownEvent,\n    handleNodePointerOverEvent,\n    handleNodePointerOutEvent,\n    handleNodeClickEvent,\n    handleNodeDoubleClickEvent,\n    handleNodeContextMenu,\n  }\n}\n\nfunction _unwrapNodePosition(nodes: Readonly<NodePositions>, node: string) {\n  const pos = nodes[node] ?? { x: 0, y: 0 }\n  return { ...pos } // unwrap reactivity\n}\n","import { watch } from \"vue\"\nimport { Emitter } from \"mitt\"\nimport { Reactive } from \"@/common/common\"\nimport { Events, EdgeEvent } from \"@/common/types\"\nimport { EdgeStates } from \"@/models/edge\"\nimport { entriesOf } from \"@/utils/object\"\nimport { MapUtil } from \"@/utils/map\"\nimport {\n  cleanClickState,\n  ClickState,\n  detectClicks,\n  EdgePointerState,\n  InteractionModes,\n} from \"./core\"\n\nexport function makeEdgeInteractionHandlers(\n  edgeStates: EdgeStates,\n  modes: InteractionModes,\n  hoveredEdges: Reactive<Set<string>>,\n  selectedEdges: Reactive<Set<string>>,\n  emitter: Emitter<Events>\n) {\n  const state = {\n    pointers: new Map<number, EdgePointerState>(), // <PointerId, ...>\n    pointerPeekCount: 0,\n    clicks: new Map<number, ClickState>(),\n  }\n\n  const edgePointerHandlers = {\n    pointerup: handleEdgePointerUpEvent,\n    pointercancel: handleEdgePointerCancelEvent,\n  }\n\n  watch(selectedEdges, selected => {\n    if (selected.size > 0 && modes.selectionMode.value !== \"edge\") {\n      modes.selectionMode.value = \"edge\"\n    } else if (selected.size === 0 && modes.selectionMode.value === \"edge\") {\n      modes.selectionMode.value = \"container\"\n    }\n  })\n\n  watch(modes.selectionMode, mode => {\n    if (mode !== \"edge\") {\n      selectedEdges.clear()\n    }\n  })\n\n  function handleEdgePointerDownEvent(edge: string, event: PointerEvent) {\n    if (event.button == 2 /* right button */) {\n      return\n    }\n    event.stopPropagation()\n\n    if (![\"default\", \"edge\"].includes(modes.viewMode.value)) {\n      return\n    }\n\n    if (state.pointers.size == 0) {\n      // Add event listeners\n      modes.viewMode.value = \"edge\"\n      entriesOf(edgePointerHandlers).forEach(([ev, handler]) => {\n        document.addEventListener(ev, handler)\n      })\n      state.pointerPeekCount = 0\n    }\n\n    state.pointerPeekCount++\n\n    // Create new pointer state\n    const pointerState: EdgePointerState = {\n      pointerId: event.pointerId,\n      id: edge,\n      eventTarget: event.currentTarget,\n    }\n    state.pointers.set(event.pointerId, pointerState)\n\n    emitter.emit(\"edge:pointerdown\", _makeEdgeEventObject(edge, event))\n  }\n\n  function handleEdgePointerUpEvent(event: PointerEvent) {\n    event.stopPropagation()\n\n    const pointerState = state.pointers.get(event.pointerId)\n    if (!pointerState) {\n      return\n    }\n\n    state.pointers.delete(event.pointerId)\n\n    const edge = pointerState.id\n    emitter.emit(\"edge:pointerup\", _makeEdgeEventObject(edge, event))\n\n    // click handling\n    const [clickEvent, doubleClickEvent] = detectClicks(\n      state.clicks,\n      pointerState.pointerId,\n      edge instanceof Array ? edge.join(\",\") : edge,\n      event,\n    )\n    pointerState.eventTarget?.dispatchEvent(clickEvent)\n    if (doubleClickEvent) {\n      pointerState.eventTarget?.dispatchEvent(doubleClickEvent)\n    }\n\n    if (state.pointers.size === 0) {\n      // reset state\n      state.pointerPeekCount = 0\n      entriesOf(edgePointerHandlers).forEach(([ev, handler]) => {\n        document.removeEventListener(ev, handler)\n      })\n      cleanClickState(state.clicks)\n      modes.viewMode.value = \"default\"\n    }\n  }\n\n  function handleEdgePointerCancelEvent(event: PointerEvent) {\n    event.stopPropagation()\n\n    const pointerState = state.pointers.get(event.pointerId)\n    if (!pointerState) {\n      return\n    }\n\n    for (const pointerState of state.pointers.values()) {\n      const edge = pointerState.id\n      emitter.emit(\"edge:pointerup\", _makeEdgeEventObject(edge, event))\n    }\n\n    // reset state\n    state.pointers.clear()\n    state.pointerPeekCount = 0\n    entriesOf(edgePointerHandlers).forEach(([ev, handler]) => {\n      document.removeEventListener(ev, handler)\n    })\n    emitter.emit(\"view:mode\", \"default\")\n  }\n\n  function handleEdgeClickEvent(edge: string | string[], event: MouseEvent) {\n    if (event.isTrusted) return // native event\n    // When a finger is placed on any object and another object is tapped,\n    // no click event is fired. Thus, click events are emulated by using\n    // pointerdown/up. The following is processing for emulated events only.\n\n    if (event.shiftKey && ![\"container\", \"edge\"].includes(modes.selectionMode.value)) {\n      return\n    }\n    modes.selectionMode.value = \"edge\"\n\n    const edges = edge instanceof Array ? edge : [edge]\n\n    const isTouchAnySelectedEdge =\n      MapUtil.valueOf(state.pointers).filter(p => {\n        const edges = p.id instanceof Array ? p.id : [p.id]\n        return edges.every(edge => selectedEdges.has(edge))\n      }).length > 0\n\n    if (edge instanceof Array) {\n      // select only selectable edge\n      const selectableEdges = edges.find(edge => edgeStates[edge]?.selectable)\n      if (selectableEdges) {\n        if (event.shiftKey || isTouchAnySelectedEdge) {\n          if (edges.some(edge => selectedEdges.has(edge))) {\n            edges.forEach(edge => selectedEdges.delete(edge))\n          } else {\n            edges.forEach(edge => {\n              const selectable = edgeStates[edge]?.selectable\n              if (!(typeof selectable === \"number\" && selectedEdges.size >= selectable)) {\n                selectedEdges.add(edge)\n              }\n            })\n          }\n        } else {\n          // make the selectedEdges the clicked summarized one\n          selectedEdges.clear()\n          edges.forEach(edge => selectedEdges.add(edge))\n        }\n      }\n    } else {\n      const selectable = edgeStates[edge]?.selectable\n      if (selectable) {\n        if (event.shiftKey || isTouchAnySelectedEdge) {\n          if (selectedEdges.has(edge)) {\n            selectedEdges.delete(edge)\n          } else if (!(typeof selectable === \"number\" && selectedEdges.size >= selectable)) {\n            selectedEdges.add(edge)\n          }\n        } else if (!selectedEdges.has(edge)) {\n          // make the selectedEdges the clicked one\n          selectedEdges.clear()\n          selectedEdges.add(edge)\n        }\n      }\n    }\n    emitter.emit(\"edge:click\", _makeEdgeEventObject(edge, event))\n  }\n\n  function handleEdgeDoubleClickEvent(edge: string | string[], event: MouseEvent) {\n    if (event.isTrusted) return // native event\n    emitter.emit(\"edge:dblclick\", _makeEdgeEventObject(edge, event))\n  }\n\n  function handleEdgePointerOverEvent(edge: string, event: PointerEvent) {\n    hoveredEdges.add(edge)\n    emitter.emit(\"edge:pointerover\", _makeEdgeEventObject(edge, event))\n  }\n\n  function handleEdgePointerOutEvent(edge: string, event: PointerEvent) {\n    hoveredEdges.delete(edge)\n    emitter.emit(\"edge:pointerout\", _makeEdgeEventObject(edge, event))\n  }\n\n  function handleEdgeContextMenu(edge: string, event: MouseEvent) {\n    event.stopPropagation()\n    emitter.emit(\"edge:contextmenu\", _makeEdgeEventObject(edge, event))\n  }\n\n  function handleEdgesPointerDownEvent(edges: string[], event: PointerEvent) {\n    if (event.button == 2 /* right button */) {\n      return\n    }\n    event.stopPropagation()\n\n    if (![\"default\", \"edge\"].includes(modes.viewMode.value)) {\n      return\n    }\n\n    if (state.pointers.size == 0) {\n      // Add event listeners\n      modes.viewMode.value = \"edge\"\n      entriesOf(edgePointerHandlers).forEach(([ev, handler]) => {\n        document.addEventListener(ev, handler)\n      })\n      state.pointerPeekCount = 0\n    }\n\n    state.pointerPeekCount++\n\n    // Create new pointer state\n    const pointerState: EdgePointerState = {\n      pointerId: event.pointerId,\n      id: edges,\n      eventTarget: event.currentTarget,\n    }\n    state.pointers.set(event.pointerId, pointerState)\n    emitter.emit(\"edge:pointerdown\", _makeEdgeEventObject(edges, event))\n  }\n\n  function handleEdgesPointerOverEvent(edges: string[], event: PointerEvent) {\n    edges.forEach(edge => hoveredEdges.add(edge))\n    emitter.emit(\"edge:pointerover\", _makeEdgeEventObject(edges, event))\n  }\n\n  function handleEdgesPointerOutEvent(edges: string[], event: PointerEvent) {\n    edges.forEach(edge => hoveredEdges.delete(edge))\n    emitter.emit(\"edge:pointerout\", _makeEdgeEventObject(edges, event))\n  }\n\n  function handleEdgesClickEvent(edges: string[], event: MouseEvent) {\n    handleEdgeClickEvent(edges, event)\n  }\n\n  function handleEdgesDoubleClickEvent(edges: string[], event: MouseEvent) {\n    handleEdgeDoubleClickEvent(edges, event)\n  }\n\n  function handleEdgesContextMenu(edges: string[], event: MouseEvent) {\n    event.stopPropagation()\n    emitter.emit(\"edge:contextmenu\", _makeEdgeEventObject(edges, event))\n  }\n\n  return {\n    handleEdgePointerDownEvent,\n    handleEdgePointerOverEvent,\n    handleEdgePointerOutEvent,\n    handleEdgeClickEvent,\n    handleEdgeDoubleClickEvent,\n    handleEdgeContextMenu,\n    handleEdgesPointerDownEvent,\n    handleEdgesPointerOverEvent,\n    handleEdgesPointerOutEvent,\n    handleEdgesClickEvent,\n    handleEdgesDoubleClickEvent,\n    handleEdgesContextMenu,\n  }\n}\n\nfunction _makeEdgeEventObject<T extends Event>(edge: string | string[], event: T): EdgeEvent<T> {\n  if (edge instanceof Array) {\n    return {\n      edges: edge,\n      event,\n      summarized: true,\n    }\n  } else {\n    return {\n      edge,\n      edges: [edge],\n      event,\n      summarized: false,\n    }\n  }\n}\n","import { onMounted, onUnmounted, Ref, watch } from \"vue\"\nimport { Emitter } from \"mitt\"\nimport { Events } from \"@/common/types\"\nimport { entriesOf } from \"@/utils/object\"\nimport {\n  ClickState,\n  createClickEvents,\n  getPointerMoveDetectionThreshold,\n  InteractionModes,\n} from \"./core\"\n\nexport function setupContainerInteractionHandlers(\n  container: Ref<SVGElement | undefined>,\n  modes: InteractionModes,\n  isSvgWheelZoomEnabled: Ref<boolean>,\n  emitter: Emitter<Events>\n) {\n  const state = {\n    moveCounter: 0,\n    pointerCounter: 0,\n    clickState: undefined as ClickState | undefined,\n  }\n\n  // measure the number of move events in the pointerdown state\n  // and use it to determine the click when pointerup.\n  const containerPointerHandlers = {\n    pointermove: handleContainerPointerMoveEvent,\n    pointerup: handleContainerPointerUpEvent,\n    pointercancel: handleContainerPointerUpEvent,\n  }\n\n  function handleContainerPointerDownEvent(_: PointerEvent) {\n    state.moveCounter = 0\n    if (state.pointerCounter === 0) {\n      // Add to event listener\n      entriesOf(containerPointerHandlers).forEach(([ev, handler]) => {\n        document.addEventListener(ev, handler, { passive: true })\n      })\n    }\n    state.pointerCounter++\n  }\n\n  function handleContainerPointerMoveEvent(_: PointerEvent) {\n    state.moveCounter++\n  }\n\n  function handleContainerPointerUpEvent(event: PointerEvent) {\n    state.pointerCounter--\n    if (state.pointerCounter <= 0) {\n      state.pointerCounter = 0\n      // Remove from event listener\n      entriesOf(containerPointerHandlers).forEach(([ev, handler]) => {\n        document.removeEventListener(ev, handler)\n      })\n      const threshold = getPointerMoveDetectionThreshold(event.pointerType)\n      if (state.moveCounter <= threshold) {\n        // Click container (without mouse move)\n        if (event.shiftKey && modes.selectionMode.value !== \"container\") {\n          return\n        }\n        modes.selectionMode.value = \"container\"\n\n        // click handling\n        const [clickState, clickEvent, doubleClickEvent] = createClickEvents(\n          state.clickState,\n          event,\n          \"view\"\n        )\n        state.clickState = clickState\n        container.value!.dispatchEvent(clickEvent)\n        if (doubleClickEvent) {\n          container.value!.dispatchEvent(doubleClickEvent)\n        }\n      }\n    }\n  }\n\n  function handleContainerClickEvent(event: MouseEvent) {\n    if (event.isTrusted) return // native event\n    // When a finger is placed on any object and another object is tapped,\n    // no click event is fired. Thus, click events are emulated by using\n    // pointerdown/up. The following is processing for emulated events only.\n    event.stopPropagation()\n    emitter.emit(\"view:click\", { event })\n  }\n\n  function handleContainerDoubleClickEvent(event: MouseEvent) {\n    if (event.isTrusted) return // native event\n    event.stopPropagation()\n    emitter.emit(\"view:dblclick\", { event })\n  }\n\n  function handleContainerContextMenuEvent(event: MouseEvent) {\n    emitter.emit(\"view:contextmenu\", { event })\n\n    if (state.pointerCounter > 0) {\n      // reset pointer down state\n      state.pointerCounter = 0\n      // Remove from event listener\n      entriesOf(containerPointerHandlers).forEach(([ev, handler]) => {\n        container.value?.removeEventListener(ev, handler)\n      })\n    }\n  }\n\n  const preventDefault = (e: MouseEvent) => {\n    e.preventDefault()\n  }\n\n  onMounted(() => {\n    const c = container.value\n    if (!c) return\n    c.addEventListener(\"pointerdown\", handleContainerPointerDownEvent, { passive: true })\n    c.addEventListener(\"click\", handleContainerClickEvent, { passive: false })\n    c.addEventListener(\"dblclick\", handleContainerDoubleClickEvent, { passive: false })\n    c.addEventListener(\"contextmenu\", handleContainerContextMenuEvent, { passive: false })\n    if (isSvgWheelZoomEnabled.value) {\n      c.addEventListener(\"wheel\", preventDefault, { passive: false })\n    }\n  })\n\n  onUnmounted(() => {\n    const c = container.value\n    if (!c) return\n    c.removeEventListener(\"pointerdown\", handleContainerPointerDownEvent)\n    c.removeEventListener(\"click\", handleContainerClickEvent)\n    c.removeEventListener(\"dblclick\", handleContainerDoubleClickEvent)\n    c.removeEventListener(\"contextmenu\", handleContainerContextMenuEvent)\n    if (isSvgWheelZoomEnabled.value) {\n      c.removeEventListener(\"wheel\", preventDefault)\n    }\n  })\n\n  watch(isSvgWheelZoomEnabled, (enabled, old) => {\n    const c = container.value\n    if (!c || enabled === old) return\n\n    if (enabled) {\n      c.addEventListener(\"wheel\", preventDefault, { passive: false })\n    } else {\n      c.removeEventListener(\"wheel\", preventDefault)\n    }\n  })\n}\n","import { Ref, watch } from \"vue\"\nimport { Reactive } from \"@/common/common\"\nimport { Events, PathEvent } from \"@/common/types\"\nimport { PathStates } from \"@/models/path\"\nimport {\n  cleanClickState,\n  ClickState,\n  detectClicks,\n  InteractionModes,\n  PathPointerState,\n} from \"./core\"\nimport { entriesOf } from \"@/utils/object\"\nimport { MapUtil } from \"@/utils/map\"\nimport { Emitter } from \"mitt\"\n\nexport function makePathInteractionHandlers(\n  pathStates: PathStates,\n  modes: InteractionModes,\n  hoveredPaths: Reactive<Set<string>>,\n  selectedPaths: Reactive<Set<string>>,\n  isInCompatibilityModeForPath: Ref<boolean>,\n  emitter: Emitter<Events>\n) {\n  const state = {\n    pointers: new Map<number, PathPointerState>(), // <PointerId, ...>\n    pointerPeekCount: 0,\n    clicks: new Map<number, ClickState>(),\n  }\n\n  function _makePathEventObject<T extends Event>(path: string, event: T): PathEvent<T> {\n    if (isInCompatibilityModeForPath.value) {\n      return { path: (pathStates[path]?.path ?? path) as any, event }\n    } else {\n      return { path, event }\n    }\n  }\n\n  const pathPointerHandlers = {\n    pointerup: handlePathPointerUpEvent,\n    pointercancel: handlePathPointerCancelEvent,\n  }\n\n  watch(selectedPaths, selected => {\n    if (selected.size > 0 && modes.selectionMode.value !== \"path\") {\n      modes.selectionMode.value = \"path\"\n    } else if (selected.size === 0 && modes.selectionMode.value === \"path\") {\n      modes.selectionMode.value = \"container\"\n    }\n  })\n\n  watch(modes.selectionMode, mode => {\n    if (mode !== \"path\") {\n      selectedPaths.clear()\n    }\n  })\n\n  function handlePathPointerDownEvent(path: string, event: PointerEvent) {\n    if (!pathStates[path]?.clickable) {\n      return\n    }\n\n    if (event.button == 2 /* right button */) {\n      return\n    }\n    event.stopPropagation()\n\n    if (![\"default\", \"path\"].includes(modes.viewMode.value)) {\n      return\n    }\n\n    if (state.pointers.size == 0) {\n      // Add event listeners\n      modes.viewMode.value = \"path\"\n      entriesOf(pathPointerHandlers).forEach(([ev, handler]) => {\n        document.addEventListener(ev, handler)\n      })\n      state.pointerPeekCount = 0\n    }\n\n    state.pointerPeekCount++\n\n    // Create new pointer state\n    const pointerState: PathPointerState = {\n      pointerId: event.pointerId,\n      id: path,\n      eventTarget: event.currentTarget,\n    }\n    state.pointers.set(event.pointerId, pointerState)\n\n    emitter.emit(\"path:pointerdown\", _makePathEventObject(path, event))\n  }\n\n  function handlePathPointerUpEvent(event: PointerEvent) {\n    const pointerState = state.pointers.get(event.pointerId)\n    if (!pointerState) {\n      return\n    }\n\n    event.stopPropagation()\n\n    state.pointers.delete(event.pointerId)\n\n    const path = pointerState.id\n    emitter.emit(\"path:pointerup\", _makePathEventObject(path, event))\n\n    // click handling\n    const [clickEvent, doubleClickEvent] = detectClicks(\n      state.clicks,\n      pointerState.pointerId,\n      path,\n      event\n    )\n    pointerState.eventTarget?.dispatchEvent(clickEvent)\n    if (doubleClickEvent) {\n      pointerState.eventTarget?.dispatchEvent(doubleClickEvent)\n    }\n\n    if (state.pointers.size === 0) {\n      // reset state\n      state.pointerPeekCount = 0\n      entriesOf(pathPointerHandlers).forEach(([ev, handler]) => {\n        document.removeEventListener(ev, handler)\n      })\n      cleanClickState(state.clicks)\n      modes.viewMode.value = \"default\"\n    }\n  }\n\n  function handlePathPointerCancelEvent(event: PointerEvent) {\n    const pointerState = state.pointers.get(event.pointerId)\n    if (!pointerState) {\n      return\n    }\n\n    event.stopPropagation()\n\n    for (const pointerState of state.pointers.values()) {\n      const path = pointerState.id\n      emitter.emit(\"path:pointerup\", _makePathEventObject(path, event))\n    }\n\n    // reset state\n    state.pointers.clear()\n    state.pointerPeekCount = 0\n    entriesOf(pathPointerHandlers).forEach(([ev, handler]) => {\n      document.removeEventListener(ev, handler)\n    })\n    emitter.emit(\"view:mode\", \"default\")\n  }\n\n  function handlePathPointerOverEvent(path: string, event: PointerEvent) {\n    if (!pathStates[path]?.hoverable) {\n      return\n    }\n    hoveredPaths.add(path)\n    emitter.emit(\"path:pointerover\", _makePathEventObject(path, event))\n  }\n\n  function handlePathPointerOutEvent(path: string, event: PointerEvent) {\n    if (!pathStates[path]?.hoverable) {\n      return\n    }\n    hoveredPaths.delete(path)\n    emitter.emit(\"path:pointerout\", _makePathEventObject(path, event))\n  }\n\n  function handlePathClickEvent(path: string, event: MouseEvent) {\n    if (event.isTrusted) return // native event\n    // When a finger is placed on any object and another object is tapped,\n    // no click event is fired. Thus, click events are emulated by using\n    // pointerdown/up. The following is processing for emulated events only.\n\n    if (!pathStates[path]?.clickable) {\n      return\n    }\n\n    if (event.shiftKey && ![\"container\", \"path\"].includes(modes.selectionMode.value)) {\n      return\n    }\n    modes.selectionMode.value = \"path\"\n\n    const selectable = pathStates[path]?.selectable ?? false\n    if (selectable) {\n      const isTouchAnySelectedPath =\n        MapUtil.valueOf(state.pointers).filter(p => selectedPaths.has(p.id)).length > 0\n      if (event.shiftKey || isTouchAnySelectedPath) {\n        // select multiple nodes\n        if (selectedPaths.has(path)) {\n          selectedPaths.delete(path)\n        } else if (!(typeof selectable === \"number\" && selectedPaths.size >= selectable)) {\n          selectedPaths.add(path)\n        }\n      } else if (!selectedPaths.has(path)) {\n        // make the selectedPaths the clicked one\n        selectedPaths.clear()\n        selectedPaths.add(path)\n      }\n    }\n    emitter.emit(\"path:click\", _makePathEventObject(path, event))\n  }\n\n  function handlePathDoubleClickEvent(path: string, event: MouseEvent) {\n    if (event.isTrusted) return // native event\n    if (!pathStates[path]?.clickable) {\n      return\n    }\n    emitter.emit(\"path:dblclick\", _makePathEventObject(path, event))\n  }\n\n  function handlePathContextMenu(path: string, event: MouseEvent) {\n    if (!pathStates[path]?.clickable) {\n      return\n    }\n    event.stopPropagation()\n    emitter.emit(\"path:contextmenu\", _makePathEventObject(path, event))\n  }\n\n  return {\n    handlePathPointerDownEvent,\n    handlePathPointerOverEvent,\n    handlePathPointerOutEvent,\n    handlePathClickEvent,\n    handlePathDoubleClickEvent,\n    handlePathContextMenu,\n  }\n}\n","/**\n * The base implementation of `_.slice` without an iteratee call guard.\n *\n * @private\n * @param {Array} array The array to slice.\n * @param {number} [start=0] The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns the slice of `array`.\n */\nfunction baseSlice(array, start, end) {\n  var index = -1,\n      length = array.length;\n\n  if (start < 0) {\n    start = -start > length ? 0 : (length + start);\n  }\n  end = end > length ? length : end;\n  if (end < 0) {\n    end += length;\n  }\n  length = start > end ? 0 : ((end - start) >>> 0);\n  start >>>= 0;\n\n  var result = Array(length);\n  while (++index < length) {\n    result[index] = array[index + start];\n  }\n  return result;\n}\n\nexport default baseSlice;\n","import baseSlice from './_baseSlice.js';\nimport isIterateeCall from './_isIterateeCall.js';\nimport toInteger from './toInteger.js';\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeCeil = Math.ceil,\n    nativeMax = Math.max;\n\n/**\n * Creates an array of elements split into groups the length of `size`.\n * If `array` can't be split evenly, the final chunk will be the remaining\n * elements.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Array\n * @param {Array} array The array to process.\n * @param {number} [size=1] The length of each chunk\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n * @returns {Array} Returns the new array of chunks.\n * @example\n *\n * _.chunk(['a', 'b', 'c', 'd'], 2);\n * // => [['a', 'b'], ['c', 'd']]\n *\n * _.chunk(['a', 'b', 'c', 'd'], 3);\n * // => [['a', 'b', 'c'], ['d']]\n */\nfunction chunk(array, size, guard) {\n  if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {\n    size = 1;\n  } else {\n    size = nativeMax(toInteger(size), 0);\n  }\n  var length = array == null ? 0 : array.length;\n  if (!length || size < 1) {\n    return [];\n  }\n  var index = 0,\n      resIndex = 0,\n      result = Array(nativeCeil(length / size));\n\n  while (index < length) {\n    result[resIndex++] = baseSlice(array, index, (index += size));\n  }\n  return result;\n}\n\nexport default chunk;\n","import root from './_root.js';\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\nexport default now;\n","import isObject from './isObject.js';\nimport now from './now.js';\nimport toNumber from './toNumber.js';\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        timeWaiting = wait - timeSinceLastCall;\n\n    return maxing\n      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)\n      : timeWaiting;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        clearTimeout(timerId);\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\nexport default debounce;\n","import { Point } from \"@/common/types\"\n\nexport function translateFromDomToSvgCoordinates(\n  svg: SVGSVGElement,\n  viewport: SVGGElement,\n  coordinates: Point\n): Point {\n  const point = svg.createSVGPoint()\n  point.x = coordinates.x\n  point.y = coordinates.y\n  const svgPoint = point.matrixTransform(viewport.getCTM()?.inverse())\n  return { x: svgPoint.x, y: svgPoint.y }\n}\n\nexport function translateFromSvgToDomCoordinates(\n  svg: SVGSVGElement,\n  viewport: SVGGElement,\n  coordinates: Point\n): Point {\n  const point = svg.createSVGPoint()\n  point.x = coordinates.x\n  point.y = coordinates.y\n  const domPoint = point.matrixTransform(viewport.getCTM() as DOMMatrixInit)\n  return { x: domPoint.x, y: domPoint.y }\n}\n","import { computed, onMounted, onUnmounted, ref, Ref, watch } from \"vue\"\nimport { debounce } from \"lodash-es\"\nimport { nonNull, Reactive } from \"@/common/common\"\nimport { Configs } from \"@/common/configs\"\nimport { Layouts, NodePositions, Point, Rectangle } from \"@/common/types\"\nimport { Vector2D } from \"@/modules/vector2d\"\nimport { NodeStates } from \"@/models/node\"\nimport { translateFromDomToSvgCoordinates } from \"@/utils/svg\"\nimport { InteractionModes } from \"./core\"\n\n// ------------------------------------------------------------------\n// Types\n// ------------------------------------------------------------------\n\nexport type StopTrigger = \"pointerup\" | \"click\" | \"manual\"\nexport type SelectionType = \"append\" | \"invert\"\n\nexport interface BoxSelectionOption {\n  stop: StopTrigger\n  type: SelectionType\n  withShiftKey: SelectionType | \"same\"\n}\n\n// ------------------------------------------------------------------\n// Export functions\n// ------------------------------------------------------------------\n\nexport function makeBoxSelectionMethods(\n  container: Ref<SVGElement | undefined>,\n  modes: InteractionModes,\n  layouts: Readonly<Layouts>,\n  nodeStates: NodeStates,\n  selectedNodes: Reactive<Set<string>>,\n  configs: Configs\n) {\n  const isBoxSelectionEnabled = computed(\n    () => !!configs.node.selectable && configs.view.boxSelectionEnabled\n  )\n  const isBoxSelectionMode = computed(() => modes.viewMode.value === \"box-selection\")\n\n  // ------------------------------------------------------------------\n  // States\n  // ------------------------------------------------------------------\n  const viewport = ref<SVGGElement>()\n  const selectionBox = ref<Rectangle>()\n  const states = {\n    pointers: new Set<number>(), // Set of pointers being pressed\n    points: new Map<number, Point>(), // Point indicated by each pointer\n    startPoint: null as Point | null, // Point where the drag started\n    selectedNodesAtSelectStarted: new Set<string>(), // Nodes selected at the start of the selection\n    selectionType: \"append\" as SelectionType, // Selection method for nodes included in the dragged range\n    options: {\n      // options specified by user at start of selection mode\n      stopTrigger: \"pointerup\" as StopTrigger,\n      selectionType: \"append\" as SelectionType,\n      selectionTypeWithShiftKey: \"same\" as SelectionType | \"same\",\n    },\n  }\n\n  // ------------------------------------------------------------------\n  // Private functions\n  // ------------------------------------------------------------------\n\n  const updateNodesSelection = debounce(\n    () => {\n      _updateNodesSelection(\n        nonNull(container.value, \"container\") as SVGSVGElement,\n        nonNull(viewport.value, \"viewport\"),\n        selectionBox,\n        layouts.nodes,\n        nodeStates,\n        selectedNodes,\n        states.selectedNodesAtSelectStarted,\n        states.selectionType\n      )\n    },\n    50,\n    { maxWait: 100 }\n  )\n\n  // ------------------------------------------------------------------\n  // Pointer event handlers\n  // ------------------------------------------------------------------\n  const pointerEventHandler = new PointerEventRegistrar(\n    container,\n    handlePointerDownEvent,\n    handlePointerUpEvent,\n    handlePointerMoveEvent,\n    handleClickEvent,\n    handleKeyDownEvent\n  )\n\n  function handleClickEvent(event: MouseEvent) {\n    if (states.options.stopTrigger !== \"click\") return\n    if (states.pointers.size > 0) return\n\n    const point = { x: event.offsetX, y: event.offsetY }\n    if (states.startPoint && Vector2D.fromObject(states.startPoint).distance(point) > 10) {\n      return // ignore in dragging\n    }\n    stopBoxSelection()\n  }\n\n  function handlePointerDownEvent(event: PointerEvent) {\n    event.stopPropagation()\n\n    const point = { x: event.offsetX, y: event.offsetY }\n    if (states.pointers.size === 0) {\n      states.startPoint = point\n\n      pointerEventHandler.activate()\n\n      states.selectedNodesAtSelectStarted.clear()\n      selectedNodes.forEach(nodeId => states.selectedNodesAtSelectStarted.add(nodeId))\n      if (states.options.selectionTypeWithShiftKey === \"same\") {\n        states.selectionType = states.options.selectionType\n      } else {\n        states.selectionType = event.shiftKey\n          ? states.options.selectionTypeWithShiftKey\n          : states.options.selectionType\n      }\n    }\n    if (!states.pointers.has(event.pointerId)) {\n      states.pointers.add(event.pointerId)\n    }\n    states.points.set(event.pointerId, point)\n    updateRectangle()\n  }\n\n  function handlePointerUpEvent(event: PointerEvent) {\n    states.pointers.delete(event.pointerId)\n    if (states.pointers.size === 1) {\n      const rect = nonNull(container.value).getBoundingClientRect()\n      const point = { x: event.x - rect.x, y: event.y - rect.y }\n      states.startPoint = point\n    } else if (states.pointers.size === 0) {\n      pointerEventHandler.deactivate()\n      if (states.options.stopTrigger === \"pointerup\") {\n        stopBoxSelection()\n      }\n      states.selectedNodesAtSelectStarted.clear()\n    }\n    updateRectangle()\n  }\n\n  function handlePointerMoveEvent(event: PointerEvent) {\n    const rect = nonNull(container.value).getBoundingClientRect()\n    const point = { x: event.x - rect.x, y: event.y - rect.y }\n    states.points.set(event.pointerId, point)\n    updateRectangle()\n    updateNodesSelection()\n  }\n\n  function handleKeyDownEvent(event: KeyboardEvent) {\n    if (event.key === \"Escape\" && states.options.stopTrigger !== \"manual\") {\n      event.stopPropagation()\n      stopBoxSelection()\n    }\n  }\n\n  function updateRectangle() {\n    let pos1: Point | undefined\n    let pos2: Point | undefined\n    const pointerArray = Array.from(states.pointers)\n    if (pointerArray.length >= 2) {\n      const first = pointerArray[0]\n      const last = pointerArray[pointerArray.length - 1]\n      pos1 = states.points.get(first)\n      pos2 = states.points.get(last)\n    } else if (states.startPoint && pointerArray.length === 1) {\n      const first = pointerArray[0]\n      pos1 = states.startPoint\n      pos2 = states.points.get(first)\n    } else {\n      pos1 = undefined\n      pos2 = undefined\n    }\n    if (pos1 && pos2) {\n      // calculate left top position and size\n      selectionBox.value = {\n        pos: {\n          x: Math.min(pos1.x, pos2.x),\n          y: Math.min(pos1.y, pos2.y),\n        },\n        size: {\n          width: Math.abs(pos2.x - pos1.x),\n          height: Math.abs(pos2.y - pos1.y),\n        },\n      }\n      if (selectionBox.value.size.width === 0) {\n        selectionBox.value.size.width = 1\n      }\n      if (selectionBox.value.size.height === 0) {\n        selectionBox.value.size.height = 1\n      }\n    } else if (selectionBox.value) {\n      selectionBox.value = undefined\n    }\n  }\n\n  // ------------------------------------------------------------------\n  // Ctrl/Cmd key box selection\n  // ------------------------------------------------------------------\n  const keyEventRegistrar = new KeyEventRegistrar(\n    container,\n    // key down\n    (event: KeyboardEvent) => {\n      if (!isBoxSelectionEnabled.value) return\n      if (configs.view.selection.detector(event)) {\n        startBoxSelection({\n          stop: \"manual\",\n          type: \"append\",\n          withShiftKey: \"invert\",\n        })\n        keyEventRegistrar.activate()\n      }\n    },\n    // key up\n    (event: KeyboardEvent) => {\n      if (!isBoxSelectionEnabled.value) return\n      if (configs.view.selection.detector(event)) {\n        if (states.pointers.size === 0) {\n          stopBoxSelection()\n        } else {\n          states.options.stopTrigger = \"pointerup\"\n        }\n        keyEventRegistrar.deactivate()\n      }\n    }\n  )\n\n  watch(isBoxSelectionEnabled, value => {\n    if (value) {\n      keyEventRegistrar.register()\n    } else {\n      keyEventRegistrar.unregister()\n    }\n  })\n\n  // ------------------------------------------------------------------\n  // Lifecycle process\n  // ------------------------------------------------------------------\n\n  onMounted(() => {\n    viewport.value = container.value?.querySelector(\".v-viewport\") as SVGGElement\n    if (isBoxSelectionEnabled.value) {\n      keyEventRegistrar.register()\n    }\n  })\n\n  onUnmounted(() => {\n    stopBoxSelection()\n    if (isBoxSelectionEnabled.value) {\n      keyEventRegistrar.unregister()\n    }\n  })\n\n  // ------------------------------------------------------------------\n  // Expose functions\n  // ------------------------------------------------------------------\n\n  function startBoxSelection(options: Partial<BoxSelectionOption> = {}) {\n    // Even if it's already in selection mode, behavior changes are acceptable.\n    states.options = {\n      stopTrigger: options.stop ?? \"pointerup\",\n      selectionType: options.type ?? \"append\",\n      selectionTypeWithShiftKey: options.withShiftKey ?? \"same\",\n    }\n\n    if (modes.viewMode.value === \"box-selection\") return\n    modes.viewMode.value = \"box-selection\"\n\n    states.pointers.clear()\n    pointerEventHandler.register()\n  }\n\n  function stopBoxSelection() {\n    if (modes.viewMode.value !== \"box-selection\") return\n    modes.viewMode.value = \"default\"\n    pointerEventHandler.unregister()\n  }\n\n  return { isBoxSelectionMode, selectionBox, startBoxSelection, stopBoxSelection }\n}\n\n// ------------------------------------------------------------------\n// Package local functions\n// ------------------------------------------------------------------\n\nfunction _updateNodesSelection(\n  svg: SVGSVGElement,\n  viewport: SVGGElement,\n  selectionBox: Ref<Rectangle | undefined>,\n  nodePositions: Readonly<NodePositions>,\n  nodeStates: Readonly<NodeStates>,\n  selectedNodes: Reactive<Set<string>>,\n  selectedNodesAtSelectStarted: Set<string>,\n  selectionType: SelectionType\n) {\n  if (!selectionBox.value) return\n  const box = selectionBox.value\n  const pos1 = translateFromDomToSvgCoordinates(svg, viewport, box.pos)\n  const pos2 = translateFromDomToSvgCoordinates(svg, viewport, {\n    x: box.pos.x + box.size.width,\n    y: box.pos.y + box.size.height,\n  })\n\n  // find enclosed nodes\n  const enclosedNodes = new Set(\n    Object.entries(nodePositions)\n      .filter(([_, pos]) => {\n        return pos1.x <= pos.x && pos.x <= pos2.x && pos1.y <= pos.y && pos.y <= pos2.y\n      })\n      .map(([nodeId, _]) => nodeId)\n  )\n\n  if (selectionType === \"append\") {\n    selectedNodes.forEach(nodeId => {\n      if (!enclosedNodes.has(nodeId)) {\n        selectedNodes.delete(nodeId)\n      }\n    })\n    enclosedNodes.forEach(nodeId => {\n      const selectable = nodeStates[nodeId]?.selectable ?? false\n      if (\n        selectable === true ||\n        (typeof selectable === \"number\" && selectedNodes.size < selectable)\n      ) {\n        selectedNodes.add(nodeId)\n      }\n    })\n  } else {\n    // selectionType === \"invert\"\n    const temporary = new Set<string>(selectedNodesAtSelectStarted)\n    temporary.forEach(nodeId => {\n      if (enclosedNodes.has(nodeId)) {\n        temporary.delete(nodeId)\n      }\n    })\n    enclosedNodes.forEach(nodeId => {\n      if (!selectedNodesAtSelectStarted.has(nodeId)) {\n        const selectable = nodeStates[nodeId]?.selectable ?? false\n        if (\n          selectable === true ||\n          (typeof selectable === \"number\" && temporary.size < selectable)\n        ) {\n          temporary.add(nodeId)\n        }\n      }\n    })\n    // replace\n    selectedNodes.clear()\n    temporary.forEach(nodeId => selectedNodes.add(nodeId))\n  }\n}\n\n// ------------------------------------------------------------------\n// Event register/unregister\n// ------------------------------------------------------------------\n\ntype KeyboardEventHandler = (event: KeyboardEvent) => void\ntype PointerEventHandler = (event: PointerEvent) => void\ntype MouseEventHandler = (event: MouseEvent) => void\n\nclass PointerEventRegistrar {\n  _container: Ref<SVGElement | undefined>\n  _handlePointerDownEvent: PointerEventHandler\n  _handlePointerUpEvent: PointerEventHandler\n  _handlePointerMoveEvent: PointerEventHandler\n  _handleClickEvent: MouseEventHandler\n  _handleKeyDownEvent: KeyboardEventHandler\n  _ignoreEvent: PointerEventHandler\n\n  constructor(\n    container: Ref<SVGElement | undefined>,\n    handlePointerDownEvent: PointerEventHandler,\n    handlePointerUpEvent: PointerEventHandler,\n    handlePointerMoveEvent: PointerEventHandler,\n    handleClickEvent: MouseEventHandler,\n    handleKeyDownEvent: KeyboardEventHandler\n  ) {\n    this._container = container\n    this._handlePointerDownEvent = handlePointerDownEvent\n    this._handlePointerUpEvent = handlePointerUpEvent\n    this._handlePointerMoveEvent = handlePointerMoveEvent\n    this._handleClickEvent = handleClickEvent\n    this._handleKeyDownEvent = handleKeyDownEvent\n    this._ignoreEvent = (event: PointerEvent) => event.stopPropagation()\n  }\n\n  register() {\n    const options = { capture: true, passive: false }\n    const container = nonNull(this._container.value, \"container\")\n    container.addEventListener(\"pointerdown\", this._handlePointerDownEvent, options)\n    container.addEventListener(\"click\", this._handleClickEvent, options)\n    container.addEventListener(\"pointerenter\", this._ignoreEvent, options)\n    container.addEventListener(\"pointerleave\", this._ignoreEvent, options)\n    document.addEventListener(\"keydown\", this._handleKeyDownEvent, options)\n  }\n\n  activate() {\n    const options = { capture: true, passive: false }\n    document.addEventListener(\"pointermove\", this._handlePointerMoveEvent, options)\n    document.addEventListener(\"pointerup\", this._handlePointerUpEvent, options)\n  }\n\n  deactivate() {\n    const options = { capture: true }\n    document.removeEventListener(\"pointermove\", this._handlePointerMoveEvent, options)\n    document.removeEventListener(\"pointerup\", this._handlePointerUpEvent, options)\n  }\n\n  unregister() {\n    this.deactivate()\n    const options = { capture: true }\n    if (this._container.value) {\n      const container = this._container.value\n      container.removeEventListener(\"pointerdown\", this._handlePointerDownEvent, options)\n      container.removeEventListener(\"click\", this._handleClickEvent, options)\n      container.removeEventListener(\"pointerenter\", this._ignoreEvent, options)\n      container.removeEventListener(\"pointerleave\", this._ignoreEvent, options)\n      document.removeEventListener(\"keydown\", this._handleKeyDownEvent, options)\n    }\n  }\n}\n\nclass KeyEventRegistrar {\n  _container: Ref<SVGElement | undefined>\n  _handleKeyDownEvent: KeyboardEventHandler\n  _handleKeyUpEvent: KeyboardEventHandler\n  _preventDefault: MouseEventHandler\n\n  constructor(\n    container: Ref<SVGElement | undefined>,\n    handleKeyDownEvent: KeyboardEventHandler,\n    handleKeyUpEvent: KeyboardEventHandler\n  ) {\n    this._container = container\n    this._handleKeyDownEvent = handleKeyDownEvent\n    this._handleKeyUpEvent = handleKeyUpEvent\n    this._preventDefault = (event: MouseEvent) => {\n      event.stopPropagation()\n      event.preventDefault()\n    }\n  }\n\n  register() {\n    document.addEventListener(\"keydown\", this._handleKeyDownEvent, { capture: true, passive: true })\n  }\n\n  activate() {\n    document.addEventListener(\"keyup\", this._handleKeyUpEvent, { capture: true, passive: true })\n    const container = nonNull(this._container.value, \"container\")\n    container.addEventListener(\"contextmenu\", this._preventDefault, { passive: false })\n  }\n\n  deactivate() {\n    document.removeEventListener(\"keyup\", this._handleKeyUpEvent, { capture: true })\n    if (this._container.value) {\n      const container = this._container.value\n      container.removeEventListener(\"contextmenu\", this._preventDefault)\n    }\n  }\n\n  unregister() {\n    this.deactivate()\n    document.removeEventListener(\"keydown\", this._handleKeyDownEvent, { capture: true })\n  }\n}\n","// Module responsible for selection state and mouse/touch operations\n\nimport { inject, InjectionKey, provide, ref, Ref, watch } from \"vue\"\nimport { Emitter } from \"mitt\"\nimport { nonNull, Reactive, ReadonlyRef } from \"@/common/common\"\nimport { Events, Layouts, Rectangle } from \"@/common/types\"\nimport { NodeStates } from \"@/models/node\"\nimport { EdgeStates } from \"@/models/edge\"\nimport { InteractionModes } from \"./core\"\nimport { makeNodeInteractionHandlers } from \"./node\"\nimport { makeEdgeInteractionHandlers } from \"./edge\"\nimport { setupContainerInteractionHandlers } from \"./container\"\nimport { PathStates } from \"@/models/path\"\nimport { makePathInteractionHandlers } from \"./path\"\nimport { BoxSelectionOption, makeBoxSelectionMethods } from \"./boxSelection\"\nimport { Configs, ViewConfig } from \"@/common/configs\"\n\ntype NodeEventHandler<T extends Event = PointerEvent> = (node: string, event: T) => void\ntype EdgeEventHandler<T extends Event = PointerEvent> = (edge: string, event: T) => void\ntype EdgesEventHandler<T extends Event = PointerEvent> = (edges: string[], event: T) => void\ntype PathEventHandler<T extends Event = PointerEvent> = (path: string, event: T) => void\n\ninterface MouseEventHandlers {\n  selectedNodes: Reactive<Set<string>>\n  hoveredNodes: Reactive<Set<string>>\n  selectedEdges: Reactive<Set<string>>\n  hoveredEdges: Reactive<Set<string>>\n  selectedPaths: Reactive<Set<string>>\n  hoveredPaths: Reactive<Set<string>>\n\n  // for Nodes\n  handleNodePointerDownEvent: NodeEventHandler\n  handleNodePointerOverEvent: NodeEventHandler\n  handleNodePointerOutEvent: NodeEventHandler\n  handleNodeClickEvent: NodeEventHandler<MouseEvent>\n  handleNodeDoubleClickEvent: NodeEventHandler<MouseEvent>\n  handleNodeContextMenu: NodeEventHandler<MouseEvent>\n\n  // for Edges\n  handleEdgePointerDownEvent: EdgeEventHandler\n  handleEdgePointerOverEvent: EdgeEventHandler\n  handleEdgePointerOutEvent: EdgeEventHandler\n  handleEdgeClickEvent: EdgeEventHandler<MouseEvent>\n  handleEdgeDoubleClickEvent: EdgeEventHandler<MouseEvent>\n  handleEdgeContextMenu: EdgeEventHandler<MouseEvent>\n  handleEdgesPointerDownEvent: EdgesEventHandler\n  handleEdgesPointerOverEvent: EdgesEventHandler\n  handleEdgesPointerOutEvent: EdgesEventHandler\n  handleEdgesClickEvent: EdgesEventHandler<MouseEvent>\n  handleEdgesDoubleClickEvent: EdgesEventHandler<MouseEvent>\n  handleEdgesContextMenu: EdgesEventHandler<MouseEvent>\n\n  // for Paths\n  handlePathPointerDownEvent: PathEventHandler\n  handlePathPointerOverEvent: PathEventHandler\n  handlePathPointerOutEvent: PathEventHandler\n  handlePathClickEvent: PathEventHandler<MouseEvent>\n  handlePathDoubleClickEvent: PathEventHandler<MouseEvent>\n  handlePathContextMenu: PathEventHandler<MouseEvent>\n\n  // for Box Selection\n  isBoxSelectionMode: Ref<boolean>\n  selectionBox: Ref<Rectangle>\n  startBoxSelection: (options?: Partial<BoxSelectionOption>) => void\n  stopBoxSelection: () => void\n}\nconst mouseEventHandlersKey = Symbol(\"mouseEventHandlers\") as InjectionKey<MouseEventHandlers>\n\nexport function provideMouseOperation(\n  container: Ref<SVGElement | undefined>,\n  layouts: Readonly<Layouts>,\n  zoomLevel: ReadonlyRef<number>,\n  nodeStates: NodeStates,\n  edgeStates: EdgeStates,\n  pathStates: PathStates,\n  selectedNodes: Reactive<Set<string>>,\n  selectedEdges: Reactive<Set<string>>,\n  selectedPaths: Reactive<Set<string>>,\n  hoveredNodes: Reactive<Set<string>>,\n  hoveredEdges: Reactive<Set<string>>,\n  hoveredPaths: Reactive<Set<string>>,\n  isInCompatibilityModeForPath: Ref<boolean>,\n  isSvgWheelZoomEnabled: Ref<boolean>,\n  configs: Configs,\n  emitter: Emitter<Events>\n): MouseEventHandlers {\n  const modes: InteractionModes = {\n    selectionMode: ref(\"container\"),\n    viewMode: ref(\"default\"),\n  }\n\n  if (selectedNodes.size > 0) {\n    modes.selectionMode.value = \"node\"\n  } else if (selectedEdges.size > 0) {\n    modes.selectionMode.value = \"edge\"\n  } else if (selectedPaths.size > 0) {\n    modes.selectionMode.value = \"path\"\n  }\n\n  watch(modes.viewMode, mode => {\n    emitter.emit(\"view:mode\", mode)\n  })\n\n  setupContainerInteractionHandlers(container, modes, isSvgWheelZoomEnabled, emitter)\n\n  const provides = <MouseEventHandlers>{\n    selectedNodes,\n    hoveredNodes,\n    selectedEdges,\n    hoveredEdges,\n    selectedPaths,\n    hoveredPaths,\n    ...makeNodeInteractionHandlers(\n      nodeStates,\n      layouts,\n      modes,\n      hoveredNodes,\n      selectedNodes,\n      zoomLevel,\n      emitter\n    ),\n    ...makeEdgeInteractionHandlers(edgeStates, modes, hoveredEdges, selectedEdges, emitter),\n    ...makePathInteractionHandlers(\n      pathStates,\n      modes,\n      hoveredPaths,\n      selectedPaths,\n      isInCompatibilityModeForPath,\n      emitter\n    ),\n    ...makeBoxSelectionMethods(\n      container,\n      modes,\n      layouts,\n      nodeStates,\n      selectedNodes,\n      configs\n    ),\n  }\n  provide(mouseEventHandlersKey, provides)\n  return provides\n}\n\nexport function useMouseOperation(): MouseEventHandlers {\n  return nonNull(inject(mouseEventHandlersKey), \"mouseEventHandlers\")\n}\n","export default function(n){return{all:n=n||new Map,on:function(t,e){var i=n.get(t);i?i.push(e):n.set(t,[e])},off:function(t,e){var i=n.get(t);i&&(e?i.splice(i.indexOf(e)>>>0,1):n.set(t,[]))},emit:function(t,e){var i=n.get(t);i&&i.slice().map(function(n){n(e)}),(i=n.get(\"*\"))&&i.slice().map(function(n){n(t,e)})}}}\n//# sourceMappingURL=mitt.mjs.map\n","import { provide, inject, InjectionKey } from \"vue\"\nimport mitt, { Emitter } from \"mitt\"\nimport { nonNull } from \"@/common/common\"\nimport { Events } from \"@/common/types\"\n\nconst eventEmitterKey = Symbol(\"emitter\") as InjectionKey<Emitter<Events>>\n\nexport function provideEventEmitter(): Emitter<Events> {\n  // event bus\n  const emitter = mitt<Events>()\n  provide(eventEmitterKey, emitter)\n  return emitter\n}\n\nexport function useEventEmitter(): Emitter<Events> {\n  return nonNull(inject(eventEmitterKey), \"event emitter\")\n}\n","module.exports = {\n  /**\n   * Get global this object\n   *\n   * @return {Object}        global this object\n   */\n  getGlobalThis: function () {\n    if (typeof globalThis !== \"undefined\") return globalThis;\n    if (typeof self !== \"undefined\") return self;\n    if (typeof window !== \"undefined\") return window;\n    if (typeof global !== \"undefined\") return global;\n    // Note: this might still return the wrong result!\n    if (typeof this !== \"undefined\") return this;\n    throw new Error(\"Unable to locate global `this`\");\n  },\n\n  /**\n   * Extends an object\n   *\n   * @param  {Object} target object to extend\n   * @param  {Object} source object to take properties from\n   * @return {Object}        extended object\n   */\n  extend: function (target, source) {\n    target = target || {};\n    for (var prop in source) {\n      // Go recursively\n      if (this.isObject(source[prop])) {\n        target[prop] = this.extend(target[prop], source[prop]);\n      } else {\n        target[prop] = source[prop];\n      }\n    }\n    return target;\n  },\n\n  /**\n   * Checks if an object is a DOM element\n   *\n   * @param  {Object}  o HTML element or String\n   * @return {Boolean}   returns true if object is a DOM element\n   */\n  isElement: function (o) {\n    return (\n      o instanceof HTMLElement ||\n      o instanceof SVGElement ||\n      o instanceof SVGSVGElement || //DOM2\n      (o &&\n        typeof o === \"object\" &&\n        o !== null &&\n        o.nodeType === 1 &&\n        typeof o.nodeName === \"string\")\n    );\n  },\n\n  /**\n   * Checks if an object is an Object\n   *\n   * @param  {Object}  o Object\n   * @return {Boolean}   returns true if object is an Object\n   */\n  isObject: function (o) {\n    return Object.prototype.toString.call(o) === \"[object Object]\";\n  },\n\n  /**\n   * Checks if variable is Number\n   *\n   * @param  {Integer|Float}  n\n   * @return {Boolean}   returns true if variable is Number\n   */\n  isNumber: function (n) {\n    return !isNaN(parseFloat(n)) && isFinite(n);\n  },\n\n  /**\n   * Search for an SVG element\n   *\n   * @param  {Object|String} elementOrSelector DOM Element or selector String\n   * @return {Object|Null}                   SVG or null\n   */\n  getSvg: function (elementOrSelector) {\n    var element, svg;\n\n    if (!this.isElement(elementOrSelector)) {\n      // If selector provided\n      if (\n        typeof elementOrSelector === \"string\" ||\n        elementOrSelector instanceof String\n      ) {\n        // Try to find the element\n        element = document.querySelector(elementOrSelector);\n\n        if (!element) {\n          throw new Error(\n            \"Provided selector did not find any elements. Selector: \" +\n              elementOrSelector\n          );\n          return null;\n        }\n      } else {\n        throw new Error(\"Provided selector is not an HTML object nor String\");\n        return null;\n      }\n    } else {\n      element = elementOrSelector;\n    }\n\n    if (element.tagName.toLowerCase() === \"svg\") {\n      svg = element;\n    } else {\n      if (element.tagName.toLowerCase() === \"object\") {\n        svg = element.contentDocument.documentElement;\n      } else {\n        if (element.tagName.toLowerCase() === \"embed\") {\n          svg = element.getSVGDocument().documentElement;\n        } else {\n          if (element.tagName.toLowerCase() === \"img\") {\n            throw new Error(\n              'Cannot script an SVG in an \"img\" element. Please use an \"object\" element or an in-line SVG.'\n            );\n          } else {\n            throw new Error(\"Cannot get SVG.\");\n          }\n          return null;\n        }\n      }\n    }\n\n    return svg;\n  },\n\n  /**\n   * Attach a given context to a function\n   * @param  {Function} fn      Function\n   * @param  {Object}   context Context\n   * @return {Function}           Function with certain context\n   */\n  proxy: function (fn, context) {\n    return function () {\n      return fn.apply(context, arguments);\n    };\n  },\n\n  /**\n   * Returns object type\n   * Uses toString that returns [object SVGPoint]\n   * And than parses object type from string\n   *\n   * @param  {Object} o Any object\n   * @return {String}   Object type\n   */\n  getType: function (o) {\n    return Object.prototype.toString\n      .apply(o)\n      .replace(/^\\[object\\s/, \"\")\n      .replace(/\\]$/, \"\");\n  },\n\n  /**\n   * If it is a touch event than add clientX and clientY to event object\n   *\n   * @param  {Event} evt\n   * @param  {SVGSVGElement} svg\n   */\n  mouseAndTouchNormalize: function (evt, svg) {\n    // If no clientX then fallback\n    if (evt.clientX === void 0 || evt.clientX === null) {\n      // Fallback\n      evt.clientX = 0;\n      evt.clientY = 0;\n\n      // If it is a touch event\n      if (evt.touches !== void 0 && evt.touches.length) {\n        if (evt.touches[0].clientX !== void 0) {\n          evt.clientX = evt.touches[0].clientX;\n          evt.clientY = evt.touches[0].clientY;\n        } else if (evt.touches[0].pageX !== void 0) {\n          var rect = svg.getBoundingClientRect();\n\n          evt.clientX = evt.touches[0].pageX - rect.left;\n          evt.clientY = evt.touches[0].pageY - rect.top;\n        }\n        // If it is a custom event\n      } else if (evt.originalEvent !== void 0) {\n        if (evt.originalEvent.clientX !== void 0) {\n          evt.clientX = evt.originalEvent.clientX;\n          evt.clientY = evt.originalEvent.clientY;\n        }\n      }\n    }\n  },\n\n  /**\n   * If it is a touch event than add clientX and clientY to event object\n   *\n   * @param  {Event} evt\n   * @param  {SVGSVGElement} svg\n   * @param  {Number} touch\n   */\n  touchNormalize: function (evt, svg, touch) {\n    // If it is a touch event\n    if (evt.touches !== void 0 && evt.touches.length) {\n      if (evt.touches[touch].clientX !== void 0) {\n        evt.clientX = evt.touches[touch].clientX;\n        evt.clientY = evt.touches[touch].clientY;\n      } else if (evt.touches[touch].pageX !== void 0) {\n        var rect = svg.getBoundingClientRect();\n\n        evt.clientX = evt.touches[touch].pageX - rect.left;\n        evt.clientY = evt.touches[touch].pageY - rect.top;\n      }\n      // If it is a custom event\n    } else {\n      // If no clientX then fallback\n      if (evt.clientX === void 0 || evt.clientX === null) {\n        // Fallback\n        evt.clientX = 0;\n        evt.clientY = 0;\n        if (evt.originalEvent !== void 0) {\n          if (evt.originalEvent.clientX !== void 0) {\n            evt.clientX = evt.originalEvent.clientX;\n            evt.clientY = evt.originalEvent.clientY;\n          }\n        }\n      }\n    }\n  },\n\n  /**\n   * Check if an event is a double click/tap\n   * TODO: For touch gestures use a library (hammer.js) that takes in account other events\n   * (touchmove and touchend). It should take in account tap duration and traveled distance\n   *\n   * @param  {Event}  evt\n   * @param  {Event}  prevEvt Previous Event\n   * @return {Boolean}\n   */\n  isDblClick: function (evt, prevEvt) {\n    // Double click detected by browser\n    if (evt.detail === 2) {\n      return true;\n    }\n    // Try to compare events\n    else if (prevEvt !== void 0 && prevEvt !== null) {\n      var timeStampDiff = evt.timeStamp - prevEvt.timeStamp, // should be lower than 250 ms\n        touchesDistance = Math.sqrt(\n          Math.pow(evt.clientX - prevEvt.clientX, 2) +\n            Math.pow(evt.clientY - prevEvt.clientY, 2)\n        );\n\n      return timeStampDiff < 250 && touchesDistance < 10;\n    }\n\n    // Nothing found\n    return false;\n  },\n\n  /**\n   * Returns current timestamp as an integer\n   *\n   * @return {Number}\n   */\n  now:\n    Date.now ||\n    function () {\n      return new Date().getTime();\n    },\n\n  // From underscore.\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time. Normally, the throttled function will run\n  // as much as it can, without ever going more than once per `wait` duration;\n  // but if you'd like to disable the execution on the leading edge, pass\n  // `{leading: false}`. To disable execution on the trailing edge, ditto.\n  throttle: function (func, wait, options) {\n    var that = this;\n    var context, args, result;\n    var timeout = null;\n    var previous = 0;\n    if (!options) {\n      options = {};\n    }\n    var later = function () {\n      previous = options.leading === false ? 0 : that.now();\n      timeout = null;\n      result = func.apply(context, args);\n      if (!timeout) {\n        context = args = null;\n      }\n    };\n    return function () {\n      var now = that.now();\n      if (!previous && options.leading === false) {\n        previous = now;\n      }\n      var remaining = wait - (now - previous);\n      context = this; // eslint-disable-line consistent-this\n      args = arguments;\n      if (remaining <= 0 || remaining > wait) {\n        clearTimeout(timeout);\n        timeout = null;\n        previous = now;\n        result = func.apply(context, args);\n        if (!timeout) {\n          context = args = null;\n        }\n      } else if (!timeout && options.trailing !== false) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n  },\n\n  /**\n   * Create a requestAnimationFrame simulation\n   *\n   * @param  {Number|String} refreshRate\n   * @return {Function}\n   */\n  createRequestAnimationFrame: function (refreshRate) {\n    var timeout = null;\n\n    // Convert refreshRate to timeout\n    if (refreshRate !== \"auto\" && refreshRate < 60 && refreshRate > 1) {\n      timeout = Math.floor(1000 / refreshRate);\n    }\n\n    if (timeout === null) {\n      return window.requestAnimationFrame || requestTimeout(33);\n    } else {\n      return requestTimeout(timeout);\n    }\n  },\n\n  /**\n   * Calculate distance of points\n   *\n   * @param  {SVGPoint} point1\n   * @param  {SVGPoint} point2\n   * @return {Number}\n   */\n  calculateDistance: function (point1, point2) {\n    var dx = point1.x - point2.x;\n    var dy = point1.y - point2.y;\n    return Math.sqrt(dx * dx + dy * dy);\n  },\n};\n\n/**\n * Create a callback that will execute after a given timeout\n *\n * @param  {Function} timeout\n * @return {Function}\n */\nfunction requestTimeout(timeout) {\n  return function (callback) {\n    window.setTimeout(callback, timeout);\n  };\n}\n","// uniwheel 0.1.2 (customized)\n// A unified cross browser mouse wheel event handler\n// https://github.com/teemualap/uniwheel\n\nvar Utils = require(\"./utilities\");\n\nmodule.exports = (function() {\n  //Full details: https://developer.mozilla.org/en-US/docs/Web/Reference/Events/wheel\n\n  var prefix = \"\",\n    _addEventListener,\n    _removeEventListener,\n    support,\n    fns = [];\n  var passiveTrueOption = { passive: true };\n  var passiveFalseOption = { passive: false };\n\n  // detect event model\n  if (Utils.getGlobalThis().addEventListener) {\n    _addEventListener = \"addEventListener\";\n    _removeEventListener = \"removeEventListener\";\n  } else {\n    _addEventListener = \"attachEvent\";\n    _removeEventListener = \"detachEvent\";\n    prefix = \"on\";\n  }\n\n  function getSupport() {\n    if (!support) {\n      support =\n        \"onwheel\" in document.createElement(\"div\")\n          ? \"wheel\" // Modern browsers support \"wheel\"\n          : document.onmousewheel !== undefined\n          ? \"mousewheel\" // Webkit and IE support at least \"mousewheel\"\n          : \"DOMMouseScroll\"; // let's assume that remaining browsers are older Firefox\n    }\n    return support;\n  }\n\n  function createCallback(element, callback) {\n    // detect available wheel event\n\n    var fn = function(originalEvent) {\n      !originalEvent && (originalEvent = window.event);\n\n      // create a normalized event object\n      var event = {\n        // keep a ref to the original event object\n        originalEvent: originalEvent,\n        target: originalEvent.target || originalEvent.srcElement,\n        type: \"wheel\",\n        deltaMode: originalEvent.type == \"MozMousePixelScroll\" ? 0 : 1,\n        deltaX: 0,\n        delatZ: 0,\n        preventDefault: function() {\n          originalEvent.preventDefault\n            ? originalEvent.preventDefault()\n            : (originalEvent.returnValue = false);\n        }\n      };\n\n      // calculate deltaY (and deltaX) according to the event\n      if (getSupport() == \"mousewheel\") {\n        event.deltaY = (-1 / 40) * originalEvent.wheelDelta;\n        // Webkit also support wheelDeltaX\n        originalEvent.wheelDeltaX &&\n          (event.deltaX = (-1 / 40) * originalEvent.wheelDeltaX);\n      } else {\n        event.deltaY = originalEvent.detail;\n      }\n\n      // it's time to fire the callback\n      return callback(event);\n    };\n\n    fns.push({\n      element: element,\n      fn: fn\n    });\n\n    return fn;\n  }\n\n  function getCallback(element) {\n    for (var i = 0; i < fns.length; i++) {\n      if (fns[i].element === element) {\n        return fns[i].fn;\n      }\n    }\n    return function() {};\n  }\n\n  function removeCallback(element) {\n    for (var i = 0; i < fns.length; i++) {\n      if (fns[i].element === element) {\n        return fns.splice(i, 1);\n      }\n    }\n  }\n\n  function _addWheelListener(elem, eventName, callback, isPassiveListener) {\n    var cb;\n\n    if (getSupport() === \"wheel\") {\n      cb = callback;\n    } else {\n      cb = createCallback(elem, callback);\n    }\n\n    elem[_addEventListener](\n      prefix + eventName,\n      cb,\n      isPassiveListener ? passiveTrueOption : passiveFalseOption\n    );\n  }\n\n  function _removeWheelListener(elem, eventName, callback, isPassiveListener) {\n    var cb;\n\n    if (getSupport() === \"wheel\") {\n      cb = callback;\n    } else {\n      cb = getCallback(elem);\n    }\n\n    elem[_removeEventListener](\n      prefix + eventName,\n      cb,\n      isPassiveListener ? passiveTrueOption : passiveFalseOption\n    );\n\n    removeCallback(elem);\n  }\n\n  function addWheelListener(elem, callback, isPassiveListener) {\n    _addWheelListener(elem, getSupport(), callback, isPassiveListener);\n\n    // handle MozMousePixelScroll in older Firefox\n    if (getSupport() == \"DOMMouseScroll\") {\n      _addWheelListener(\n        elem,\n        \"MozMousePixelScroll\",\n        callback,\n        isPassiveListener\n      );\n    }\n  }\n\n  function removeWheelListener(elem, callback, isPassiveListener) {\n    _removeWheelListener(elem, getSupport(), callback, isPassiveListener);\n\n    // handle MozMousePixelScroll in older Firefox\n    if (getSupport() == \"DOMMouseScroll\") {\n      _removeWheelListener(\n        elem,\n        \"MozMousePixelScroll\",\n        callback,\n        isPassiveListener\n      );\n    }\n  }\n\n  return {\n    on: addWheelListener,\n    off: removeWheelListener\n  };\n})();\n","var Utils = require(\"./utilities\"),\n  _browser = \"unknown\";\n\n// http://stackoverflow.com/questions/9847580/how-to-detect-safari-chrome-ie-firefox-and-opera-browser\nif (\n  /*@cc_on!@*/ false ||\n  (typeof document != \"undefined\" && !!document.documentMode)\n) {\n  // internet explorer\n  _browser = \"ie\";\n}\n\nmodule.exports = {\n  svgNS: \"http://www.w3.org/2000/svg\",\n  xmlNS: \"http://www.w3.org/XML/1998/namespace\",\n  xmlnsNS: \"http://www.w3.org/2000/xmlns/\",\n  xlinkNS: \"http://www.w3.org/1999/xlink\",\n  evNS: \"http://www.w3.org/2001/xml-events\",\n\n  /**\n   * Get svg dimensions: width and height\n   *\n   * @param  {SVGSVGElement} svg\n   * @return {Object}     {width: 0, height: 0}\n   */\n  getBoundingClientRectNormalized: function (svg) {\n    if (svg.clientWidth && svg.clientHeight) {\n      return { width: svg.clientWidth, height: svg.clientHeight };\n    } else if (!!svg.getBoundingClientRect()) {\n      return svg.getBoundingClientRect();\n    } else {\n      throw new Error(\"Cannot get BoundingClientRect for SVG.\");\n    }\n  },\n\n  /**\n   * Gets g element with class of \"viewport\" or creates it if it doesn't exist\n   *\n   * @param  {SVGSVGElement} svg\n   * @return {SVGElement}     g (group) element\n   */\n  getOrCreateViewport: function (svg, selector) {\n    var viewport = null;\n\n    if (Utils.isElement(selector)) {\n      viewport = selector;\n    } else {\n      viewport = svg.querySelector(selector);\n    }\n\n    // Check if there is just one main group in SVG\n    if (!viewport) {\n      var childNodes = Array.prototype.slice\n        .call(svg.childNodes || svg.children)\n        .filter(function (el) {\n          return el.nodeName !== \"defs\" && el.nodeName !== \"#text\";\n        });\n\n      // Node name should be SVGGElement and should have no transform attribute\n      // Groups with transform are not used as viewport because it involves parsing of all transform possibilities\n      if (\n        childNodes.length === 1 &&\n        childNodes[0].nodeName === \"g\" &&\n        childNodes[0].getAttribute(\"transform\") === null\n      ) {\n        viewport = childNodes[0];\n      }\n    }\n\n    // If no favorable group element exists then create one\n    if (!viewport) {\n      var viewportId =\n        \"viewport-\" + new Date().toISOString().replace(/\\D/g, \"\");\n      viewport = document.createElementNS(this.svgNS, \"g\");\n      viewport.setAttribute(\"id\", viewportId);\n\n      // Internet Explorer (all versions?) can't use childNodes, but other browsers prefer (require?) using childNodes\n      var svgChildren = svg.childNodes || svg.children;\n      if (!!svgChildren && svgChildren.length > 0) {\n        for (var i = svgChildren.length; i > 0; i--) {\n          // Move everything into viewport except defs\n          if (svgChildren[svgChildren.length - i].nodeName !== \"defs\") {\n            viewport.appendChild(svgChildren[svgChildren.length - i]);\n          }\n        }\n      }\n      svg.appendChild(viewport);\n    }\n\n    // Parse class names\n    var classNames = [];\n    if (viewport.getAttribute(\"class\")) {\n      classNames = viewport.getAttribute(\"class\").split(\" \");\n    }\n\n    // Set class (if not set already)\n    if (!~classNames.indexOf(\"svg-pan-zoom_viewport\")) {\n      classNames.push(\"svg-pan-zoom_viewport\");\n      viewport.setAttribute(\"class\", classNames.join(\" \"));\n    }\n\n    return viewport;\n  },\n\n  /**\n   * Set SVG attributes\n   *\n   * @param  {SVGSVGElement} svg\n   */\n  setupSvgAttributes: function (svg) {\n    // Setting default attributes\n    svg.setAttribute(\"xmlns\", this.svgNS);\n    svg.setAttributeNS(this.xmlnsNS, \"xmlns:xlink\", this.xlinkNS);\n    svg.setAttributeNS(this.xmlnsNS, \"xmlns:ev\", this.evNS);\n\n    // Needed for Internet Explorer, otherwise the viewport overflows\n    if (svg.parentNode !== null) {\n      var style = svg.getAttribute(\"style\") || \"\";\n      if (style.toLowerCase().indexOf(\"overflow\") === -1) {\n        svg.setAttribute(\"style\", \"overflow: hidden; \" + style);\n      }\n    }\n  },\n\n  /**\n   * How long Internet Explorer takes to finish updating its display (ms).\n   */\n  internetExplorerRedisplayInterval: 300,\n\n  /**\n   * Forces the browser to redisplay all SVG elements that rely on an\n   * element defined in a 'defs' section. It works globally, for every\n   * available defs element on the page.\n   * The throttling is intentionally global.\n   *\n   * This is only needed for IE. It is as a hack to make markers (and 'use' elements?)\n   * visible after pan/zoom when there are multiple SVGs on the page.\n   * See bug report: https://connect.microsoft.com/IE/feedback/details/781964/\n   * also see svg-pan-zoom issue: https://github.com/ariutta/svg-pan-zoom/issues/62\n   */\n  refreshDefsGlobal: Utils.throttle(\n    function () {\n      var allDefs = document.querySelectorAll(\"defs\");\n      var allDefsCount = allDefs.length;\n      for (var i = 0; i < allDefsCount; i++) {\n        var thisDefs = allDefs[i];\n        thisDefs.parentNode.insertBefore(thisDefs, thisDefs);\n      }\n    },\n    this ? this.internetExplorerRedisplayInterval : null\n  ),\n\n  /**\n   * Sets the current transform matrix of an element\n   *\n   * @param {SVGElement} element\n   * @param {SVGMatrix} matrix  CTM\n   * @param {SVGElement} defs\n   */\n  setCTM: function (element, matrix, defs) {\n    var that = this,\n      s =\n        \"matrix(\" +\n        matrix.a +\n        \",\" +\n        matrix.b +\n        \",\" +\n        matrix.c +\n        \",\" +\n        matrix.d +\n        \",\" +\n        matrix.e +\n        \",\" +\n        matrix.f +\n        \")\";\n\n    element.setAttributeNS(null, \"transform\", s);\n    if (\"transform\" in element.style) {\n      element.style.transform = s;\n    } else if (\"-ms-transform\" in element.style) {\n      element.style[\"-ms-transform\"] = s;\n    } else if (\"-webkit-transform\" in element.style) {\n      element.style[\"-webkit-transform\"] = s;\n    }\n\n    // IE has a bug that makes markers disappear on zoom (when the matrix \"a\" and/or \"d\" elements change)\n    // see http://stackoverflow.com/questions/17654578/svg-marker-does-not-work-in-ie9-10\n    // and http://srndolha.wordpress.com/2013/11/25/svg-line-markers-may-disappear-in-internet-explorer-11/\n    if (_browser === \"ie\" && !!defs) {\n      // this refresh is intended for redisplaying the SVG during zooming\n      defs.parentNode.insertBefore(defs, defs);\n      // this refresh is intended for redisplaying the other SVGs on a page when panning a given SVG\n      // it is also needed for the given SVG itself, on zoomEnd, if the SVG contains any markers that\n      // are located under any other element(s).\n      window.setTimeout(function () {\n        that.refreshDefsGlobal();\n      }, that.internetExplorerRedisplayInterval);\n    }\n  },\n\n  /**\n   * Instantiate an SVGPoint object with given event coordinates\n   *\n   * @param {Event} evt\n   * @param  {SVGSVGElement} svg\n   * @return {SVGPoint}     point\n   */\n  getEventPoint: function (evt, svg) {\n    var point = svg.createSVGPoint();\n\n    Utils.mouseAndTouchNormalize(evt, svg);\n\n    point.x = evt.clientX;\n    point.y = evt.clientY;\n\n    return point;\n  },\n\n  /**\n   * Instantiate an SVGPoint object with given touch event coordinates\n   *\n   * @param {Event} evt\n   * @param  {SVGSVGElement} svg\n   * @param  {Number} touch\n   * @return {SVGPoint}     point\n   */\n  getTouchPoint: function (evt, svg, touch) {\n    var point = svg.createSVGPoint();\n\n    Utils.touchNormalize(evt, svg, touch);\n\n    point.x = evt.clientX;\n    point.y = evt.clientY;\n\n    return point;\n  },\n\n  /**\n   * Get SVG center point\n   *\n   * @param  {SVGSVGElement} svg\n   * @return {SVGPoint}\n   */\n  getSvgCenterPoint: function (svg, width, height) {\n    return this.createSVGPoint(svg, width / 2, height / 2);\n  },\n\n  /**\n   * Create a SVGPoint with given x and y\n   *\n   * @param  {SVGSVGElement} svg\n   * @param  {Number} x\n   * @param  {Number} y\n   * @return {SVGPoint}\n   */\n  createSVGPoint: function (svg, x, y) {\n    var point = svg.createSVGPoint();\n    point.x = x;\n    point.y = y;\n\n    return point;\n  },\n};\n","var SvgUtils = require(\"./svg-utilities\");\n\nmodule.exports = {\n  enable: function (instance) {\n    // Select (and create if necessary) defs\n    var defs = instance.svg.querySelector(\"defs\");\n    if (!defs) {\n      defs = document.createElementNS(SvgUtils.svgNS, \"defs\");\n      instance.svg.appendChild(defs);\n    }\n\n    // Check for style element, and create it if it doesn't exist\n    var styleEl = defs.querySelector(\"style#svg-pan-zoom-controls-styles\");\n    if (!styleEl) {\n      var style = document.createElementNS(SvgUtils.svgNS, \"style\");\n      style.setAttribute(\"id\", \"svg-pan-zoom-controls-styles\");\n      style.setAttribute(\"type\", \"text/css\");\n      style.textContent =\n        \".svg-pan-zoom-control { cursor: pointer; fill: black; fill-opacity: 0.333; } .svg-pan-zoom-control:hover { fill-opacity: 0.8; } .svg-pan-zoom-control-background { fill: white; fill-opacity: 0.5; } .svg-pan-zoom-control-background { fill-opacity: 0.8; }\";\n      defs.appendChild(style);\n    }\n\n    // Zoom Group\n    var zoomGroup = document.createElementNS(SvgUtils.svgNS, \"g\");\n    zoomGroup.setAttribute(\"id\", \"svg-pan-zoom-controls\");\n    zoomGroup.setAttribute(\n      \"transform\",\n      \"translate(\" +\n        (instance.width - 70) +\n        \" \" +\n        (instance.height - 76) +\n        \") scale(0.75)\"\n    );\n    zoomGroup.setAttribute(\"class\", \"svg-pan-zoom-control\");\n\n    // Control elements\n    zoomGroup.appendChild(this._createZoomIn(instance));\n    zoomGroup.appendChild(this._createZoomReset(instance));\n    zoomGroup.appendChild(this._createZoomOut(instance));\n\n    // Finally append created element\n    instance.svg.appendChild(zoomGroup);\n\n    // Cache control instance\n    instance.controlIcons = zoomGroup;\n  },\n\n  _createZoomIn: function (instance) {\n    var zoomIn = document.createElementNS(SvgUtils.svgNS, \"g\");\n    zoomIn.setAttribute(\"id\", \"svg-pan-zoom-zoom-in\");\n    zoomIn.setAttribute(\"transform\", \"translate(30.5 5) scale(0.015)\");\n    zoomIn.setAttribute(\"class\", \"svg-pan-zoom-control\");\n    zoomIn.addEventListener(\n      \"click\",\n      function () {\n        instance.getPublicInstance().zoomIn();\n      },\n      false\n    );\n    zoomIn.addEventListener(\n      \"touchstart\",\n      function () {\n        instance.getPublicInstance().zoomIn();\n      },\n      false\n    );\n\n    var zoomInBackground = document.createElementNS(SvgUtils.svgNS, \"rect\"); // TODO change these background space fillers to rounded rectangles so they look prettier\n    zoomInBackground.setAttribute(\"x\", \"0\");\n    zoomInBackground.setAttribute(\"y\", \"0\");\n    zoomInBackground.setAttribute(\"width\", \"1500\"); // larger than expected because the whole group is transformed to scale down\n    zoomInBackground.setAttribute(\"height\", \"1400\");\n    zoomInBackground.setAttribute(\"class\", \"svg-pan-zoom-control-background\");\n    zoomIn.appendChild(zoomInBackground);\n\n    var zoomInShape = document.createElementNS(SvgUtils.svgNS, \"path\");\n    zoomInShape.setAttribute(\n      \"d\",\n      \"M1280 576v128q0 26 -19 45t-45 19h-320v320q0 26 -19 45t-45 19h-128q-26 0 -45 -19t-19 -45v-320h-320q-26 0 -45 -19t-19 -45v-128q0 -26 19 -45t45 -19h320v-320q0 -26 19 -45t45 -19h128q26 0 45 19t19 45v320h320q26 0 45 19t19 45zM1536 1120v-960 q0 -119 -84.5 -203.5t-203.5 -84.5h-960q-119 0 -203.5 84.5t-84.5 203.5v960q0 119 84.5 203.5t203.5 84.5h960q119 0 203.5 -84.5t84.5 -203.5z\"\n    );\n    zoomInShape.setAttribute(\"class\", \"svg-pan-zoom-control-element\");\n    zoomIn.appendChild(zoomInShape);\n\n    return zoomIn;\n  },\n\n  _createZoomReset: function (instance) {\n    // reset\n    var resetPanZoomControl = document.createElementNS(SvgUtils.svgNS, \"g\");\n    resetPanZoomControl.setAttribute(\"id\", \"svg-pan-zoom-reset-pan-zoom\");\n    resetPanZoomControl.setAttribute(\"transform\", \"translate(5 35) scale(0.4)\");\n    resetPanZoomControl.setAttribute(\"class\", \"svg-pan-zoom-control\");\n    resetPanZoomControl.addEventListener(\n      \"click\",\n      function () {\n        instance.getPublicInstance().reset();\n      },\n      false\n    );\n    resetPanZoomControl.addEventListener(\n      \"touchstart\",\n      function () {\n        instance.getPublicInstance().reset();\n      },\n      false\n    );\n\n    var resetPanZoomControlBackground = document.createElementNS(\n      SvgUtils.svgNS,\n      \"rect\"\n    ); // TODO change these background space fillers to rounded rectangles so they look prettier\n    resetPanZoomControlBackground.setAttribute(\"x\", \"2\");\n    resetPanZoomControlBackground.setAttribute(\"y\", \"2\");\n    resetPanZoomControlBackground.setAttribute(\"width\", \"182\"); // larger than expected because the whole group is transformed to scale down\n    resetPanZoomControlBackground.setAttribute(\"height\", \"58\");\n    resetPanZoomControlBackground.setAttribute(\n      \"class\",\n      \"svg-pan-zoom-control-background\"\n    );\n    resetPanZoomControl.appendChild(resetPanZoomControlBackground);\n\n    var resetPanZoomControlShape1 = document.createElementNS(\n      SvgUtils.svgNS,\n      \"path\"\n    );\n    resetPanZoomControlShape1.setAttribute(\n      \"d\",\n      \"M33.051,20.632c-0.742-0.406-1.854-0.609-3.338-0.609h-7.969v9.281h7.769c1.543,0,2.701-0.188,3.473-0.562c1.365-0.656,2.048-1.953,2.048-3.891C35.032,22.757,34.372,21.351,33.051,20.632z\"\n    );\n    resetPanZoomControlShape1.setAttribute(\n      \"class\",\n      \"svg-pan-zoom-control-element\"\n    );\n    resetPanZoomControl.appendChild(resetPanZoomControlShape1);\n\n    var resetPanZoomControlShape2 = document.createElementNS(\n      SvgUtils.svgNS,\n      \"path\"\n    );\n    resetPanZoomControlShape2.setAttribute(\n      \"d\",\n      \"M170.231,0.5H15.847C7.102,0.5,0.5,5.708,0.5,11.84v38.861C0.5,56.833,7.102,61.5,15.847,61.5h154.384c8.745,0,15.269-4.667,15.269-10.798V11.84C185.5,5.708,178.976,0.5,170.231,0.5z M42.837,48.569h-7.969c-0.219-0.766-0.375-1.383-0.469-1.852c-0.188-0.969-0.289-1.961-0.305-2.977l-0.047-3.211c-0.03-2.203-0.41-3.672-1.142-4.406c-0.732-0.734-2.103-1.102-4.113-1.102h-7.05v13.547h-7.055V14.022h16.524c2.361,0.047,4.178,0.344,5.45,0.891c1.272,0.547,2.351,1.352,3.234,2.414c0.731,0.875,1.31,1.844,1.737,2.906s0.64,2.273,0.64,3.633c0,1.641-0.414,3.254-1.242,4.84s-2.195,2.707-4.102,3.363c1.594,0.641,2.723,1.551,3.387,2.73s0.996,2.98,0.996,5.402v2.32c0,1.578,0.063,2.648,0.19,3.211c0.19,0.891,0.635,1.547,1.333,1.969V48.569z M75.579,48.569h-26.18V14.022h25.336v6.117H56.454v7.336h16.781v6H56.454v8.883h19.125V48.569z M104.497,46.331c-2.44,2.086-5.887,3.129-10.34,3.129c-4.548,0-8.125-1.027-10.731-3.082s-3.909-4.879-3.909-8.473h6.891c0.224,1.578,0.662,2.758,1.316,3.539c1.196,1.422,3.246,2.133,6.15,2.133c1.739,0,3.151-0.188,4.236-0.562c2.058-0.719,3.087-2.055,3.087-4.008c0-1.141-0.504-2.023-1.512-2.648c-1.008-0.609-2.607-1.148-4.796-1.617l-3.74-0.82c-3.676-0.812-6.201-1.695-7.576-2.648c-2.328-1.594-3.492-4.086-3.492-7.477c0-3.094,1.139-5.664,3.417-7.711s5.623-3.07,10.036-3.07c3.685,0,6.829,0.965,9.431,2.895c2.602,1.93,3.966,4.73,4.093,8.402h-6.938c-0.128-2.078-1.057-3.555-2.787-4.43c-1.154-0.578-2.587-0.867-4.301-0.867c-1.907,0-3.428,0.375-4.565,1.125c-1.138,0.75-1.706,1.797-1.706,3.141c0,1.234,0.561,2.156,1.682,2.766c0.721,0.406,2.25,0.883,4.589,1.43l6.063,1.43c2.657,0.625,4.648,1.461,5.975,2.508c2.059,1.625,3.089,3.977,3.089,7.055C108.157,41.624,106.937,44.245,104.497,46.331z M139.61,48.569h-26.18V14.022h25.336v6.117h-18.281v7.336h16.781v6h-16.781v8.883h19.125V48.569z M170.337,20.14h-10.336v28.43h-7.266V20.14h-10.383v-6.117h27.984V20.14z\"\n    );\n    resetPanZoomControlShape2.setAttribute(\n      \"class\",\n      \"svg-pan-zoom-control-element\"\n    );\n    resetPanZoomControl.appendChild(resetPanZoomControlShape2);\n\n    return resetPanZoomControl;\n  },\n\n  _createZoomOut: function (instance) {\n    // zoom out\n    var zoomOut = document.createElementNS(SvgUtils.svgNS, \"g\");\n    zoomOut.setAttribute(\"id\", \"svg-pan-zoom-zoom-out\");\n    zoomOut.setAttribute(\"transform\", \"translate(30.5 70) scale(0.015)\");\n    zoomOut.setAttribute(\"class\", \"svg-pan-zoom-control\");\n    zoomOut.addEventListener(\n      \"click\",\n      function () {\n        instance.getPublicInstance().zoomOut();\n      },\n      false\n    );\n    zoomOut.addEventListener(\n      \"touchstart\",\n      function () {\n        instance.getPublicInstance().zoomOut();\n      },\n      false\n    );\n\n    var zoomOutBackground = document.createElementNS(SvgUtils.svgNS, \"rect\"); // TODO change these background space fillers to rounded rectangles so they look prettier\n    zoomOutBackground.setAttribute(\"x\", \"0\");\n    zoomOutBackground.setAttribute(\"y\", \"0\");\n    zoomOutBackground.setAttribute(\"width\", \"1500\"); // larger than expected because the whole group is transformed to scale down\n    zoomOutBackground.setAttribute(\"height\", \"1400\");\n    zoomOutBackground.setAttribute(\"class\", \"svg-pan-zoom-control-background\");\n    zoomOut.appendChild(zoomOutBackground);\n\n    var zoomOutShape = document.createElementNS(SvgUtils.svgNS, \"path\");\n    zoomOutShape.setAttribute(\n      \"d\",\n      \"M1280 576v128q0 26 -19 45t-45 19h-896q-26 0 -45 -19t-19 -45v-128q0 -26 19 -45t45 -19h896q26 0 45 19t19 45zM1536 1120v-960q0 -119 -84.5 -203.5t-203.5 -84.5h-960q-119 0 -203.5 84.5t-84.5 203.5v960q0 119 84.5 203.5t203.5 84.5h960q119 0 203.5 -84.5 t84.5 -203.5z\"\n    );\n    zoomOutShape.setAttribute(\"class\", \"svg-pan-zoom-control-element\");\n    zoomOut.appendChild(zoomOutShape);\n\n    return zoomOut;\n  },\n\n  disable: function (instance) {\n    if (instance.controlIcons) {\n      instance.controlIcons.parentNode.removeChild(instance.controlIcons);\n      instance.controlIcons = null;\n    }\n  },\n};\n","var SvgUtils = require(\"./svg-utilities\"),\n  Utils = require(\"./utilities\");\n\nvar ShadowViewport = function (viewport, options) {\n  this.init(viewport, options);\n};\n\n/**\n * Initialization\n *\n * @param  {SVGElement} viewport\n * @param  {Object} options\n */\nShadowViewport.prototype.init = function (viewport, options) {\n  // DOM Elements\n  this.viewport = viewport;\n  this.options = options;\n\n  // State cache\n  this.originalState = { zoom: 1, x: 0, y: 0 };\n  this.activeState = { zoom: 1, x: 0, y: 0 };\n\n  this.updateCTMCached = Utils.proxy(this.updateCTM, this);\n\n  // Create a custom requestAnimationFrame taking in account refreshRate\n  this.requestAnimationFrame = Utils.createRequestAnimationFrame(\n    this.options.refreshRate\n  );\n\n  // ViewBox\n  this.viewBox = { x: 0, y: 0, width: 0, height: 0 };\n  this.cacheViewBox();\n\n  // Process CTM\n  var newCTM = this.processCTM();\n\n  // Update viewport CTM and cache zoom and pan\n  this.setCTM(newCTM);\n\n  // Update CTM in this frame\n  this.updateCTM();\n};\n\n/**\n * Cache initial viewBox value\n * If no viewBox is defined, then use viewport size/position instead for viewBox values\n */\nShadowViewport.prototype.cacheViewBox = function () {\n  var svgViewBox = this.options.svg.getAttribute(\"viewBox\");\n\n  if (svgViewBox) {\n    var viewBoxValues = svgViewBox\n      .split(/[\\s\\,]/)\n      .filter(function (v) {\n        return v;\n      })\n      .map(parseFloat);\n\n    // Cache viewbox x and y offset\n    this.viewBox.x = viewBoxValues[0];\n    this.viewBox.y = viewBoxValues[1];\n    this.viewBox.width = viewBoxValues[2];\n    this.viewBox.height = viewBoxValues[3];\n\n    var zoom = Math.min(\n      this.options.width / this.viewBox.width,\n      this.options.height / this.viewBox.height\n    );\n\n    // Update active state\n    this.activeState.zoom = zoom;\n    this.activeState.x = (this.options.width - this.viewBox.width * zoom) / 2;\n    this.activeState.y = (this.options.height - this.viewBox.height * zoom) / 2;\n\n    // Force updating CTM\n    this.updateCTMOnNextFrame();\n\n    this.options.svg.removeAttribute(\"viewBox\");\n  } else {\n    this.simpleViewBoxCache();\n  }\n};\n\n/**\n * Recalculate viewport sizes and update viewBox cache\n */\nShadowViewport.prototype.simpleViewBoxCache = function () {\n  var bBox = this.viewport.getBBox();\n\n  this.viewBox.x = bBox.x;\n  this.viewBox.y = bBox.y;\n  this.viewBox.width = bBox.width;\n  this.viewBox.height = bBox.height;\n};\n\n/**\n * Returns a viewbox object. Safe to alter\n *\n * @return {Object} viewbox object\n */\nShadowViewport.prototype.getViewBox = function () {\n  return Utils.extend({}, this.viewBox);\n};\n\n/**\n * Get initial zoom and pan values. Save them into originalState\n * Parses viewBox attribute to alter initial sizes\n *\n * @return {CTM} CTM object based on options\n */\nShadowViewport.prototype.processCTM = function () {\n  var newCTM = this.getCTM();\n\n  if (this.options.fit || this.options.contain) {\n    var newScale;\n    if (this.options.fit) {\n      newScale = Math.min(\n        this.options.width / this.viewBox.width,\n        this.options.height / this.viewBox.height\n      );\n    } else {\n      newScale = Math.max(\n        this.options.width / this.viewBox.width,\n        this.options.height / this.viewBox.height\n      );\n    }\n\n    newCTM.a = newScale; //x-scale\n    newCTM.d = newScale; //y-scale\n    newCTM.e = -this.viewBox.x * newScale; //x-transform\n    newCTM.f = -this.viewBox.y * newScale; //y-transform\n  }\n\n  if (this.options.center) {\n    var offsetX =\n        (this.options.width -\n          (this.viewBox.width + this.viewBox.x * 2) * newCTM.a) *\n        0.5,\n      offsetY =\n        (this.options.height -\n          (this.viewBox.height + this.viewBox.y * 2) * newCTM.a) *\n        0.5;\n\n    newCTM.e = offsetX;\n    newCTM.f = offsetY;\n  }\n\n  // Cache initial values. Based on activeState and fix+center opitons\n  this.originalState.zoom = newCTM.a;\n  this.originalState.x = newCTM.e;\n  this.originalState.y = newCTM.f;\n\n  return newCTM;\n};\n\n/**\n * Return originalState object. Safe to alter\n *\n * @return {Object}\n */\nShadowViewport.prototype.getOriginalState = function () {\n  return Utils.extend({}, this.originalState);\n};\n\n/**\n * Return actualState object. Safe to alter\n *\n * @return {Object}\n */\nShadowViewport.prototype.getState = function () {\n  return Utils.extend({}, this.activeState);\n};\n\n/**\n * Get zoom scale\n *\n * @return {Float} zoom scale\n */\nShadowViewport.prototype.getZoom = function () {\n  return this.activeState.zoom;\n};\n\n/**\n * Get zoom scale for pubilc usage\n *\n * @return {Float} zoom scale\n */\nShadowViewport.prototype.getRelativeZoom = function () {\n  return this.activeState.zoom / this.originalState.zoom;\n};\n\n/**\n * Compute zoom scale for pubilc usage\n *\n * @return {Float} zoom scale\n */\nShadowViewport.prototype.computeRelativeZoom = function (scale) {\n  return scale / this.originalState.zoom;\n};\n\n/**\n * Get pan\n *\n * @return {Object}\n */\nShadowViewport.prototype.getPan = function () {\n  return { x: this.activeState.x, y: this.activeState.y };\n};\n\n/**\n * Return cached viewport CTM value that can be safely modified\n *\n * @return {SVGMatrix}\n */\nShadowViewport.prototype.getCTM = function () {\n  var safeCTM = this.options.svg.createSVGMatrix();\n\n  // Copy values manually as in FF they are not itterable\n  safeCTM.a = this.activeState.zoom;\n  safeCTM.b = 0;\n  safeCTM.c = 0;\n  safeCTM.d = this.activeState.zoom;\n  safeCTM.e = this.activeState.x;\n  safeCTM.f = this.activeState.y;\n\n  return safeCTM;\n};\n\n/**\n * Set a new CTM\n *\n * @param {SVGMatrix} newCTM\n */\nShadowViewport.prototype.setCTM = function (newCTM) {\n  var willZoom = this.isZoomDifferent(newCTM),\n    willPan = this.isPanDifferent(newCTM);\n\n  if (willZoom || willPan) {\n    // Before zoom\n    if (willZoom) {\n      // If returns false then cancel zooming\n      if (\n        this.options.beforeZoom(\n          this.getRelativeZoom(),\n          this.computeRelativeZoom(newCTM.a)\n        ) === false\n      ) {\n        newCTM.a = newCTM.d = this.activeState.zoom;\n        willZoom = false;\n      } else {\n        this.updateCache(newCTM);\n        this.options.onZoom(this.getRelativeZoom());\n      }\n    }\n\n    // Before pan\n    if (willPan) {\n      var preventPan = this.options.beforePan(this.getPan(), {\n          x: newCTM.e,\n          y: newCTM.f,\n        }),\n        // If prevent pan is an object\n        preventPanX = false,\n        preventPanY = false;\n\n      // If prevent pan is Boolean false\n      if (preventPan === false) {\n        // Set x and y same as before\n        newCTM.e = this.getPan().x;\n        newCTM.f = this.getPan().y;\n\n        preventPanX = preventPanY = true;\n      } else if (Utils.isObject(preventPan)) {\n        // Check for X axes attribute\n        if (preventPan.x === false) {\n          // Prevent panning on x axes\n          newCTM.e = this.getPan().x;\n          preventPanX = true;\n        } else if (Utils.isNumber(preventPan.x)) {\n          // Set a custom pan value\n          newCTM.e = preventPan.x;\n        }\n\n        // Check for Y axes attribute\n        if (preventPan.y === false) {\n          // Prevent panning on x axes\n          newCTM.f = this.getPan().y;\n          preventPanY = true;\n        } else if (Utils.isNumber(preventPan.y)) {\n          // Set a custom pan value\n          newCTM.f = preventPan.y;\n        }\n      }\n\n      // Update willPan flag\n      // Check if newCTM is still different\n      if ((preventPanX && preventPanY) || !this.isPanDifferent(newCTM)) {\n        willPan = false;\n      } else {\n        this.updateCache(newCTM);\n        this.options.onPan(this.getPan());\n      }\n    }\n\n    // Check again if should zoom or pan\n    if (willZoom || willPan) {\n      this.updateCTMOnNextFrame();\n    }\n  }\n};\n\nShadowViewport.prototype.isZoomDifferent = function (newCTM) {\n  return this.activeState.zoom !== newCTM.a;\n};\n\nShadowViewport.prototype.isPanDifferent = function (newCTM) {\n  return this.activeState.x !== newCTM.e || this.activeState.y !== newCTM.f;\n};\n\n/**\n * Update cached CTM and active state\n *\n * @param {SVGMatrix} newCTM\n */\nShadowViewport.prototype.updateCache = function (newCTM) {\n  this.activeState.zoom = newCTM.a;\n  this.activeState.x = newCTM.e;\n  this.activeState.y = newCTM.f;\n};\n\nShadowViewport.prototype.pendingUpdate = false;\n\n/**\n * Place a request to update CTM on next Frame\n */\nShadowViewport.prototype.updateCTMOnNextFrame = function () {\n  if (!this.pendingUpdate) {\n    // Lock\n    this.pendingUpdate = true;\n\n    // Throttle next update\n    this.requestAnimationFrame.call(window, this.updateCTMCached);\n  }\n};\n\n/**\n * Update viewport CTM with cached CTM\n */\nShadowViewport.prototype.updateCTM = function () {\n  var ctm = this.getCTM();\n\n  // Updates SVG element\n  SvgUtils.setCTM(this.viewport, ctm, this.defs);\n\n  // Free the lock\n  this.pendingUpdate = false;\n\n  // Notify about the update\n  if (this.options.onUpdatedCTM) {\n    this.options.onUpdatedCTM(ctm);\n  }\n};\n\nmodule.exports = function (viewport, options) {\n  return new ShadowViewport(viewport, options);\n};\n","var Wheel = require(\"./uniwheel\"),\n  ControlIcons = require(\"./control-icons\"),\n  Utils = require(\"./utilities\"),\n  SvgUtils = require(\"./svg-utilities\"),\n  ShadowViewport = require(\"./shadow-viewport\");\n\nvar SvgPanZoom = function (svg, options) {\n  this.init(svg, options);\n};\n\nvar optionsDefaults = {\n  viewportSelector: \".svg-pan-zoom_viewport\", // Viewport selector. Can be querySelector string or SVGElement\n  panEnabled: true, // enable or disable panning (default enabled)\n  controlIconsEnabled: false, // insert icons to give user an option in addition to mouse events to control pan/zoom (default disabled)\n  zoomEnabled: true, // enable or disable zooming (default enabled)\n  dblClickZoomEnabled: true, // enable or disable zooming by double clicking (default enabled)\n  mouseWheelZoomEnabled: true, // enable or disable zooming by mouse wheel (default enabled)\n  preventMouseEventsDefault: true, // enable or disable preventDefault for mouse events\n  zoomScaleSensitivity: 0.1, // Zoom sensitivity\n  minZoom: 0.5, // Minimum Zoom level\n  maxZoom: 10, // Maximum Zoom level\n  fit: true, // enable or disable viewport fit in SVG (default true)\n  contain: false, // enable or disable viewport contain the svg (default false)\n  center: true, // enable or disable viewport centering in SVG (default true)\n  refreshRate: \"auto\", // Maximum number of frames per second (altering SVG's viewport)\n  beforeZoom: null,\n  onZoom: null,\n  beforePan: null,\n  onPan: null,\n  customEventsHandler: null,\n  eventsListenerElement: null,\n  onUpdatedCTM: null,\n};\n\nvar passiveListenerTrueOption = { passive: true };\nvar passiveListenerFalseOption = { passive: false };\n\nSvgPanZoom.prototype.init = function (svg, options) {\n  var that = this;\n\n  this.svg = svg;\n  this.defs = svg.querySelector(\"defs\");\n\n  // Add default attributes to SVG\n  SvgUtils.setupSvgAttributes(this.svg);\n\n  // Set options\n  this.options = Utils.extend(Utils.extend({}, optionsDefaults), options);\n\n  // Set default state\n  this.state = \"none\";\n\n  // Get dimensions\n  var boundingClientRectNormalized =\n    SvgUtils.getBoundingClientRectNormalized(svg);\n  this.width = boundingClientRectNormalized.width;\n  this.height = boundingClientRectNormalized.height;\n\n  // Init shadow viewport\n  this.viewport = ShadowViewport(\n    SvgUtils.getOrCreateViewport(this.svg, this.options.viewportSelector),\n    {\n      svg: this.svg,\n      width: this.width,\n      height: this.height,\n      fit: this.options.fit,\n      contain: this.options.contain,\n      center: this.options.center,\n      refreshRate: this.options.refreshRate,\n      // Put callbacks into functions as they can change through time\n      beforeZoom: function (oldScale, newScale) {\n        if (that.viewport && that.options.beforeZoom) {\n          return that.options.beforeZoom(oldScale, newScale);\n        }\n      },\n      onZoom: function (scale) {\n        if (that.viewport && that.options.onZoom) {\n          return that.options.onZoom(scale);\n        }\n      },\n      beforePan: function (oldPoint, newPoint) {\n        if (that.viewport && that.options.beforePan) {\n          return that.options.beforePan(oldPoint, newPoint);\n        }\n      },\n      onPan: function (point) {\n        if (that.viewport && that.options.onPan) {\n          return that.options.onPan(point);\n        }\n      },\n      onUpdatedCTM: function (ctm) {\n        if (that.viewport && that.options.onUpdatedCTM) {\n          return that.options.onUpdatedCTM(ctm);\n        }\n      },\n    }\n  );\n\n  // Wrap callbacks into public API context\n  var publicInstance = this.getPublicInstance();\n  publicInstance.setBeforeZoom(this.options.beforeZoom);\n  publicInstance.setOnZoom(this.options.onZoom);\n  publicInstance.setBeforePan(this.options.beforePan);\n  publicInstance.setOnPan(this.options.onPan);\n  publicInstance.setOnUpdatedCTM(this.options.onUpdatedCTM);\n\n  if (this.options.controlIconsEnabled) {\n    ControlIcons.enable(this);\n  }\n\n  // Init events handlers\n  this.lastMouseWheelEventTime = Date.now();\n  this.setupHandlers();\n};\n\n/**\n * Register event handlers\n */\nSvgPanZoom.prototype.setupHandlers = function () {\n  var that = this,\n    prevEvt = null; // use for touchstart event to detect double tap\n\n  this.eventListeners = {\n    // Mouse down group\n    pointerdown: function (evt) {\n      if (evt.pointerType === \"touch\") return;\n      var result = that.handleMouseDown(evt, prevEvt);\n      prevEvt = evt;\n      return result;\n    },\n    touchstart: function (evt) {\n      var result = that.handleTouchStart(evt, prevEvt);\n      prevEvt = evt;\n      return result;\n    },\n\n    // Mouse up group\n    pointerup: function (evt) {\n      if (evt.pointerType === \"touch\") return;\n      return that.handleMouseUp(evt);\n    },\n    touchend: function (evt) {\n      return that.handleTouchEnd(evt);\n    },\n\n    // Mouse move group\n    pointermove: function (evt) {\n      if (evt.pointerType === \"touch\") return;\n      return that.handleMouseMove(evt);\n    },\n    touchmove: function (evt) {\n      return that.handleTouchMove(evt);\n    },\n\n    // Mouse leave group\n    pointerleave: function (evt) {\n      if (evt.pointerType === \"touch\") return;\n      return that.handleMouseUp(evt);\n    },\n    pointercancel: function (evt) {\n      if (evt.pointerType === \"touch\") return;\n      return that.handleMouseUp(evt);\n    },\n    touchleave: function (evt) {\n      return that.handleTouchEnd(evt);\n    },\n    touchcancel: function (evt) {\n      return that.handleTouchEnd(evt);\n    },\n  };\n\n  // Init custom events handler if available\n  // eslint-disable-next-line eqeqeq\n  if (this.options.customEventsHandler != null) {\n    this.options.customEventsHandler.init({\n      svgElement: this.svg,\n      eventsListenerElement: this.options.eventsListenerElement,\n      instance: this.getPublicInstance(),\n    });\n\n    // Custom event handler may halt builtin listeners\n    var haltEventListeners =\n      this.options.customEventsHandler.haltEventListeners;\n    if (haltEventListeners && haltEventListeners.length) {\n      for (var i = haltEventListeners.length - 1; i >= 0; i--) {\n        if (this.eventListeners.hasOwnProperty(haltEventListeners[i])) {\n          delete this.eventListeners[haltEventListeners[i]];\n        }\n      }\n    }\n  }\n\n  // Bind eventListeners\n  for (var event in this.eventListeners) {\n    // Attach event to eventsListenerElement or SVG if not available\n    (this.options.eventsListenerElement || this.svg).addEventListener(\n      event,\n      this.eventListeners[event],\n      !this.options.preventMouseEventsDefault\n        ? passiveListenerTrueOption\n        : passiveListenerFalseOption\n    );\n  }\n\n  // Zoom using mouse wheel\n  if (this.options.mouseWheelZoomEnabled) {\n    this.options.mouseWheelZoomEnabled = false; // set to false as enable will set it back to true\n    this.enableMouseWheelZoom();\n  }\n};\n\n/**\n * Enable ability to zoom using mouse wheel\n */\nSvgPanZoom.prototype.enableMouseWheelZoom = function () {\n  if (!this.options.mouseWheelZoomEnabled) {\n    var that = this;\n\n    // Mouse wheel listener\n    this.wheelListener = function (evt) {\n      return that.handleMouseWheel(evt);\n    };\n\n    // Bind wheelListener\n    var isPassiveListener = !this.options.preventMouseEventsDefault;\n    Wheel.on(\n      this.options.eventsListenerElement || this.svg,\n      this.wheelListener,\n      isPassiveListener\n    );\n\n    this.options.mouseWheelZoomEnabled = true;\n  }\n};\n\n/**\n * Disable ability to zoom using mouse wheel\n */\nSvgPanZoom.prototype.disableMouseWheelZoom = function () {\n  if (this.options.mouseWheelZoomEnabled) {\n    var isPassiveListener = !this.options.preventMouseEventsDefault;\n    Wheel.off(\n      this.options.eventsListenerElement || this.svg,\n      this.wheelListener,\n      isPassiveListener\n    );\n    this.options.mouseWheelZoomEnabled = false;\n  }\n};\n\n/**\n * Handle mouse wheel event\n *\n * @param  {Event} evt\n */\nSvgPanZoom.prototype.handleMouseWheel = function (evt) {\n  if (!this.options.zoomEnabled || this.state !== \"none\") {\n    return;\n  }\n\n  if (this.options.preventMouseEventsDefault) {\n    if (evt.preventDefault) {\n      evt.preventDefault();\n    } else {\n      evt.returnValue = false;\n    }\n  }\n\n  // Default delta in case that deltaY is not available\n  var delta = evt.deltaY || 1,\n    timeDelta = Date.now() - this.lastMouseWheelEventTime,\n    divider = 3 + Math.max(0, 30 - timeDelta);\n\n  // Update cache\n  this.lastMouseWheelEventTime = Date.now();\n\n  // Make empirical adjustments for browsers that give deltaY in pixels (deltaMode=0)\n  if (\"deltaMode\" in evt && evt.deltaMode === 0 && evt.wheelDelta) {\n    delta = evt.deltaY === 0 ? 0 : Math.abs(evt.wheelDelta) / evt.deltaY;\n  }\n\n  delta =\n    -0.3 < delta && delta < 0.3\n      ? delta\n      : ((delta > 0 ? 1 : -1) * Math.log(Math.abs(delta) + 10)) / divider;\n\n  var inversedScreenCTM = this.svg.getScreenCTM().inverse(),\n    relativeMousePoint = SvgUtils.getEventPoint(evt, this.svg).matrixTransform(\n      inversedScreenCTM\n    ),\n    zoom = Math.pow(1 + this.options.zoomScaleSensitivity, -1 * delta); // multiplying by neg. 1 so as to make zoom in/out behavior match Google maps behavior\n\n  this.zoomAtPoint(zoom, relativeMousePoint);\n};\n\n/**\n * Zoom in at a SVG point\n *\n * @param  {SVGPoint} point\n * @param  {Float} zoomScale    Number representing how much to zoom\n * @param  {Boolean} zoomAbsolute Default false. If true, zoomScale is treated as an absolute value.\n *                                Otherwise, zoomScale is treated as a multiplied (e.g. 1.10 would zoom in 10%)\n */\nSvgPanZoom.prototype.zoomAtPoint = function (zoomScale, point, zoomAbsolute) {\n  var originalState = this.viewport.getOriginalState();\n\n  if (!zoomAbsolute) {\n    // Fit zoomScale in set bounds\n    if (\n      this.getZoom() * zoomScale <\n      this.options.minZoom * originalState.zoom\n    ) {\n      zoomScale = (this.options.minZoom * originalState.zoom) / this.getZoom();\n    } else if (\n      this.getZoom() * zoomScale >\n      this.options.maxZoom * originalState.zoom\n    ) {\n      zoomScale = (this.options.maxZoom * originalState.zoom) / this.getZoom();\n    }\n  } else {\n    // Fit zoomScale in set bounds\n    zoomScale = Math.max(\n      this.options.minZoom * originalState.zoom,\n      Math.min(this.options.maxZoom * originalState.zoom, zoomScale)\n    );\n    // Find relative scale to achieve desired scale\n    zoomScale = zoomScale / this.getZoom();\n  }\n\n  var oldCTM = this.viewport.getCTM(),\n    relativePoint = point.matrixTransform(oldCTM.inverse()),\n    modifier = this.svg\n      .createSVGMatrix()\n      .translate(relativePoint.x, relativePoint.y)\n      .scale(zoomScale)\n      .translate(-relativePoint.x, -relativePoint.y),\n    newCTM = oldCTM.multiply(modifier);\n\n  if (newCTM.a !== oldCTM.a) {\n    this.viewport.setCTM(newCTM);\n  }\n};\n\n/**\n * Zoom at center point\n *\n * @param  {Float} scale\n * @param  {Boolean} absolute Marks zoom scale as relative or absolute\n */\nSvgPanZoom.prototype.zoom = function (scale, absolute) {\n  this.zoomAtPoint(\n    scale,\n    SvgUtils.getSvgCenterPoint(this.svg, this.width, this.height),\n    absolute\n  );\n};\n\n/**\n * Zoom used by public instance\n *\n * @param  {Float} scale\n * @param  {Boolean} absolute Marks zoom scale as relative or absolute\n */\nSvgPanZoom.prototype.publicZoom = function (scale, absolute) {\n  if (absolute) {\n    scale = this.computeFromRelativeZoom(scale);\n  }\n\n  this.zoom(scale, absolute);\n};\n\n/**\n * Zoom at point used by public instance\n *\n * @param  {Float} scale\n * @param  {SVGPoint|Object} point    An object that has x and y attributes\n * @param  {Boolean} absolute Marks zoom scale as relative or absolute\n */\nSvgPanZoom.prototype.publicZoomAtPoint = function (scale, point, absolute) {\n  if (absolute) {\n    // Transform zoom into a relative value\n    scale = this.computeFromRelativeZoom(scale);\n  }\n\n  // If not a SVGPoint but has x and y then create a SVGPoint\n  if (Utils.getType(point) !== \"SVGPoint\") {\n    if (\"x\" in point && \"y\" in point) {\n      point = SvgUtils.createSVGPoint(this.svg, point.x, point.y);\n    } else {\n      throw new Error(\"Given point is invalid\");\n    }\n  }\n\n  this.zoomAtPoint(scale, point, absolute);\n};\n\n/**\n * Get zoom scale\n *\n * @return {Float} zoom scale\n */\nSvgPanZoom.prototype.getZoom = function () {\n  return this.viewport.getZoom();\n};\n\n/**\n * Get zoom scale for public usage\n *\n * @return {Float} zoom scale\n */\nSvgPanZoom.prototype.getRelativeZoom = function () {\n  return this.viewport.getRelativeZoom();\n};\n\n/**\n * Compute actual zoom from public zoom\n *\n * @param  {Float} zoom\n * @return {Float} zoom scale\n */\nSvgPanZoom.prototype.computeFromRelativeZoom = function (zoom) {\n  return zoom * this.viewport.getOriginalState().zoom;\n};\n\n/**\n * Set zoom to initial state\n */\nSvgPanZoom.prototype.resetZoom = function () {\n  var originalState = this.viewport.getOriginalState();\n\n  this.zoom(originalState.zoom, true);\n};\n\n/**\n * Set pan to initial state\n */\nSvgPanZoom.prototype.resetPan = function () {\n  this.pan(this.viewport.getOriginalState());\n};\n\n/**\n * Set pan and zoom to initial state\n */\nSvgPanZoom.prototype.reset = function () {\n  this.resetZoom();\n  this.resetPan();\n};\n\n/**\n * Handle double click event\n * See handleMouseDown() for alternate detection method\n *\n * @param {Event} evt\n */\nSvgPanZoom.prototype.handleDblClick = function (evt) {\n  if (this.options.preventMouseEventsDefault) {\n    if (evt.preventDefault) {\n      evt.preventDefault();\n    } else {\n      evt.returnValue = false;\n    }\n  }\n\n  // Check if target was a control button\n  if (this.options.controlIconsEnabled) {\n    var targetClass = evt.target.getAttribute(\"class\") || \"\";\n    if (targetClass.indexOf(\"svg-pan-zoom-control\") > -1) {\n      return false;\n    }\n  }\n\n  var zoomFactor;\n\n  if (evt.shiftKey) {\n    zoomFactor = 1 / ((1 + this.options.zoomScaleSensitivity) * 2); // zoom out when shift key pressed\n  } else {\n    zoomFactor = (1 + this.options.zoomScaleSensitivity) * 2;\n  }\n\n  var point = SvgUtils.getEventPoint(evt, this.svg).matrixTransform(\n    this.svg.getScreenCTM().inverse()\n  );\n  this.zoomAtPoint(zoomFactor, point);\n};\n\n/**\n * Handle click event\n *\n * @param {Event} evt\n */\nSvgPanZoom.prototype.handleMouseDown = function (evt, prevEvt) {\n  if (this.options.preventMouseEventsDefault) {\n    if (evt.preventDefault) {\n      evt.preventDefault();\n    } else {\n      evt.returnValue = false;\n    }\n  }\n\n  Utils.mouseAndTouchNormalize(evt, this.svg);\n\n  // Double click detection; more consistent than ondblclick\n  if (this.options.dblClickZoomEnabled && Utils.isDblClick(evt, prevEvt)) {\n    this.handleDblClick(evt);\n  } else {\n    // Pan mode\n    this.state = \"pan\";\n    this.firstEventCTM = this.viewport.getCTM();\n    this.stateOrigin = SvgUtils.getEventPoint(evt, this.svg).matrixTransform(\n      this.firstEventCTM.inverse()\n    );\n  }\n};\n\n/**\n * Handle mouse move event\n *\n * @param  {Event} evt\n */\nSvgPanZoom.prototype.handleMouseMove = function (evt) {\n  if (this.options.preventMouseEventsDefault) {\n    if (evt.preventDefault) {\n      evt.preventDefault();\n    } else {\n      evt.returnValue = false;\n    }\n  }\n\n  if (this.state === \"pan\" && this.options.panEnabled) {\n    // Pan mode\n    var point = SvgUtils.getEventPoint(evt, this.svg).matrixTransform(\n        this.firstEventCTM.inverse()\n      ),\n      viewportCTM = this.firstEventCTM.translate(\n        point.x - this.stateOrigin.x,\n        point.y - this.stateOrigin.y\n      );\n\n    this.viewport.setCTM(viewportCTM);\n  }\n};\n\n/**\n * Handle mouse button release event\n *\n * @param {Event} evt\n */\nSvgPanZoom.prototype.handleMouseUp = function (evt) {\n  if (this.options.preventMouseEventsDefault) {\n    if (evt.preventDefault) {\n      evt.preventDefault();\n    } else {\n      evt.returnValue = false;\n    }\n  }\n\n  if (this.state === \"pan\") {\n    // Quit pan mode\n    this.state = \"none\";\n  }\n};\n\n/**\n * Handle click event\n *\n * @param {Event} evt\n */\nSvgPanZoom.prototype.handleTouchStart = function (evt, prevEvt) {\n  if (evt.touches.length == 1) {\n    this.handleMouseDown(evt, prevEvt);\n  } else {\n    if (this.options.preventMouseEventsDefault) {\n      if (evt.preventDefault) {\n        evt.preventDefault();\n      } else {\n        evt.returnValue = false;\n      }\n    }\n\n    this.firstEventCTM = this.viewport.getCTM();\n    var touch1 = SvgUtils.getTouchPoint(evt, this.svg, 0);\n    var touch2 = SvgUtils.getTouchPoint(evt, this.svg, 1);\n    this.firstDistance = Utils.calculateDistance(touch1, touch2);\n    touch1.x = (touch1.x + touch2.x) / 2;\n    touch1.y = (touch1.y + touch2.y) / 2;\n    this.stateOrigin = touch1.matrixTransform(this.firstEventCTM.inverse());\n    this.firstZoomLevel = this.getZoom();\n  }\n};\n\n/**\n * Handle mouse move event\n *\n * @param  {Event} evt\n */\nSvgPanZoom.prototype.handleTouchMove = function (evt) {\n  if (evt.touches.length == 1) {\n    this.handleMouseMove(evt);\n  } else {\n    // pan and zoom\n    if (this.options.preventMouseEventsDefault) {\n      if (evt.preventDefault) {\n        evt.preventDefault();\n      } else {\n        evt.returnValue = false;\n      }\n    }\n    if (!this.options.panEnabled && !this.options.zoomEnabled) {\n      return;\n    }\n\n    var touch1 = SvgUtils.getTouchPoint(evt, this.svg, 0);\n    var touch2 = SvgUtils.getTouchPoint(evt, this.svg, 1);\n    var center = this.svg.createSVGPoint();\n    center.x = (touch1.x + touch2.x) / 2;\n    center.y = (touch1.y + touch2.y) / 2;\n\n    if (this.state === \"pan\" && this.options.panEnabled) {\n      // Pan mode\n      var point = center.matrixTransform(this.firstEventCTM.inverse());\n      var viewportCTM = this.firstEventCTM.translate(\n        point.x - this.stateOrigin.x,\n        point.y - this.stateOrigin.y\n      );\n      this.viewport.setCTM(viewportCTM);\n    }\n\n    if (this.options.zoomEnabled) {\n      // zoom\n      var distance = Utils.calculateDistance(touch1, touch2);\n      var scale = distance / this.firstDistance;\n      var inversedScreenCTM = this.svg.getScreenCTM().inverse();\n      var relativeTouchPoint = center.matrixTransform(inversedScreenCTM);\n      this.zoomAtPoint(this.firstZoomLevel * scale, relativeTouchPoint, true);\n    }\n  }\n};\n\n/**\n * Handle mouse button release event\n *\n * @param {Event} evt\n */\nSvgPanZoom.prototype.handleTouchEnd = function (evt) {\n  if (evt.touches.length == 0) {\n    this.handleMouseUp(evt);\n  } else {\n    if (this.options.preventMouseEventsDefault) {\n      if (evt.preventDefault) {\n        evt.preventDefault();\n      } else {\n        evt.returnValue = false;\n      }\n    }\n\n    this.firstEventCTM = this.viewport.getCTM();\n    if (evt.touches.length == 1) {\n      this.stateOrigin = SvgUtils.getEventPoint(evt, this.svg).matrixTransform(\n        this.firstEventCTM.inverse()\n      );\n    } else {\n      var touch1 = SvgUtils.getTouchPoint(evt, this.svg, 0);\n      var touch2 = SvgUtils.getTouchPoint(evt, this.svg, 1);\n      this.firstDistance = Utils.calculateDistance(touch1, touch2);\n      touch1.x = (touch1.x + touch2.x) / 2;\n      touch1.y = (touch1.y + touch2.y) / 2;\n      this.stateOrigin = touch1.matrixTransform(this.firstEventCTM.inverse());\n    }\n  }\n};\n\n/**\n * Adjust viewport size (only) so it will fit in SVG\n * Does not center image\n */\nSvgPanZoom.prototype.fit = function () {\n  var viewBox = this.viewport.getViewBox(),\n    newScale = Math.min(\n      this.width / viewBox.width,\n      this.height / viewBox.height\n    );\n\n  this.zoom(newScale, true);\n};\n\n/**\n * Adjust viewport size (only) so it will contain the SVG\n * Does not center image\n */\nSvgPanZoom.prototype.contain = function () {\n  var viewBox = this.viewport.getViewBox(),\n    newScale = Math.max(\n      this.width / viewBox.width,\n      this.height / viewBox.height\n    );\n\n  this.zoom(newScale, true);\n};\n\n/**\n * Adjust viewport pan (only) so it will be centered in SVG\n * Does not zoom/fit/contain image\n */\nSvgPanZoom.prototype.center = function () {\n  var viewBox = this.viewport.getViewBox(),\n    offsetX =\n      (this.width - (viewBox.width + viewBox.x * 2) * this.getZoom()) * 0.5,\n    offsetY =\n      (this.height - (viewBox.height + viewBox.y * 2) * this.getZoom()) * 0.5;\n\n  this.getPublicInstance().pan({ x: offsetX, y: offsetY });\n};\n\n/**\n * Update content cached BorderBox\n * Use when viewport contents change\n */\nSvgPanZoom.prototype.updateBBox = function () {\n  this.viewport.simpleViewBoxCache();\n};\n\n/**\n * Pan to a rendered position\n *\n * @param  {Object} point {x: 0, y: 0}\n */\nSvgPanZoom.prototype.pan = function (point) {\n  var viewportCTM = this.viewport.getCTM();\n  viewportCTM.e = point.x;\n  viewportCTM.f = point.y;\n  this.viewport.setCTM(viewportCTM);\n};\n\n/**\n * Relatively pan the graph by a specified rendered position vector\n *\n * @param  {Object} point {x: 0, y: 0}\n */\nSvgPanZoom.prototype.panBy = function (point) {\n  var viewportCTM = this.viewport.getCTM();\n  viewportCTM.e += point.x;\n  viewportCTM.f += point.y;\n  this.viewport.setCTM(viewportCTM);\n};\n\n/**\n * Get pan vector\n *\n * @return {Object} {x: 0, y: 0}\n */\nSvgPanZoom.prototype.getPan = function () {\n  var state = this.viewport.getState();\n\n  return { x: state.x, y: state.y };\n};\n\n/**\n * Recalculates cached svg dimensions and controls position\n */\nSvgPanZoom.prototype.resize = function () {\n  // Get dimensions\n  var boundingClientRectNormalized = SvgUtils.getBoundingClientRectNormalized(\n    this.svg\n  );\n  this.width = boundingClientRectNormalized.width;\n  this.height = boundingClientRectNormalized.height;\n\n  // Recalculate original state\n  var viewport = this.viewport;\n  viewport.options.width = this.width;\n  viewport.options.height = this.height;\n  viewport.processCTM();\n\n  // Reposition control icons by re-enabling them\n  if (this.options.controlIconsEnabled) {\n    this.getPublicInstance().disableControlIcons();\n    this.getPublicInstance().enableControlIcons();\n  }\n};\n\n/**\n * Unbind mouse events, free callbacks and destroy public instance\n */\nSvgPanZoom.prototype.destroy = function () {\n  var that = this;\n\n  // Free callbacks\n  this.beforeZoom = null;\n  this.onZoom = null;\n  this.beforePan = null;\n  this.onPan = null;\n  this.onUpdatedCTM = null;\n\n  // Destroy custom event handlers\n  // eslint-disable-next-line eqeqeq\n  if (this.options.customEventsHandler != null) {\n    this.options.customEventsHandler.destroy({\n      svgElement: this.svg,\n      eventsListenerElement: this.options.eventsListenerElement,\n      instance: this.getPublicInstance(),\n    });\n  }\n\n  // Unbind eventListeners\n  for (var event in this.eventListeners) {\n    (this.options.eventsListenerElement || this.svg).removeEventListener(\n      event,\n      this.eventListeners[event],\n      !this.options.preventMouseEventsDefault\n        ? passiveListenerTrueOption\n        : passiveListenerFalseOption\n    );\n  }\n\n  // Unbind wheelListener\n  this.disableMouseWheelZoom();\n\n  // Remove control icons\n  this.getPublicInstance().disableControlIcons();\n\n  // Remove instance from instancesStore\n  instancesStore = instancesStore.filter(function (instance) {\n    return instance.svg !== that.svg;\n  });\n\n  // Delete options and its contents\n  delete this.options;\n\n  // Delete viewport to make public shadow viewport functions uncallable\n  delete this.viewport;\n\n  // Destroy public instance and rewrite getPublicInstance\n  delete this.publicInstance;\n  delete this.pi;\n  this.getPublicInstance = function () {\n    return null;\n  };\n};\n\n/**\n * Returns a public instance object\n *\n * @return {Object} Public instance object\n */\nSvgPanZoom.prototype.getPublicInstance = function () {\n  var that = this;\n\n  // Create cache\n  if (!this.publicInstance) {\n    this.publicInstance = this.pi = {\n      // Pan\n      enablePan: function () {\n        that.options.panEnabled = true;\n        return that.pi;\n      },\n      disablePan: function () {\n        that.options.panEnabled = false;\n        return that.pi;\n      },\n      isPanEnabled: function () {\n        return !!that.options.panEnabled;\n      },\n      pan: function (point) {\n        that.pan(point);\n        return that.pi;\n      },\n      panBy: function (point) {\n        that.panBy(point);\n        return that.pi;\n      },\n      getPan: function () {\n        return that.getPan();\n      },\n      // Pan event\n      setBeforePan: function (fn) {\n        that.options.beforePan =\n          fn === null ? null : Utils.proxy(fn, that.publicInstance);\n        return that.pi;\n      },\n      setOnPan: function (fn) {\n        that.options.onPan =\n          fn === null ? null : Utils.proxy(fn, that.publicInstance);\n        return that.pi;\n      },\n      // Zoom and Control Icons\n      enableZoom: function () {\n        that.options.zoomEnabled = true;\n        return that.pi;\n      },\n      disableZoom: function () {\n        that.options.zoomEnabled = false;\n        return that.pi;\n      },\n      isZoomEnabled: function () {\n        return !!that.options.zoomEnabled;\n      },\n      enableControlIcons: function () {\n        if (!that.options.controlIconsEnabled) {\n          that.options.controlIconsEnabled = true;\n          ControlIcons.enable(that);\n        }\n        return that.pi;\n      },\n      disableControlIcons: function () {\n        if (that.options.controlIconsEnabled) {\n          that.options.controlIconsEnabled = false;\n          ControlIcons.disable(that);\n        }\n        return that.pi;\n      },\n      isControlIconsEnabled: function () {\n        return !!that.options.controlIconsEnabled;\n      },\n      // Double click zoom\n      enableDblClickZoom: function () {\n        that.options.dblClickZoomEnabled = true;\n        return that.pi;\n      },\n      disableDblClickZoom: function () {\n        that.options.dblClickZoomEnabled = false;\n        return that.pi;\n      },\n      isDblClickZoomEnabled: function () {\n        return !!that.options.dblClickZoomEnabled;\n      },\n      // Mouse wheel zoom\n      enableMouseWheelZoom: function () {\n        that.enableMouseWheelZoom();\n        return that.pi;\n      },\n      disableMouseWheelZoom: function () {\n        that.disableMouseWheelZoom();\n        return that.pi;\n      },\n      isMouseWheelZoomEnabled: function () {\n        return !!that.options.mouseWheelZoomEnabled;\n      },\n      // Zoom scale and bounds\n      setZoomScaleSensitivity: function (scale) {\n        that.options.zoomScaleSensitivity = scale;\n        return that.pi;\n      },\n      setMinZoom: function (zoom) {\n        that.options.minZoom = zoom;\n        return that.pi;\n      },\n      setMaxZoom: function (zoom) {\n        that.options.maxZoom = zoom;\n        return that.pi;\n      },\n      // Zoom event\n      setBeforeZoom: function (fn) {\n        that.options.beforeZoom =\n          fn === null ? null : Utils.proxy(fn, that.publicInstance);\n        return that.pi;\n      },\n      setOnZoom: function (fn) {\n        that.options.onZoom =\n          fn === null ? null : Utils.proxy(fn, that.publicInstance);\n        return that.pi;\n      },\n      // Zooming\n      zoom: function (scale) {\n        that.publicZoom(scale, true);\n        return that.pi;\n      },\n      zoomBy: function (scale) {\n        that.publicZoom(scale, false);\n        return that.pi;\n      },\n      zoomAtPoint: function (scale, point) {\n        that.publicZoomAtPoint(scale, point, true);\n        return that.pi;\n      },\n      zoomAtPointBy: function (scale, point) {\n        that.publicZoomAtPoint(scale, point, false);\n        return that.pi;\n      },\n      zoomIn: function () {\n        this.zoomBy(1 + that.options.zoomScaleSensitivity);\n        return that.pi;\n      },\n      zoomOut: function () {\n        this.zoomBy(1 / (1 + that.options.zoomScaleSensitivity));\n        return that.pi;\n      },\n      getZoom: function () {\n        return that.getRelativeZoom();\n      },\n      // CTM update\n      setOnUpdatedCTM: function (fn) {\n        that.options.onUpdatedCTM =\n          fn === null ? null : Utils.proxy(fn, that.publicInstance);\n        return that.pi;\n      },\n      // Reset\n      resetZoom: function () {\n        that.resetZoom();\n        return that.pi;\n      },\n      resetPan: function () {\n        that.resetPan();\n        return that.pi;\n      },\n      reset: function () {\n        that.reset();\n        return that.pi;\n      },\n      // Fit, Contain and Center\n      fit: function () {\n        that.fit();\n        return that.pi;\n      },\n      contain: function () {\n        that.contain();\n        return that.pi;\n      },\n      center: function () {\n        that.center();\n        return that.pi;\n      },\n      // Size and Resize\n      updateBBox: function () {\n        that.updateBBox();\n        return that.pi;\n      },\n      resize: function () {\n        that.resize();\n        return that.pi;\n      },\n      getSizes: function () {\n        return {\n          width: that.width,\n          height: that.height,\n          realZoom: that.getZoom(),\n          viewBox: that.viewport.getViewBox(),\n        };\n      },\n      // Destroy\n      destroy: function () {\n        that.destroy();\n        return that.pi;\n      },\n    };\n  }\n\n  return this.publicInstance;\n};\n\n/**\n * Stores pairs of instances of SvgPanZoom and SVG\n * Each pair is represented by an object {svg: SVGSVGElement, instance: SvgPanZoom}\n *\n * @type {Array}\n */\nvar instancesStore = [];\n\nvar svgPanZoom = function (elementOrSelector, options) {\n  var svg = Utils.getSvg(elementOrSelector);\n\n  if (svg === null) {\n    return null;\n  } else {\n    // Look for existent instance\n    for (var i = instancesStore.length - 1; i >= 0; i--) {\n      if (instancesStore[i].svg === svg) {\n        return instancesStore[i].instance.getPublicInstance();\n      }\n    }\n\n    // If instance not found - create one\n    instancesStore.push({\n      svg: svg,\n      instance: new SvgPanZoom(svg, options),\n    });\n\n    // Return just pushed instance\n    return instancesStore[\n      instancesStore.length - 1\n    ].instance.getPublicInstance();\n  }\n};\n\nmodule.exports = svgPanZoom;\n","import svgPanZoom, * as SvgPanZoom from \"@dash14/svg-pan-zoom\"\n\nexport interface Box {\n  top: number\n  bottom: number\n  left: number\n  right: number\n}\n\ninterface ViewArea {\n  box: Box\n  center: SvgPanZoom.Point\n}\n\nexport interface SvgPanZoomInstance extends SvgPanZoom.Instance {\n  fitToContents(): SvgPanZoomInstance\n  getViewArea(): ViewArea\n  getViewBox(): Box\n  setViewBox(box: Box): void\n  getRealZoom(): number\n  applyAbsoluteZoomLevel(zoomLevel: number, minZoomLevel: number, maxZoomLevel: number): void\n  setPanEnabled(enabled: boolean): SvgPanZoomInstance\n  setZoomEnabled(enabled: boolean): SvgPanZoomInstance\n}\n\nexport interface CustomEventOptions {\n  svgElement: SVGSVGElement;\n  instance: SvgPanZoomInstance;\n}\n\nexport interface CustomEventHandler {\n  init: (options: CustomEventOptions) => void;\n  haltEventListeners: string[];\n  destroy: (options: CustomEventOptions) => void;\n}\n\nexport interface SvgPanZoomOptions extends Omit<SvgPanZoom.Options, \"customEventsHandler\"> {\n  customEventsHandler?: CustomEventHandler; // (default null)\n}\n\nexport interface SvgPanZoomInternal extends SvgPanZoomInstance {\n  _isPanEnabled: boolean\n  _isZoomEnabled: boolean\n  _internalIsPanEnabled(): boolean\n  _internalEnablePan(): void\n  _internalDisablePan(): void\n  _internalIsZoomEnabled(): boolean\n  _internalEnableZoom(): void\n  _internalDisableZoom(): void\n}\n\nconst methods: Partial<SvgPanZoomInternal> = {\n  fitToContents(this: SvgPanZoomInternal) {\n    this.fit()\n      .center()\n      .zoomOut() // Zoom out two steps.\n      .zoomOut()\n    return this\n  },\n  getViewArea(this: SvgPanZoomInternal) {\n    const sizes = this.getSizes()\n    const pan = this.getPan()\n    const scale = sizes.realZoom\n    pan.x /= scale\n    pan.y /= scale\n    const viewport = {\n      width: sizes.width / scale,\n      height: sizes.height / scale,\n    }\n    return {\n      box: {\n        top: -pan.y,\n        bottom: viewport.height - pan.y,\n        left: -pan.x,\n        right: viewport.width - pan.x,\n      },\n      center: {\n        x: viewport.width / 2 - pan.x,\n        y: viewport.height / 2 - pan.y,\n      },\n    }\n  },\n  getViewBox(this: SvgPanZoomInternal): Box {\n    return this.getViewArea().box\n  },\n  setViewBox(this: SvgPanZoomInternal, box: Box) {\n    // Adjust zoom and pan to include the box.\n    // If the aspect ratio is different from the box, pan to\n    // include the box with keeping the center.\n    const width = box.right - box.left\n    const height = box.bottom - box.top\n    const { width: sizeWidth, height: sizeHeight } = this.getSizes()\n    const ratio = width / height\n    const currentRatio = sizeWidth / sizeHeight\n    const newWidth = ratio < currentRatio ? height * currentRatio : width\n    const newHeight = ratio > currentRatio ? width / currentRatio : height\n    const absoluteZoom = Math.min(\n      sizeWidth / newWidth,\n      sizeHeight / newHeight\n    )\n    const realZoom = this.getRealZoom()\n    const relativeZoom = this.getZoom()\n    const originalZoom = realZoom / relativeZoom\n    this.zoom(absoluteZoom / originalZoom)\n\n    const center = {\n      x: (box.left + width / 2) * absoluteZoom,\n      y: (box.top + height / 2) * absoluteZoom\n    }\n    this.pan({\n      x: -(center.x) + newWidth / 2 * absoluteZoom,\n      y: -(center.y) + newHeight / 2 * absoluteZoom\n    })\n  },\n  getRealZoom(this: SvgPanZoomInternal) {\n    return this.getSizes().realZoom\n  },\n  applyAbsoluteZoomLevel(this: SvgPanZoomInternal, zoomLevel: number, minZoomLevel: number, maxZoomLevel: number) {\n    // normalize\n    const min = Math.max(0.0001, minZoomLevel)\n    const max = Math.max(min, maxZoomLevel)\n    const zoom = Math.max(Math.min(max, zoomLevel), min)\n\n    const realZoom = this.getRealZoom()\n    const relativeZoom = this.getZoom()\n    const originalZoom = realZoom / relativeZoom\n\n    this.setMinZoom(min / originalZoom)\n      .setMaxZoom(max / originalZoom)\n      .zoom(zoom / originalZoom)\n  },\n  isPanEnabled(this: SvgPanZoomInternal) {\n    return this._isPanEnabled\n  },\n  enablePan(this: SvgPanZoomInternal) {\n    this._isPanEnabled = true\n    this._internalEnablePan()\n    return this\n  },\n  disablePan(this: SvgPanZoomInternal) {\n    this._isPanEnabled = false\n    this._internalDisablePan()\n    return this\n  },\n  isZoomEnabled(this: SvgPanZoomInternal) {\n    return this._isZoomEnabled\n  },\n  enableZoom(this: SvgPanZoomInternal) {\n    this._isZoomEnabled = true\n    this._internalEnableZoom()\n    return this\n  },\n  disableZoom(this: SvgPanZoomInternal) {\n    this._isZoomEnabled = false\n    this._internalDisableZoom()\n    return this\n  },\n  setPanEnabled(this: SvgPanZoomInternal, enabled: boolean) {\n    if (enabled) {\n      this.enablePan()\n    } else {\n      this.disablePan()\n    }\n    return this\n  },\n  setZoomEnabled(this: SvgPanZoomInternal, enabled: boolean) {\n    if (enabled) {\n      this.enableZoom()\n      this.enableDblClickZoom()\n    } else {\n      this.disableZoom()\n      this.disableDblClickZoom()\n    }\n    return this\n  },\n}\n\nfunction constructor(\n  svgPanZoom: SvgPanZoom.Instance,\n  options: SvgPanZoomOptions,\n): SvgPanZoomInternal {\n  const instance = svgPanZoom as SvgPanZoomInternal\n  instance._isPanEnabled = options.panEnabled ?? true\n  instance._isZoomEnabled = options?.zoomEnabled ?? true\n  instance._internalIsPanEnabled = instance.isPanEnabled\n  instance._internalEnablePan = instance.enablePan\n  instance._internalDisablePan = instance.disablePan\n  instance._internalIsZoomEnabled = instance.isZoomEnabled\n  instance._internalEnableZoom = instance.enableZoom\n  instance._internalDisableZoom = instance.disableZoom\n  Object.assign(svgPanZoom, methods)\n  return instance\n}\n\nexport function createSvgPanZoomEx(\n  svg: SVGElement,\n  options: SvgPanZoomOptions\n): SvgPanZoomInstance {\n\n  const userInit = options.customEventsHandler?.init ?? ((_: any) => {})\n  const userDestroy = options.customEventsHandler?.destroy ?? ((_: any) => {})\n  const haltEventListeners = options.customEventsHandler?.haltEventListeners ?? []\n\n  if (options.mouseWheelZoomEnabled === undefined) {\n    options.mouseWheelZoomEnabled = options.zoomEnabled\n  }\n\n  options.customEventsHandler = {\n    init: o => {\n      constructor(o.instance, options)\n      userInit(o)\n    },\n    destroy: o => userDestroy(o),\n    haltEventListeners\n  }\n\n  return svgPanZoom(svg, options as SvgPanZoom.Options) as SvgPanZoomInternal\n}\n","import { ref, Ref, onMounted, onUnmounted } from \"vue\"\nimport { nonNull } from \"@/common/common\"\nimport { createSvgPanZoomEx, SvgPanZoomInstance, SvgPanZoomOptions } from \"@/modules/svg-pan-zoom-ex\"\n\ntype Callback = () => void\n\nenum State {\n  INITIAL = 0,\n  MOUNTED = 1,\n  UNMOUNTED = 2\n}\n\nexport function useSvgPanZoom(svg: Ref<SVGSVGElement | undefined>, options: SvgPanZoomOptions) {\n  const instance = ref<SvgPanZoomInstance>()\n  let state = State.INITIAL\n  const mountedCallbacks: Callback[] = []\n  const unmountedCallbacks: Callback[] = []\n\n  const instanceMounted = () => {\n    state = State.MOUNTED\n    mountedCallbacks.forEach(c => c())\n    mountedCallbacks.length = 0 // clear\n  }\n\n  const instanceUnmounted = () => {\n    state = State.UNMOUNTED\n    unmountedCallbacks.forEach(c => c())\n    unmountedCallbacks.length = 0 // clear\n  }\n\n  onMounted(() => {\n    const element = nonNull(svg.value, \"<svg>\")\n    // hook init/destroy custom events\n    const userInit = options.customEventsHandler?.init ?? ((_: any) => {})\n    const userDestroy = options.customEventsHandler?.destroy ?? ((_: any) => {})\n    const haltEventListeners = options.customEventsHandler?.haltEventListeners ?? []\n\n    options.customEventsHandler = {\n      init: o => {\n        instance.value = o.instance\n        userInit(o)\n        instanceMounted()\n      },\n      destroy: o => {\n        instanceUnmounted()\n        userDestroy(o)\n      },\n      haltEventListeners\n    }\n\n    const initialize = () => {\n      const rect = element.getBoundingClientRect()\n      // In svg-pan-zoom, the shadow viewport is generated based with\n      // size on initialization. At this time, if the width and height\n      // are zero, an exception will occur during the calculation.\n      // Therefore, initialization is performed after allocating the area.\n      // Note that even after onMounted, the area is not allocated at\n      // the time of page switching with Nuxt.\n      if (rect.width !== 0 && rect.height !== 0) {\n        createSvgPanZoomEx(element, options)\n      } else {\n        setTimeout(initialize, 200)\n      }\n    }\n    initialize()\n  })\n\n  onUnmounted(() => {\n    instance.value?.destroy()\n    instance.value = undefined\n  })\n\n  const onSvgPanZoomMounted = (callback: Callback) => {\n    if (state === State.INITIAL) {\n      mountedCallbacks.push(callback)\n    } else if (state === State.MOUNTED) {\n      callback()\n    }\n  }\n\n  const onSvgPanZoomUnmounted = (callback: Callback) => {\n    if (state === State.INITIAL || state === State.MOUNTED) {\n      unmountedCallbacks.push(callback)\n    } else {\n      callback()\n    }\n  }\n\n  return { svgPanZoom: instance, onSvgPanZoomMounted, onSvgPanZoomUnmounted }\n}\n","import { provide, inject, InjectionKey, Ref, computed } from \"vue\"\nimport { nonNull } from \"@/common/common\"\nimport { ViewConfig } from \"@/common/configs\"\n\ninterface ZoomProvides {\n  zoomLevel: Ref<number>,\n  scale: Ref<number>\n}\n\nconst zoomLevelKey = Symbol(\"zoomLevel\") as InjectionKey<ZoomProvides>\n\nexport function provideZoomLevel(zoomLevel: Ref<number>, viewStyle: ViewConfig) {\n  const scale = computed(() => {\n    return viewStyle.scalingObjects ? 1 : (1 / zoomLevel.value)\n  })\n  provide(zoomLevelKey, {\n    zoomLevel,\n    scale\n  })\n  return { scale }\n}\n\nexport function useZoomLevel(): ZoomProvides {\n  return nonNull(inject(zoomLevelKey), \"zoomLevel\")\n}\n","import { nextTick, ref } from \"vue\"\n\ntype TimingFunction = \"ease\" | \"linear\" | \"ease-in\" | \"ease-out\" | \"ease-in-out\" | string\n\n/** Parameters of transition */\ninterface TransitionParameters {\n  enabled: boolean\n  duration: number\n  timingFunction: TimingFunction\n}\n\ntype Function = () => void | Promise<void>\n\nfunction isPromise(obj: any): boolean {\n  return obj instanceof Promise || (obj && typeof obj.then === \"function\")\n}\n\nexport function useTransitionWhile() {\n  let timerId: number | null = null\n  const transitionOption = ref<TransitionParameters>({\n    enabled: false,\n    duration: 300,\n    timingFunction: \"linear\"\n  })\n\n  function transitionWhile(\n    func: Function,\n    duration: number = 300,\n    timingFunction: TimingFunction = \"linear\"\n  ) {\n    if (timerId) {\n      clearTimeout(timerId)\n      timerId = null\n    }\n    transitionOption.value = {\n      enabled: true,\n      duration,\n      timingFunction\n    }\n\n    nextTick(async () => {\n      const promise = func()\n      if (isPromise(promise)) {\n        await promise\n      }\n\n      if (timerId) {\n        clearTimeout(timerId)\n      }\n      timerId = window?.setTimeout(() => {\n        transitionOption.value.enabled = false\n        timerId = null\n      }, duration)\n    })\n  }\n\n  return { transitionWhile, transitionOption }\n}\n\n","import { ref, Ref, watchEffect } from \"vue\"\nimport { InputPaths, Path } from \"@/common/types\"\n\nexport function useTranslatePathsToObject<T>(input: Ref<InputPaths>) {\n  const objects = ref<Record<string, Path>>({})\n\n  const isInCompatibilityModeForPath = ref(false)\n  let nextId = 1\n  const idStore = new Map<Path, string>()\n\n  // translate for compatibility\n  watchEffect(() => {\n    if (input.value instanceof Array) {\n      const containKeys = new Set<string>([])\n      objects.value = Object.fromEntries(\n        input.value.map(path => {\n          let id = path.id\n          if (!id) {\n            if (!isInCompatibilityModeForPath.value) {\n              isInCompatibilityModeForPath.value = true\n              console.warn(\n                \"[v-network-graph] Please specify the `id` field for the `Path` object.\" +\n                  \" Currently, this works for compatibility,\" +\n                  \" but in the future, the id field will be required.\"\n              )\n            }\n            id = idStore.get(path)\n            if (!id) {\n              id = \"path-\" + nextId++\n              idStore.set(path, id)\n            }\n          }\n          containKeys.add(id)\n          return [id, path]\n        })\n      )\n      if (isInCompatibilityModeForPath.value) {\n        for (const [path, id] of Array.from(idStore.entries())) {\n          if (!containKeys.has(id)) {\n            idStore.delete(path)\n          }\n        }\n      }\n    } else {\n      objects.value = input.value\n    }\n  })\n\n  return { objects, isInCompatibilityModeForPath }\n}\n","import { watch, reactive, ref, Ref } from \"vue\"\nimport isEqual from \"lodash-es/isEqual\"\nimport { Reactive } from \"../common/common\"\n\nexport function bindProp<T, K extends string & keyof T>(\n  props: T,\n  name: K,\n  emit: (event: `update:${K}`, ...args: any[]) => void,\n  filter?: (arg: T[K]) => T[K]\n): Ref<T[K]> {\n  // Build two-way binding ties.\n\n  // Since it is not always passed in props (emit does not\n  // rewrite it), always keep a ref for self management.\n\n  if (filter) {\n    const prop = ref<T[K]>(filter(props[name])) as Ref<T[K]>\n    const update = (filtered: T[K]) => {\n      if (!isEqual(filtered, prop.value)) {\n        prop.value = filtered\n      }\n      if (!isEqual(filtered, props[name])) {\n        emit(`update:${name}` as const, filtered)\n      }\n    }\n    watch(() => filter(prop.value), update)\n    watch(() => props[name],v => update(filter(v)))\n    if (prop.value !== props[name]) {\n      emit(`update:${name}` as const, prop.value)\n    }\n    return prop\n  }\n\n  const prop = ref<T[K]>(props[name]) as Ref<T[K]>\n  watch(\n    () => props[name],\n    v => {\n      if (!isEqual(v, prop.value)) {\n        prop.value = v\n      }\n    }\n  )\n  watch(prop, v => {\n    if (!isEqual(v, props[name])) {\n      emit(`update:${name}` as const, v)\n    }\n  })\n  return prop\n}\n\ntype KeysOfType<Obj, Val> = {\n  [K in keyof Obj]-?: Obj[K] extends Val ? K : never\n}[keyof Obj]\n\nexport function bindPropKeySet<T, K extends string & KeysOfType<T, string[]>>(\n  props: T,\n  name: K,\n  sourceObject: Ref<{ [name: string]: any }>,\n  emit: (event: `update:${K}`, ...args: any[]) => void\n): Reactive<Set<string>> {\n  // Generate two-way bindings for a given prop.\n  // Assumes that the specified prop indicates the key of the object.\n  const bound = reactive<Set<string>>(new Set())\n  watch(\n    () => props[name],\n    () => {\n      // Since it is not recognized as a string[] by type checking,\n      // use any for now.\n      const prop: string[] = props[name] as any\n      const filtered = prop.filter(n => n in sourceObject.value)\n      if (!isEqual(filtered, Array.from(bound))) {\n        bound.clear()\n        filtered.forEach(bound.add, bound)\n      }\n    },\n    { deep: true, immediate: true }\n  )\n  watch(bound, () => {\n    const array = Array.from(bound)\n    if (!isEqual(props[name], array)) {\n      emit(`update:${name}` as const, array)\n    }\n  })\n  return Reactive(bound)\n}\n","<script setup lang=\"ts\">\nimport { PropType, ref, watchEffect } from \"vue\"\nimport { AnyShapeStyle } from \"@/common/configs\"\nimport { useZoomLevel } from \"@/composables/zoom\"\nimport { applyScaleToDasharray } from \"@/utils/visual\"\n\nconst props = defineProps({\n  baseX: {\n    type: Number,\n    default: 0,\n  },\n  baseY: {\n    type: Number,\n    default: 0,\n  },\n  config: {\n    type: Object as PropType<AnyShapeStyle>,\n    required: true,\n  },\n})\n\nconst { scale } = useZoomLevel()\n\nconst x = ref(props.baseX)\nconst y = ref(props.baseY)\nconst strokeWidth = ref(0)\nconst strokeColor = ref(\"#000000\")\nconst strokeDasharray = ref<string | number | undefined>(undefined)\nconst radius = ref(0)\nconst width = ref(0)\nconst height = ref(0)\nconst borderRadius = ref(0)\n\nwatchEffect(() => {\n  const s = scale.value\n  strokeWidth.value = props.config.strokeWidth * s\n  strokeColor.value = props.config.strokeColor ?? \"none\"\n  strokeDasharray.value = applyScaleToDasharray(props.config.strokeDasharray, s)\n\n  if (props.config.type === \"circle\") {\n    x.value = props.baseX\n    y.value = props.baseY\n    radius.value = props.config.radius * s\n  } else {\n    width.value = props.config.width * s\n    height.value = props.config.height * s\n    borderRadius.value = props.config.borderRadius * s\n    x.value = props.baseX - width.value / 2\n    y.value = props.baseY - height.value / 2\n  }\n})\n\ndefineExpose({\n  x,\n  y,\n  strokeWidth,\n  strokeColor,\n  strokeDasharray,\n  radius,\n  width,\n  height,\n  borderRadius,\n})\n</script>\n\n<template>\n  <circle\n    v-if=\"config.type === 'circle'\"\n    class=\"v-shape-circle\"\n    :cx=\"x\"\n    :cy=\"y\"\n    :r=\"radius\"\n    :fill=\"config.color\"\n    :stroke=\"strokeColor\"\n    :stroke-width=\"strokeWidth\"\n    :stroke-dasharray=\"strokeDasharray\"\n  />\n  <rect\n    v-else\n    class=\"v-shape-rect\"\n    :x=\"x\"\n    :y=\"y\"\n    :width=\"width\"\n    :height=\"height\"\n    :rx=\"borderRadius\"\n    :ry=\"borderRadius\"\n    :fill=\"config.color\"\n    :stroke=\"strokeColor\"\n    :stroke-width=\"strokeWidth\"\n    :stroke-dasharray=\"strokeDasharray\"\n  />\n</template>\n","<script setup lang=\"ts\">\nimport { computed, PropType, reactive, Ref, ref, useAttrs, watch } from \"vue\"\nimport { onMounted, onUnmounted } from \"vue\"\nimport { LabelStyle } from \"@/common/configs\"\nimport { useZoomLevel } from \"@/composables/zoom\"\n\ntype Rect = { x: number; y: number; width: number; height: number }\n\nfunction updateBackgroundPosition(\n  element: SVGTextElement,\n  pos: Rect,\n  transform: Ref<string | undefined>\n) {\n  const bbox = element.getBBox()\n  pos.x = bbox.x\n  pos.y = bbox.y\n  pos.width = bbox.width\n  pos.height = bbox.height\n  transform.value = element.getAttribute(\"transform\") ?? undefined\n}\n\nfunction enableMutationObserver(\n  element: SVGTextElement,\n  pos: Rect,\n  transform: Ref<string | undefined>\n) {\n  const observer = new MutationObserver(() => {\n    updateBackgroundPosition(element, pos, transform)\n  })\n  observer.observe(element, {\n    attributes: true,\n    attributeFilter: [\"x\", \"y\", \"transform\", \"font-size\"],\n  })\n  updateBackgroundPosition(element, pos, transform)\n  return observer\n}\n\nconst props = defineProps({\n  text: {\n    type: String,\n    required: true,\n  },\n  x: {\n    type: Number,\n    required: true,\n  },\n  y: {\n    type: Number,\n    required: true,\n  },\n  dominantBaseline: {\n    type: String,\n    required: false,\n    default: \"central\"\n  },\n  config: {\n    type: Object as PropType<LabelStyle>,\n    required: true,\n  },\n})\n\nconst attrs = useAttrs()\n\nconst { scale } = useZoomLevel()\n\nconst texts = computed(() => props.text?.toString().split(/\\r?\\n/) ?? \"\")\n\nconst fontSize = computed(() => {\n  return attrs['font-size'] as number ?? (props.config.fontSize * scale.value)\n})\n\nconst lineHeight = computed(() => fontSize.value * props.config.lineHeight)\n\nconst topDeltaY = computed(() => {\n  const dominantBaseline = props.dominantBaseline\n  if (dominantBaseline === \"hanging\") {\n    return 0\n  } else if (dominantBaseline === \"central\") {\n    return -(lineHeight.value * (texts.value.length - 1)) / 2\n  } else {\n    // \"auto\", \"text-top\"\n    return -lineHeight.value * (texts.value.length - 1)\n  }\n})\n\nconst element = ref<SVGTextElement>()\nconst transform = ref(\"\") // copy from <text>\nconst pos = reactive<Rect>({ x: 0, y: 0, width: 0, height: 0 })\nconst backgroundRectPos = computed(() => {\n  const config = props.config.background\n  if (!config) return pos\n  let paddingVertical, paddingHorizontal\n  if (config.padding instanceof Object) {\n    paddingVertical = config.padding.vertical\n    paddingHorizontal = config.padding.horizontal\n  } else {\n    paddingVertical = config.padding ?? 0\n    paddingHorizontal = config.padding ?? 0\n  }\n  const lineMargin = lineHeight.value - fontSize.value\n  return {\n    x: pos.x - paddingHorizontal * scale.value,\n    y: pos.y - paddingVertical * scale.value - (lineMargin / 2),\n    width: pos.width + paddingHorizontal * 2 * scale.value,\n    height: pos.height + paddingVertical * 2 * scale.value + lineMargin,\n  }\n})\n\nlet observer: MutationObserver | undefined\nconst updateObserver = () => {\n  if (props.config.background && props.config.background.visible) {\n    if (!observer && element.value) {\n      observer = enableMutationObserver(element.value, pos, transform)\n    }\n  } else {\n    observer?.disconnect()\n    observer = undefined\n  }\n}\n\nonMounted(() => updateObserver())\nwatch(\n  () => props.config.background && props.config.background.visible,\n  (v, prev) => {\n    if (v == prev) return\n    updateObserver()\n  }\n)\nonUnmounted(() => {\n  observer?.disconnect()\n  observer = undefined\n})\n\ndefineExpose({ fontSize, element, transform, backgroundRectPos, scale })\n</script>\n\n<template>\n  <rect\n    v-if=\"config.background && config.background.visible\"\n    class=\"v-text-background\"\n    v-bind=\"backgroundRectPos\"\n    :rx=\"(config.background?.borderRadius ?? 0) * scale\"\n    :ry=\"(config.background?.borderRadius ?? 0) * scale\"\n    :fill=\"config.background?.color ?? '#ffffff'\"\n    :transform=\"transform\"\n  />\n  <text\n    ref=\"element\"\n    class=\"v-text\"\n    v-bind=\"$attrs\"\n    :x=\"x\"\n    :y=\"y\"\n    :dominant-baseline=\"dominantBaseline\"\n    :font-family=\"$attrs['font-family'] ? `${$attrs['font-family']}` : config.fontFamily\"\n    :font-size=\"fontSize\"\n    :fill=\"$attrs.fill ? `${$attrs.fill}` : config.color\"\n  >\n    <template v-if=\"texts.length <= 1\">\n      {{ text }}\n    </template>\n    <template v-else>\n      <!--\n        In Safari, it seems that `<tspan>` does not inherit the\n        `dominant-baseline` attribute from its parent `<text>` element.\n        Therefore, set the dominant-baseline directly on `<tspan>`.\n        Chrome and Firefox do not have this issue.\n        refs. https://stackoverflow.com/questions/41985077/centering-an-svg-element-chrome-vs-safari/42023579#42023579\n      -->\n      <tspan\n        v-for=\"(t, i) in texts\"\n        :key=\"i\"\n        :x=\"x\"\n        :dy=\"i == 0 ? topDeltaY : lineHeight\"\n        :dominant-baseline=\"dominantBaseline\"\n      >{{ t }}</tspan>\n    </template>\n  </text>\n</template>\n","\nexport default (sfc, props) => {\n  const target = sfc.__vccOpts || sfc;\n  for (const [key, val] of props) {\n    target[key] = val;\n  }\n  return target;\n}\n","<script setup lang=\"ts\">\nimport { computed, PropType, ref, watchEffect } from \"vue\"\nimport { Position } from \"@/common/types\"\nimport { NodeLabelDirection } from \"@/common/configs\"\nimport { NodeState } from \"@/models/node\"\nimport { useNodeConfig } from \"@/composables/config\"\nimport { useMouseOperation } from \"@/composables/mouse\"\nimport { useZoomLevel } from \"@/composables/zoom\"\nimport VShape from \"@/components/base/VShape.vue\"\nimport VText from \"@/components/base/VLabelText.vue\"\n\nconst props = defineProps({\n  id: {\n    type: String,\n    required: true,\n  },\n  state: {\n    type: Object as PropType<NodeState>,\n    required: true,\n  },\n  pos: {\n    type: Object as PropType<Position>,\n    required: false,\n    default: undefined,\n  },\n})\n\nconst x = computed(() => props.pos?.x || 0)\nconst y = computed(() => props.pos?.y || 0)\n\nconst config = useNodeConfig()\nconst { scale } = useZoomLevel()\n\nconst {\n  handleNodePointerDownEvent,\n  handleNodePointerOverEvent,\n  handleNodePointerOutEvent,\n  handleNodeClickEvent,\n  handleNodeDoubleClickEvent,\n  handleNodeContextMenu,\n} = useMouseOperation()\n\nconst labelVisibility = computed(() => {\n  if (props.state.label.visible) {\n    return props.state.labelText ?? false\n  }\n  return false\n})\n\nconst labelMargin = computed(() => {\n  if (props.state.label.direction === NodeLabelDirection.CENTER) {\n    return 0\n  } else {\n    return props.state.label.margin * scale.value\n  }\n})\n\nconst labelShiftV = ref(0) // Amount of label shift (vertical)\nconst labelShiftH = ref(0) // Amount of label shift (horizontal)\nconst labelDiagonalShiftV = ref(0) // Amount of shift in diagonal direction (vertical)\nconst labelDiagonalShiftH = ref(0) // Amount of shift in diagonal direction (horizontal)\n\nwatchEffect(() => {\n  const s = scale.value\n  const shape = props.state.shape\n  if (shape.type == \"circle\") {\n    const radius = shape.radius * s\n    const m = radius + labelMargin.value\n    const diagonalMargin = Math.sqrt(m ** 2 / 2)\n    labelShiftV.value = radius + labelMargin.value\n    labelShiftH.value = radius + labelMargin.value\n    labelDiagonalShiftV.value = diagonalMargin\n    labelDiagonalShiftH.value = diagonalMargin\n  } else {\n    const borderRadius = shape.borderRadius * s\n    const width = shape.width * s\n    const height = shape.height * s\n    const m = borderRadius + labelMargin.value\n    const diagonalMargin = Math.sqrt(m ** 2 / 2)\n    labelShiftV.value = height / 2 + labelMargin.value\n    labelShiftH.value = width / 2 + labelMargin.value\n    labelDiagonalShiftV.value = height / 2 - borderRadius + diagonalMargin\n    labelDiagonalShiftH.value = width / 2 - borderRadius + diagonalMargin\n  }\n})\n\nconst textAnchor = computed(() => {\n  switch (props.state.label.direction) {\n    case NodeLabelDirection.CENTER:\n    case NodeLabelDirection.NORTH:\n    case NodeLabelDirection.SOUTH:\n      return \"middle\"\n    case NodeLabelDirection.EAST:\n    case NodeLabelDirection.NORTH_EAST:\n    case NodeLabelDirection.SOUTH_EAST:\n      return \"start\"\n    case NodeLabelDirection.WEST:\n    case NodeLabelDirection.NORTH_WEST:\n    case NodeLabelDirection.SOUTH_WEST:\n    default:\n      return \"end\"\n  }\n})\nconst dominantBaseline = computed(() => {\n  switch (props.state.label.direction) {\n    case NodeLabelDirection.NORTH:\n    case NodeLabelDirection.NORTH_EAST:\n    case NodeLabelDirection.NORTH_WEST:\n      return \"text-top\"\n    case NodeLabelDirection.SOUTH:\n    case NodeLabelDirection.SOUTH_EAST:\n    case NodeLabelDirection.SOUTH_WEST:\n      return \"hanging\"\n    case NodeLabelDirection.CENTER:\n    case NodeLabelDirection.EAST:\n    case NodeLabelDirection.WEST:\n    default:\n      return \"central\"\n  }\n})\nconst labelX = computed(() => {\n  switch (props.state.label.direction) {\n    case NodeLabelDirection.CENTER:\n    case NodeLabelDirection.NORTH:\n    case NodeLabelDirection.SOUTH:\n      return 0\n    case NodeLabelDirection.EAST:\n      return labelShiftH.value\n    case NodeLabelDirection.WEST:\n      return -labelShiftH.value\n    case NodeLabelDirection.NORTH_EAST:\n    case NodeLabelDirection.SOUTH_EAST:\n      return labelDiagonalShiftH.value\n    case NodeLabelDirection.NORTH_WEST:\n    case NodeLabelDirection.SOUTH_WEST:\n    default:\n      return -labelDiagonalShiftH.value\n  }\n})\nconst labelY = computed(() => {\n  switch (props.state.label.direction) {\n    case NodeLabelDirection.NORTH:\n      return -labelShiftV.value\n    case NodeLabelDirection.SOUTH:\n      return labelShiftV.value\n    case NodeLabelDirection.CENTER:\n    case NodeLabelDirection.EAST:\n    case NodeLabelDirection.WEST:\n      return 0\n    case NodeLabelDirection.NORTH_EAST:\n    case NodeLabelDirection.NORTH_WEST:\n      return -labelDiagonalShiftV.value\n    case NodeLabelDirection.SOUTH_EAST:\n    case NodeLabelDirection.SOUTH_WEST:\n    default:\n      return labelDiagonalShiftV.value\n  }\n})\n\ndefineExpose({\n  x,\n  y,\n  config,\n  labelVisibility,\n  handleNodePointerDownEvent,\n  handleNodePointerOverEvent,\n  handleNodePointerOutEvent,\n  handleNodeClickEvent,\n  handleNodeDoubleClickEvent,\n  handleNodeContextMenu,\n  textAnchor,\n  dominantBaseline,\n  labelX,\n  labelY,\n  scale,\n})\n</script>\n\n<template>\n  <g\n    :class=\"{ 'v-node': true, hover: state.hovered, selected: state.selected }\"\n    :transform=\"`translate(${x} ${y})`\"\n    @pointerdown.stop=\"handleNodePointerDownEvent(id, $event)\"\n    @pointerenter.passive=\"handleNodePointerOverEvent(id, $event)\"\n    @pointerleave.passive=\"handleNodePointerOutEvent(id, $event)\"\n    @click.stop=\"handleNodeClickEvent(id, $event)\"\n    @dblclick.stop=\"handleNodeDoubleClickEvent(id, $event)\"\n    @contextmenu=\"handleNodeContextMenu(id, $event)\"\n  >\n    <slot\n      name=\"override-node\"\n      :node-id=\"id\"\n      :scale=\"scale\"\n      :config=\"state.shape\"\n      :class=\"{ draggable: state.draggable, selectable: state.selectable }\"\n    >\n      <v-shape\n        :config=\"state.shape\"\n        :class=\"{ draggable: state.draggable, selectable: state.selectable }\"\n      />\n    </slot>\n    <slot\n      v-if=\"labelVisibility\"\n      name=\"override-node-label\"\n      :node-id=\"id\"\n      :scale=\"scale\"\n      :text=\"state.labelText\"\n      :x=\"labelX\"\n      :y=\"labelY\"\n      :config=\"state.label\"\n      :shape=\"state.shape\"\n      :text-anchor=\"textAnchor\"\n      :dominant-baseline=\"dominantBaseline\"\n    >\n      <v-text\n        :text=\"state.labelText\"\n        :x=\"labelX\"\n        :y=\"labelY\"\n        :config=\"state.label\"\n        :text-anchor=\"textAnchor\"\n        :dominant-baseline=\"dominantBaseline\"\n      />\n    </slot>\n  </g>\n</template>\n\n<style lang=\"scss\" scoped>\n$transition: 0.1s linear;\n\n:where(.v-shape-circle) {\n  pointer-events: none;\n  transition: fill $transition, stroke $transition, stroke-width $transition,\n  r $transition;\n}\n:where(.v-shape-rect) {\n  pointer-events: none;\n  transition: fill $transition, stroke $transition, stroke-width $transition,\n    x $transition, y $transition, width $transition, height $transition;\n}\n.v-node {\n  :deep(.draggable),\n  :deep(.selectable) {\n    pointer-events: all;\n    cursor: pointer;\n  }\n  :deep(.v-text) {\n    pointer-events: none;\n    user-select: none;\n    cursor: default;\n  }\n  :where(.v-text) {\n    transition: x $transition, y $transition;\n  }\n}\n\n</style>\n","<script setup lang=\"ts\">\nimport { computed, PropType, reactive, watchEffect } from \"vue\"\nimport { Position } from \"@/common/types\"\nimport { CircleShapeStyle, RectangleShapeStyle, ShapeStyle } from \"@/common/configs\"\nimport { NodeState } from \"@/models/node\"\nimport { useNodeConfig } from \"@/composables/config\"\nimport VShape from \"@/components/base/VShape.vue\"\n\nconst props = defineProps({\n  id: {\n    type: String,\n    required: true,\n  },\n  state: {\n    type: Object as PropType<NodeState>,\n    required: true,\n  },\n  pos: {\n    type: Object as PropType<Position>,\n    required: false,\n    default: undefined,\n  },\n})\n\nconst x = computed(() => props.pos?.x || 0)\nconst y = computed(() => props.pos?.y || 0)\n\nconst config = useNodeConfig()\nconst shapeConfig = reactive<ShapeStyle>({} as any)\n\nwatchEffect(() => {\n  const shapeStyle = props.state.shape\n  if (shapeStyle.type === \"circle\") {\n    const shape: CircleShapeStyle = {\n      type: \"circle\",\n      radius:\n        shapeStyle.radius +\n        (shapeStyle.strokeWidth ?? 0) / 2 +\n        config.focusring.padding +\n        config.focusring.width / 2,\n      color: \"none\",\n      strokeWidth: config.focusring.width,\n      strokeColor: config.focusring.color,\n      strokeDasharray: config.focusring.dasharray,\n    }\n    Object.assign(shapeConfig, shape)\n  } else {\n    const shape: RectangleShapeStyle = {\n      type: \"rect\",\n      width:\n        shapeStyle.width +\n        (shapeStyle.strokeWidth ?? 0) +\n        config.focusring.padding * 2 +\n        config.focusring.width,\n      height:\n        shapeStyle.height +\n        (shapeStyle.strokeWidth ?? 0) +\n        config.focusring.padding * 2 +\n        config.focusring.width,\n      borderRadius:\n        shapeStyle.borderRadius > 0 ? shapeStyle.borderRadius + config.focusring.padding : 0,\n      color: \"none\",\n      strokeWidth: config.focusring.width,\n      strokeColor: config.focusring.color,\n      strokeDasharray: config.focusring.dasharray,\n    }\n    Object.assign(shapeConfig, shape)\n  }\n})\n\ndefineExpose({ x, y, shapeConfig })\n</script>\n\n<template>\n  <v-shape\n    class=\"v-node-focus-ring\"\n    :base-x=\"x\"\n    :base-y=\"y\"\n    :config=\"shapeConfig\"\n  />\n</template>\n\n<style lang=\"scss\" scoped>\n$transition: 0.1s linear;\n\n.v-node-focus-ring {\n  pointer-events: none;\n}\n\n:where(.v-shape-circle) {\n  transition: r $transition;\n}\n:where(.v-shape-rect) {\n  transition: x $transition, y $transition, width $transition, height $transition;\n}\n:where(.dragging .v-shape-circleg),\n:where(.dragging .v-shape-rect) {\n  transition: none;\n}\n</style>\n","<script setup lang=\"ts\">\nimport { computed, PropType } from \"vue\"\nimport { Position } from \"@/common/types\";\nimport { StrokeStyle } from \"@/common/configs\"\nimport { useZoomLevel } from \"@/composables/zoom\"\nimport { applyScaleToDasharray, getDasharrayUnit } from \"@/utils/visual\"\n\nconst props = defineProps({\n  p1: {\n    type: Object as PropType<Position>,\n    required: true,\n  },\n  p2: {\n    type: Object as PropType<Position>,\n    required: true,\n  },\n  config: {\n    type: Object as PropType<StrokeStyle>,\n    required: true,\n  },\n})\n\nconst { scale } = useZoomLevel()\n\nconst strokeWidth = computed(() => {\n  return props.config.width * scale.value\n})\n\nconst strokeDasharray = computed(() => {\n  return applyScaleToDasharray(props.config.dasharray, scale.value)\n})\n\nconst animationSpeed = computed(() => {\n  const speed = props.config.animate\n    ? getDasharrayUnit(props.config.dasharray) * props.config.animationSpeed * scale.value\n    : false\n  return speed ? `--animation-speed:${speed}` : undefined\n})\n\ndefineExpose({ strokeWidth, strokeDasharray, animationSpeed })\n</script>\n\n<template>\n  <path\n    :class=\"{ 'v-line': true, animate: config.animate }\"\n    :d=\"`M ${p1.x} ${p1.y} L ${p2.x} ${p2.y}`\"\n    :stroke=\"config.color\"\n    :stroke-width=\"strokeWidth\"\n    :stroke-dasharray=\"strokeDasharray\"\n    :stroke-linecap=\"config.linecap\"\n    :style=\"animationSpeed\"\n  />\n</template>\n\n<style scoped>\n.v-line.animate {\n  --animation-speed: 100;\n  animation: dash 10s linear infinite;\n  stroke-dashoffset: var(--animation-speed);\n}\n@keyframes dash {\n  to {\n    stroke-dashoffset: 0;\n  }\n}\n</style>\n","<script setup lang=\"ts\">\nimport { computed, PropType } from \"vue\"\nimport { StrokeStyle } from \"@/common/configs\"\nimport { EdgeState } from \"@/models/edge\"\nimport { useZoomLevel } from \"@/composables/zoom\"\nimport { applyScaleToDasharray, getDasharrayUnit } from \"@/utils/visual\"\nimport chunk from \"lodash-es/chunk\"\n\nconst props = defineProps({\n  state: {\n    type: Object as PropType<EdgeState>,\n    required: true,\n  },\n  config: {\n    type: Object as PropType<StrokeStyle>,\n    required: true,\n  },\n  markerStart: {\n    type: String,\n    required: false,\n    default: undefined\n  },\n  markerEnd: {\n    type: String,\n    required: false,\n    default: undefined\n  }\n})\n\nconst { scale } = useZoomLevel()\n\nconst pathD = computed(() => {\n  const p = props.state.position\n  const points = [ ...props.state.curve?.control ?? [], { x: p.p2.x, y: p.p2.y }]\n  const d: string[] = []\n  d.push(`M ${p.p1.x} ${p.p1.y}`)\n  chunk(points, 2).forEach(([p1, p2]) => d.push(`Q ${p1.x} ${p1.y} ${p2.x} ${p2.y}`))\n  return d.join(\" \")\n})\n\nconst strokeWidth = computed(() => {\n  return props.config.width * scale.value\n})\n\nconst strokeDasharray = computed(() => {\n  return applyScaleToDasharray(props.config.dasharray, scale.value)\n})\n\nconst animationSpeed = computed(() => {\n  const speed = props.config.animate\n    ? getDasharrayUnit(props.config.dasharray) * props.config.animationSpeed * scale.value\n    : false\n  return speed ? `--animation-speed:${speed}` : undefined\n})\n\ndefineExpose({ strokeWidth, strokeDasharray, animationSpeed })\n</script>\n\n<template>\n  <!-- <circle\n    v-if=\"state.curve\"\n    :cx=\"state.curve.circle.center.x\"\n    :cy=\"state.curve.circle.center.y\"\n    :r=\"state.curve.circle.radius\"\n    fill=\"#ff000080\"\n  />\n  <circle\n    v-for=\"cp in state.curve?.control\"\n    :key=\"JSON.stringify(cp)\"\n    :cx=\"cp.x\"\n    :cy=\"cp.y\"\n    :r=\"2\"\n    fill=\"#0000ff\"\n  /> -->\n  <path\n    :class=\"{ 'v-line': true, animate: config.animate }\"\n    :d=\"pathD\"\n    fill=\"none\"\n    :stroke=\"config.color\"\n    :stroke-width=\"strokeWidth\"\n    :stroke-dasharray=\"strokeDasharray\"\n    :stroke-linecap=\"config.linecap\"\n    :style=\"animationSpeed\"\n    :marker-start=\"markerStart\"\n    :marker-end=\"markerEnd\"\n  />\n</template>\n\n<style scoped>\n.v-line.animate {\n  --animation-speed: 100;\n  animation: dash 10s linear infinite;\n  stroke-dashoffset: var(--animation-speed);\n}\n@keyframes dash {\n  to {\n    stroke-dashoffset: 0;\n  }\n}\n</style>\n","<script setup lang=\"ts\">\nimport { PropType } from \"vue\"\nimport { Position } from \"@/common/types\"\nimport { EdgeState } from \"@/models/edge\"\nimport { useEdgeConfig } from \"@/composables/config\"\nimport VLine from \"@/components/base/VLine.vue\"\nimport VEdgeCurved from \"./VEdgeCurved.vue\"\n\ndefineProps({\n  id: {\n    type: String,\n    required: true,\n  },\n  state: {\n    type: Object as PropType<EdgeState>,\n    required: true,\n  },\n  sourcePos: {\n    type: Object as PropType<Position>,\n    required: false,\n    default: undefined,\n  },\n  targetPos: {\n    type: Object as PropType<Position>,\n    required: false,\n    default: undefined,\n  },\n})\n\nconst config = useEdgeConfig()\n\ndefineExpose({ config })\n</script>\n\n<template>\n  <v-line\n    v-if=\"config.type == 'straight' || !state.curve\"\n    :data-edge-id=\"id\"\n    v-bind=\"state.position\"\n    :class=\"{ selectable: state.selectable, hover: state.hovered, selected: state.selected }\"\n    :config=\"state.line.stroke\"\n    :marker-start=\"state.sourceMarkerId ? `url('#${state.sourceMarkerId}')` : undefined\"\n    :marker-end=\"state.targetMarkerId ? `url('#${state.targetMarkerId}')` : undefined\"\n  />\n  <v-edge-curved\n    v-else\n    :data-edge-id=\"id\"\n    :class=\"{ selectable: state.selectable, hover: state.hovered, selected: state.selected }\"\n    :state=\"state\"\n    :config=\"state.line.stroke\"\n    :marker-start=\"state.sourceMarkerId ? `url('#${state.sourceMarkerId}')` : undefined\"\n    :marker-end=\"state.targetMarkerId ? `url('#${state.targetMarkerId}')` : undefined\"\n  />\n</template>\n\n<style lang=\"scss\" scoped>\n$transition: 0.1s linear;\n\n:where(.v-line) {\n  transition: stroke $transition, stroke-width $transition;\n  pointer-events: none;\n}\n</style>\n","<script setup lang=\"ts\">\nimport { computed, PropType, ref, watchEffect } from \"vue\"\nimport { Edges, NodePositions, LinePosition, Position } from \"@/common/types\"\nimport { Config } from \"@/common/configs\"\nimport { useEdgeConfig } from \"@/composables/config\"\nimport { useStates } from \"@/composables/state\"\nimport { useMouseOperation } from \"@/composables/mouse\"\nimport VLine from \"@/components/base/VLine.vue\"\nimport VShape from \"@/components/base/VShape.vue\"\nimport VText from \"@/components/base/VLabelText.vue\"\n\nconst props = defineProps({\n  edges: {\n    type: Object as PropType<Edges>,\n    required: true,\n  },\n  layouts: {\n    type: Object as PropType<NodePositions>,\n    required: true,\n  },\n})\n\nconst config = useEdgeConfig()\nconst {\n  handleEdgesPointerDownEvent,\n  handleEdgesPointerOverEvent,\n  handleEdgesPointerOutEvent,\n  handleEdgesClickEvent,\n  handleEdgesDoubleClickEvent,\n  handleEdgesContextMenu,\n} = useMouseOperation()\n\nconst { edgeStates } = useStates()\n\n// Since the specified edges are in the same pair,\n// get the first one and draw it.\nconst pos = ref<LinePosition>({ p1: { x: 0, y: 0 }, p2: { x: 0, y: 0 } })\nconst centerPos = ref<Position>({ x: 0, y: 0 })\n\nwatchEffect(() => {\n  const edgeId = Object.keys(props.edges).find(edgeId => edgeId in edgeStates)\n  if (edgeId) {\n    pos.value = edgeStates[edgeId].position\n    centerPos.value = {\n      x: (pos.value.p1.x + pos.value.p2.x) / 2,\n      y: (pos.value.p1.y + pos.value.p2.y) / 2,\n    }\n  }\n})\n\nconst edgeIds = computed(() => Object.keys(props.edges))\nconst labelConfig = computed(() => Config.values(config.summarized.label, props.edges))\nconst shapeConfig = computed(() => Config.values(config.summarized.shape, props.edges))\nconst strokeConfig = computed(() => Config.values(config.summarized.stroke, props.edges))\n\nconst hovered = computed(() => edgeIds.value.some(edge => edgeStates[edge].hovered))\nconst selectable = computed(() => edgeIds.value.some(edge => edgeStates[edge].selectable))\nconst selected = computed(() => edgeIds.value.some(edge => edgeStates[edge].selected))\n\ndefineExpose({\n  config,\n  pos,\n  centerPos,\n  handleEdgesPointerDownEvent,\n  handleEdgesPointerOverEvent,\n  handleEdgesPointerOutEvent,\n  handleEdgesClickEvent,\n  handleEdgesDoubleClickEvent,\n  handleEdgesContextMenu,\n  hovered,\n  selectable,\n  selected,\n})\n</script>\n\n<template>\n  <g\n    :class=\"{ 'v-line-summarized': true, hovered, selectable, selected }\"\n    @pointerdown.stop=\"handleEdgesPointerDownEvent(edgeIds, $event)\"\n    @pointerenter.passive=\"handleEdgesPointerOverEvent(edgeIds, $event)\"\n    @pointerleave.passive=\"handleEdgesPointerOutEvent(edgeIds, $event)\"\n    @click.stop=\"handleEdgesClickEvent(edgeIds, $event)\"\n    @dblclick.stop=\"handleEdgesDoubleClickEvent(edgeIds, $event)\"\n    @contextmenu=\"handleEdgesContextMenu(edgeIds, $event)\"\n  >\n    <v-line v-bind=\"pos\" :config=\"strokeConfig\" :data-edge-id=\"edgeIds[0]\" />\n    <v-shape :base-x=\"centerPos.x\" :base-y=\"centerPos.y\" :config=\"shapeConfig\" />\n    <v-text\n      :text=\"Object.keys(edges).length.toString()\"\n      :x=\"centerPos.x\"\n      :y=\"centerPos.y\"\n      :config=\"labelConfig\"\n      text-anchor=\"middle\"\n      dominant-baseline=\"central\"\n    />\n  </g>\n</template>\n\n<style lang=\"scss\" scoped>\n.v-line-summarized {\n  &.selectable {\n    cursor: pointer;\n  }\n}\n</style>\n","<script setup lang=\"ts\">\nimport { PropType } from \"vue\"\nimport { Edge, EdgePosition, Edges, LinePosition, Point } from \"@/common/types\"\nimport { EdgeState } from \"@/models/edge\"\nimport { useZoomLevel } from \"@/composables/zoom\";\nimport { useContainers } from \"@/composables/container\";\nimport { Config } from \"@/common/configs\";\nimport { useEdgeConfig } from \"@/composables/config\";\n\nconst props = defineProps({\n  edgeId: {\n    type: String,\n    required: false,\n    default: undefined\n  },\n  edge: {\n    type: Object as PropType<Edge>,\n    required: false,\n    default: undefined\n  },\n  edges: {\n    type: Object as PropType<Edges>,\n    required: false,\n    default: () => {}\n  },\n  state: {\n    type: Object as PropType<EdgeState>,\n    required: true\n  },\n  isSummarized: {\n    type: Boolean,\n    required: true\n  }\n})\n\nconst { svg } = useContainers()\nconst { scale } = useZoomLevel()\nconst edgeConfig = useEdgeConfig()\n\nfunction getStrokeConfig() {\n  if (props.isSummarized) {\n    return Config.values(edgeConfig.summarized.stroke, props.edges)\n  } else {\n    return props.state.line.stroke\n  }\n}\n\nfunction toEdgePosition(line: LinePosition): EdgePosition {\n  return { source: line.p1, target: line.p2 }\n}\n\nfunction calculateCenterPoint(state: EdgeState): Point {\n  if (state.curve) {\n    return state.curve.center\n  } else {\n    const p1 = state.origin.p1\n    const p2 = state.origin.p2\n    return {\n      x: (p1.x + p2.x) / 2,\n      y: (p1.y + p2.y) / 2,\n    }\n  }\n}\n\nfunction getPathTotalLength() {\n  if (!svg.value) return 0\n  const edgeId = props.edgeId ?? Object.keys(props.edges)[0]\n  const path = svg.value.querySelector<SVGPathElement>(`path[data-edge-id=\"${edgeId}\"]`)\n  if (!path) return 0\n  return path.getTotalLength()\n}\n\nfunction calculatePointAtLength(distance: number): Point {\n  if (!svg.value || !isFinite(distance)) return props.state.position.p1\n\n  // for detecting changes and re-calculation\n  props.state\n\n  const edgeId = props.edgeId ?? Object.keys(props.edges)[0]\n\n  const path = svg.value.querySelector<SVGPathElement>(`path[data-edge-id=\"${edgeId}\"]`)\n  if (!path) return props.state.position.p1\n\n  const p = path.getPointAtLength(distance)\n  return { x: p.x, y: p.y }\n}\n</script>\n\n<template>\n  <g class=\"v-edge-overlay\">\n    <slot\n      v-if=\"isSummarized\"\n      :edges=\"edges\"\n      :is-summarized=\"isSummarized\"\n      :stroke=\"getStrokeConfig()\"\n      :position=\"toEdgePosition(state.origin)\"\n      :center=\"calculateCenterPoint(state)\"\n      :hovered=\"state.hovered\"\n      :selected=\"state.selected\"\n      :scale=\"scale\"\n      :length=\"getPathTotalLength()\"\n      :point-at-length=\"calculatePointAtLength\"\n    />\n    <slot\n      v-else\n      :edge-id=\"edgeId\"\n      :edge=\"edge\"\n      :edges=\"{ [edgeId!]: edge }\"\n      :is-summarized=\"isSummarized\"\n      :stroke=\"getStrokeConfig()\"\n      :position=\"toEdgePosition(state.origin)\"\n      :center=\"calculateCenterPoint(state)\"\n      :hovered=\"state.hovered\"\n      :selected=\"state.selected\"\n      :scale=\"scale\"\n      :length=\"getPathTotalLength()\"\n      :point-at-length=\"calculatePointAtLength\"\n    />\n  </g>\n</template>","<script setup lang=\"ts\">\nimport { useStates, isSummarizedEdges } from \"@/composables/state\"\nimport VEdge from \"./VEdge.vue\"\nimport VEdgeSummarized from \"./VEdgeSummarized.vue\"\nimport VEdgeOverlay from \"./VEdgeOverlay.vue\"\n\ndefineProps({\n  hasEdgeOverlaySlot: {\n    type: Boolean,\n    required: true,\n  },\n})\n\nconst { edgeStates, edgeZOrderedList, edgeGroupStates, layouts } = useStates()\n\n// type FlattenEdge = {\n//     key: string\n//     summarize: true\n//     edges: Edges\n//     id?: undefined\n//     edge?: undefined\n// } | {\n//     key: string\n//     summarize: false\n//     edges?: undefined\n//     id: string\n//     edge: Edge\n// }\n\n// const flattenEdges = computed(() => {\n//   const results: FlattenEdge[] = []\n//   for (const [key, {summarize, edges}] of Object.entries(edgeGroupStates.edgeGroups)) {\n//     if (summarize) {\n//       results.push({ key, summarize, edges })\n//     } else {\n//       results.push(...Object.entries(edges).map(([id, edge]) => ({ key, summarize, id, edge })))\n//     }\n//   }\n//   return results\n// })\n\ndefineExpose({ edgeStates, edgeZOrderedList, edgeGroupStates, layouts })\n</script>\n\n<template>\n  <template v-for=\"entry in edgeZOrderedList\">\n    <template v-if=\"isSummarizedEdges(entry)\">\n      <v-edge-summarized\n        :key=\"entry.key\"\n        :edges=\"entry.group.edges\"\n        :layouts=\"layouts.nodes\"\n      />\n      <v-edge-overlay\n        v-if=\"hasEdgeOverlaySlot\"\n        :key=\"entry.key\"\n        :edges=\"entry.group.edges\"\n        :state=\"edgeStates[Object.keys(entry.group.edges)[0]]\"\n        :is-summarized=\"true\"\n      >\n        <template #default=\"slotProps\">\n          <slot v-bind=\"slotProps\" />\n        </template>\n      </v-edge-overlay>\n    </template>\n    <template v-else>\n      <v-edge\n        :key=\"entry.key\"\n        :id=\"entry.key\"\n        :state=\"edgeStates[entry.key]\"\n        :source-pos=\"layouts.nodes[entry.edge.source]\"\n        :target-pos=\"layouts.nodes[entry.edge.target]\"\n      />\n      <v-edge-overlay\n        v-if=\"hasEdgeOverlaySlot\"\n        :key=\"entry.key\"\n        :edge-id=\"entry.key\"\n        :edge=\"entry.edge\"\n        :state=\"edgeStates[entry.key]\"\n        :is-summarized=\"false\"\n      >\n        <template #default=\"slotProps\">\n          <slot v-bind=\"slotProps\" />\n        </template>\n      </v-edge-overlay>\n    </template>\n  </template>\n</template>\n","<script setup lang=\"ts\">\nimport { computed, PropType } from \"vue\"\nimport { Position } from \"@/common/types\"\nimport { EdgeState } from \"@/models/edge\"\nimport { useEdgeConfig } from \"@/composables/config\"\nimport { useMouseOperation } from \"@/composables/mouse\"\nimport { useZoomLevel } from \"@/composables/zoom\"\nimport chunk from \"lodash-es/chunk\"\n\nconst props = defineProps({\n  id: {\n    type: String,\n    required: true,\n  },\n  state: {\n    type: Object as PropType<EdgeState>,\n    required: true,\n  },\n  sourcePos: {\n    type: Object as PropType<Position>,\n    required: false,\n    default: undefined,\n  },\n  targetPos: {\n    type: Object as PropType<Position>,\n    required: false,\n    default: undefined,\n  },\n})\n\nconst { scale } = useZoomLevel()\n\nconst config = useEdgeConfig()\nconst {\n  handleEdgePointerDownEvent,\n  handleEdgePointerOverEvent,\n  handleEdgePointerOutEvent,\n  handleEdgeClickEvent,\n  handleEdgeDoubleClickEvent,\n  handleEdgeContextMenu,\n} = useMouseOperation()\n\nconst pathD = computed(() => {\n  const p = props.state.position\n  if (config.type === \"straight\" || !props.state.curve) {\n    return `M ${p.p1.x} ${p.p1.y} L ${p.p2.x} ${p.p2.y}`\n  } else {\n    const points = [ ...props.state.curve.control, { x: p.p2.x, y: p.p2.y }]\n    const d: string[] = []\n    d.push(`M ${p.p1.x} ${p.p1.y}`)\n    chunk(points, 2).forEach(([p1, p2]) => d.push(`Q ${p1.x} ${p1.y} ${p2.x} ${p2.y}`))\n    return d.join(\" \")\n  }\n})\n\nconst strokeWidth = computed(() => (props.state.line.stroke.width + 10) * scale.value)\n\ndefineExpose({\n  config,\n  handleEdgePointerDownEvent,\n  handleEdgePointerOverEvent,\n  handleEdgePointerOutEvent,\n  handleEdgeClickEvent,\n  handleEdgeDoubleClickEvent,\n  handleEdgeContextMenu,\n})\n</script>\n\n<template>\n  <path\n    :class=\"{ 'v-line-background': true, selectable: state.selectable }\"\n    :d=\"pathD\"\n    stroke=\"transparent\"\n    :stroke-width=\"strokeWidth\"\n    fill=\"none\"\n    @pointerdown.stop=\"handleEdgePointerDownEvent(id, $event)\"\n    @pointerenter.passive=\"handleEdgePointerOverEvent(id, $event)\"\n    @pointerleave.passive=\"handleEdgePointerOutEvent(id, $event)\"\n    @click.stop=\"handleEdgeClickEvent(id, $event)\"\n    @dblclick.stop=\"handleEdgeDoubleClickEvent(id, $event)\"\n    @contextmenu=\"handleEdgeContextMenu(id, $event)\"\n  />\n</template>\n\n<style lang=\"scss\" scoped>\n.v-line-background {\n  &.selectable {\n    cursor: pointer;\n  }\n}\n</style>\n","<script setup lang=\"ts\">\nimport { useStates } from \"@/composables/state\"\nimport VEdgeBackground from \"./VEdgeBackground.vue\"\n\nconst { edgeStates, edgeGroupStates, layouts } = useStates()\n\ndefineExpose({ edgeStates, edgeGroupStates, layouts })\n</script>\n\n<template>\n  <template v-for=\"({ summarize, edges }) in edgeGroupStates.edgeGroups\">\n    <template v-if=\"!summarize\">\n      <template v-for=\"(edge, id) in edges\" :key=\"id\">\n        <v-edge-background\n          :id=\"id\"\n          :state=\"edgeStates[id]\"\n          :source-pos=\"layouts.nodes[edge.source]\"\n          :target-pos=\"layouts.nodes[edge.target]\"\n        />\n      </template>\n    </template>\n  </template>\n</template>\n","<script setup lang=\"ts\">\nimport { computed } from \"vue\"\nimport { StrokeStyle } from \"@/common/configs\"\nimport { EdgeGroup } from \"@/models/edge\"\nimport { useStates } from \"@/composables/state\"\nimport { useEdgeConfig } from \"@/composables/config\"\nimport { useZoomLevel } from \"@/composables/zoom\"\nimport * as v2d from \"@/modules/calculation/2d\"\n\nconst edgeConfig = useEdgeConfig()\nconst { nodeStates, edgeStates, edgeGroupStates, summarizedEdgeStates, layouts } = useStates()\nconst { scale } = useZoomLevel()\n\n// not summarized\nconst individualEdgeGroups = computed(() =>\n  Object.fromEntries(\n    Object.entries(edgeGroupStates.edgeGroups).filter(\n      ([_, group]) => !group.summarize && Object.keys(group.edges).length > 0\n    )\n  )\n)\n\nconst edgeGroups = computed(() => {\n  const individual: Record<string, EdgeGroup> = {}\n  const summarized: Record<string, EdgeGroup> = {}\n  Object.entries(edgeGroupStates.edgeGroups).forEach(([id, group]) => {\n    if (Object.keys(group.edges).length > 0) {\n      if (group.summarize) {\n        summarized[id] = group\n      } else {\n        individual[id] = group\n      }\n    }\n  })\n  return { individual, summarized }\n})\n\nconst nodeShape = computed(() => (node: string) => {\n  return {\n    pos: layouts.nodes[node] ?? { x: 0, y: 0 },\n    shape: nodeStates[node].shape,\n  }\n})\n\nconst labelAreaPosition = computed(() => (edgeId: string, edgeStyle: StrokeStyle) => {\n  return v2d.calculateEdgeLabelArea(\n    edgeStates[edgeId].labelPosition,\n    edgeStyle,\n    edgeConfig.label.margin,\n    edgeConfig.label.padding,\n    scale.value\n  )\n})\n\nconst groupLabelAreaPosition = computed(() => (id: string, group: EdgeGroup) => {\n  const edgeId = Object.keys(group.edges)[0]\n  return v2d.calculateEdgeLabelArea(\n    edgeStates[edgeId].labelPosition,\n    summarizedEdgeStates[id]?.stroke ?? edgeStates[edgeId].line.stroke,\n    edgeConfig.label.margin,\n    edgeConfig.label.padding,\n    scale.value\n  )\n})\n\nconst representativeEdgeState = computed(() => (group: EdgeGroup) => {\n  return edgeStates[Object.keys(group.edges)[0]]\n})\n\ndefineExpose({\n  individualEdgeGroups,\n  edgeGroups,\n  nodeShape,\n  labelAreaPosition,\n  groupLabelAreaPosition,\n  representativeEdgeState,\n  edgeStates,\n  edgeConfig,\n  scale,\n})\n</script>\n\n<template>\n  <g class=\"v-edge-labels\">\n    <template v-for=\"(group, id) in edgeGroups.individual\" :key=\"id\">\n      <template v-for=\"(edge, edgeId) in group.edges\" :key=\"edgeId\">\n        <slot\n          name=\"edge-label\"\n          :edge-id=\"edgeId\"\n          :edge=\"edge\"\n          :config=\"edgeConfig.label\"\n          :area=\"labelAreaPosition(edgeId, edgeStates[edgeId].line.stroke)\"\n          :hovered=\"edgeStates[edgeId].hovered\"\n          :selected=\"edgeStates[edgeId].selected\"\n          :scale=\"scale\"\n        />\n      </template>\n    </template>\n    <template v-for=\"(group, id) in edgeGroups.summarized\" :key=\"id\">\n      <slot\n        name=\"edges-label\"\n        :edges=\"group.edges\"\n        :config=\"edgeConfig.label\"\n        :area=\"groupLabelAreaPosition(id, group)\"\n        :hovered=\"representativeEdgeState(group).hovered\"\n        :selected=\"representativeEdgeState(group).selected\"\n        :scale=\"scale\"\n      />\n    </template>\n  </g>\n</template>\n\n<style lang=\"scss\" scoped>\n.v-edge-labels {\n  :deep(.v-text),\n  :deep(.v-text-background) {\n    pointer-events: none;\n  }\n}\n</style>\n","<script setup lang=\"ts\">\nimport { onMounted, onUnmounted, ref } from \"vue\"\nimport { useContainers } from \"@/composables/container\"\n\n// By detecting and copying changes in the `transform` and `style`\n// attributes reflected by svg-pan-zoom, it follows changes in the\n// display area caused by panning and zooming.\n\nconst { viewport } = useContainers()\n\n// ref=\"background\"\nconst background = ref<SVGGElement>()\n\nconst updateAttributes = (attrs: string[], bgLayer: SVGGElement, vpLayer: SVGGElement) => {\n  attrs.forEach(attr => bgLayer.setAttribute(attr, vpLayer.getAttribute(attr) ?? \"\"))\n}\n\nconst observer = new MutationObserver(records => {\n  if (!background.value) return\n  const attrs = records.map(r => r.attributeName ?? \"\").filter(Boolean)\n  updateAttributes(attrs, background.value, viewport.value)\n})\n\nonMounted(() => {\n  const attrs = [\"transform\", \"style\"]\n  observer.observe(viewport.value, {\n    attributes: true,\n    attributeFilter: attrs\n  })\n  if (!background.value) return\n  updateAttributes(attrs, background.value, viewport.value)\n})\n\nonUnmounted(() => {\n  observer.disconnect()\n})\n\ndefineExpose({ background })\n</script>\n\n<template>\n  <g ref=\"background\" class=\"v-background-viewport\">\n    <slot />\n  </g>\n</template>\n","<script setup lang=\"ts\">\nimport { onMounted, ref, watchEffect } from \"vue\"\nimport { Point, Size } from \"@/common/types\"\nimport { useZoomLevel } from \"@/composables/zoom\"\nimport { useContainers } from \"@/composables/container\"\nimport { useEventEmitter } from \"@/composables/event-emitter\"\nimport { useViewConfig } from \"@/composables/config\"\n\n// [index, pos, start, end, attrs][]\ntype LineDefinitions = [number, number, number, number, Record<string, any>][]\n\nconst { container, svgPanZoom } = useContainers()\nconst { zoomLevel } = useZoomLevel()\nconst emitter = useEventEmitter()\nconst config = useViewConfig()\n\n// left-top point in SVG coordinates\nconst basePoint = ref<Point>({ x: 0, y: 0 })\n\n// container size in pixel\nconst viewport = ref<Size>({ width: 500, height: 500 })\n\nonMounted(() => {\n  const pan = svgPanZoom.value?.getPan()\n  if (pan) {\n    basePoint.value = {\n      x: -pan.x,\n      y: -pan.y,\n    }\n  }\n  const rect = container.value.getBoundingClientRect()\n  viewport.value = {\n    width: rect.width,\n    height: rect.height,\n  }\n})\n\nemitter.on(\"view:resize\", rect => {\n  viewport.value = { width: rect.width, height: rect.height }\n})\n\nemitter.on(\"view:pan\", pan => {\n  basePoint.value = { x: -pan.x, y: -pan.y }\n})\n\nemitter.on(\"view:zoom\", () => {\n  const pan = svgPanZoom.value?.getPan()\n  if (pan) {\n    basePoint.value = { x: -pan.x, y: -pan.y }\n  }\n})\n\nconst thickVerticals = ref<LineDefinitions>([])\nconst thickHorizontals = ref<LineDefinitions>([])\nconst normalVerticals = ref<LineDefinitions>([])\nconst normalHorizontals = ref<LineDefinitions>([])\n\n// make grid lines\nwatchEffect(() => {\n  const thickH: LineDefinitions = []\n  const thickV: LineDefinitions = []\n  const normalH: LineDefinitions = []\n  const normalV: LineDefinitions = []\n\n  const s = 1 / zoomLevel.value\n  const gi = config.grid.interval\n  const x = basePoint.value.x * s\n  const y = basePoint.value.y * s\n  const width = Math.floor(viewport.value.width / gi + 1) * gi\n  const height = Math.floor(viewport.value.height / gi + 1) * gi\n  const maxWidth = (basePoint.value.x + width) * s\n  const maxHeight = (basePoint.value.y + height) * s\n  const inc = config.grid.thickIncrements // interval to make the line thicker\n  const normalDasharray = config.grid.line.dasharray\n  const thickDasharray = config.grid.thick.dasharray\n\n  let thickAttrs = {\n    stroke: config.grid.thick.color,\n    \"stroke-width\": config.grid.thick.width,\n    \"stroke-dasharray\": thickDasharray,\n    \"stroke-dashoffset\": thickDasharray ? x / s : undefined\n  }\n\n  let normalAttrs = {\n    stroke: config.grid.line.color,\n    \"stroke-width\": config.grid.line.width,\n    \"stroke-dasharray\": normalDasharray,\n    \"stroke-dashoffset\": normalDasharray ? x / s : undefined\n  }\n\n  // horizontal lines\n  const w = (basePoint.value.x + width) * s\n  for (let i = y; i <= maxHeight; i += gi) {\n    const index = Math.floor(i / gi)\n    if (inc && index % inc === 0) {\n      thickH.push([index, index * gi, x, w, thickAttrs])\n    } else {\n      normalH.push([index, index * gi, x, w, normalAttrs])\n    }\n  }\n\n  thickAttrs = { ...thickAttrs }\n  thickAttrs[\"stroke-dashoffset\"] = thickDasharray ? y / s : undefined\n\n  normalAttrs = { ...normalAttrs }\n  normalAttrs[\"stroke-dashoffset\"] = normalDasharray ? y / s : undefined\n\n  // vertical lines\n  const h = (basePoint.value.y + height) * s\n  for (let i = x; i <= maxWidth; i += gi) {\n    const index = Math.floor(i / gi)\n    if (inc && index % inc === 0) {\n      thickV.push([index, index * gi, y, h, thickAttrs])\n    } else {\n      normalV.push([index, index * gi, y, h, normalAttrs])\n    }\n  }\n\n  thickHorizontals.value = thickH\n  thickVerticals.value = thickV\n  normalHorizontals.value = normalH\n  normalVerticals.value = normalV\n})\n\ndefineExpose({\n  thickVerticals,\n  thickHorizontals,\n  normalVerticals,\n  normalHorizontals,\n})\n</script>\n\n<template>\n  <g class=\"v-background-grid\" shape-rendering=\"crispEdges\">\n    <!-- normal -->\n    <path\n      v-for=\"([i, v, x, w, attrs]) in normalHorizontals\"\n      :key=\"`nv${i}`\"\n      :d=\"`M ${x} ${v} L ${w} ${v}`\"\n      v-bind=\"attrs\"\n      style=\"vector-effect: non-scaling-stroke;\"\n    />\n    <path\n      v-for=\"([i, v, y, h, attrs]) in normalVerticals\"\n      :key=\"`nh${i}`\"\n      :d=\"`M ${v} ${y} L ${v} ${h}`\"\n      v-bind=\"attrs\"\n      style=\"vector-effect: non-scaling-stroke;\"\n    />\n    <!-- thick -->\n    <path\n      v-for=\"([i, v, x, w, attrs]) in thickHorizontals\"\n      :key=\"`tv${i}`\"\n      :d=\"`M ${x} ${v} L ${w} ${v}`\"\n      v-bind=\"attrs\"\n      style=\"vector-effect: non-scaling-stroke;\"\n    />\n    <path\n      v-for=\"([i, v, y, h, attrs]) in thickVerticals\"\n      :key=\"`th${i}`\"\n      :d=\"`M ${v} ${y} L ${v} ${h}`\"\n      v-bind=\"attrs\"\n      style=\"vector-effect: non-scaling-stroke;\"\n    />\n  </g>\n</template>\n\n<style>\n.v-background-grid {\n  pointer-events: none;\n}\n</style>\n","\ntype Args<T> = [...(T | null)[], T]\n\nexport function findFirstNonNull<T>(...values: Args<T>): T {\n  return values.find(v => !!v) as T\n}\n","import { NodePositions, PositionOrCurve } from \"@/common/types\"\nimport { NodeStates } from \"@/models/node\"\nimport { EdgeStates, EdgeState } from \"@/models/edge\"\nimport { EdgeLine, EdgeObject, PathState } from \"@/models/path\"\nimport { AnyShapeStyle, PathEndType } from \"@/common/configs\"\nimport { findFirstNonNull } from \"@/utils/collection\"\nimport * as v2d from \"@/modules/calculation/2d\"\nimport * as PointUtils from \"@/modules/calculation/point\"\nimport { VectorLine } from \"@/modules/calculation/line\"\nimport * as LineUtils from \"@/modules/calculation/line\"\nimport V, { Vector2D } from \"@/modules/vector2d\"\n\nconst EPSILON = Number.EPSILON * 100 // 2.2204... x 1014.\n\nexport function calculatePathPoints(\n  path: PathState,\n  nodeStates: NodeStates,\n  nodeLayouts: NodePositions,\n  edgeStates: EdgeStates,\n  scale: number,\n  curveInNode: boolean,\n  pathEndType: PathEndType,\n  margin: number\n): PositionOrCurve[] {\n  // The relationship between the source/target of a link and the connection\n  // by path can be different.\n  // Detect node at connection point and determine source/target for the path.\n  const edges = path.edges\n\n  // Edge ID list -> List of Edge locations\n  const directions = _detectDirectionsOfPathEdges(edges) // true: forward, false: reverse\n  const edgePos = edges.map((edge, i) => _getEdgeLine(edge, directions[i], edgeStates[edge.edgeId]))\n\n  // the results\n  const points: (Vector2D[] | Vector2D)[] = []\n\n  let isMarginOverRunStart = false\n  let isMarginOverRunEnd = false\n\n  // ----------------------------------------------------\n  // Determine the starting point.\n  // ----------------------------------------------------\n  {\n    const firstEdge = edgePos[0]\n    let nodeRadius = _getNodeRadius(nodeStates[firstEdge.source].shape) * scale\n    const lineMargin = margin + (pathEndType === \"edgeOfNode\" ? nodeRadius : 0)\n    const nextPoint =\n      lineMargin <= 0\n        ? firstEdge.line.source\n        : _calculateEdgeOfNode(firstEdge, lineMargin, nodeLayouts, true)\n    points.push(nextPoint)\n    nodeRadius = _getNodeRadius(nodeStates[firstEdge.target].shape) * scale\n    if (margin > 0) {\n      const distance = V.distance(firstEdge.line.source, firstEdge.line.target)\n      if (distance <= lineMargin + nodeRadius) {\n        isMarginOverRunStart = true\n      }\n    }\n  }\n\n  // ----------------------------------------------------\n  // Determine transit points.\n  // ----------------------------------------------------\n  const length = edges.length\n  for (let i = 1; i < length; i++) {\n    const prev = edgePos[i - 1]\n    const next = edgePos[i]\n\n    const nodeId = next.source\n    const nodePos = Vector2D.fromObject(nodeLayouts[nodeId] ?? { x: 0, y: 0 })\n\n    // The intersection point of two lines: [X]\n    const crossPoint = _getIntersectionOfLines(prev, next, nodePos)\n\n    // Place another small circle inside the node's circle and\n    // calculate transit points so that the path line is smooth.\n    //   Inner circle: [] radius: `nodeCoreRadius`\n    //   Node circle : []  radius: `nodeRadius`\n    const nodeRadius = _getNodeRadius(nodeStates[nodeId].shape) * scale\n    const nodeCoreRadius = Math.max(nodeRadius * (2 / 3), nodeRadius - 4 * scale)\n    const prevCoreIp = _getIntersectionOfLineAndNode(prev, nodePos, nodeCoreRadius, true)\n    const nextCoreIp = _getIntersectionOfLineAndNode(next, nodePos, nodeCoreRadius, false)\n    const prevNodeIp = _getIntersectionOfLineAndNode(prev, nodePos, nodeRadius, true)\n    const nextNodeIp = _getIntersectionOfLineAndNode(next, nodePos, nodeRadius, false)\n\n    // ----------------------------------------------------\n    // Calculate transit points in the node.\n    // ----------------------------------------------------\n    let pos: Vector2D | Vector2D[]\n    if (crossPoint) {\n      const d = V.distance(crossPoint, nodePos)\n      if (d < nodeCoreRadius) {\n        // (1) [] includes [X]:\n        //  * [X]: control point in bezier\n        //  * intersection with []: transit point\n        pos = [\n          findFirstNonNull(prevCoreIp, prevNodeIp, prev.line.target),\n          crossPoint,\n          findFirstNonNull(nextCoreIp, nextNodeIp, next.line.source),\n        ]\n      } else if (d <= nodeRadius) {\n        // (2) [] includes [X]:\n        //  * [X]: control point in bezier\n        let p1: Vector2D, p2: Vector2D\n        if (prevNodeIp && prevCoreIp) {\n          // the prev line intersects [] and []:\n          // Of []x[line], []x[line], use the one closer to [X] as the transit point.\n          p1 =\n            V.distance(crossPoint, prevCoreIp) < V.distance(crossPoint, prevNodeIp)\n              ? prevCoreIp\n              : prevNodeIp\n        } else {\n          // the prev line intersects only with []:\n          // use []x[line] as the transit point.\n          p1 = prevNodeIp || prev.line.target\n        }\n        if (nextNodeIp && nextCoreIp) {\n          // the next line intersects with [] and []:\n          // Of []x[line], []x[line], use the one closer to [X] as the transit point.\n          p2 =\n            V.distance(crossPoint, nextCoreIp) < V.distance(crossPoint, nextNodeIp)\n              ? nextCoreIp\n              : nextNodeIp\n        } else {\n          // the next line intersects only with []:\n          // use []x[line] as the transit point.\n          p2 = nextNodeIp || next.line.source\n        }\n        pos = [p1, crossPoint, p2]\n      } else {\n        // (3) [X] is out of the node([])\n        if (prevCoreIp && nextCoreIp) {\n          // both lines intersect with []:\n          // use the []x[line] as transit point, and\n          // center of the node as control point in bezier.\n          pos = [prevCoreIp, nodePos, nextCoreIp]\n        } else if (prevNodeIp && nextNodeIp) {\n          // both lines intersect with []:\n          // use the []x[line] as transit point, and\n          // center of the node as control point in bezier.\n          pos = [prevNodeIp, nodePos, nextNodeIp]\n        } else {\n          // either or both lines do not intersect the node:\n          // [X] as transit point in bezier, and not place control points.\n          // []x[line] or []x[line] or end of [line] as the transit points, and\n          // center of the node as control point in bezier.\n          pos = [\n            findFirstNonNull(prevCoreIp, prevNodeIp, prev.line.target),\n            nodePos,\n            findFirstNonNull(nextCoreIp, nextNodeIp, next.line.source),\n          ]\n        }\n      }\n    } else {\n      // There is no intersection of two lines:\n      // center of the node as control point in bezier.\n      if (prevCoreIp && nextCoreIp) {\n        // both lines intersect with []:\n        // []x[line] as transit point.\n        pos = [prevCoreIp, nodePos, nextCoreIp]\n      } else if (prevNodeIp && nextNodeIp) {\n        // both lines intersect with []:\n        // []x[line] as transit point.\n        pos = [prevNodeIp, nodePos, nextNodeIp]\n      } else {\n        // either or both lines do not intersect the node:\n        // the end of the line as transit point.\n        pos = [prev.line.target, nodePos, next.line.source]\n      }\n    }\n\n    // ----------------------------------------------------\n    // Specify points on the curve.\n    // ----------------------------------------------------\n    if (prev.curve) {\n      // The starting point has already been added to `points`.\n      const lastPoints = points[points.length - 1]\n      if (lastPoints) {\n        const lastPoint =\n          lastPoints instanceof Array ? lastPoints[lastPoints.length - 1] : lastPoints\n        let nextPoint\n        if (pos instanceof Array) {\n          // Curved lines always end at the center of the node.\n          // To avoid smoothness, use only a transit point.\n          nextPoint = curveInNode ? pos[0] : pos[1]\n        } else {\n          nextPoint = pos\n        }\n        const control = v2d.calculateBezierCurveControlPoint(\n          lastPoint,\n          prev.curve.circle.center,\n          nextPoint,\n          prev.curve.theta\n        )\n        if (pos instanceof Array && curveInNode) {\n          points.push([...control, ...pos])\n        } else {\n          points.push([...control, nextPoint])\n        }\n      }\n    } else {\n      if (curveInNode || !(pos instanceof Array)) {\n        points.push(pos)\n      } else {\n        if (next.curve) {\n          points.push(pos[1]) // use control point as transit point\n        } else {\n          points.push(pos[0], pos[2]) // without control point to avoid smoothness\n        }\n      }\n    }\n  }\n\n  // ----------------------------------------------------\n  // Determine the terminate point.\n  // ----------------------------------------------------\n  {\n    const lastEdge = edgePos[edgePos.length - 1]\n    let nodeRadius = _getNodeRadius(nodeStates[lastEdge.target].shape) * scale\n    const lineMargin = margin + (pathEndType === \"edgeOfNode\" ? nodeRadius : 0)\n    const nextPoint =\n      lineMargin <= 0\n        ? lastEdge.line.target\n        : _calculateEdgeOfNode(lastEdge, lineMargin, nodeLayouts, false)\n    nodeRadius = _getNodeRadius(nodeStates[lastEdge.source].shape) * scale\n    const curve = lastEdge.curve\n    if (curve) {\n      // curve\n      const pos = points[points.length - 1]\n      const lastPoint = pos instanceof Array ? pos[pos.length - 1] : pos\n      const control = v2d.calculateBezierCurveControlPoint(\n        lastPoint,\n        curve.circle.center,\n        nextPoint,\n        curve.theta\n      )\n      points.push([...control, nextPoint])\n    } else {\n      // straight\n      points.push(nextPoint)\n    }\n    if (margin > 0) {\n      const distance = V.distance(lastEdge.line.source, lastEdge.line.target)\n      if (distance <= lineMargin + nodeRadius) {\n        isMarginOverRunEnd = true\n      }\n    }\n  }\n\n  if (isMarginOverRunStart) {\n    points.shift()\n    if (points[0] instanceof Array) {\n      points.unshift(points[0][0])\n    }\n  }\n  if (isMarginOverRunEnd) {\n    points.pop()\n  }\n\n  return points\n}\n\nfunction _detectDirectionsOfPathEdges(edges: EdgeObject[]): boolean[] {\n  const length = edges.length\n\n  if (length <= 1) {\n    return [true]\n  }\n\n  const directions: boolean[] = [] // true: forward, false: reverse\n  let lastNode: string | null = null\n  for (let i = 0; i < length; i++) {\n    const source = edges[i].edge.source\n    const target = edges[i].edge.target\n    let isForward\n    if (i === 0) {\n      if (length > 2) {\n        // If the next edge is an edge between the same nodes,\n        // check for more next edges.\n        const edge0 = [source, target].sort()\n        const edge1 = [edges[1].edge.source, edges[1].edge.target].sort()\n        if (edge0[0] === edge1[0] && edge0[1] === edge1[1]) {\n          const next = [edges[2].edge.source, edges[2].edge.target]\n          if (next.includes(edges[1].edge.target)) {\n            // edge1 is forward\n            isForward = target === edges[1].edge.source\n          } else {\n            // edge1 is reverse\n            isForward = target === edges[1].edge.target\n          }\n        } else {\n          isForward = [edges[1].edge.source, edges[1].edge.target].includes(target)\n        }\n      } else {\n        isForward = [edges[1].edge.source, edges[1].edge.target].includes(target)\n      }\n    } else {\n      isForward = lastNode === source\n    }\n    directions.push(isForward)\n    lastNode = isForward ? target : source\n  }\n  return directions\n}\n\nfunction _calculateEdgeOfNode(\n  edge: EdgeLine,\n  nodeRadius: number,\n  nodeLayouts: NodePositions,\n  direction: boolean\n) {\n  const nodeId = direction ? edge.source : edge.target\n  const curve = edge.curve\n  if (curve) {\n    let moveRad = nodeRadius / curve.circle.radius\n    if (curve.theta > 0) {\n      moveRad *= -1\n    }\n    if (!direction) {\n      moveRad *= -1\n    }\n    return Vector2D.fromObject(\n      v2d.moveOnCircumference(\n        direction ? edge.line.source : edge.line.target,\n        curve.circle.center,\n        moveRad\n      )\n    )\n  } else {\n    let source: Vector2D, target: Vector2D\n    if (direction) {\n      source = edge.line.target\n      target = edge.line.source\n    } else {\n      source = edge.line.source\n      target = edge.line.target\n    }\n    // straight\n    const p = PointUtils.getIntersectionOfLineTargetAndCircle(\n      source,\n      target,\n      Vector2D.fromObject(nodeLayouts[nodeId]),\n      nodeRadius\n    )\n    return p === null ? source : p\n  }\n}\n\nfunction _getIntersectionOfLines(\n  prev: EdgeLine,\n  next: EdgeLine,\n  nodePos: Vector2D\n): Vector2D | null {\n  let crossPoint: Vector2D | null = null\n  if (prev.curve) {\n    if (next.curve) {\n      if (prev.line.target.isEqualTo(next.line.source)) {\n        return prev.line.target.clone()\n      }\n      // curve -- curve\n      crossPoint = PointUtils.getIntersectionOfCircles(\n        prev.curve.circle.center,\n        prev.curve.circle.radius,\n        next.curve.circle.center,\n        next.curve.circle.radius,\n        prev.curve.center\n      )\n    } else {\n      // curve -- straight\n      crossPoint = PointUtils.getIntersectionOfLineTargetAndCircle2(\n        next.line.target,\n        next.line.source,\n        prev.curve.circle.center,\n        prev.curve.circle.radius,\n        nodePos\n      )\n    }\n  } else {\n    if (next.curve) {\n      // straight -- curve\n      crossPoint = PointUtils.getIntersectionOfLineTargetAndCircle(\n        prev.line.source,\n        prev.line.target,\n        next.curve.circle.center,\n        next.curve.circle.radius\n      )\n    } else {\n      // straight -- straight\n      const prevSlope = _getSlope(prev.line)\n      const nextSlope = _getSlope(next.line)\n      const isParallel =\n        (!isFinite(prevSlope) && !isFinite(nextSlope)) || Math.abs(prevSlope - nextSlope) < EPSILON\n      if (isParallel) {\n        crossPoint = null // not exist intersection point\n      } else {\n        crossPoint = PointUtils.getIntersectionPointOfLines(prev.line, next.line)\n      }\n    }\n  }\n  return crossPoint\n}\n\nfunction _getIntersectionOfLineAndNode(\n  edge: EdgeLine,\n  nodeCenter: Vector2D,\n  nodeRadius: number,\n  targetSide: boolean\n): Vector2D | null {\n  if (edge.curve) {\n    return PointUtils.getIntersectionOfCircles(\n      nodeCenter,\n      nodeRadius,\n      edge.curve.circle.center,\n      edge.curve.circle.radius,\n      Vector2D.fromObject(edge.curve.center)\n    )\n  } else {\n    return PointUtils.getIntersectionOfLineTargetAndCircle(\n      targetSide ? edge.line.source : edge.line.target,\n      targetSide ? edge.line.target : edge.line.source,\n      nodeCenter,\n      nodeRadius\n    )\n  }\n}\n\nfunction _getEdgeLine(edge: EdgeObject, direction: boolean, state: EdgeState): EdgeLine {\n  let position = state.origin\n  let source = edge.edge.source\n  let target = edge.edge.target\n  let curve = state.curve\n  if (!direction) {\n    position = LineUtils.inverseLine(position)\n    source = edge.edge.target\n    target = edge.edge.source\n    if (curve) {\n      curve = { ...curve, theta: -curve.theta }\n    }\n  }\n  const line = VectorLine.fromLinePosition(position)\n  const result: EdgeLine = {\n    edgeId: edge.edgeId,\n    source,\n    target,\n    line,\n    curve,\n  }\n  return result\n}\n\nfunction _getNodeRadius(shape: AnyShapeStyle) {\n  if (shape.type == \"circle\") {\n    return shape.radius\n  } else {\n    return Math.min(shape.width, shape.height) / 2\n  }\n}\n\nfunction _getSlope(pos: VectorLine) {\n  return (pos.target.y - pos.source.y) / (pos.target.x - pos.source.x)\n}\n","<script setup lang=\"ts\">\nimport { computed, PropType } from \"vue\"\nimport { PositionOrCurve } from \"@/common/types\"\nimport { Config } from \"@/common/configs\"\nimport { PathState } from \"@/models/path\"\nimport { usePathConfig } from \"@/composables/config\"\nimport { useZoomLevel } from \"@/composables/zoom\"\nimport { applyScaleToDasharray, getDasharrayUnit } from \"@/utils/visual\"\nimport chunk from \"lodash-es/chunk\"\n\nconst props = defineProps({\n  points: {\n    type: Array as PropType<PositionOrCurve[]>,\n    required: true,\n  },\n  path: {\n    type: Object as PropType<PathState>,\n    required: true,\n  }\n})\n\nconst { scale } = useZoomLevel()\nconst pathConfig = usePathConfig()\n\nconst d = computed(() => {\n  let move = true\n  return props.points.map(p => {\n    if (p === null) {\n      move = true\n    } else if (p instanceof Array) {\n      p = [...p]\n      const list = []\n      if (p.length % 2 === 1) {\n        const x = p[0]\n        p = p.slice(1)\n        list.push(`L ${x.x} ${x.y}`)\n      }\n      chunk(p, 2).map(([p1, p2]) => list.push(`Q ${p1.x} ${p1.y} ${p2.x} ${p2.y}`))\n      return list.join(\" \")\n    } else {\n      const m = move\n      move = false\n      return `${m ? \"M \" : \"L \"}${p.x} ${p.y}`\n    }\n  }).join(\" \")\n})\n\nconst config = computed(() => {\n  const state = props.path\n  if (state.selected) {\n    return Config.values(pathConfig.selected, state.path)\n  } else if (state.hovered && pathConfig.hover) {\n    return Config.values(pathConfig.hover, state.path)\n  } else {\n    return Config.values(pathConfig.normal, state.path)\n  }\n})\n\nconst strokeDasharray = computed(() => {\n  return applyScaleToDasharray(config.value.dasharray, scale.value)\n})\n\nconst animationSpeed = computed(() => {\n  const speed = config.value.animate\n    ? getDasharrayUnit(config.value.dasharray) * config.value.animationSpeed * scale.value\n    : false\n  return speed ? `--animation-speed:${speed}` : undefined\n})\n\ndefineExpose({ d, scale, config, strokeDasharray, animationSpeed })\n</script>\n\n<template>\n  <path\n    :class=\"{ 'v-path-line': true, animate: config.animate }\"\n    :d=\"d\"\n    fill=\"none\"\n    :stroke=\"config.color\"\n    :stroke-width=\"config.width * scale\"\n    :stroke-dasharray=\"strokeDasharray\"\n    :stroke-linecap=\"config.linecap\"\n    :stroke-linejoin=\"config.linejoin\"\n    :style=\"animationSpeed\"\n  />\n</template>\n\n<style scoped>\n.v-path-line.animate {\n  --animation-speed: 100;\n  animation: dash 10s linear infinite;\n  stroke-dashoffset: var(--animation-speed);\n}\n@keyframes dash {\n  to {\n    stroke-dashoffset: 0;\n  }\n}\n</style>\n","<script setup lang=\"ts\">\nimport { computed } from \"vue\"\nimport { PositionOrCurve } from \"@/common/types\"\nimport { Config } from \"@/common/configs\"\nimport { PathState } from \"@/models/path\"\nimport { useStates } from \"@/composables/state\"\nimport { usePathConfig } from \"@/composables/config\"\nimport { useZoomLevel } from \"@/composables/zoom\"\nimport { calculatePathPoints } from \"@/modules/calculation/path\"\nimport { useMouseOperation } from \"@/composables/mouse\"\nimport VPathLine from \"./VPathLine.vue\"\n\nconst { pathZOrderedList, nodeStates, edgeStates, layouts } = useStates()\nconst { scale } = useZoomLevel()\nconst pathConfig = usePathConfig()\n\nconst {\n  handlePathPointerDownEvent,\n  handlePathPointerOverEvent,\n  handlePathPointerOutEvent,\n  handlePathClickEvent,\n  handlePathDoubleClickEvent,\n  handlePathContextMenu,\n} = useMouseOperation()\n\nconst calcPathPoints = computed(() => (path: PathState): PositionOrCurve[] => {\n  if (path.edges.length === 0) return []\n  const margin = Config.value(pathConfig.margin, path.path) * scale.value\n  return calculatePathPoints(\n    path,\n    nodeStates,\n    layouts.nodes,\n    edgeStates,\n    scale.value,\n    pathConfig.curveInNode,\n    pathConfig.end,\n    margin\n  )\n})\n\ndefineExpose({\n  pathConfig,\n  pathZOrderedList,\n  calcPathPoints,\n  handlePathPointerDownEvent,\n  handlePathPointerOverEvent,\n  handlePathPointerOutEvent,\n  handlePathClickEvent,\n  handlePathDoubleClickEvent,\n  handlePathContextMenu,\n})\n</script>\n\n<template>\n  <transition-group\n    :name=\"pathConfig.transition\"\n    :css=\"!!pathConfig.transition\"\n    tag=\"g\"\n    class=\"v-paths\"\n  >\n    <v-path-line\n      v-for=\"path in pathZOrderedList\"\n      :key=\"path.id\"\n      :points=\"calcPathPoints(path)\"\n      :class=\"{ clickable: path.clickable, hoverable: path.hoverable }\"\n      :path=\"path\"\n      @pointerdown=\"handlePathPointerDownEvent(path.id, $event)\"\n      @pointerenter.passive=\"handlePathPointerOverEvent(path.id, $event)\"\n      @pointerleave.passive=\"handlePathPointerOutEvent(path.id, $event)\"\n      @click.stop=\"handlePathClickEvent(path.id, $event)\"\n      @dblclick.stop=\"handlePathDoubleClickEvent(path.id, $event)\"\n      @contextmenu=\"handlePathContextMenu(path.id, $event)\"\n    />\n  </transition-group>\n</template>\n\n<style lang=\"scss\" scoped>\n$transition: 0.1s linear;\n\n.v-path-line {\n  pointer-events: none;\n  transition: stroke $transition, stroke-width $transition;\n\n  &.clickable {\n    pointer-events: stroke;\n    cursor: pointer;\n  }\n  &.hoverable {\n    pointer-events: stroke;\n  }\n}\n</style>\n","<script setup lang=\"ts\">\n  import { computed, PropType } from \"vue\"\n  import { MarkerUnits } from \"@/common/configs\"\n\nconst props = defineProps({\n  width: {\n    type: Number,\n    required: true,\n  },\n  height: {\n    type: Number,\n    required: true,\n  },\n  refX: {\n    type: Number,\n    required: true,\n  },\n  color: {\n    type: String,\n    required: true,\n  },\n  isSource: {\n    type: Boolean,\n    required: true,\n  },\n  units: {\n    type: String as PropType<MarkerUnits>,\n    required: true,\n  }\n})\n\nconst arrowPoints = computed(() => {\n  const w = props.width\n  const h = props.height\n  if (props.isSource) {\n    return `${w} ${h}, 0 ${h / 2}, ${w} 0`\n  } else {\n    return `0 0, ${w} ${h / 2}, 0 ${h}`\n  }\n})\n\n</script>\n\n<template>\n  <polygon :points=\"arrowPoints\" :fill=\"color\" />\n</template>\n","<script setup lang=\"ts\">\nimport { computed, PropType } from \"vue\"\nimport { MarkerUnits } from \"@/common/configs\"\n\nconst props = defineProps({\n  width: {\n    type: Number,\n    required: true,\n  },\n  height: {\n    type: Number,\n    required: true,\n  },\n  refX: {\n    type: Number,\n    required: true,\n  },\n  color: {\n    type: String,\n    required: true,\n  },\n  isSource: {\n    type: Boolean,\n    required: true,\n  },\n  units: {\n    type: String as PropType<MarkerUnits>,\n    required: true,\n  }\n})\n\nconst angleStroke = computed(() => {\n  return props.units === \"strokeWidth\" ? 1 : Math.min(props.width, props.height) / 5\n})\n\nconst anglePoints = computed(() => {\n  const m = angleStroke.value / 2\n  const w = props.width\n  const h = props.height\n  if (props.isSource) {\n    return `${w - m} ${h - m}, ${m} ${h / 2}, ${w - m} ${m}`\n  } else {\n    return `${m} ${m}, ${w - m} ${h / 2}, ${m} ${h - m}`\n  }\n})\n</script>\n\n<template>\n  <polyline\n    :points=\"anglePoints\"\n    fill=\"none\"\n    :stroke-width=\"angleStroke\"\n    :stroke=\"color\"\n    stroke-linecap=\"round\"\n    stroke-linejoin=\"round\"\n  />\n</template>\n","<script setup lang=\"ts\">\nimport { computed, PropType } from \"vue\"\nimport { EdgeHeadType } from \"@/common/configs\"\nimport { HeadMarker } from \"@/composables/marker\"\nimport VMarkerHeadArrow from \"./VMarkerHeadArrow.vue\"\nimport VMarkerHeadAngle from \"./VMarkerHeadAngle.vue\"\nimport VMarkerHeadCircle from \"./VMarkerHeadCircle.vue\"\n\ntype MarkerType = Exclude<EdgeHeadType, \"none\" | \"custom\">\n\nconst types: Record<MarkerType, any> = {\n  arrow: VMarkerHeadArrow,\n  angle: VMarkerHeadAngle,\n  circle: VMarkerHeadCircle\n}\n\nconst props = defineProps({\n  id: {\n    type: String,\n    required: true,\n  },\n  marker: {\n    type: Object as PropType<HeadMarker>,\n    required: true,\n  },\n  scale: {\n    type: Number,\n    required: true,\n  },\n})\n\nconst width = computed(\n  () => props.marker.width * (props.marker.units === \"strokeWidth\" ? 1 : props.scale)\n)\n\nconst height = computed(\n  () => props.marker.height * (props.marker.units === \"strokeWidth\" ? 1 : props.scale)\n)\n\nconst refX = computed(() => {\n  const margin = props.marker.margin * (props.marker.units === \"strokeWidth\" ? 1 : props.scale)\n  return props.marker.isSource ? width.value + margin : -margin\n})\n\n</script>\n\n<template>\n  <marker\n    v-if=\"marker.type !== 'none' && marker.type !== 'custom'\"\n    :id=\"id\"\n    :markerWidth=\"width\"\n    :markerHeight=\"height\"\n    :refX=\"refX\"\n    :refY=\"height / 2\"\n    orient=\"auto\"\n    :markerUnits=\"marker.units\"\n    class=\"v-marker\"\n  >\n    <component\n      :is=\"types[marker.type]\"\n      :width=\"width\"\n      :height=\"height\"\n      :refX=\"refX\"\n      :color=\"marker.color\"\n      :is-source=\"marker.isSource\"\n      :units=\"marker.units\"\n    />\n  </marker>\n</template>\n","<template>\n  <div ref=\"container\" class=\"v-network-graph\">\n    <svg\n      ref=\"svg\"\n      class=\"v-canvas\"\n      :class=\"{ show, dragging, touches, 'box-selection-mode': isBoxSelectionMode }\"\n      width=\"500\"\n      height=\"500\"\n      viewBox=\"0 0 500 500\"\n    >\n      <!-- outside of viewport -->\n      <slot\n        v-for=\"layerName in layerDefs['root']\"\n        :key=\"layerName\"\n        :name=\"layerName\"\n        :scale=\"scale\"\n      />\n\n      <defs v-if=\"Object.keys(markers).length > 0\">\n        <v-marker-head\n          v-for=\"(marker, id) in markers\"\n          :id=\"id\"\n          :key=\"id\"\n          :marker=\"marker\"\n          :scale=\"scale\"\n        />\n      </defs>\n\n      <!-- background-viewport:\n           area outside the scope of SVG text retrieval but targeted by pan/zoom. -->\n      <v-background-viewport v-if=\"isShowBackgroundViewport\">\n        <g v-for=\"layerName in layerDefs['background']\" :key=\"layerName\" class=\"v-layer\">\n          <slot :name=\"layerName\" :scale=\"scale\" />\n        </g>\n\n        <!-- grid -->\n        <v-background-grid v-if=\"isShowGrid\" />\n\n        <g v-for=\"layerName in layerDefs['grid']\" :key=\"layerName\" class=\"v-layer\">\n          <slot :name=\"layerName\" :scale=\"scale\" />\n        </g>\n      </v-background-viewport>\n\n      <!-- viewport: pan/zoom target and within the range of SVG text retrieval. -->\n      <g\n        ref=\"viewport\"\n        class=\"v-viewport\"\n        :class=\"{ 'v-transition': transitionOption.enabled }\"\n        :style=\"transitionStyles\"\n      >\n        <g v-for=\"layerName in layerDefs['base']\" :key=\"layerName\" class=\"v-layer\">\n          <slot :name=\"layerName\" :scale=\"scale\" />\n        </g>\n\n        <!-- edges -->\n        <g class=\"v-layer-edges\">\n          <v-edge-backgrounds />\n          <v-edge-groups :hasEdgeOverlaySlot=\"hasEdgeOverlaySlot\">\n            <template #default=\"slotProps\">\n              <slot name=\"edge-overlay\" v-bind=\"slotProps\" />\n            </template>\n          </v-edge-groups>\n        </g>\n\n        <g v-for=\"layerName in layerDefs['edges']\" :key=\"layerName\" class=\"v-layer\">\n          <slot :name=\"layerName\" :scale=\"scale\" />\n        </g>\n\n        <!-- edge labels -->\n        <v-edge-labels v-if=\"hasEdgeLabelSlot || hasEdgesLabelSlot\">\n          <!-- edge labels -->\n          <template v-if=\"hasEdgeLabelSlot\" #edge-label=\"slotProps\">\n            <slot name=\"edge-label\" v-bind=\"slotProps\" />\n          </template>\n\n          <!-- summarized edges labels -->\n          <template v-if=\"hasEdgesLabelSlot\" #edges-label=\"slotProps\">\n            <slot name=\"edges-label\" v-bind=\"slotProps\" />\n          </template>\n        </v-edge-labels>\n\n        <!-- node selections (focus ring) -->\n        <g v-if=\"visibleNodeFocusRing\" class=\"v-layer-nodes-selections\">\n          <v-node-focus-ring\n            v-for=\"nodeId in currentSelectedNodes\"\n            :id=\"nodeId\"\n            :key=\"nodeId\"\n            :state=\"nodeStates[nodeId]\"\n            :pos=\"currentLayouts.nodes[nodeId]\"\n          />\n        </g>\n\n        <g v-for=\"layerName in layerDefs['focusring']\" :key=\"layerName\" class=\"v-layer\">\n          <slot :name=\"layerName\" :scale=\"scale\" />\n        </g>\n\n        <!-- nodes -->\n        <transition-group\n          :name=\"allConfigs.node.transition\"\n          :css=\"!!allConfigs.node.transition\"\n          tag=\"g\"\n          class=\"v-layer-nodes\"\n        >\n          <v-node\n            v-for=\"state in nodeZOrderedList\"\n            :id=\"state.id\"\n            :key=\"state.id\"\n            :state=\"state\"\n            :pos=\"currentLayouts.nodes[state.id]\"\n          >\n            <!-- override the node -->\n            <template v-if=\"hasOverrideNodeSlot\" #override-node=\"slotProps\">\n              <slot name=\"override-node\" v-bind=\"slotProps\" />\n            </template>\n            <!-- override the node label -->\n            <template v-if=\"hasOverrideNodeLabelSlot\" #override-node-label=\"slotProps\">\n              <slot name=\"override-node-label\" v-bind=\"slotProps\" />\n            </template>\n          </v-node>\n        </transition-group>\n\n        <g v-for=\"layerName in layerDefs['nodes']\" :key=\"layerName\" class=\"v-layer\">\n          <slot :name=\"layerName\" :scale=\"scale\" />\n        </g>\n\n        <v-paths v-if=\"visiblePaths\" />\n\n        <g v-for=\"layerName in layerDefs['paths']\" :key=\"layerName\" class=\"v-layer\">\n          <slot :name=\"layerName\" :scale=\"scale\" />\n        </g>\n      </g>\n\n      <!-- selection box -->\n      <v-selection-box\n        v-if=\"selectionBox\"\n        :box=\"selectionBox\"\n        :config=\"allConfigs.view.selection.box\"\n      />\n    </svg>\n  </div>\n</template>\n\n<script lang=\"ts\">\nimport { CSSProperties, defineComponent, PropType, readonly, ref, toRef } from \"vue\"\nimport { computed, nextTick, watch } from \"vue\"\nimport { EventHandlers, Nodes, Edges, InputPaths, Layouts, UserLayouts } from \"@/common/types\"\nimport { Layers, LayerPosition, LayerPositions, Point, Sizes } from \"@/common/types\"\nimport { Reactive, nonNull } from \"@/common/common\"\nimport { UserConfigs, ViewConfig } from \"@/common/configs\"\nimport { provideContainers } from \"@/composables/container\"\nimport { provideConfigs } from \"@/composables/config\"\nimport { provideStates, makeStateInput } from \"@/composables/state\"\nimport { provideMouseOperation } from \"@/composables/mouse\"\nimport { provideEventEmitter } from \"@/composables/event-emitter\"\nimport { makeMarkerState } from \"@/composables/marker\"\nimport { useSvgPanZoom } from \"@/composables/svg-pan-zoom\"\nimport { provideZoomLevel } from \"@/composables/zoom\"\nimport { useTransitionWhile } from \"@/composables/transition\"\nimport { useTranslatePathsToObject } from \"@/composables/object\"\nimport { bindProp, bindPropKeySet } from \"@/utils/props\"\nimport { translateFromSvgToDomCoordinates, translateFromDomToSvgCoordinates } from \"@/utils/svg\"\nimport VNode from \"./node/VNode.vue\"\nimport VNodeFocusRing from \"./node/VNodeFocusRing.vue\"\nimport VEdgeGroups from \"./edge/VEdgeGroups.vue\"\nimport VEdgeBackgrounds from \"./edge/VEdgeBackgrounds.vue\"\nimport VEdgeLabels from \"./edge/VEdgeLabels.vue\"\nimport VBackgroundViewport from \"./background/VBackgroundViewport.vue\"\nimport VBackgroundGrid from \"./background/VBackgroundGrid.vue\"\nimport VPaths from \"./path/VPaths.vue\"\nimport VMarkerHead from \"./marker/VMarkerHead.vue\"\nimport VSelectionBox from \"./base/VSelectionBox.vue\"\nimport { SvgPanZoomInstance, Box } from \"@/modules/svg-pan-zoom-ex\"\n\nconst SYSTEM_SLOTS = [\n  \"override-node\",\n  \"override-node-label\",\n  \"edge-overlay\",\n  \"edge-label\",\n  \"edges-label\",\n]\n\nenum State {\n  INITIAL = 0,\n  LOADED = 1,\n  UNLOADED = 2,\n}\n\nexport default defineComponent({\n  components: {\n    VNode,\n    VNodeFocusRing,\n    VEdgeGroups,\n    VEdgeBackgrounds,\n    VEdgeLabels,\n    VBackgroundViewport,\n    VBackgroundGrid,\n    VPaths,\n    VMarkerHead,\n    VSelectionBox,\n  },\n  props: {\n    nodes: {\n      type: Object as PropType<Nodes>,\n      default: () => ({}),\n    },\n    edges: {\n      type: Object as PropType<Edges>,\n      default: () => ({}),\n    },\n    paths: {\n      type: [Object, Array] as PropType<InputPaths>,\n      default: () => ({}),\n    },\n    layouts: {\n      type: Object as PropType<UserLayouts>,\n      default: () => ({}),\n    },\n    zoomLevel: {\n      type: Number,\n      default: 1,\n    },\n    selectedNodes: {\n      type: Array as PropType<string[]>,\n      default: () => [],\n    },\n    selectedEdges: {\n      type: Array as PropType<string[]>,\n      default: () => [],\n    },\n    selectedPaths: {\n      type: Array as PropType<string[]>,\n      default: () => [],\n    },\n    configs: {\n      type: Object as PropType<UserConfigs>,\n      default: () => ({}),\n    },\n    layers: {\n      type: Object as PropType<Layers>,\n      default: () => ({}),\n    },\n    eventHandlers: {\n      // Since a large number of events will be issued, to avoid\n      // contaminating the event log of the development tools,\n      // events are designed to be notified to a handler function\n      // specified by the user.\n      type: Object as PropType<EventHandlers>,\n      default: () => ({}),\n    },\n  },\n  emits: [\n    \"update:zoomLevel\",\n    \"update:selectedNodes\",\n    \"update:selectedEdges\",\n    \"update:selectedPaths\",\n    \"update:layouts\",\n  ],\n  setup(props, { emit, slots }) {\n    const nodesRef = toRef(props, \"nodes\")\n    const edgesRef = toRef(props, \"edges\")\n    const { objects: pathsRef, isInCompatibilityModeForPath } = useTranslatePathsToObject(\n      toRef(props, \"paths\")\n    )\n\n    // Event Bus\n    const emitter = provideEventEmitter()\n    Object.entries(props.eventHandlers).forEach(([type, event]) => {\n      emitter.on(type as any, event as any)\n    })\n\n    // Style settings\n    const configs = provideConfigs(toRef(props, \"configs\"))\n\n    // Additional layers\n    const layerDefs = computed(() => {\n      const definedSlots = new Set(Object.keys(slots))\n      SYSTEM_SLOTS.forEach(s => definedSlots.delete(s))\n\n      const layers = Object.fromEntries(LayerPositions.map(n => [n, [] as string[]]))\n      Object.assign(\n        layers,\n        Object.entries(props.layers).reduce((accum, [name, type]) => {\n          definedSlots.delete(name)\n          if (type in accum) {\n            accum[type].push(name)\n          } else {\n            accum[type] = [name]\n          }\n          return accum\n        }, {} as Record<LayerPosition, string[]>)\n      )\n      // The default slot and any slots not defined in the layers into root.\n      layers[\"root\"].push(...definedSlots)\n      return layers as Record<LayerPosition, string[]>\n    })\n\n    // Grid layer\n    const isShowGrid = computed(() => configs.view.grid.visible)\n    const isShowBackgroundViewport = computed(() => {\n      const layers = layerDefs.value\n      return isShowGrid.value || layers[\"background\"].length > 0 || layers[\"grid\"].length > 0\n    })\n\n    // slots\n    const hasOverrideNodeSlot = computed(() => \"override-node\" in slots)\n    const hasOverrideNodeLabelSlot = computed(() => \"override-node-label\" in slots)\n    const hasEdgeOverlaySlot = computed(() => \"edge-overlay\" in slots)\n    const hasEdgeLabelSlot = computed(() => \"edge-label\" in slots)\n    const hasEdgesLabelSlot = computed(() => \"edges-label\" in slots)\n\n    // -----------------------------------------------------------------------\n    // SVG\n    // -----------------------------------------------------------------------\n    const container = ref<HTMLDivElement>()\n    const svg = ref<SVGElement & SVGSVGElement>()\n    const viewport = ref<SVGGElement>()\n    const state = ref<State>(State.INITIAL)\n    const show = computed(() => state.value !== State.INITIAL)\n\n    const zoomLevel = bindProp(props, \"zoomLevel\", emit, v => {\n      v = Math.max(v, configs.view.minZoomLevel)\n      v = Math.min(v, configs.view.maxZoomLevel)\n      return v\n    })\n\n    // SVG pan / zoom\n    const { svgPanZoom, onSvgPanZoomMounted, onSvgPanZoomUnmounted } = useSvgPanZoom(svg, {\n      viewportSelector: \".v-viewport\",\n      minZoom: configs.view.minZoomLevel, // temporary\n      maxZoom: configs.view.maxZoomLevel, // temporary\n      dblClickZoomEnabled: isDoubleClickZoomEnabled(configs.view),\n      mouseWheelZoomEnabled: isMouseWheelZoomEnabled(configs.view),\n      fit: true,\n      center: true,\n      zoomEnabled: configs.view.zoomEnabled,\n      preventMouseEventsDefault: false,\n      onZoom: _ => {\n        if (state.value === State.UNLOADED) return\n        const z = svgPanZoom.value?.getRealZoom() ?? 1\n        if (Math.abs(zoomLevel.value - z) >= 1.0e-6) {\n          zoomLevel.value = z\n          emitter.emit(\"view:zoom\", z)\n        }\n      },\n      panEnabled: configs.view.panEnabled,\n      onPan: p => {\n        if (state.value === State.UNLOADED) return\n        emitter.emit(\"view:pan\", p)\n      },\n    })\n\n    provideContainers({ container, svg, viewport, svgPanZoom })\n\n    // Observe container resizing\n    const rectSize = { width: 0, height: 0 }\n    const resizeObserver = globalThis.ResizeObserver\n      ? new ResizeObserver(() => {\n          svgPanZoom.value?.resize()\n          if (!configs.view.autoPanOnResize) return\n          // Pan to keep the view area centered\n          const r = container.value?.getBoundingClientRect()\n          if (r) {\n            const x = -(rectSize.width - r.width) / 2\n            const y = -(rectSize.height - r.height) / 2\n            svgPanZoom.value?.panBy({ x, y })\n            const { width, height } = r\n            if (rectSize.width !== width || rectSize.height !== height) {\n              Object.assign(rectSize, { width, height })\n              emitter.emit(\"view:resize\", { x: r.x, y: r.y, width, height })\n            }\n          }\n        })\n      : undefined\n    onSvgPanZoomMounted(() => {\n      const c = nonNull(container.value, \"svg-pan-zoom container\")\n      resizeObserver?.observe(c)\n      configs.view.onSvgPanZoomInitialized?.(nonNull(svgPanZoom.value, \"svg-pan-zoom instance\"))\n      const r = c.getBoundingClientRect()\n      const { width, height } = r\n      Object.assign(rectSize, { width, height })\n      viewport.value?.addEventListener(\"touchstart\", stopEventPropagation, { passive: false })\n    })\n    onSvgPanZoomUnmounted(() => {\n      resizeObserver?.disconnect()\n      viewport.value?.removeEventListener(\"touchstart\", stopEventPropagation)\n    })\n\n    const applyAbsoluteZoomLevel = (absoluteZoomLevel: number) => {\n      svgPanZoom.value?.applyAbsoluteZoomLevel(\n        absoluteZoomLevel,\n        configs.view.minZoomLevel,\n        configs.view.maxZoomLevel\n      )\n    }\n\n    watch(\n      () => configs.view.panEnabled,\n      v => {\n        svgPanZoom.value?.setPanEnabled(v)\n      }\n    )\n    watch(\n      () => [\n        configs.view.zoomEnabled,\n        isDoubleClickZoomEnabled(configs.view),\n        isMouseWheelZoomEnabled(configs.view),\n      ],\n      v => {\n        applyZoomEnabled(\n          svgPanZoom.value!,\n          configs.view.zoomEnabled,\n          configs.view.doubleClickZoomEnabled,\n          configs.view.mouseWheelZoomEnabled\n        )\n      }\n    )\n\n    watch(zoomLevel, v => applyAbsoluteZoomLevel(v))\n    watch(\n      () => [configs.view.minZoomLevel, configs.view.maxZoomLevel],\n      _ => {\n        applyAbsoluteZoomLevel(zoomLevel.value)\n      }\n    )\n\n    // Provide zoom level / scaling parameter\n    const { scale } = provideZoomLevel(zoomLevel, configs.view)\n\n    onSvgPanZoomMounted(() => {\n      // apply initial zoom level\n      const initialZoomLevel = props.zoomLevel\n      applyAbsoluteZoomLevel(initialZoomLevel)\n    })\n\n    // To resolve the problem that the center position and\n    // magnification rate may not be recognized.\n    const updateBorderBox = (callback: () => void) => {\n      if (Object.keys(props.nodes).length > 0) {\n        svgPanZoom.value?.updateBBox()\n        nextTick(callback)\n      } else {\n        callback()\n      }\n    }\n\n    // Scales the content to fit in the SVG area.\n    const fitToContents = () => {\n      updateBorderBox(() => {\n        if (svgPanZoom.value) {\n          svgPanZoom.value.fitToContents()\n          emitter.emit(\"view:fit\", undefined)\n        }\n      })\n    }\n\n    // Place content in the center of the SVG area.\n    const panToCenter = () => {\n      updateBorderBox(() => {\n        svgPanZoom.value?.center()\n      })\n    }\n\n    // Get viewport box\n    const getViewBox = () =>\n      svgPanZoom.value?.getViewBox() ?? {\n        top: 0,\n        bottom: 0,\n        left: 0,\n        right: 0,\n      }\n\n    // Get viewport box\n    const setViewBox = (box: Box) => svgPanZoom.value?.setViewBox(box)\n\n    // -----------------------------------------------------------------------\n    // States of selected nodes/edges\n    // -----------------------------------------------------------------------\n    const currentSelectedNodes = bindPropKeySet(props, \"selectedNodes\", nodesRef, emit)\n    watch(currentSelectedNodes, nodes => emitter.emit(\"node:select\", Array.from(nodes)))\n\n    const currentSelectedEdges = bindPropKeySet(props, \"selectedEdges\", edgesRef, emit)\n    watch(currentSelectedEdges, edges => emitter.emit(\"edge:select\", Array.from(edges)))\n\n    const currentSelectedPaths = bindPropKeySet(props, \"selectedPaths\", pathsRef, emit)\n    watch(currentSelectedPaths, paths => emitter.emit(\"path:select\", Array.from(paths)))\n\n    const hoveredNodes = Reactive(new Set<string>())\n    const hoveredEdges = Reactive(new Set<string>())\n    const hoveredPaths = Reactive(new Set<string>())\n    const currentLayouts = Reactive<Layouts>({ nodes: {} })\n\n    // two-way binding\n    watch(\n      () => props.layouts,\n      () => Object.assign(currentLayouts, props.layouts),\n      { deep: true, immediate: true }\n    )\n    watch(currentLayouts, () => emit(\"update:layouts\", currentLayouts), { deep: true })\n\n    const visibleNodeFocusRing = computed(() => {\n      return configs.node.focusring.visible\n    })\n\n    // -----------------------------------------------------------------------\n    // SVG Markers\n    // -----------------------------------------------------------------------\n    const markerState = makeMarkerState()\n\n    // -----------------------------------------------------------------------\n    // Mouse processing\n    // -----------------------------------------------------------------------\n\n    // mouse pointer change on dragging\n    const dragging = ref<boolean>(false)\n    emitter.on(\"node:dragstart\", _ => (dragging.value = true))\n    emitter.on(\"node:dragend\", _ => (dragging.value = false))\n    emitter.on(\"view:mode\", mode => {\n      // avoid pan/zoom when using nodes and edges with multi-touch\n      if (configs.view.panEnabled) {\n        if (mode === \"default\") {\n          svgPanZoom.value?.enablePan()\n        } else {\n          svgPanZoom.value?.disablePan()\n        }\n      }\n      if (configs.view.zoomEnabled) {\n        if (mode === \"default\") {\n          svgPanZoom.value?.enableZoom()\n        } else {\n          svgPanZoom.value?.disableZoom()\n        }\n      }\n    })\n\n    const touches = computed(() => {\n      return configs.view.panEnabled || configs.view.zoomEnabled || configs.node.draggable\n    })\n\n    const { nodeStates, nodeZOrderedList, edgeStates, pathStates } = provideStates(\n      makeStateInput(nodesRef, currentSelectedNodes, hoveredNodes),\n      makeStateInput(edgesRef, currentSelectedEdges, hoveredEdges),\n      makeStateInput(pathsRef, currentSelectedPaths, hoveredPaths),\n      readonly(configs),\n      currentLayouts,\n      markerState,\n      scale\n    )\n\n    const isSvgWheelZoomEnabled = computed(() => isMouseWheelZoomEnabled(configs.view))\n\n    // mouse and touch support\n    const { isBoxSelectionMode, selectionBox, startBoxSelection, stopBoxSelection } =\n      provideMouseOperation(\n        svg,\n        readonly(currentLayouts),\n        readonly(zoomLevel),\n        nodeStates,\n        edgeStates,\n        pathStates,\n        currentSelectedNodes,\n        currentSelectedEdges,\n        currentSelectedPaths,\n        hoveredNodes,\n        hoveredEdges,\n        hoveredPaths,\n        isInCompatibilityModeForPath,\n        isSvgWheelZoomEnabled,\n        configs,\n        emitter\n      )\n\n    // -----------------------------------------------------------------------\n    // Paths\n    // -----------------------------------------------------------------------\n    const visiblePaths = computed(() => configs.path.visible)\n\n    // -----------------------------------------------------------------------\n    // Node layout handler\n    // -----------------------------------------------------------------------\n\n    const activateParams = () => ({\n      layouts: Reactive(currentLayouts.nodes), // deprecated parameter.\n      nodePositions: toRef(currentLayouts, \"nodes\"),\n      nodes: nodesRef,\n      edges: edgesRef,\n      configs: readonly(configs),\n      scale: readonly(scale),\n      emitter,\n      svgPanZoom: nonNull(svgPanZoom.value),\n    })\n    watch(\n      () => configs.view.layoutHandler,\n      (newHandler, oldHandler) => {\n        oldHandler.deactivate()\n        newHandler.activate(activateParams())\n      }\n    )\n\n    // -----------------------------------------------------------------------\n    // Transition of element positions\n    // -----------------------------------------------------------------------\n\n    // #transitionWhile() method\n    const { transitionWhile, transitionOption } = useTransitionWhile()\n    const transitionStyles = computed(() => {\n      const o = transitionOption.value\n      return (\n        o.enabled\n          ? {\n              \"--transition-duration\": o.duration + \"ms\",\n              \"--transition-function\": o.timingFunction,\n            }\n          : {}\n      ) as CSSProperties\n    })\n\n    // -----------------------------------------------------------------------\n    // Events\n    // -----------------------------------------------------------------------\n\n    onSvgPanZoomMounted(() => {\n      updateBorderBox(() => {\n        // pan to center\n        const svg = nonNull(svgPanZoom.value, \"svg-pan-zoom\")\n\n        // activate layout handler.\n        // (calc the positions of nodes whose positions are not specified)\n        configs.view.layoutHandler.activate(activateParams())\n\n        nextTick(() => {\n          const autoPanAndZoom = configs.view.autoPanAndZoomOnLoad\n          if (configs.view.fit || autoPanAndZoom !== false) {\n            const nodesEmpty = Object.keys(props.nodes).length == 0\n            if (nodesEmpty || autoPanAndZoom === \"center-zero\") {\n              // Pan (0, 0) to the center.\n              const sizes = svg.getSizes()\n              svg.pan({\n                x: sizes.width / 2,\n                y: sizes.height / 2,\n              })\n            } else if (autoPanAndZoom === \"fit-content\" || configs.view.fit) {\n              fitToContents()\n            } else if (autoPanAndZoom === \"center-content\") {\n              panToCenter()\n            }\n          }\n\n          emitter.emit(\"view:load\")\n\n          // start displaying the svg\n          state.value = State.LOADED\n        })\n      })\n    })\n\n    onSvgPanZoomUnmounted(() => {\n      state.value = State.UNLOADED\n      emitter.emit(\"view:unload\")\n      configs.view.layoutHandler.deactivate()\n    })\n\n    return {\n      // html ref\n      container,\n      svg,\n      viewport,\n      show,\n\n      // instance\n      svgPanZoom,\n\n      // properties\n      allConfigs: configs,\n      layerDefs,\n      isShowGrid,\n      isShowBackgroundViewport,\n      hasOverrideNodeSlot,\n      hasOverrideNodeLabelSlot,\n      hasEdgeOverlaySlot,\n      hasEdgeLabelSlot,\n      hasEdgesLabelSlot,\n      scale,\n      nodeStates,\n      nodeZOrderedList,\n      currentSelectedNodes,\n      markers: markerState.markers,\n      dragging,\n      touches,\n      currentLayouts,\n      visibleNodeFocusRing,\n      visiblePaths,\n      transitionOption,\n      transitionStyles,\n      isBoxSelectionMode,\n      selectionBox,\n\n      // methods\n      fitToContents,\n      panToCenter,\n      getViewBox,\n      setViewBox,\n      transitionWhile,\n      startBoxSelection,\n      stopBoxSelection,\n    }\n  },\n  methods: {\n    /**\n     * Zoom in\n     */\n    zoomIn() {\n      this.svgPanZoom?.zoomIn()\n    },\n    /**\n     * Zoom out\n     */\n    zoomOut() {\n      this.svgPanZoom?.zoomOut()\n    },\n    /**\n     * Pan to a rendered position\n     * @return {Point} point to pan\n     */\n    panTo(point: Point) {\n      this.svgPanZoom?.pan(point)\n    },\n    /**\n     * Relatively pan the graph by a specified rendered position vector\n     * @return {Point} relative point to pan\n     */\n    panBy(point: Point) {\n      this.svgPanZoom?.panBy(point)\n    },\n    /**\n     * Get pan vector\n     * @return {Point} pan vector\n     */\n    getPan(): Point {\n      return nonNull(this.svgPanZoom).getPan()\n    },\n    /**\n     * Get all calculate svg dimensions\n     */\n    getSizes(): Sizes {\n      const sizes = nonNull(this.svgPanZoom).getSizes()\n      return {\n        width: sizes.width,\n        height: sizes.height,\n        viewBox: sizes.viewBox,\n      }\n    },\n    /**\n     * Translate from DOM to SVG coordinates\n     * @return {Point} coordinates in the SVG\n     */\n    translateFromDomToSvgCoordinates(coordinates: Point): Point {\n      return translateFromDomToSvgCoordinates(\n        nonNull(this.svg, \"svg\"),\n        nonNull(this.viewport, \"viewport\"),\n        coordinates\n      )\n    },\n    /**\n     * Translate from SVG to DOM coordinates\n     * @return {Point} coordinates in the DOM\n     */\n    translateFromSvgToDomCoordinates(coordinates: Point): Point {\n      return translateFromSvgToDomCoordinates(\n        nonNull(this.svg, \"svg\"),\n        nonNull(this.viewport, \"viewport\"),\n        coordinates\n      )\n    },\n    /**\n     * Get graph as SVG text.\n     * @return {string} SVG text\n     */\n    getAsSvg(): string {\n      const element = nonNull(this.svg, \"svg\")\n      const viewport = nonNull(this.viewport, \"svg viewport\")\n\n      const target = element.cloneNode(true) as SVGElement\n\n      const box = viewport.getBBox()\n      const z = 1 / this.scale\n      const svg = {\n        x: Math.floor((box.x - 10) * z),\n        y: Math.floor((box.y - 10) * z),\n        width: Math.ceil((box.width + 20) * z),\n        height: Math.ceil((box.height + 20) * z),\n      }\n      target.setAttribute(\"width\", svg.width.toString())\n      target.setAttribute(\"height\", svg.height.toString())\n\n      const v = target.querySelector(\".v-viewport\") as SVGGElement\n      v.setAttribute(\"transform\", `translate(${-svg.x} ${-svg.y}), scale(${z})`)\n      v.removeAttribute(\"style\")\n\n      target.setAttribute(\"viewBox\", `0 0 ${svg.width} ${svg.height}`)\n\n      let data = target.outerHTML\n\n      // cleanup\n      data = data.replaceAll(/ data-v-[0-9a-z]+=\"\"/g, \"\")\n      data = data.replaceAll(/<!--[\\s\\S]*?-->/gm, \"\")\n      return data\n    },\n  },\n})\n\nfunction applyZoomEnabled(\n  svgPanZoom: SvgPanZoomInstance,\n  enable: boolean,\n  enableDblClick: boolean,\n  enableMouseWheel: boolean\n): void {\n  svgPanZoom.setZoomEnabled(enable)\n  if (enable && enableDblClick) {\n    svgPanZoom.enableDblClickZoom()\n  } else {\n    svgPanZoom.disableDblClickZoom()\n  }\n  if (enable && enableMouseWheel) {\n    svgPanZoom.enableMouseWheelZoom()\n  } else {\n    svgPanZoom.disableMouseWheelZoom()\n  }\n}\n\nfunction isDoubleClickZoomEnabled(view: ViewConfig): boolean {\n  return view.zoomEnabled && view.doubleClickZoomEnabled\n}\n\nfunction isMouseWheelZoomEnabled(view: ViewConfig): boolean {\n  return view.zoomEnabled && view.mouseWheelZoomEnabled\n}\n\nfunction stopEventPropagation(event: Event) {\n  event.stopPropagation()\n}\n</script>\n\n<style lang=\"scss\" scoped>\n.v-network-graph {\n  padding: 0;\n  position: relative;\n  user-select: none;\n}\n:where(.v-network-graph) {\n  width: 100%;\n  height: 100%;\n}\n.v-canvas {\n  -webkit-tap-highlight-color: transparent;\n  width: 100%;\n  height: 100%;\n  // Respond to disorder until the svgPanZoom library is activated\n  opacity: 0;\n  &.show {\n    opacity: 1;\n    transition: opacity 0.5s linear;\n  }\n}\n\n.v-canvas.dragging {\n  :deep(*) {\n    cursor: grabbing !important;\n  }\n  :deep(.v-line) {\n    transition: d 0s;\n  }\n}\n\n.v-canvas.touches {\n  // prevent to perform browser's default action\n  touch-action: none;\n}\n\n.v-canvas.box-selection-mode {\n  cursor: crosshair !important;\n  :deep(*) {\n    cursor: crosshair !important;\n  }\n}\n\n// transition options for #transitionWhile()\n.v-canvas {\n  --transition-duration: 300ms;\n  --transition-function: linear;\n  .v-viewport.v-transition {\n    ::v-deep(.v-node) {\n      transition: transform var(--transition-duration) var(--transition-function);\n    }\n    ::v-deep(.v-layer-edges) path {\n      transition: d var(--transition-duration) var(--transition-function);\n    }\n    ::v-deep(.v-path-line) {\n      transition: d var(--transition-duration) var(--transition-function);\n    }\n  }\n}\n</style>\n","<script setup lang=\"ts\">\nimport { computed, PropType, Ref, ref, watchEffect } from \"vue\"\nimport { EdgeLabelStyle } from \"@/common/configs\"\nimport { Edge, EdgeLabelArea } from \"@/common/types\"\nimport { VectorLine } from \"@/modules/calculation/line\"\nimport VText from \"@/components/base/VLabelText.vue\"\n\nconst props = defineProps({\n  area: {\n    type: Object as PropType<EdgeLabelArea>,\n    required: true,\n  },\n  config: {\n    type: Object as PropType<EdgeLabelStyle>,\n    required: true,\n  },\n  text: {\n    type: String,\n    required: false,\n    default: \"\",\n  },\n  align: {\n    type: String as PropType<\"center\" | \"source\" | \"target\">,\n    required: false,\n    default: \"center\",\n  },\n  verticalAlign: {\n    type: String as PropType<\"center\" | \"above\" | \"below\">,\n    required: false,\n    default: \"center\",\n  },\n  // The followings are the definitions to avoid passing unwanted\n  // items to <text> when they are specified in v-bind.\n  edge: {\n    type: Object as PropType<Edge>,\n    required: false,\n    default: undefined\n  },\n  hovered: {\n    type: Boolean,\n    required: false,\n    default: false\n  },\n  selected: {\n    type: Boolean,\n    required: false,\n    default: false\n  },\n  scale: {\n    type: Number,\n    required: false,\n    default: undefined\n  }\n})\n\nconst x = ref(0)\nconst y = ref(0)\nconst textAnchor: Ref<\"middle\" | \"start\" | \"end\"> = ref(\"middle\")\nconst dominantBaseline: Ref<\"text-top\" | \"hanging\" | \"central\"> = ref(\"central\")\nconst angle = ref(0)\n\nwatchEffect(() => {\n  const s = props.area.source\n  const t = props.area.target\n  if (props.align === \"source\") {\n    if (s.above.x == t.above.x) {\n      textAnchor.value = s.above.y > t.above.y ? \"start\" : \"end\"\n    } else {\n      textAnchor.value = s.above.x < t.above.x ? \"start\" : \"end\"\n    }\n    if (props.verticalAlign === \"above\") {\n      x.value = s.above.x\n      y.value = s.above.y\n      dominantBaseline.value = \"text-top\"\n    } else if (props.verticalAlign === \"below\") {\n      x.value = s.below.x\n      y.value = s.below.y\n      dominantBaseline.value = \"hanging\"\n    } else {\n      // center\n      x.value = (s.above.x + s.below.x) / 2\n      y.value = (s.above.y + s.below.y) / 2\n      dominantBaseline.value = \"central\"\n    }\n  } else if (props.align === \"target\") {\n    if (s.above.x == t.above.x) {\n      textAnchor.value = s.above.y < t.above.y ? \"start\" : \"end\"\n    } else {\n      textAnchor.value = s.above.x > t.above.x ? \"start\" : \"end\"\n    }\n    if (props.verticalAlign === \"above\") {\n      x.value = t.above.x\n      y.value = t.above.y\n      dominantBaseline.value = \"text-top\"\n    } else if (props.verticalAlign === \"below\") {\n      x.value = t.below.x\n      y.value = t.below.y\n      dominantBaseline.value = \"hanging\"\n    } else {\n      // center\n      x.value = (t.above.x + t.below.x) / 2\n      y.value = (t.above.y + t.below.y) / 2\n      dominantBaseline.value = \"central\"\n    }\n  } else {\n    // center\n    textAnchor.value = \"middle\"\n    if (props.verticalAlign === \"above\") {\n      x.value = (s.above.x + t.above.x) / 2\n      y.value = (s.above.y + t.above.y) / 2\n      dominantBaseline.value = \"text-top\"\n    } else if (props.verticalAlign === \"below\") {\n      x.value = (s.below.x + t.below.x) / 2\n      y.value = (s.below.y + t.below.y) / 2\n      dominantBaseline.value = \"hanging\"\n    } else {\n      // center\n      x.value = (s.above.x + t.below.x) / 2\n      y.value = (s.above.y + t.below.y) / 2\n      dominantBaseline.value = \"central\"\n    }\n  }\n  let degree = VectorLine.fromPositions(s.above, t.above).v.angleDegree()\n  if (degree < -90 || degree >= 90) {\n    degree = degree + 180\n    if (degree > 180) {\n      degree -= 360\n    }\n  }\n  angle.value = degree\n})\n\n// If there is no background config and text overlaps the line,\n// automatically set the background.\nconst updatedConfig = computed(() => {\n  if (dominantBaseline.value === \"central\" && !props.config.background) {\n    return {\n      ...props.config,\n      background: {\n        visible: true,\n        color: \"#ffffff\",\n        padding: {\n          vertical: 1,\n          horizontal: 4,\n        },\n        borderRadius: 2\n      }\n    }\n  } else {\n    return props.config\n  }\n})\n\ndefineExpose({ x, y, textAnchor, dominantBaseline, angle, updatedConfig })\n</script>\n\n<template>\n  <v-text\n    class=\"v-edge-label\"\n    :text=\"text\"\n    :x=\"x\"\n    :y=\"y\"\n    :config=\"updatedConfig\"\n    :text-anchor=\"textAnchor\"\n    :dominant-baseline=\"dominantBaseline\"\n    :transform=\"`rotate(${angle} ${x} ${y})`\"\n  />\n  <!-- <g>\n    <circle\n      :cx=\"area.source.above.x\"\n      :cy=\"area.source.above.y\"\n      r=\"3\"\n      fill=\"red\"\n    />\n    <circle\n      :cx=\"area.target.above.x\"\n      :cy=\"area.target.above.y\"\n      r=\"3\"\n      fill=\"green\"\n    />\n    <circle\n      :cx=\"area.source.below.x\"\n      :cy=\"area.source.below.y\"\n      r=\"3\"\n      fill=\"blue\"\n    />\n    <circle\n      :cx=\"area.target.below.x\"\n      :cy=\"area.target.below.y\"\n      r=\"3\"\n      fill=\"orange\"\n    />\n  </g> -->\n</template>\n","import { Ref } from \"vue\"\nimport { Position } from \"@/common/types\"\nimport { SimpleLayout } from \"./simple\"\n\nconst DEFAULT_GRID = 10\n\nexport type GridLayoutParameters = {\n  grid?: number\n}\n\nexport class GridLayout extends SimpleLayout {\n  constructor(private options: GridLayoutParameters = {}) {\n    super()\n  }\n\n  protected setNodePosition(nodeLayout: Ref<Position>, pos: Position) {\n    const grid = this.options.grid || DEFAULT_GRID\n    nodeLayout.value.x = Math.floor(pos.x / grid) * grid\n    nodeLayout.value.y = Math.floor(pos.y / grid) * grid\n  }\n}\n","import { App, Plugin } from \"vue\"\n\n// Import vue components\nimport * as components from \"./components/index\"\n\n// install function executed by Vue.use()\nconst install: Exclude<Plugin[\"install\"], undefined> = function (app: App) {\n  Object.entries(components).forEach(([componentName, component]) => {\n    app.component(componentName, component)\n  })\n}\n\n// Create module definition for Vue.use()\nexport default install\n\nexport type VNetworkGraphInstance = InstanceType<typeof components.VNetworkGraph>\nexport type Instance = InstanceType<typeof components.VNetworkGraph>\n\n// To allow individual component use, export components\n// each can be registered via Vue.component()\nexport * from \"./components/index\"\n\nexport { getFullConfigs } from \"./common/config-defaults\"\n\nexport { SimpleLayout } from \"./layouts/simple\"\nexport { GridLayout } from \"./layouts/grid\"\n// export { ForceLayout } from \"./layouts/force\"\nexport type { LayoutHandler } from \"./layouts/handler\"\n\nexport * from \"./common/types\"\nexport * from \"./common/configs\"\nexport { Vector2D } from \"./modules/vector2d\"\n\n// Export for more advanced visualization. However, be aware of the\n// possibility of destructive specification changes in the future.\nexport { useStates } from \"./composables/state\"\n\nexport type { Box } from \"./modules/svg-pan-zoom-ex\"\n\n// // iife/cjs usage extends esm default export - so import it all\n// import plugin, * as components from '.';\n\n// // Attach named exports directly to plugin. IIFE/CJS will\n// // only expose one global var, with component exports exposed as properties of\n// // that global var (eg. plugin.component)\n// type NamedExports = Exclude<typeof components, 'default'>;\n// type ExtendedPlugin = typeof plugin & NamedExports;\n// Object.entries(components).forEach(([componentName, component]) => {\n//   if (componentName !== 'default') {\n//     const key = componentName as Exclude<keyof NamedExports, 'default'>;\n//     const val = component as Exclude<ExtendedPlugin, typeof plugin>;\n//     (plugin as ExtendedPlugin)[key] = val;\n//   }\n// });\n\n// export default plugin;"]},"metadata":{},"sourceType":"module"}